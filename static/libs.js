(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __knownSymbol = (name, symbol) => {
    return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  };
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __asyncGenerator = (__this, __arguments, generator) => {
    var resume = (k, v, yes, no) => {
      try {
        var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
        Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
      } catch (e) {
        no(e);
      }
    };
    var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));
    var it = {};
    return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
  };
  var __yieldStar = (value) => {
    var obj = value[__knownSymbol("asyncIterator")];
    var isAwait = false;
    var method;
    var it = {};
    if (obj == null) {
      obj = value[__knownSymbol("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw")
            throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object))
              throw TypeError("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };
  var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

  // node_modules/@atproto/api/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@atproto/api/dist/index.js"(exports, module) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require2() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export = (target, all) => {
        for (var name2 in all)
          __defProp2(target, name2, { get: all[name2], enumerable: true });
      };
      var __copyProps2 = (to, from3, except, desc) => {
        if (from3 && typeof from3 === "object" || typeof from3 === "function") {
          for (let key of __getOwnPropNames2(from3))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc2(from3, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var require_boundaries = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/boundaries.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.EXTENDED_PICTOGRAPHIC = exports2.CLUSTER_BREAK = void 0;
          var CLUSTER_BREAK;
          (function(CLUSTER_BREAK2) {
            CLUSTER_BREAK2[CLUSTER_BREAK2["CR"] = 0] = "CR";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LF"] = 1] = "LF";
            CLUSTER_BREAK2[CLUSTER_BREAK2["CONTROL"] = 2] = "CONTROL";
            CLUSTER_BREAK2[CLUSTER_BREAK2["EXTEND"] = 3] = "EXTEND";
            CLUSTER_BREAK2[CLUSTER_BREAK2["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
            CLUSTER_BREAK2[CLUSTER_BREAK2["SPACINGMARK"] = 5] = "SPACINGMARK";
            CLUSTER_BREAK2[CLUSTER_BREAK2["L"] = 6] = "L";
            CLUSTER_BREAK2[CLUSTER_BREAK2["V"] = 7] = "V";
            CLUSTER_BREAK2[CLUSTER_BREAK2["T"] = 8] = "T";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LV"] = 9] = "LV";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LVT"] = 10] = "LVT";
            CLUSTER_BREAK2[CLUSTER_BREAK2["OTHER"] = 11] = "OTHER";
            CLUSTER_BREAK2[CLUSTER_BREAK2["PREPEND"] = 12] = "PREPEND";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE"] = 13] = "E_BASE";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_MODIFIER"] = 14] = "E_MODIFIER";
            CLUSTER_BREAK2[CLUSTER_BREAK2["ZWJ"] = 15] = "ZWJ";
            CLUSTER_BREAK2[CLUSTER_BREAK2["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
          })(CLUSTER_BREAK = exports2.CLUSTER_BREAK || (exports2.CLUSTER_BREAK = {}));
          exports2.EXTENDED_PICTOGRAPHIC = 101;
        }
      });
      var require_GraphemerHelper = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerHelper.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var boundaries_1 = require_boundaries();
          var NotBreak = 0;
          var BreakStart = 1;
          var Break = 2;
          var BreakLastRegional = 3;
          var BreakPenultimateRegional = 4;
          var GraphemerHelper = class {
            static isSurrogate(str, pos) {
              return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
            }
            static codePointAt(str, idx) {
              if (idx === void 0) {
                idx = 0;
              }
              const code2 = str.charCodeAt(idx);
              if (55296 <= code2 && code2 <= 56319 && idx < str.length - 1) {
                const hi = code2;
                const low = str.charCodeAt(idx + 1);
                if (56320 <= low && low <= 57343) {
                  return (hi - 55296) * 1024 + (low - 56320) + 65536;
                }
                return hi;
              }
              if (56320 <= code2 && code2 <= 57343 && idx >= 1) {
                const hi = str.charCodeAt(idx - 1);
                const low = code2;
                if (55296 <= hi && hi <= 56319) {
                  return (hi - 55296) * 1024 + (low - 56320) + 65536;
                }
                return low;
              }
              return code2;
            }
            static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
              const all = [start].concat(mid).concat([end]);
              const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
              const previous = all[all.length - 2];
              const next = end;
              const nextEmoji = endEmoji;
              const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
              if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
              }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
                if (all.filter(function(c) {
                  return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                }).length % 2 === 1) {
                  return BreakLastRegional;
                } else {
                  return BreakPenultimateRegional;
                }
              }
              if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
                return NotBreak;
              } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
                return BreakStart;
              } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
                return BreakStart;
              } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
                return NotBreak;
              } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
                return NotBreak;
              } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
                return NotBreak;
              } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
                return NotBreak;
              } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
                return NotBreak;
              } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
                return NotBreak;
              }
              const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
              if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.EXTEND;
              }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
                return NotBreak;
              }
              if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
                return Break;
              }
              if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
                return NotBreak;
              }
              return BreakStart;
            }
          };
          exports2.default = GraphemerHelper;
        }
      });
      var require_GraphemerIterator = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerIterator.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var GraphemerIterator = class {
            constructor(str, nextBreak) {
              this._index = 0;
              this._str = str;
              this._nextBreak = nextBreak;
            }
            [Symbol.iterator]() {
              return this;
            }
            next() {
              let brk;
              if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
                const value = this._str.slice(this._index, brk);
                this._index = brk;
                return { value, done: false };
              }
              if (this._index < this._str.length) {
                const value = this._str.slice(this._index);
                this._index = this._str.length;
                return { value, done: false };
              }
              return { value: void 0, done: true };
            }
          };
          exports2.default = GraphemerIterator;
        }
      });
      var require_Graphemer = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/Graphemer.js"(exports2) {
          "use strict";
          var __importDefault = exports2 && exports2.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var boundaries_1 = require_boundaries();
          var GraphemerHelper_1 = __importDefault(require_GraphemerHelper());
          var GraphemerIterator_1 = __importDefault(require_GraphemerIterator());
          var Graphemer2 = class {
            static nextBreak(string3, index) {
              if (index === void 0) {
                index = 0;
              }
              if (index < 0) {
                return 0;
              }
              if (index >= string3.length - 1) {
                return string3.length;
              }
              const prevCP = GraphemerHelper_1.default.codePointAt(string3, index);
              const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
              const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
              const mid = [];
              const midEmoji = [];
              for (let i = index + 1; i < string3.length; i++) {
                if (GraphemerHelper_1.default.isSurrogate(string3, i - 1)) {
                  continue;
                }
                const nextCP = GraphemerHelper_1.default.codePointAt(string3, i);
                const next = Graphemer2.getGraphemeBreakProperty(nextCP);
                const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
                if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
                  return i;
                }
                mid.push(next);
                midEmoji.push(nextEmoji);
              }
              return string3.length;
            }
            splitGraphemes(str) {
              const res = [];
              let index = 0;
              let brk;
              while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
                res.push(str.slice(index, brk));
                index = brk;
              }
              if (index < str.length) {
                res.push(str.slice(index));
              }
              return res;
            }
            iterateGraphemes(str) {
              return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
            }
            countGraphemes(str) {
              let count = 0;
              let index = 0;
              let brk;
              while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
                index = brk;
                count++;
              }
              if (index < str.length) {
                count++;
              }
              return count;
            }
            static getGraphemeBreakProperty(code2) {
              if (code2 < 48905) {
                if (code2 < 44116) {
                  if (code2 < 4141) {
                    if (code2 < 2818) {
                      if (code2 < 2363) {
                        if (code2 < 1759) {
                          if (code2 < 1471) {
                            if (code2 < 127) {
                              if (code2 < 11) {
                                if (code2 < 10) {
                                  if (0 <= code2 && code2 <= 9) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 === 10) {
                                    return boundaries_1.CLUSTER_BREAK.LF;
                                  }
                                }
                              } else {
                                if (code2 < 13) {
                                  if (11 <= code2 && code2 <= 12) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 14) {
                                    if (code2 === 13) {
                                      return boundaries_1.CLUSTER_BREAK.CR;
                                    }
                                  } else {
                                    if (14 <= code2 && code2 <= 31) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 768) {
                                if (code2 < 173) {
                                  if (127 <= code2 && code2 <= 159) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 === 173) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              } else {
                                if (code2 < 1155) {
                                  if (768 <= code2 && code2 <= 879) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1425) {
                                    if (1155 <= code2 && code2 <= 1161) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (1425 <= code2 && code2 <= 1469) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 1552) {
                              if (code2 < 1476) {
                                if (code2 < 1473) {
                                  if (code2 === 1471) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1473 <= code2 && code2 <= 1474) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 1479) {
                                  if (1476 <= code2 && code2 <= 1477) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1536) {
                                    if (code2 === 1479) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (1536 <= code2 && code2 <= 1541) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 1648) {
                                if (code2 < 1564) {
                                  if (1552 <= code2 && code2 <= 1562) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1611) {
                                    if (code2 === 1564) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (1611 <= code2 && code2 <= 1631) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 1750) {
                                  if (code2 === 1648) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1757) {
                                    if (1750 <= code2 && code2 <= 1756) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 1757) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2075) {
                            if (code2 < 1840) {
                              if (code2 < 1770) {
                                if (code2 < 1767) {
                                  if (1759 <= code2 && code2 <= 1764) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1767 <= code2 && code2 <= 1768) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 1807) {
                                  if (1770 <= code2 && code2 <= 1773) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 1807) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                  if (code2 === 1809) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2027) {
                                if (code2 < 1958) {
                                  if (1840 <= code2 && code2 <= 1866) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1958 <= code2 && code2 <= 1968) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2045) {
                                  if (2027 <= code2 && code2 <= 2035) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2070) {
                                    if (code2 === 2045) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2070 <= code2 && code2 <= 2073) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2200) {
                              if (code2 < 2089) {
                                if (code2 < 2085) {
                                  if (2075 <= code2 && code2 <= 2083) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2085 <= code2 && code2 <= 2087) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2137) {
                                  if (2089 <= code2 && code2 <= 2093) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2192) {
                                    if (2137 <= code2 && code2 <= 2139) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2192 <= code2 && code2 <= 2193) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2275) {
                                if (code2 < 2250) {
                                  if (2200 <= code2 && code2 <= 2207) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2274) {
                                    if (2250 <= code2 && code2 <= 2273) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2274) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2307) {
                                  if (2275 <= code2 && code2 <= 2306) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2307) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 2362) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 2561) {
                          if (code2 < 2434) {
                            if (code2 < 2381) {
                              if (code2 < 2366) {
                                if (code2 === 2363) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 2364) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2369) {
                                  if (2366 <= code2 && code2 <= 2368) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2377) {
                                    if (2369 <= code2 && code2 <= 2376) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2377 <= code2 && code2 <= 2380) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2385) {
                                if (code2 < 2382) {
                                  if (code2 === 2381) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2382 <= code2 && code2 <= 2383) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2402) {
                                  if (2385 <= code2 && code2 <= 2391) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2433) {
                                    if (2402 <= code2 && code2 <= 2403) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2433) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2503) {
                              if (code2 < 2494) {
                                if (code2 < 2492) {
                                  if (2434 <= code2 && code2 <= 2435) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 2492) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2495) {
                                  if (code2 === 2494) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2497) {
                                    if (2495 <= code2 && code2 <= 2496) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2497 <= code2 && code2 <= 2500) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2519) {
                                if (code2 < 2507) {
                                  if (2503 <= code2 && code2 <= 2504) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2509) {
                                    if (2507 <= code2 && code2 <= 2508) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 2509) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2530) {
                                  if (code2 === 2519) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2558) {
                                    if (2530 <= code2 && code2 <= 2531) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2558) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2691) {
                            if (code2 < 2631) {
                              if (code2 < 2620) {
                                if (code2 < 2563) {
                                  if (2561 <= code2 && code2 <= 2562) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2563) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2622) {
                                  if (code2 === 2620) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2625) {
                                    if (2622 <= code2 && code2 <= 2624) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2625 <= code2 && code2 <= 2626) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2672) {
                                if (code2 < 2635) {
                                  if (2631 <= code2 && code2 <= 2632) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2641) {
                                    if (2635 <= code2 && code2 <= 2637) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2641) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2677) {
                                  if (2672 <= code2 && code2 <= 2673) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2689) {
                                    if (code2 === 2677) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2689 <= code2 && code2 <= 2690) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2761) {
                              if (code2 < 2750) {
                                if (code2 === 2691) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 2748) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2753) {
                                  if (2750 <= code2 && code2 <= 2752) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2759) {
                                    if (2753 <= code2 && code2 <= 2757) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2759 <= code2 && code2 <= 2760) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2786) {
                                if (code2 < 2763) {
                                  if (code2 === 2761) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2765) {
                                    if (2763 <= code2 && code2 <= 2764) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 2765) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2810) {
                                  if (2786 <= code2 && code2 <= 2787) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2817) {
                                    if (2810 <= code2 && code2 <= 2815) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2817) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 3315) {
                        if (code2 < 3076) {
                          if (code2 < 2946) {
                            if (code2 < 2887) {
                              if (code2 < 2878) {
                                if (code2 < 2876) {
                                  if (2818 <= code2 && code2 <= 2819) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 2876) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2880) {
                                  if (2878 <= code2 && code2 <= 2879) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2881) {
                                    if (code2 === 2880) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2881 <= code2 && code2 <= 2884) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2893) {
                                if (code2 < 2891) {
                                  if (2887 <= code2 && code2 <= 2888) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2891 <= code2 && code2 <= 2892) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2901) {
                                  if (code2 === 2893) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2914) {
                                    if (2901 <= code2 && code2 <= 2903) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2914 <= code2 && code2 <= 2915) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3014) {
                              if (code2 < 3007) {
                                if (code2 === 2946) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3006) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3008) {
                                  if (code2 === 3007) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3009) {
                                    if (code2 === 3008) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3009 <= code2 && code2 <= 3010) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3031) {
                                if (code2 < 3018) {
                                  if (3014 <= code2 && code2 <= 3016) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3021) {
                                    if (3018 <= code2 && code2 <= 3020) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3021) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3072) {
                                  if (code2 === 3031) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3073) {
                                    if (code2 === 3072) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3073 <= code2 && code2 <= 3075) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3262) {
                            if (code2 < 3146) {
                              if (code2 < 3134) {
                                if (code2 === 3076) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3132) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3137) {
                                  if (3134 <= code2 && code2 <= 3136) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3142) {
                                    if (3137 <= code2 && code2 <= 3140) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3142 <= code2 && code2 <= 3144) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3201) {
                                if (code2 < 3157) {
                                  if (3146 <= code2 && code2 <= 3149) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3170) {
                                    if (3157 <= code2 && code2 <= 3158) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3170 <= code2 && code2 <= 3171) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3202) {
                                  if (code2 === 3201) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3260) {
                                    if (3202 <= code2 && code2 <= 3203) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3260) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3270) {
                              if (code2 < 3264) {
                                if (code2 === 3262) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 3263) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3266) {
                                  if (3264 <= code2 && code2 <= 3265) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3267) {
                                    if (code2 === 3266) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3267 <= code2 && code2 <= 3268) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3276) {
                                if (code2 < 3271) {
                                  if (code2 === 3270) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3274) {
                                    if (3271 <= code2 && code2 <= 3272) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3274 <= code2 && code2 <= 3275) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3285) {
                                  if (3276 <= code2 && code2 <= 3277) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3298) {
                                    if (3285 <= code2 && code2 <= 3286) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3298 <= code2 && code2 <= 3299) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 3551) {
                          if (code2 < 3406) {
                            if (code2 < 3391) {
                              if (code2 < 3330) {
                                if (code2 < 3328) {
                                  if (code2 === 3315) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3328 <= code2 && code2 <= 3329) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 3387) {
                                  if (3330 <= code2 && code2 <= 3331) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3390) {
                                    if (3387 <= code2 && code2 <= 3388) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 3390) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3398) {
                                if (code2 < 3393) {
                                  if (3391 <= code2 && code2 <= 3392) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3393 <= code2 && code2 <= 3396) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 3402) {
                                  if (3398 <= code2 && code2 <= 3400) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3405) {
                                    if (3402 <= code2 && code2 <= 3404) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3405) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3530) {
                              if (code2 < 3426) {
                                if (code2 === 3406) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code2 === 3415) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3457) {
                                  if (3426 <= code2 && code2 <= 3427) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3458) {
                                    if (code2 === 3457) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3458 <= code2 && code2 <= 3459) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3538) {
                                if (code2 < 3535) {
                                  if (code2 === 3530) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3536) {
                                    if (code2 === 3535) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3536 <= code2 && code2 <= 3537) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3542) {
                                  if (3538 <= code2 && code2 <= 3540) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3544) {
                                    if (code2 === 3542) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3544 <= code2 && code2 <= 3550) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3893) {
                            if (code2 < 3655) {
                              if (code2 < 3633) {
                                if (code2 < 3570) {
                                  if (code2 === 3551) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3570 <= code2 && code2 <= 3571) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 3635) {
                                  if (code2 === 3633) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3636) {
                                    if (code2 === 3635) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3636 <= code2 && code2 <= 3642) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3764) {
                                if (code2 < 3761) {
                                  if (3655 <= code2 && code2 <= 3662) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 3761) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 3763) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 3784) {
                                  if (3764 <= code2 && code2 <= 3772) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3864) {
                                    if (3784 <= code2 && code2 <= 3790) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3864 <= code2 && code2 <= 3865) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3967) {
                              if (code2 < 3897) {
                                if (code2 === 3893) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3895) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3902) {
                                  if (code2 === 3897) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3953) {
                                    if (3902 <= code2 && code2 <= 3903) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3953 <= code2 && code2 <= 3966) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3981) {
                                if (code2 < 3968) {
                                  if (code2 === 3967) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3974) {
                                    if (3968 <= code2 && code2 <= 3972) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3974 <= code2 && code2 <= 3975) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3993) {
                                  if (3981 <= code2 && code2 <= 3991) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4038) {
                                    if (3993 <= code2 && code2 <= 4028) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 4038) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 7204) {
                      if (code2 < 6448) {
                        if (code2 < 5938) {
                          if (code2 < 4226) {
                            if (code2 < 4157) {
                              if (code2 < 4146) {
                                if (code2 < 4145) {
                                  if (4141 <= code2 && code2 <= 4144) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 4145) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 4153) {
                                  if (4146 <= code2 && code2 <= 4151) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4155) {
                                    if (4153 <= code2 && code2 <= 4154) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (4155 <= code2 && code2 <= 4156) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 4184) {
                                if (code2 < 4182) {
                                  if (4157 <= code2 && code2 <= 4158) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4182 <= code2 && code2 <= 4183) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 4190) {
                                  if (4184 <= code2 && code2 <= 4185) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4209) {
                                    if (4190 <= code2 && code2 <= 4192) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (4209 <= code2 && code2 <= 4212) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 4352) {
                              if (code2 < 4229) {
                                if (code2 === 4226) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 4228) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 4237) {
                                  if (4229 <= code2 && code2 <= 4230) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 4237) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 4253) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 4957) {
                                if (code2 < 4448) {
                                  if (4352 <= code2 && code2 <= 4447) {
                                    return boundaries_1.CLUSTER_BREAK.L;
                                  }
                                } else {
                                  if (code2 < 4520) {
                                    if (4448 <= code2 && code2 <= 4519) {
                                      return boundaries_1.CLUSTER_BREAK.V;
                                    }
                                  } else {
                                    if (4520 <= code2 && code2 <= 4607) {
                                      return boundaries_1.CLUSTER_BREAK.T;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 5906) {
                                  if (4957 <= code2 && code2 <= 4959) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 5909) {
                                    if (5906 <= code2 && code2 <= 5908) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 5909) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 6089) {
                            if (code2 < 6070) {
                              if (code2 < 5970) {
                                if (code2 < 5940) {
                                  if (5938 <= code2 && code2 <= 5939) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 5940) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 6002) {
                                  if (5970 <= code2 && code2 <= 5971) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6068) {
                                    if (6002 <= code2 && code2 <= 6003) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6068 <= code2 && code2 <= 6069) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6078) {
                                if (code2 < 6071) {
                                  if (code2 === 6070) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (6071 <= code2 && code2 <= 6077) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6086) {
                                  if (6078 <= code2 && code2 <= 6085) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6087) {
                                    if (code2 === 6086) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6087 <= code2 && code2 <= 6088) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6277) {
                              if (code2 < 6155) {
                                if (code2 < 6109) {
                                  if (6089 <= code2 && code2 <= 6099) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6109) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6158) {
                                  if (6155 <= code2 && code2 <= 6157) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6158) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                  if (code2 === 6159) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6435) {
                                if (code2 < 6313) {
                                  if (6277 <= code2 && code2 <= 6278) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6432) {
                                    if (code2 === 6313) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6432 <= code2 && code2 <= 6434) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 6439) {
                                  if (6435 <= code2 && code2 <= 6438) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6441) {
                                    if (6439 <= code2 && code2 <= 6440) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6441 <= code2 && code2 <= 6443) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 6971) {
                          if (code2 < 6744) {
                            if (code2 < 6681) {
                              if (code2 < 6451) {
                                if (code2 < 6450) {
                                  if (6448 <= code2 && code2 <= 6449) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6450) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6457) {
                                  if (6451 <= code2 && code2 <= 6456) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6679) {
                                    if (6457 <= code2 && code2 <= 6459) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6679 <= code2 && code2 <= 6680) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6741) {
                                if (code2 < 6683) {
                                  if (6681 <= code2 && code2 <= 6682) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6683) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6742) {
                                  if (code2 === 6741) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6742) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 6743) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6771) {
                              if (code2 < 6754) {
                                if (code2 < 6752) {
                                  if (6744 <= code2 && code2 <= 6750) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6752) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6757) {
                                  if (code2 === 6754) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6765) {
                                    if (6757 <= code2 && code2 <= 6764) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6765 <= code2 && code2 <= 6770) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6912) {
                                if (code2 < 6783) {
                                  if (6771 <= code2 && code2 <= 6780) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6832) {
                                    if (code2 === 6783) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6832 <= code2 && code2 <= 6862) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 6916) {
                                  if (6912 <= code2 && code2 <= 6915) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6964) {
                                    if (code2 === 6916) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (6964 <= code2 && code2 <= 6970) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 7080) {
                            if (code2 < 7019) {
                              if (code2 < 6973) {
                                if (code2 === 6971) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 6972) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 6978) {
                                  if (6973 <= code2 && code2 <= 6977) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6979) {
                                    if (code2 === 6978) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6979 <= code2 && code2 <= 6980) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7073) {
                                if (code2 < 7040) {
                                  if (7019 <= code2 && code2 <= 7027) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 7042) {
                                    if (7040 <= code2 && code2 <= 7041) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 7042) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 7074) {
                                  if (code2 === 7073) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7078) {
                                    if (7074 <= code2 && code2 <= 7077) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7078 <= code2 && code2 <= 7079) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 7144) {
                              if (code2 < 7083) {
                                if (code2 < 7082) {
                                  if (7080 <= code2 && code2 <= 7081) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7082) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 7142) {
                                  if (7083 <= code2 && code2 <= 7085) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7142) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 7143) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7150) {
                                if (code2 < 7146) {
                                  if (7144 <= code2 && code2 <= 7145) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 7149) {
                                    if (7146 <= code2 && code2 <= 7148) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 7149) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 7151) {
                                  if (code2 === 7150) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7154) {
                                    if (7151 <= code2 && code2 <= 7153) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7154 <= code2 && code2 <= 7155) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 43346) {
                        if (code2 < 11647) {
                          if (code2 < 7415) {
                            if (code2 < 7380) {
                              if (code2 < 7220) {
                                if (code2 < 7212) {
                                  if (7204 <= code2 && code2 <= 7211) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7212 <= code2 && code2 <= 7219) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 7222) {
                                  if (7220 <= code2 && code2 <= 7221) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7376) {
                                    if (7222 <= code2 && code2 <= 7223) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7376 <= code2 && code2 <= 7378) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7394) {
                                if (code2 < 7393) {
                                  if (7380 <= code2 && code2 <= 7392) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7393) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 7405) {
                                  if (7394 <= code2 && code2 <= 7400) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7405) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 7412) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 8205) {
                              if (code2 < 7616) {
                                if (code2 < 7416) {
                                  if (code2 === 7415) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7416 <= code2 && code2 <= 7417) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 8203) {
                                  if (7616 <= code2 && code2 <= 7679) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 8203) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                  if (code2 === 8204) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 8288) {
                                if (code2 < 8206) {
                                  if (code2 === 8205) {
                                    return boundaries_1.CLUSTER_BREAK.ZWJ;
                                  }
                                } else {
                                  if (code2 < 8232) {
                                    if (8206 <= code2 && code2 <= 8207) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (8232 <= code2 && code2 <= 8238) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 8400) {
                                  if (8288 <= code2 && code2 <= 8303) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 11503) {
                                    if (8400 <= code2 && code2 <= 8432) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (11503 <= code2 && code2 <= 11505) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 43043) {
                            if (code2 < 42612) {
                              if (code2 < 12330) {
                                if (code2 < 11744) {
                                  if (code2 === 11647) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (11744 <= code2 && code2 <= 11775) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 12441) {
                                  if (12330 <= code2 && code2 <= 12335) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 42607) {
                                    if (12441 <= code2 && code2 <= 12442) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (42607 <= code2 && code2 <= 42610) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43010) {
                                if (code2 < 42654) {
                                  if (42612 <= code2 && code2 <= 42621) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 42736) {
                                    if (42654 <= code2 && code2 <= 42655) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (42736 <= code2 && code2 <= 42737) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 43014) {
                                  if (code2 === 43010) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43014) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43019) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43188) {
                              if (code2 < 43047) {
                                if (code2 < 43045) {
                                  if (43043 <= code2 && code2 <= 43044) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43045 <= code2 && code2 <= 43046) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43052) {
                                  if (code2 === 43047) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43136) {
                                    if (code2 === 43052) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43136 <= code2 && code2 <= 43137) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43263) {
                                if (code2 < 43204) {
                                  if (43188 <= code2 && code2 <= 43203) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43232) {
                                    if (43204 <= code2 && code2 <= 43205) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43232 <= code2 && code2 <= 43249) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 43302) {
                                  if (code2 === 43263) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 43335) {
                                    if (43302 <= code2 && code2 <= 43309) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43335 <= code2 && code2 <= 43345) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 43698) {
                          if (code2 < 43493) {
                            if (code2 < 43444) {
                              if (code2 < 43392) {
                                if (code2 < 43360) {
                                  if (43346 <= code2 && code2 <= 43347) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43360 <= code2 && code2 <= 43388) {
                                    return boundaries_1.CLUSTER_BREAK.L;
                                  }
                                }
                              } else {
                                if (code2 < 43395) {
                                  if (43392 <= code2 && code2 <= 43394) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43395) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 43443) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43450) {
                                if (code2 < 43446) {
                                  if (43444 <= code2 && code2 <= 43445) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43446 <= code2 && code2 <= 43449) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43452) {
                                  if (43450 <= code2 && code2 <= 43451) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43454) {
                                    if (43452 <= code2 && code2 <= 43453) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43454 <= code2 && code2 <= 43456) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43573) {
                              if (code2 < 43567) {
                                if (code2 < 43561) {
                                  if (code2 === 43493) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43561 <= code2 && code2 <= 43566) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43569) {
                                  if (43567 <= code2 && code2 <= 43568) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43571) {
                                    if (43569 <= code2 && code2 <= 43570) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43571 <= code2 && code2 <= 43572) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43597) {
                                if (code2 < 43587) {
                                  if (43573 <= code2 && code2 <= 43574) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43587) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43596) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43644) {
                                  if (code2 === 43597) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 43644) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43696) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44006) {
                            if (code2 < 43756) {
                              if (code2 < 43710) {
                                if (code2 < 43703) {
                                  if (43698 <= code2 && code2 <= 43700) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43703 <= code2 && code2 <= 43704) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43713) {
                                  if (43710 <= code2 && code2 <= 43711) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43713) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43755) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43766) {
                                if (code2 < 43758) {
                                  if (43756 <= code2 && code2 <= 43757) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 43765) {
                                    if (43758 <= code2 && code2 <= 43759) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 43765) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44003) {
                                  if (code2 === 43766) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 44005) {
                                    if (44003 <= code2 && code2 <= 44004) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 44005) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44032) {
                              if (code2 < 44009) {
                                if (code2 < 44008) {
                                  if (44006 <= code2 && code2 <= 44007) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 44008) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 44012) {
                                  if (44009 <= code2 && code2 <= 44010) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 44012) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 44013) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44061) {
                                if (code2 < 44033) {
                                  if (code2 === 44032) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44060) {
                                    if (44033 <= code2 && code2 <= 44059) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44060) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44088) {
                                  if (44061 <= code2 && code2 <= 44087) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44089) {
                                    if (code2 === 44088) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44089 <= code2 && code2 <= 44115) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 46497) {
                    if (code2 < 45293) {
                      if (code2 < 44704) {
                        if (code2 < 44397) {
                          if (code2 < 44256) {
                            if (code2 < 44173) {
                              if (code2 < 44144) {
                                if (code2 < 44117) {
                                  if (code2 === 44116) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44117 <= code2 && code2 <= 44143) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44145) {
                                  if (code2 === 44144) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44172) {
                                    if (44145 <= code2 && code2 <= 44171) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44172) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44201) {
                                if (code2 < 44200) {
                                  if (44173 <= code2 && code2 <= 44199) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44200) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44228) {
                                  if (44201 <= code2 && code2 <= 44227) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44229) {
                                    if (code2 === 44228) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44229 <= code2 && code2 <= 44255) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44313) {
                              if (code2 < 44284) {
                                if (code2 < 44257) {
                                  if (code2 === 44256) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44257 <= code2 && code2 <= 44283) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44285) {
                                  if (code2 === 44284) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44312) {
                                    if (44285 <= code2 && code2 <= 44311) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44312) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44368) {
                                if (code2 < 44340) {
                                  if (44313 <= code2 && code2 <= 44339) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44341) {
                                    if (code2 === 44340) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44341 <= code2 && code2 <= 44367) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44369) {
                                  if (code2 === 44368) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44396) {
                                    if (44369 <= code2 && code2 <= 44395) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44396) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44537) {
                            if (code2 < 44480) {
                              if (code2 < 44425) {
                                if (code2 < 44424) {
                                  if (44397 <= code2 && code2 <= 44423) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44424) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44452) {
                                  if (44425 <= code2 && code2 <= 44451) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44453) {
                                    if (code2 === 44452) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44453 <= code2 && code2 <= 44479) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44508) {
                                if (code2 < 44481) {
                                  if (code2 === 44480) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44481 <= code2 && code2 <= 44507) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44509) {
                                  if (code2 === 44508) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44536) {
                                    if (44509 <= code2 && code2 <= 44535) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44536) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44620) {
                              if (code2 < 44565) {
                                if (code2 < 44564) {
                                  if (44537 <= code2 && code2 <= 44563) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44564) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44592) {
                                  if (44565 <= code2 && code2 <= 44591) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44593) {
                                    if (code2 === 44592) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44593 <= code2 && code2 <= 44619) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44649) {
                                if (code2 < 44621) {
                                  if (code2 === 44620) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44648) {
                                    if (44621 <= code2 && code2 <= 44647) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44648) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44676) {
                                  if (44649 <= code2 && code2 <= 44675) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44677) {
                                    if (code2 === 44676) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44677 <= code2 && code2 <= 44703) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 44985) {
                          if (code2 < 44844) {
                            if (code2 < 44761) {
                              if (code2 < 44732) {
                                if (code2 < 44705) {
                                  if (code2 === 44704) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44705 <= code2 && code2 <= 44731) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44733) {
                                  if (code2 === 44732) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44760) {
                                    if (44733 <= code2 && code2 <= 44759) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44760) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44789) {
                                if (code2 < 44788) {
                                  if (44761 <= code2 && code2 <= 44787) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44788) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44816) {
                                  if (44789 <= code2 && code2 <= 44815) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44817) {
                                    if (code2 === 44816) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44817 <= code2 && code2 <= 44843) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44901) {
                              if (code2 < 44872) {
                                if (code2 < 44845) {
                                  if (code2 === 44844) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44845 <= code2 && code2 <= 44871) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44873) {
                                  if (code2 === 44872) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44900) {
                                    if (44873 <= code2 && code2 <= 44899) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44900) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44956) {
                                if (code2 < 44928) {
                                  if (44901 <= code2 && code2 <= 44927) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44929) {
                                    if (code2 === 44928) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44929 <= code2 && code2 <= 44955) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44957) {
                                  if (code2 === 44956) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44984) {
                                    if (44957 <= code2 && code2 <= 44983) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44984) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45152) {
                            if (code2 < 45068) {
                              if (code2 < 45013) {
                                if (code2 < 45012) {
                                  if (44985 <= code2 && code2 <= 45011) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45012) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45040) {
                                  if (45013 <= code2 && code2 <= 45039) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45041) {
                                    if (code2 === 45040) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45041 <= code2 && code2 <= 45067) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45097) {
                                if (code2 < 45069) {
                                  if (code2 === 45068) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45096) {
                                    if (45069 <= code2 && code2 <= 45095) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45096) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45124) {
                                  if (45097 <= code2 && code2 <= 45123) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45125) {
                                    if (code2 === 45124) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45125 <= code2 && code2 <= 45151) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45209) {
                              if (code2 < 45180) {
                                if (code2 < 45153) {
                                  if (code2 === 45152) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45153 <= code2 && code2 <= 45179) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45181) {
                                  if (code2 === 45180) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45208) {
                                    if (45181 <= code2 && code2 <= 45207) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45208) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45264) {
                                if (code2 < 45236) {
                                  if (45209 <= code2 && code2 <= 45235) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45237) {
                                    if (code2 === 45236) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45237 <= code2 && code2 <= 45263) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45265) {
                                  if (code2 === 45264) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45292) {
                                    if (45265 <= code2 && code2 <= 45291) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45292) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 45908) {
                        if (code2 < 45600) {
                          if (code2 < 45433) {
                            if (code2 < 45376) {
                              if (code2 < 45321) {
                                if (code2 < 45320) {
                                  if (45293 <= code2 && code2 <= 45319) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45320) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45348) {
                                  if (45321 <= code2 && code2 <= 45347) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45349) {
                                    if (code2 === 45348) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45349 <= code2 && code2 <= 45375) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45404) {
                                if (code2 < 45377) {
                                  if (code2 === 45376) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45377 <= code2 && code2 <= 45403) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45405) {
                                  if (code2 === 45404) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45432) {
                                    if (45405 <= code2 && code2 <= 45431) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45432) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45516) {
                              if (code2 < 45461) {
                                if (code2 < 45460) {
                                  if (45433 <= code2 && code2 <= 45459) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45460) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45488) {
                                  if (45461 <= code2 && code2 <= 45487) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45489) {
                                    if (code2 === 45488) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45489 <= code2 && code2 <= 45515) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45545) {
                                if (code2 < 45517) {
                                  if (code2 === 45516) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45544) {
                                    if (45517 <= code2 && code2 <= 45543) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45544) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45572) {
                                  if (45545 <= code2 && code2 <= 45571) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45573) {
                                    if (code2 === 45572) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45573 <= code2 && code2 <= 45599) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45741) {
                            if (code2 < 45657) {
                              if (code2 < 45628) {
                                if (code2 < 45601) {
                                  if (code2 === 45600) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45601 <= code2 && code2 <= 45627) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45629) {
                                  if (code2 === 45628) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45656) {
                                    if (45629 <= code2 && code2 <= 45655) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45656) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45712) {
                                if (code2 < 45684) {
                                  if (45657 <= code2 && code2 <= 45683) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45685) {
                                    if (code2 === 45684) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45685 <= code2 && code2 <= 45711) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45713) {
                                  if (code2 === 45712) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45740) {
                                    if (45713 <= code2 && code2 <= 45739) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45740) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45824) {
                              if (code2 < 45769) {
                                if (code2 < 45768) {
                                  if (45741 <= code2 && code2 <= 45767) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45768) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45796) {
                                  if (45769 <= code2 && code2 <= 45795) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45797) {
                                    if (code2 === 45796) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45797 <= code2 && code2 <= 45823) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45853) {
                                if (code2 < 45825) {
                                  if (code2 === 45824) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45852) {
                                    if (45825 <= code2 && code2 <= 45851) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45852) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45880) {
                                  if (45853 <= code2 && code2 <= 45879) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45881) {
                                    if (code2 === 45880) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45881 <= code2 && code2 <= 45907) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 46189) {
                          if (code2 < 46048) {
                            if (code2 < 45965) {
                              if (code2 < 45936) {
                                if (code2 < 45909) {
                                  if (code2 === 45908) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45909 <= code2 && code2 <= 45935) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45937) {
                                  if (code2 === 45936) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45964) {
                                    if (45937 <= code2 && code2 <= 45963) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45964) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45993) {
                                if (code2 < 45992) {
                                  if (45965 <= code2 && code2 <= 45991) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45992) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46020) {
                                  if (45993 <= code2 && code2 <= 46019) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46021) {
                                    if (code2 === 46020) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46021 <= code2 && code2 <= 46047) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46105) {
                              if (code2 < 46076) {
                                if (code2 < 46049) {
                                  if (code2 === 46048) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46049 <= code2 && code2 <= 46075) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46077) {
                                  if (code2 === 46076) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46104) {
                                    if (46077 <= code2 && code2 <= 46103) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46104) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46160) {
                                if (code2 < 46132) {
                                  if (46105 <= code2 && code2 <= 46131) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46133) {
                                    if (code2 === 46132) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46133 <= code2 && code2 <= 46159) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46161) {
                                  if (code2 === 46160) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46188) {
                                    if (46161 <= code2 && code2 <= 46187) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46188) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46356) {
                            if (code2 < 46272) {
                              if (code2 < 46217) {
                                if (code2 < 46216) {
                                  if (46189 <= code2 && code2 <= 46215) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46216) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46244) {
                                  if (46217 <= code2 && code2 <= 46243) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46245) {
                                    if (code2 === 46244) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46245 <= code2 && code2 <= 46271) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46301) {
                                if (code2 < 46273) {
                                  if (code2 === 46272) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46300) {
                                    if (46273 <= code2 && code2 <= 46299) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46300) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46328) {
                                  if (46301 <= code2 && code2 <= 46327) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46329) {
                                    if (code2 === 46328) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46329 <= code2 && code2 <= 46355) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46413) {
                              if (code2 < 46384) {
                                if (code2 < 46357) {
                                  if (code2 === 46356) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46357 <= code2 && code2 <= 46383) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46385) {
                                  if (code2 === 46384) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46412) {
                                    if (46385 <= code2 && code2 <= 46411) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46412) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46468) {
                                if (code2 < 46440) {
                                  if (46413 <= code2 && code2 <= 46439) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46441) {
                                    if (code2 === 46440) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46441 <= code2 && code2 <= 46467) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46469) {
                                  if (code2 === 46468) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46496) {
                                    if (46469 <= code2 && code2 <= 46495) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46496) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 47701) {
                      if (code2 < 47112) {
                        if (code2 < 46804) {
                          if (code2 < 46637) {
                            if (code2 < 46580) {
                              if (code2 < 46525) {
                                if (code2 < 46524) {
                                  if (46497 <= code2 && code2 <= 46523) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46524) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46552) {
                                  if (46525 <= code2 && code2 <= 46551) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46553) {
                                    if (code2 === 46552) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46553 <= code2 && code2 <= 46579) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46608) {
                                if (code2 < 46581) {
                                  if (code2 === 46580) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46581 <= code2 && code2 <= 46607) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46609) {
                                  if (code2 === 46608) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46636) {
                                    if (46609 <= code2 && code2 <= 46635) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46636) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46720) {
                              if (code2 < 46665) {
                                if (code2 < 46664) {
                                  if (46637 <= code2 && code2 <= 46663) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46664) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46692) {
                                  if (46665 <= code2 && code2 <= 46691) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46693) {
                                    if (code2 === 46692) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46693 <= code2 && code2 <= 46719) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46749) {
                                if (code2 < 46721) {
                                  if (code2 === 46720) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46748) {
                                    if (46721 <= code2 && code2 <= 46747) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46748) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46776) {
                                  if (46749 <= code2 && code2 <= 46775) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46777) {
                                    if (code2 === 46776) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46777 <= code2 && code2 <= 46803) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46945) {
                            if (code2 < 46861) {
                              if (code2 < 46832) {
                                if (code2 < 46805) {
                                  if (code2 === 46804) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46805 <= code2 && code2 <= 46831) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46833) {
                                  if (code2 === 46832) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46860) {
                                    if (46833 <= code2 && code2 <= 46859) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46860) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46916) {
                                if (code2 < 46888) {
                                  if (46861 <= code2 && code2 <= 46887) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46889) {
                                    if (code2 === 46888) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46889 <= code2 && code2 <= 46915) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46917) {
                                  if (code2 === 46916) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46944) {
                                    if (46917 <= code2 && code2 <= 46943) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46944) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47028) {
                              if (code2 < 46973) {
                                if (code2 < 46972) {
                                  if (46945 <= code2 && code2 <= 46971) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46972) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47e3) {
                                  if (46973 <= code2 && code2 <= 46999) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47001) {
                                    if (code2 === 47e3) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47001 <= code2 && code2 <= 47027) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47057) {
                                if (code2 < 47029) {
                                  if (code2 === 47028) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47056) {
                                    if (47029 <= code2 && code2 <= 47055) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47056) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47084) {
                                  if (47057 <= code2 && code2 <= 47083) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47085) {
                                    if (code2 === 47084) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47085 <= code2 && code2 <= 47111) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 47393) {
                          if (code2 < 47252) {
                            if (code2 < 47169) {
                              if (code2 < 47140) {
                                if (code2 < 47113) {
                                  if (code2 === 47112) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47113 <= code2 && code2 <= 47139) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47141) {
                                  if (code2 === 47140) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47168) {
                                    if (47141 <= code2 && code2 <= 47167) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47168) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47197) {
                                if (code2 < 47196) {
                                  if (47169 <= code2 && code2 <= 47195) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47196) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47224) {
                                  if (47197 <= code2 && code2 <= 47223) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47225) {
                                    if (code2 === 47224) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47225 <= code2 && code2 <= 47251) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47309) {
                              if (code2 < 47280) {
                                if (code2 < 47253) {
                                  if (code2 === 47252) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47253 <= code2 && code2 <= 47279) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47281) {
                                  if (code2 === 47280) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47308) {
                                    if (47281 <= code2 && code2 <= 47307) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47308) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47364) {
                                if (code2 < 47336) {
                                  if (47309 <= code2 && code2 <= 47335) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47337) {
                                    if (code2 === 47336) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47337 <= code2 && code2 <= 47363) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47365) {
                                  if (code2 === 47364) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47392) {
                                    if (47365 <= code2 && code2 <= 47391) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47392) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 47560) {
                            if (code2 < 47476) {
                              if (code2 < 47421) {
                                if (code2 < 47420) {
                                  if (47393 <= code2 && code2 <= 47419) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47420) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47448) {
                                  if (47421 <= code2 && code2 <= 47447) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47449) {
                                    if (code2 === 47448) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47449 <= code2 && code2 <= 47475) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47505) {
                                if (code2 < 47477) {
                                  if (code2 === 47476) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47504) {
                                    if (47477 <= code2 && code2 <= 47503) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47504) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47532) {
                                  if (47505 <= code2 && code2 <= 47531) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47533) {
                                    if (code2 === 47532) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47533 <= code2 && code2 <= 47559) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47617) {
                              if (code2 < 47588) {
                                if (code2 < 47561) {
                                  if (code2 === 47560) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47561 <= code2 && code2 <= 47587) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47589) {
                                  if (code2 === 47588) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47616) {
                                    if (47589 <= code2 && code2 <= 47615) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47616) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47672) {
                                if (code2 < 47644) {
                                  if (47617 <= code2 && code2 <= 47643) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47645) {
                                    if (code2 === 47644) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47645 <= code2 && code2 <= 47671) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47673) {
                                  if (code2 === 47672) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47700) {
                                    if (47673 <= code2 && code2 <= 47699) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47700) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 48316) {
                        if (code2 < 48008) {
                          if (code2 < 47841) {
                            if (code2 < 47784) {
                              if (code2 < 47729) {
                                if (code2 < 47728) {
                                  if (47701 <= code2 && code2 <= 47727) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47728) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47756) {
                                  if (47729 <= code2 && code2 <= 47755) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47757) {
                                    if (code2 === 47756) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47757 <= code2 && code2 <= 47783) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47812) {
                                if (code2 < 47785) {
                                  if (code2 === 47784) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47785 <= code2 && code2 <= 47811) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47813) {
                                  if (code2 === 47812) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47840) {
                                    if (47813 <= code2 && code2 <= 47839) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47840) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47924) {
                              if (code2 < 47869) {
                                if (code2 < 47868) {
                                  if (47841 <= code2 && code2 <= 47867) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47868) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47896) {
                                  if (47869 <= code2 && code2 <= 47895) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47897) {
                                    if (code2 === 47896) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47897 <= code2 && code2 <= 47923) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47953) {
                                if (code2 < 47925) {
                                  if (code2 === 47924) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47952) {
                                    if (47925 <= code2 && code2 <= 47951) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47952) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47980) {
                                  if (47953 <= code2 && code2 <= 47979) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47981) {
                                    if (code2 === 47980) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47981 <= code2 && code2 <= 48007) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48149) {
                            if (code2 < 48065) {
                              if (code2 < 48036) {
                                if (code2 < 48009) {
                                  if (code2 === 48008) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48009 <= code2 && code2 <= 48035) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48037) {
                                  if (code2 === 48036) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48064) {
                                    if (48037 <= code2 && code2 <= 48063) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48064) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48120) {
                                if (code2 < 48092) {
                                  if (48065 <= code2 && code2 <= 48091) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48093) {
                                    if (code2 === 48092) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48093 <= code2 && code2 <= 48119) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48121) {
                                  if (code2 === 48120) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48148) {
                                    if (48121 <= code2 && code2 <= 48147) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48148) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48232) {
                              if (code2 < 48177) {
                                if (code2 < 48176) {
                                  if (48149 <= code2 && code2 <= 48175) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48176) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48204) {
                                  if (48177 <= code2 && code2 <= 48203) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48205) {
                                    if (code2 === 48204) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48205 <= code2 && code2 <= 48231) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48261) {
                                if (code2 < 48233) {
                                  if (code2 === 48232) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48260) {
                                    if (48233 <= code2 && code2 <= 48259) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48260) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48288) {
                                  if (48261 <= code2 && code2 <= 48287) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48289) {
                                    if (code2 === 48288) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48289 <= code2 && code2 <= 48315) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 48597) {
                          if (code2 < 48456) {
                            if (code2 < 48373) {
                              if (code2 < 48344) {
                                if (code2 < 48317) {
                                  if (code2 === 48316) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48317 <= code2 && code2 <= 48343) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48345) {
                                  if (code2 === 48344) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48372) {
                                    if (48345 <= code2 && code2 <= 48371) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48372) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48401) {
                                if (code2 < 48400) {
                                  if (48373 <= code2 && code2 <= 48399) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48400) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48428) {
                                  if (48401 <= code2 && code2 <= 48427) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48429) {
                                    if (code2 === 48428) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48429 <= code2 && code2 <= 48455) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48513) {
                              if (code2 < 48484) {
                                if (code2 < 48457) {
                                  if (code2 === 48456) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48457 <= code2 && code2 <= 48483) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48485) {
                                  if (code2 === 48484) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48512) {
                                    if (48485 <= code2 && code2 <= 48511) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48512) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48568) {
                                if (code2 < 48540) {
                                  if (48513 <= code2 && code2 <= 48539) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48541) {
                                    if (code2 === 48540) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48541 <= code2 && code2 <= 48567) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48569) {
                                  if (code2 === 48568) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48596) {
                                    if (48569 <= code2 && code2 <= 48595) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48596) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48764) {
                            if (code2 < 48680) {
                              if (code2 < 48625) {
                                if (code2 < 48624) {
                                  if (48597 <= code2 && code2 <= 48623) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48624) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48652) {
                                  if (48625 <= code2 && code2 <= 48651) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48653) {
                                    if (code2 === 48652) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48653 <= code2 && code2 <= 48679) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48709) {
                                if (code2 < 48681) {
                                  if (code2 === 48680) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48708) {
                                    if (48681 <= code2 && code2 <= 48707) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48708) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48736) {
                                  if (48709 <= code2 && code2 <= 48735) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48737) {
                                    if (code2 === 48736) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48737 <= code2 && code2 <= 48763) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48821) {
                              if (code2 < 48792) {
                                if (code2 < 48765) {
                                  if (code2 === 48764) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48765 <= code2 && code2 <= 48791) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48793) {
                                  if (code2 === 48792) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48820) {
                                    if (48793 <= code2 && code2 <= 48819) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48820) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48876) {
                                if (code2 < 48848) {
                                  if (48821 <= code2 && code2 <= 48847) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48849) {
                                    if (code2 === 48848) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48849 <= code2 && code2 <= 48875) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48877) {
                                  if (code2 === 48876) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48904) {
                                    if (48877 <= code2 && code2 <= 48903) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48904) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 53720) {
                  if (code2 < 51312) {
                    if (code2 < 50108) {
                      if (code2 < 49493) {
                        if (code2 < 49212) {
                          if (code2 < 49045) {
                            if (code2 < 48988) {
                              if (code2 < 48933) {
                                if (code2 < 48932) {
                                  if (48905 <= code2 && code2 <= 48931) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48932) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48960) {
                                  if (48933 <= code2 && code2 <= 48959) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48961) {
                                    if (code2 === 48960) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48961 <= code2 && code2 <= 48987) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49016) {
                                if (code2 < 48989) {
                                  if (code2 === 48988) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48989 <= code2 && code2 <= 49015) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49017) {
                                  if (code2 === 49016) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49044) {
                                    if (49017 <= code2 && code2 <= 49043) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49044) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49128) {
                              if (code2 < 49073) {
                                if (code2 < 49072) {
                                  if (49045 <= code2 && code2 <= 49071) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49072) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49100) {
                                  if (49073 <= code2 && code2 <= 49099) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49101) {
                                    if (code2 === 49100) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49101 <= code2 && code2 <= 49127) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49157) {
                                if (code2 < 49129) {
                                  if (code2 === 49128) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49156) {
                                    if (49129 <= code2 && code2 <= 49155) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49156) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49184) {
                                  if (49157 <= code2 && code2 <= 49183) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49185) {
                                    if (code2 === 49184) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49185 <= code2 && code2 <= 49211) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49352) {
                            if (code2 < 49269) {
                              if (code2 < 49240) {
                                if (code2 < 49213) {
                                  if (code2 === 49212) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49213 <= code2 && code2 <= 49239) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49241) {
                                  if (code2 === 49240) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49268) {
                                    if (49241 <= code2 && code2 <= 49267) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49268) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49297) {
                                if (code2 < 49296) {
                                  if (49269 <= code2 && code2 <= 49295) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49296) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49324) {
                                  if (49297 <= code2 && code2 <= 49323) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49325) {
                                    if (code2 === 49324) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49325 <= code2 && code2 <= 49351) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49409) {
                              if (code2 < 49380) {
                                if (code2 < 49353) {
                                  if (code2 === 49352) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49353 <= code2 && code2 <= 49379) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49381) {
                                  if (code2 === 49380) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49408) {
                                    if (49381 <= code2 && code2 <= 49407) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49408) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49464) {
                                if (code2 < 49436) {
                                  if (49409 <= code2 && code2 <= 49435) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49437) {
                                    if (code2 === 49436) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49437 <= code2 && code2 <= 49463) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49465) {
                                  if (code2 === 49464) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49492) {
                                    if (49465 <= code2 && code2 <= 49491) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49492) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 49800) {
                          if (code2 < 49633) {
                            if (code2 < 49576) {
                              if (code2 < 49521) {
                                if (code2 < 49520) {
                                  if (49493 <= code2 && code2 <= 49519) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49520) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49548) {
                                  if (49521 <= code2 && code2 <= 49547) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49549) {
                                    if (code2 === 49548) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49549 <= code2 && code2 <= 49575) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49604) {
                                if (code2 < 49577) {
                                  if (code2 === 49576) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49577 <= code2 && code2 <= 49603) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49605) {
                                  if (code2 === 49604) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49632) {
                                    if (49605 <= code2 && code2 <= 49631) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49632) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49716) {
                              if (code2 < 49661) {
                                if (code2 < 49660) {
                                  if (49633 <= code2 && code2 <= 49659) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49660) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49688) {
                                  if (49661 <= code2 && code2 <= 49687) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49689) {
                                    if (code2 === 49688) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49689 <= code2 && code2 <= 49715) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49745) {
                                if (code2 < 49717) {
                                  if (code2 === 49716) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49744) {
                                    if (49717 <= code2 && code2 <= 49743) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49744) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49772) {
                                  if (49745 <= code2 && code2 <= 49771) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49773) {
                                    if (code2 === 49772) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49773 <= code2 && code2 <= 49799) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49941) {
                            if (code2 < 49857) {
                              if (code2 < 49828) {
                                if (code2 < 49801) {
                                  if (code2 === 49800) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49801 <= code2 && code2 <= 49827) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49829) {
                                  if (code2 === 49828) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49856) {
                                    if (49829 <= code2 && code2 <= 49855) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49856) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49912) {
                                if (code2 < 49884) {
                                  if (49857 <= code2 && code2 <= 49883) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49885) {
                                    if (code2 === 49884) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49885 <= code2 && code2 <= 49911) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49913) {
                                  if (code2 === 49912) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49940) {
                                    if (49913 <= code2 && code2 <= 49939) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49940) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50024) {
                              if (code2 < 49969) {
                                if (code2 < 49968) {
                                  if (49941 <= code2 && code2 <= 49967) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49968) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49996) {
                                  if (49969 <= code2 && code2 <= 49995) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49997) {
                                    if (code2 === 49996) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49997 <= code2 && code2 <= 50023) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50053) {
                                if (code2 < 50025) {
                                  if (code2 === 50024) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50052) {
                                    if (50025 <= code2 && code2 <= 50051) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50052) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50080) {
                                  if (50053 <= code2 && code2 <= 50079) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50081) {
                                    if (code2 === 50080) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50081 <= code2 && code2 <= 50107) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 50697) {
                        if (code2 < 50389) {
                          if (code2 < 50248) {
                            if (code2 < 50165) {
                              if (code2 < 50136) {
                                if (code2 < 50109) {
                                  if (code2 === 50108) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50109 <= code2 && code2 <= 50135) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50137) {
                                  if (code2 === 50136) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50164) {
                                    if (50137 <= code2 && code2 <= 50163) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50164) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50193) {
                                if (code2 < 50192) {
                                  if (50165 <= code2 && code2 <= 50191) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50192) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50220) {
                                  if (50193 <= code2 && code2 <= 50219) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50221) {
                                    if (code2 === 50220) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50221 <= code2 && code2 <= 50247) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50305) {
                              if (code2 < 50276) {
                                if (code2 < 50249) {
                                  if (code2 === 50248) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50249 <= code2 && code2 <= 50275) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50277) {
                                  if (code2 === 50276) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50304) {
                                    if (50277 <= code2 && code2 <= 50303) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50304) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50360) {
                                if (code2 < 50332) {
                                  if (50305 <= code2 && code2 <= 50331) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50333) {
                                    if (code2 === 50332) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50333 <= code2 && code2 <= 50359) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50361) {
                                  if (code2 === 50360) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50388) {
                                    if (50361 <= code2 && code2 <= 50387) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50388) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 50556) {
                            if (code2 < 50472) {
                              if (code2 < 50417) {
                                if (code2 < 50416) {
                                  if (50389 <= code2 && code2 <= 50415) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50416) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50444) {
                                  if (50417 <= code2 && code2 <= 50443) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50445) {
                                    if (code2 === 50444) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50445 <= code2 && code2 <= 50471) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50501) {
                                if (code2 < 50473) {
                                  if (code2 === 50472) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50500) {
                                    if (50473 <= code2 && code2 <= 50499) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50500) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50528) {
                                  if (50501 <= code2 && code2 <= 50527) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50529) {
                                    if (code2 === 50528) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50529 <= code2 && code2 <= 50555) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50613) {
                              if (code2 < 50584) {
                                if (code2 < 50557) {
                                  if (code2 === 50556) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50557 <= code2 && code2 <= 50583) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50585) {
                                  if (code2 === 50584) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50612) {
                                    if (50585 <= code2 && code2 <= 50611) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50612) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50668) {
                                if (code2 < 50640) {
                                  if (50613 <= code2 && code2 <= 50639) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50641) {
                                    if (code2 === 50640) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50641 <= code2 && code2 <= 50667) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50669) {
                                  if (code2 === 50668) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50696) {
                                    if (50669 <= code2 && code2 <= 50695) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50696) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 51004) {
                          if (code2 < 50837) {
                            if (code2 < 50780) {
                              if (code2 < 50725) {
                                if (code2 < 50724) {
                                  if (50697 <= code2 && code2 <= 50723) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50724) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50752) {
                                  if (50725 <= code2 && code2 <= 50751) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50753) {
                                    if (code2 === 50752) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50753 <= code2 && code2 <= 50779) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50808) {
                                if (code2 < 50781) {
                                  if (code2 === 50780) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50781 <= code2 && code2 <= 50807) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50809) {
                                  if (code2 === 50808) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50836) {
                                    if (50809 <= code2 && code2 <= 50835) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50836) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50920) {
                              if (code2 < 50865) {
                                if (code2 < 50864) {
                                  if (50837 <= code2 && code2 <= 50863) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50864) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50892) {
                                  if (50865 <= code2 && code2 <= 50891) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50893) {
                                    if (code2 === 50892) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50893 <= code2 && code2 <= 50919) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50949) {
                                if (code2 < 50921) {
                                  if (code2 === 50920) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50948) {
                                    if (50921 <= code2 && code2 <= 50947) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50948) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50976) {
                                  if (50949 <= code2 && code2 <= 50975) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50977) {
                                    if (code2 === 50976) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50977 <= code2 && code2 <= 51003) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51145) {
                            if (code2 < 51061) {
                              if (code2 < 51032) {
                                if (code2 < 51005) {
                                  if (code2 === 51004) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51005 <= code2 && code2 <= 51031) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51033) {
                                  if (code2 === 51032) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51060) {
                                    if (51033 <= code2 && code2 <= 51059) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51060) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51116) {
                                if (code2 < 51088) {
                                  if (51061 <= code2 && code2 <= 51087) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51089) {
                                    if (code2 === 51088) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51089 <= code2 && code2 <= 51115) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51117) {
                                  if (code2 === 51116) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51144) {
                                    if (51117 <= code2 && code2 <= 51143) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51144) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51228) {
                              if (code2 < 51173) {
                                if (code2 < 51172) {
                                  if (51145 <= code2 && code2 <= 51171) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51172) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51200) {
                                  if (51173 <= code2 && code2 <= 51199) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51201) {
                                    if (code2 === 51200) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51201 <= code2 && code2 <= 51227) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51257) {
                                if (code2 < 51229) {
                                  if (code2 === 51228) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51256) {
                                    if (51229 <= code2 && code2 <= 51255) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51256) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51284) {
                                  if (51257 <= code2 && code2 <= 51283) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51285) {
                                    if (code2 === 51284) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51285 <= code2 && code2 <= 51311) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 52516) {
                      if (code2 < 51901) {
                        if (code2 < 51593) {
                          if (code2 < 51452) {
                            if (code2 < 51369) {
                              if (code2 < 51340) {
                                if (code2 < 51313) {
                                  if (code2 === 51312) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51313 <= code2 && code2 <= 51339) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51341) {
                                  if (code2 === 51340) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51368) {
                                    if (51341 <= code2 && code2 <= 51367) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51368) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51397) {
                                if (code2 < 51396) {
                                  if (51369 <= code2 && code2 <= 51395) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51396) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51424) {
                                  if (51397 <= code2 && code2 <= 51423) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51425) {
                                    if (code2 === 51424) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51425 <= code2 && code2 <= 51451) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51509) {
                              if (code2 < 51480) {
                                if (code2 < 51453) {
                                  if (code2 === 51452) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51453 <= code2 && code2 <= 51479) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51481) {
                                  if (code2 === 51480) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51508) {
                                    if (51481 <= code2 && code2 <= 51507) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51508) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51564) {
                                if (code2 < 51536) {
                                  if (51509 <= code2 && code2 <= 51535) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51537) {
                                    if (code2 === 51536) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51537 <= code2 && code2 <= 51563) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51565) {
                                  if (code2 === 51564) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51592) {
                                    if (51565 <= code2 && code2 <= 51591) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51592) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51760) {
                            if (code2 < 51676) {
                              if (code2 < 51621) {
                                if (code2 < 51620) {
                                  if (51593 <= code2 && code2 <= 51619) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51620) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51648) {
                                  if (51621 <= code2 && code2 <= 51647) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51649) {
                                    if (code2 === 51648) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51649 <= code2 && code2 <= 51675) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51705) {
                                if (code2 < 51677) {
                                  if (code2 === 51676) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51704) {
                                    if (51677 <= code2 && code2 <= 51703) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51704) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51732) {
                                  if (51705 <= code2 && code2 <= 51731) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51733) {
                                    if (code2 === 51732) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51733 <= code2 && code2 <= 51759) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51817) {
                              if (code2 < 51788) {
                                if (code2 < 51761) {
                                  if (code2 === 51760) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51761 <= code2 && code2 <= 51787) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51789) {
                                  if (code2 === 51788) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51816) {
                                    if (51789 <= code2 && code2 <= 51815) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51816) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51872) {
                                if (code2 < 51844) {
                                  if (51817 <= code2 && code2 <= 51843) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51845) {
                                    if (code2 === 51844) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51845 <= code2 && code2 <= 51871) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51873) {
                                  if (code2 === 51872) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51900) {
                                    if (51873 <= code2 && code2 <= 51899) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51900) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 52208) {
                          if (code2 < 52041) {
                            if (code2 < 51984) {
                              if (code2 < 51929) {
                                if (code2 < 51928) {
                                  if (51901 <= code2 && code2 <= 51927) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51928) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51956) {
                                  if (51929 <= code2 && code2 <= 51955) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51957) {
                                    if (code2 === 51956) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51957 <= code2 && code2 <= 51983) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52012) {
                                if (code2 < 51985) {
                                  if (code2 === 51984) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51985 <= code2 && code2 <= 52011) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52013) {
                                  if (code2 === 52012) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52040) {
                                    if (52013 <= code2 && code2 <= 52039) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52040) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52124) {
                              if (code2 < 52069) {
                                if (code2 < 52068) {
                                  if (52041 <= code2 && code2 <= 52067) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52068) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52096) {
                                  if (52069 <= code2 && code2 <= 52095) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52097) {
                                    if (code2 === 52096) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52097 <= code2 && code2 <= 52123) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52153) {
                                if (code2 < 52125) {
                                  if (code2 === 52124) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52152) {
                                    if (52125 <= code2 && code2 <= 52151) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52152) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52180) {
                                  if (52153 <= code2 && code2 <= 52179) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52181) {
                                    if (code2 === 52180) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52181 <= code2 && code2 <= 52207) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52349) {
                            if (code2 < 52265) {
                              if (code2 < 52236) {
                                if (code2 < 52209) {
                                  if (code2 === 52208) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52209 <= code2 && code2 <= 52235) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52237) {
                                  if (code2 === 52236) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52264) {
                                    if (52237 <= code2 && code2 <= 52263) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52264) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52320) {
                                if (code2 < 52292) {
                                  if (52265 <= code2 && code2 <= 52291) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52293) {
                                    if (code2 === 52292) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52293 <= code2 && code2 <= 52319) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52321) {
                                  if (code2 === 52320) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52348) {
                                    if (52321 <= code2 && code2 <= 52347) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52348) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52432) {
                              if (code2 < 52377) {
                                if (code2 < 52376) {
                                  if (52349 <= code2 && code2 <= 52375) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52376) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52404) {
                                  if (52377 <= code2 && code2 <= 52403) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52405) {
                                    if (code2 === 52404) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52405 <= code2 && code2 <= 52431) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52461) {
                                if (code2 < 52433) {
                                  if (code2 === 52432) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52460) {
                                    if (52433 <= code2 && code2 <= 52459) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52460) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52488) {
                                  if (52461 <= code2 && code2 <= 52487) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52489) {
                                    if (code2 === 52488) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52489 <= code2 && code2 <= 52515) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 53105) {
                        if (code2 < 52797) {
                          if (code2 < 52656) {
                            if (code2 < 52573) {
                              if (code2 < 52544) {
                                if (code2 < 52517) {
                                  if (code2 === 52516) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52517 <= code2 && code2 <= 52543) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52545) {
                                  if (code2 === 52544) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52572) {
                                    if (52545 <= code2 && code2 <= 52571) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52572) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52601) {
                                if (code2 < 52600) {
                                  if (52573 <= code2 && code2 <= 52599) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52600) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52628) {
                                  if (52601 <= code2 && code2 <= 52627) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52629) {
                                    if (code2 === 52628) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52629 <= code2 && code2 <= 52655) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52713) {
                              if (code2 < 52684) {
                                if (code2 < 52657) {
                                  if (code2 === 52656) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52657 <= code2 && code2 <= 52683) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52685) {
                                  if (code2 === 52684) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52712) {
                                    if (52685 <= code2 && code2 <= 52711) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52712) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52768) {
                                if (code2 < 52740) {
                                  if (52713 <= code2 && code2 <= 52739) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52741) {
                                    if (code2 === 52740) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52741 <= code2 && code2 <= 52767) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52769) {
                                  if (code2 === 52768) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52796) {
                                    if (52769 <= code2 && code2 <= 52795) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52796) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52964) {
                            if (code2 < 52880) {
                              if (code2 < 52825) {
                                if (code2 < 52824) {
                                  if (52797 <= code2 && code2 <= 52823) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52824) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52852) {
                                  if (52825 <= code2 && code2 <= 52851) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52853) {
                                    if (code2 === 52852) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52853 <= code2 && code2 <= 52879) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52909) {
                                if (code2 < 52881) {
                                  if (code2 === 52880) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52908) {
                                    if (52881 <= code2 && code2 <= 52907) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52908) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52936) {
                                  if (52909 <= code2 && code2 <= 52935) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52937) {
                                    if (code2 === 52936) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52937 <= code2 && code2 <= 52963) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53021) {
                              if (code2 < 52992) {
                                if (code2 < 52965) {
                                  if (code2 === 52964) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52965 <= code2 && code2 <= 52991) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52993) {
                                  if (code2 === 52992) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53020) {
                                    if (52993 <= code2 && code2 <= 53019) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53020) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53076) {
                                if (code2 < 53048) {
                                  if (53021 <= code2 && code2 <= 53047) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53049) {
                                    if (code2 === 53048) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53049 <= code2 && code2 <= 53075) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53077) {
                                  if (code2 === 53076) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53104) {
                                    if (53077 <= code2 && code2 <= 53103) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53104) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 53412) {
                          if (code2 < 53245) {
                            if (code2 < 53188) {
                              if (code2 < 53133) {
                                if (code2 < 53132) {
                                  if (53105 <= code2 && code2 <= 53131) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53132) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53160) {
                                  if (53133 <= code2 && code2 <= 53159) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53161) {
                                    if (code2 === 53160) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53161 <= code2 && code2 <= 53187) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53216) {
                                if (code2 < 53189) {
                                  if (code2 === 53188) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53189 <= code2 && code2 <= 53215) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53217) {
                                  if (code2 === 53216) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53244) {
                                    if (53217 <= code2 && code2 <= 53243) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53244) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53328) {
                              if (code2 < 53273) {
                                if (code2 < 53272) {
                                  if (53245 <= code2 && code2 <= 53271) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53272) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53300) {
                                  if (53273 <= code2 && code2 <= 53299) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53301) {
                                    if (code2 === 53300) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53301 <= code2 && code2 <= 53327) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53357) {
                                if (code2 < 53329) {
                                  if (code2 === 53328) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53356) {
                                    if (53329 <= code2 && code2 <= 53355) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53356) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53384) {
                                  if (53357 <= code2 && code2 <= 53383) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53385) {
                                    if (code2 === 53384) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53385 <= code2 && code2 <= 53411) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 53553) {
                            if (code2 < 53469) {
                              if (code2 < 53440) {
                                if (code2 < 53413) {
                                  if (code2 === 53412) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53413 <= code2 && code2 <= 53439) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53441) {
                                  if (code2 === 53440) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53468) {
                                    if (53441 <= code2 && code2 <= 53467) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53468) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53524) {
                                if (code2 < 53496) {
                                  if (53469 <= code2 && code2 <= 53495) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53497) {
                                    if (code2 === 53496) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53497 <= code2 && code2 <= 53523) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53525) {
                                  if (code2 === 53524) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53552) {
                                    if (53525 <= code2 && code2 <= 53551) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53552) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53636) {
                              if (code2 < 53581) {
                                if (code2 < 53580) {
                                  if (53553 <= code2 && code2 <= 53579) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53580) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53608) {
                                  if (53581 <= code2 && code2 <= 53607) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53609) {
                                    if (code2 === 53608) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53609 <= code2 && code2 <= 53635) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53665) {
                                if (code2 < 53637) {
                                  if (code2 === 53636) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53664) {
                                    if (53637 <= code2 && code2 <= 53663) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53664) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53692) {
                                  if (53665 <= code2 && code2 <= 53691) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53693) {
                                    if (code2 === 53692) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53693 <= code2 && code2 <= 53719) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 70459) {
                    if (code2 < 54897) {
                      if (code2 < 54308) {
                        if (code2 < 54001) {
                          if (code2 < 53860) {
                            if (code2 < 53777) {
                              if (code2 < 53748) {
                                if (code2 < 53721) {
                                  if (code2 === 53720) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53721 <= code2 && code2 <= 53747) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53749) {
                                  if (code2 === 53748) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53776) {
                                    if (53749 <= code2 && code2 <= 53775) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53776) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53805) {
                                if (code2 < 53804) {
                                  if (53777 <= code2 && code2 <= 53803) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53804) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53832) {
                                  if (53805 <= code2 && code2 <= 53831) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53833) {
                                    if (code2 === 53832) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53833 <= code2 && code2 <= 53859) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53917) {
                              if (code2 < 53888) {
                                if (code2 < 53861) {
                                  if (code2 === 53860) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53861 <= code2 && code2 <= 53887) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53889) {
                                  if (code2 === 53888) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53916) {
                                    if (53889 <= code2 && code2 <= 53915) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53916) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53972) {
                                if (code2 < 53944) {
                                  if (53917 <= code2 && code2 <= 53943) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53945) {
                                    if (code2 === 53944) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53945 <= code2 && code2 <= 53971) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53973) {
                                  if (code2 === 53972) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54e3) {
                                    if (53973 <= code2 && code2 <= 53999) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54e3) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54141) {
                            if (code2 < 54084) {
                              if (code2 < 54029) {
                                if (code2 < 54028) {
                                  if (54001 <= code2 && code2 <= 54027) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54028) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54056) {
                                  if (54029 <= code2 && code2 <= 54055) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54057) {
                                    if (code2 === 54056) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54057 <= code2 && code2 <= 54083) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54112) {
                                if (code2 < 54085) {
                                  if (code2 === 54084) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54085 <= code2 && code2 <= 54111) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54113) {
                                  if (code2 === 54112) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54140) {
                                    if (54113 <= code2 && code2 <= 54139) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54140) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54224) {
                              if (code2 < 54169) {
                                if (code2 < 54168) {
                                  if (54141 <= code2 && code2 <= 54167) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54168) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54196) {
                                  if (54169 <= code2 && code2 <= 54195) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54197) {
                                    if (code2 === 54196) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54197 <= code2 && code2 <= 54223) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54253) {
                                if (code2 < 54225) {
                                  if (code2 === 54224) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54252) {
                                    if (54225 <= code2 && code2 <= 54251) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54252) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54280) {
                                  if (54253 <= code2 && code2 <= 54279) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54281) {
                                    if (code2 === 54280) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54281 <= code2 && code2 <= 54307) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 54589) {
                          if (code2 < 54448) {
                            if (code2 < 54365) {
                              if (code2 < 54336) {
                                if (code2 < 54309) {
                                  if (code2 === 54308) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54309 <= code2 && code2 <= 54335) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54337) {
                                  if (code2 === 54336) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54364) {
                                    if (54337 <= code2 && code2 <= 54363) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54364) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54393) {
                                if (code2 < 54392) {
                                  if (54365 <= code2 && code2 <= 54391) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54392) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54420) {
                                  if (54393 <= code2 && code2 <= 54419) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54421) {
                                    if (code2 === 54420) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54421 <= code2 && code2 <= 54447) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54505) {
                              if (code2 < 54476) {
                                if (code2 < 54449) {
                                  if (code2 === 54448) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54449 <= code2 && code2 <= 54475) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54477) {
                                  if (code2 === 54476) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54504) {
                                    if (54477 <= code2 && code2 <= 54503) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54504) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54560) {
                                if (code2 < 54532) {
                                  if (54505 <= code2 && code2 <= 54531) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54533) {
                                    if (code2 === 54532) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54533 <= code2 && code2 <= 54559) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54561) {
                                  if (code2 === 54560) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54588) {
                                    if (54561 <= code2 && code2 <= 54587) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54588) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54756) {
                            if (code2 < 54672) {
                              if (code2 < 54617) {
                                if (code2 < 54616) {
                                  if (54589 <= code2 && code2 <= 54615) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54616) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54644) {
                                  if (54617 <= code2 && code2 <= 54643) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54645) {
                                    if (code2 === 54644) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54645 <= code2 && code2 <= 54671) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54701) {
                                if (code2 < 54673) {
                                  if (code2 === 54672) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54700) {
                                    if (54673 <= code2 && code2 <= 54699) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54700) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54728) {
                                  if (54701 <= code2 && code2 <= 54727) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54729) {
                                    if (code2 === 54728) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54729 <= code2 && code2 <= 54755) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54813) {
                              if (code2 < 54784) {
                                if (code2 < 54757) {
                                  if (code2 === 54756) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54757 <= code2 && code2 <= 54783) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54785) {
                                  if (code2 === 54784) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54812) {
                                    if (54785 <= code2 && code2 <= 54811) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54812) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54868) {
                                if (code2 < 54840) {
                                  if (54813 <= code2 && code2 <= 54839) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54841) {
                                    if (code2 === 54840) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54841 <= code2 && code2 <= 54867) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54869) {
                                  if (code2 === 54868) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54896) {
                                    if (54869 <= code2 && code2 <= 54895) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54896) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 69632) {
                        if (code2 < 55216) {
                          if (code2 < 55037) {
                            if (code2 < 54980) {
                              if (code2 < 54925) {
                                if (code2 < 54924) {
                                  if (54897 <= code2 && code2 <= 54923) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54924) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54952) {
                                  if (54925 <= code2 && code2 <= 54951) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54953) {
                                    if (code2 === 54952) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54953 <= code2 && code2 <= 54979) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 55008) {
                                if (code2 < 54981) {
                                  if (code2 === 54980) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54981 <= code2 && code2 <= 55007) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 55009) {
                                  if (code2 === 55008) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 55036) {
                                    if (55009 <= code2 && code2 <= 55035) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 55036) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 55120) {
                              if (code2 < 55065) {
                                if (code2 < 55064) {
                                  if (55037 <= code2 && code2 <= 55063) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 55064) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 55092) {
                                  if (55065 <= code2 && code2 <= 55091) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 55093) {
                                    if (code2 === 55092) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (55093 <= code2 && code2 <= 55119) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 55149) {
                                if (code2 < 55121) {
                                  if (code2 === 55120) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 55148) {
                                    if (55121 <= code2 && code2 <= 55147) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 55148) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 55176) {
                                  if (55149 <= code2 && code2 <= 55175) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 55177) {
                                    if (code2 === 55176) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (55177 <= code2 && code2 <= 55203) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 68097) {
                            if (code2 < 65279) {
                              if (code2 < 64286) {
                                if (code2 < 55243) {
                                  if (55216 <= code2 && code2 <= 55238) {
                                    return boundaries_1.CLUSTER_BREAK.V;
                                  }
                                } else {
                                  if (55243 <= code2 && code2 <= 55291) {
                                    return boundaries_1.CLUSTER_BREAK.T;
                                  }
                                }
                              } else {
                                if (code2 < 65024) {
                                  if (code2 === 64286) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 65056) {
                                    if (65024 <= code2 && code2 <= 65039) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (65056 <= code2 && code2 <= 65071) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 66045) {
                                if (code2 < 65438) {
                                  if (code2 === 65279) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 65520) {
                                    if (65438 <= code2 && code2 <= 65439) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (65520 <= code2 && code2 <= 65531) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 66272) {
                                  if (code2 === 66045) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 66422) {
                                    if (code2 === 66272) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (66422 <= code2 && code2 <= 66426) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 68325) {
                              if (code2 < 68108) {
                                if (code2 < 68101) {
                                  if (68097 <= code2 && code2 <= 68099) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (68101 <= code2 && code2 <= 68102) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 68152) {
                                  if (68108 <= code2 && code2 <= 68111) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 68159) {
                                    if (68152 <= code2 && code2 <= 68154) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 68159) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69373) {
                                if (code2 < 68900) {
                                  if (68325 <= code2 && code2 <= 68326) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69291) {
                                    if (68900 <= code2 && code2 <= 68903) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (69291 <= code2 && code2 <= 69292) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 69446) {
                                  if (69373 <= code2 && code2 <= 69375) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69506) {
                                    if (69446 <= code2 && code2 <= 69456) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (69506 <= code2 && code2 <= 69509) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 70016) {
                          if (code2 < 69815) {
                            if (code2 < 69747) {
                              if (code2 < 69634) {
                                if (code2 === 69632) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 69633) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 69688) {
                                  if (code2 === 69634) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 69744) {
                                    if (69688 <= code2 && code2 <= 69702) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 69744) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69762) {
                                if (code2 < 69759) {
                                  if (69747 <= code2 && code2 <= 69748) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69759 <= code2 && code2 <= 69761) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 69808) {
                                  if (code2 === 69762) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 69811) {
                                    if (69808 <= code2 && code2 <= 69810) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (69811 <= code2 && code2 <= 69814) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 69888) {
                              if (code2 < 69821) {
                                if (code2 < 69817) {
                                  if (69815 <= code2 && code2 <= 69816) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (69817 <= code2 && code2 <= 69818) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 69826) {
                                  if (code2 === 69821) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 === 69826) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 69837) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69933) {
                                if (code2 < 69927) {
                                  if (69888 <= code2 && code2 <= 69890) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69932) {
                                    if (69927 <= code2 && code2 <= 69931) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 69932) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 69957) {
                                  if (69933 <= code2 && code2 <= 69940) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70003) {
                                    if (69957 <= code2 && code2 <= 69958) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 70003) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 70194) {
                            if (code2 < 70082) {
                              if (code2 < 70067) {
                                if (code2 < 70018) {
                                  if (70016 <= code2 && code2 <= 70017) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 70018) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70070) {
                                  if (70067 <= code2 && code2 <= 70069) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70079) {
                                    if (70070 <= code2 && code2 <= 70078) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70079 <= code2 && code2 <= 70080) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70095) {
                                if (code2 < 70089) {
                                  if (70082 <= code2 && code2 <= 70083) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 70094) {
                                    if (70089 <= code2 && code2 <= 70092) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 70094) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 70188) {
                                  if (code2 === 70095) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70191) {
                                    if (70188 <= code2 && code2 <= 70190) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70191 <= code2 && code2 <= 70193) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70209) {
                              if (code2 < 70197) {
                                if (code2 < 70196) {
                                  if (70194 <= code2 && code2 <= 70195) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70196) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70198) {
                                  if (code2 === 70197) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70206) {
                                    if (70198 <= code2 && code2 <= 70199) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 70206) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70371) {
                                if (code2 < 70367) {
                                  if (code2 === 70209) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70368) {
                                    if (code2 === 70367) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70368 <= code2 && code2 <= 70370) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 70400) {
                                  if (70371 <= code2 && code2 <= 70378) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70402) {
                                    if (70400 <= code2 && code2 <= 70401) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70402 <= code2 && code2 <= 70403) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 72343) {
                      if (code2 < 71339) {
                        if (code2 < 70841) {
                          if (code2 < 70512) {
                            if (code2 < 70471) {
                              if (code2 < 70463) {
                                if (code2 < 70462) {
                                  if (70459 <= code2 && code2 <= 70460) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 70462) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70464) {
                                  if (code2 === 70463) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70465) {
                                    if (code2 === 70464) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70465 <= code2 && code2 <= 70468) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70487) {
                                if (code2 < 70475) {
                                  if (70471 <= code2 && code2 <= 70472) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70475 <= code2 && code2 <= 70477) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70498) {
                                  if (code2 === 70487) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70502) {
                                    if (70498 <= code2 && code2 <= 70499) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70502 <= code2 && code2 <= 70508) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70725) {
                              if (code2 < 70712) {
                                if (code2 < 70709) {
                                  if (70512 <= code2 && code2 <= 70516) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70709 <= code2 && code2 <= 70711) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70720) {
                                  if (70712 <= code2 && code2 <= 70719) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70722) {
                                    if (70720 <= code2 && code2 <= 70721) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70722 <= code2 && code2 <= 70724) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70832) {
                                if (code2 < 70726) {
                                  if (code2 === 70725) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70726) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 70750) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70833) {
                                  if (code2 === 70832) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70835) {
                                    if (70833 <= code2 && code2 <= 70834) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70835 <= code2 && code2 <= 70840) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 71096) {
                            if (code2 < 70847) {
                              if (code2 < 70843) {
                                if (code2 === 70841) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 70842) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70845) {
                                  if (70843 <= code2 && code2 <= 70844) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70845) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 70846) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71087) {
                                if (code2 < 70849) {
                                  if (70847 <= code2 && code2 <= 70848) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70850) {
                                    if (code2 === 70849) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70850 <= code2 && code2 <= 70851) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71088) {
                                  if (code2 === 71087) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71090) {
                                    if (71088 <= code2 && code2 <= 71089) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71090 <= code2 && code2 <= 71093) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71216) {
                              if (code2 < 71102) {
                                if (code2 < 71100) {
                                  if (71096 <= code2 && code2 <= 71099) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71100 <= code2 && code2 <= 71101) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 71103) {
                                  if (code2 === 71102) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 71132) {
                                    if (71103 <= code2 && code2 <= 71104) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (71132 <= code2 && code2 <= 71133) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71229) {
                                if (code2 < 71219) {
                                  if (71216 <= code2 && code2 <= 71218) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 71227) {
                                    if (71219 <= code2 && code2 <= 71226) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (71227 <= code2 && code2 <= 71228) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71230) {
                                  if (code2 === 71229) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71231) {
                                    if (code2 === 71230) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71231 <= code2 && code2 <= 71232) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 71999) {
                          if (code2 < 71463) {
                            if (code2 < 71350) {
                              if (code2 < 71341) {
                                if (code2 === 71339) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 71340) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 71342) {
                                  if (code2 === 71341) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71344) {
                                    if (71342 <= code2 && code2 <= 71343) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71344 <= code2 && code2 <= 71349) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71453) {
                                if (code2 === 71350) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 71351) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71458) {
                                  if (71453 <= code2 && code2 <= 71455) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71462) {
                                    if (71458 <= code2 && code2 <= 71461) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 71462) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71984) {
                              if (code2 < 71727) {
                                if (code2 < 71724) {
                                  if (71463 <= code2 && code2 <= 71467) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71724 <= code2 && code2 <= 71726) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 71736) {
                                  if (71727 <= code2 && code2 <= 71735) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71737) {
                                    if (code2 === 71736) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71737 <= code2 && code2 <= 71738) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71995) {
                                if (code2 < 71985) {
                                  if (code2 === 71984) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71991) {
                                    if (71985 <= code2 && code2 <= 71989) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71991 <= code2 && code2 <= 71992) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71997) {
                                  if (71995 <= code2 && code2 <= 71996) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 71997) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 71998) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 72193) {
                            if (code2 < 72145) {
                              if (code2 < 72001) {
                                if (code2 === 71999) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code2 === 72e3) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 72002) {
                                  if (code2 === 72001) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 === 72002) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 72003) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72156) {
                                if (code2 < 72148) {
                                  if (72145 <= code2 && code2 <= 72147) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72154) {
                                    if (72148 <= code2 && code2 <= 72151) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72154 <= code2 && code2 <= 72155) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 72160) {
                                  if (72156 <= code2 && code2 <= 72159) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 72160) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 72164) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 72263) {
                              if (code2 < 72249) {
                                if (code2 < 72243) {
                                  if (72193 <= code2 && code2 <= 72202) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72243 <= code2 && code2 <= 72248) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72250) {
                                  if (code2 === 72249) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72251) {
                                    if (code2 === 72250) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  } else {
                                    if (72251 <= code2 && code2 <= 72254) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72281) {
                                if (code2 < 72273) {
                                  if (code2 === 72263) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72279) {
                                    if (72273 <= code2 && code2 <= 72278) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72279 <= code2 && code2 <= 72280) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 72324) {
                                  if (72281 <= code2 && code2 <= 72283) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72330) {
                                    if (72324 <= code2 && code2 <= 72329) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  } else {
                                    if (72330 <= code2 && code2 <= 72342) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 94033) {
                        if (code2 < 73104) {
                          if (code2 < 72881) {
                            if (code2 < 72766) {
                              if (code2 < 72751) {
                                if (code2 < 72344) {
                                  if (code2 === 72343) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72344 <= code2 && code2 <= 72345) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72752) {
                                  if (code2 === 72751) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72760) {
                                    if (72752 <= code2 && code2 <= 72758) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72760 <= code2 && code2 <= 72765) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72850) {
                                if (code2 === 72766) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 72767) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 72873) {
                                  if (72850 <= code2 && code2 <= 72871) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72874) {
                                    if (code2 === 72873) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (72874 <= code2 && code2 <= 72880) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 73018) {
                              if (code2 < 72884) {
                                if (code2 < 72882) {
                                  if (code2 === 72881) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72882 <= code2 && code2 <= 72883) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72885) {
                                  if (code2 === 72884) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 73009) {
                                    if (72885 <= code2 && code2 <= 72886) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73009 <= code2 && code2 <= 73014) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 73030) {
                                if (code2 < 73020) {
                                  if (code2 === 73018) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 73023) {
                                    if (73020 <= code2 && code2 <= 73021) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73023 <= code2 && code2 <= 73029) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 73031) {
                                  if (code2 === 73030) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 73098) {
                                    if (code2 === 73031) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73098 <= code2 && code2 <= 73102) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 73526) {
                            if (code2 < 73459) {
                              if (code2 < 73109) {
                                if (code2 < 73107) {
                                  if (73104 <= code2 && code2 <= 73105) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73107 <= code2 && code2 <= 73108) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 73110) {
                                  if (code2 === 73109) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 73110) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 73111) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 73474) {
                                if (code2 < 73461) {
                                  if (73459 <= code2 && code2 <= 73460) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 73472) {
                                    if (73461 <= code2 && code2 <= 73462) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (73472 <= code2 && code2 <= 73473) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 73475) {
                                  if (code2 === 73474) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 73524) {
                                    if (code2 === 73475) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (73524 <= code2 && code2 <= 73525) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 78896) {
                              if (code2 < 73536) {
                                if (code2 < 73534) {
                                  if (73526 <= code2 && code2 <= 73530) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73534 <= code2 && code2 <= 73535) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 73537) {
                                  if (code2 === 73536) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 73537) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 73538) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 92912) {
                                if (code2 < 78912) {
                                  if (78896 <= code2 && code2 <= 78911) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 78919) {
                                    if (code2 === 78912) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (78919 <= code2 && code2 <= 78933) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 92976) {
                                  if (92912 <= code2 && code2 <= 92916) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 94031) {
                                    if (92976 <= code2 && code2 <= 92982) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 94031) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 121476) {
                          if (code2 < 119143) {
                            if (code2 < 113824) {
                              if (code2 < 94180) {
                                if (code2 < 94095) {
                                  if (94033 <= code2 && code2 <= 94087) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (94095 <= code2 && code2 <= 94098) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 94192) {
                                  if (code2 === 94180) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 113821) {
                                    if (94192 <= code2 && code2 <= 94193) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (113821 <= code2 && code2 <= 113822) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 118576) {
                                if (code2 < 118528) {
                                  if (113824 <= code2 && code2 <= 113827) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (118528 <= code2 && code2 <= 118573) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 119141) {
                                  if (118576 <= code2 && code2 <= 118598) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 119141) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 119142) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 119173) {
                              if (code2 < 119150) {
                                if (code2 < 119149) {
                                  if (119143 <= code2 && code2 <= 119145) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 119149) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 119155) {
                                  if (119150 <= code2 && code2 <= 119154) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 119163) {
                                    if (119155 <= code2 && code2 <= 119162) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (119163 <= code2 && code2 <= 119170) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 121344) {
                                if (code2 < 119210) {
                                  if (119173 <= code2 && code2 <= 119179) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 119362) {
                                    if (119210 <= code2 && code2 <= 119213) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (119362 <= code2 && code2 <= 119364) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 121403) {
                                  if (121344 <= code2 && code2 <= 121398) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 121461) {
                                    if (121403 <= code2 && code2 <= 121452) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 121461) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 123628) {
                            if (code2 < 122907) {
                              if (code2 < 121505) {
                                if (code2 < 121499) {
                                  if (code2 === 121476) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (121499 <= code2 && code2 <= 121503) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 122880) {
                                  if (121505 <= code2 && code2 <= 121519) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 122888) {
                                    if (122880 <= code2 && code2 <= 122886) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (122888 <= code2 && code2 <= 122904) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 123023) {
                                if (code2 < 122915) {
                                  if (122907 <= code2 && code2 <= 122913) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 122918) {
                                    if (122915 <= code2 && code2 <= 122916) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (122918 <= code2 && code2 <= 122922) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 123184) {
                                  if (code2 === 123023) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 123566) {
                                    if (123184 <= code2 && code2 <= 123190) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 123566) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 127995) {
                              if (code2 < 125136) {
                                if (code2 < 124140) {
                                  if (123628 <= code2 && code2 <= 123631) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (124140 <= code2 && code2 <= 124143) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 125252) {
                                  if (125136 <= code2 && code2 <= 125142) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 127462) {
                                    if (125252 <= code2 && code2 <= 125258) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (127462 <= code2 && code2 <= 127487) {
                                      return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 917632) {
                                if (code2 < 917504) {
                                  if (127995 <= code2 && code2 <= 127999) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 917536) {
                                    if (917504 <= code2 && code2 <= 917535) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (917536 <= code2 && code2 <= 917631) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 917760) {
                                  if (917632 <= code2 && code2 <= 917759) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 918e3) {
                                    if (917760 <= code2 && code2 <= 917999) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (918e3 <= code2 && code2 <= 921599) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return boundaries_1.CLUSTER_BREAK.OTHER;
            }
            static getEmojiProperty(code2) {
              if (code2 < 10160) {
                if (code2 < 9728) {
                  if (code2 < 9e3) {
                    if (code2 < 8482) {
                      if (code2 < 8252) {
                        if (code2 === 169) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 174) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 8252) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 8265) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 8596) {
                        if (code2 === 8482) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 8505) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 8617) {
                          if (8596 <= code2 && code2 <= 8601) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 8986) {
                            if (8617 <= code2 && code2 <= 8618) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (8986 <= code2 && code2 <= 8987) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 9410) {
                      if (code2 < 9167) {
                        if (code2 === 9e3) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 9096) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 9193) {
                          if (code2 === 9167) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9208) {
                            if (9193 <= code2 && code2 <= 9203) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9208 <= code2 && code2 <= 9210) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 9654) {
                        if (code2 < 9642) {
                          if (code2 === 9410) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9642 <= code2 && code2 <= 9643) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 9664) {
                          if (code2 === 9654) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9723) {
                            if (code2 === 9664) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9723 <= code2 && code2 <= 9726) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 10035) {
                    if (code2 < 10004) {
                      if (code2 < 9748) {
                        if (code2 < 9735) {
                          if (9728 <= code2 && code2 <= 9733) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9735 <= code2 && code2 <= 9746) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 9872) {
                          if (9748 <= code2 && code2 <= 9861) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9992) {
                            if (9872 <= code2 && code2 <= 9989) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9992 <= code2 && code2 <= 10002) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 10013) {
                        if (code2 === 10004) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 10006) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 10017) {
                          if (code2 === 10013) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10017) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 10024) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 10067) {
                      if (code2 < 10055) {
                        if (code2 < 10052) {
                          if (10035 <= code2 && code2 <= 10036) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10052) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 10060) {
                          if (code2 === 10055) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10060) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 10062) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    } else {
                      if (code2 < 10083) {
                        if (code2 < 10071) {
                          if (10067 <= code2 && code2 <= 10069) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10071) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 10133) {
                          if (10083 <= code2 && code2 <= 10087) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 10145) {
                            if (10133 <= code2 && code2 <= 10135) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (code2 === 10145) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 127489) {
                  if (code2 < 12951) {
                    if (code2 < 11035) {
                      if (code2 < 10548) {
                        if (code2 === 10160) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 10175) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 11013) {
                          if (10548 <= code2 && code2 <= 10549) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (11013 <= code2 && code2 <= 11015) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    } else {
                      if (code2 < 11093) {
                        if (code2 < 11088) {
                          if (11035 <= code2 && code2 <= 11036) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 11088) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 12336) {
                          if (code2 === 11093) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 12336) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 12349) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 127340) {
                      if (code2 < 126976) {
                        if (code2 === 12951) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 12953) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 127245) {
                          if (126976 <= code2 && code2 <= 127231) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127279) {
                            if (127245 <= code2 && code2 <= 127247) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (code2 === 127279) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 127374) {
                        if (code2 < 127358) {
                          if (127340 <= code2 && code2 <= 127345) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127358 <= code2 && code2 <= 127359) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 127377) {
                          if (code2 === 127374) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127405) {
                            if (127377 <= code2 && code2 <= 127386) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (127405 <= code2 && code2 <= 127461) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 128981) {
                    if (code2 < 127561) {
                      if (code2 < 127535) {
                        if (code2 < 127514) {
                          if (127489 <= code2 && code2 <= 127503) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 127514) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 127538) {
                          if (code2 === 127535) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127548) {
                            if (127538 <= code2 && code2 <= 127546) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (127548 <= code2 && code2 <= 127551) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 128326) {
                        if (code2 < 128e3) {
                          if (127561 <= code2 && code2 <= 127994) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (128e3 <= code2 && code2 <= 128317) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 128640) {
                          if (128326 <= code2 && code2 <= 128591) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 128884) {
                            if (128640 <= code2 && code2 <= 128767) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (128884 <= code2 && code2 <= 128895) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 129198) {
                      if (code2 < 129096) {
                        if (code2 < 129036) {
                          if (128981 <= code2 && code2 <= 129023) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129036 <= code2 && code2 <= 129039) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 129114) {
                          if (129096 <= code2 && code2 <= 129103) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 129160) {
                            if (129114 <= code2 && code2 <= 129119) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (129160 <= code2 && code2 <= 129167) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 129340) {
                        if (code2 < 129292) {
                          if (129198 <= code2 && code2 <= 129279) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129292 <= code2 && code2 <= 129338) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 129351) {
                          if (129340 <= code2 && code2 <= 129349) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 130048) {
                            if (129351 <= code2 && code2 <= 129791) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (130048 <= code2 && code2 <= 131069) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return boundaries_1.CLUSTER_BREAK.OTHER;
            }
          };
          exports2.default = Graphemer2;
        }
      });
      var require_lib = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/index.js"(exports2) {
          "use strict";
          var __importDefault = exports2 && exports2.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var Graphemer_1 = __importDefault(require_Graphemer());
          exports2.default = Graphemer_1.default;
        }
      });
      var require_dist3 = __commonJS2({
        "../../node_modules/.pnpm/iso-datestring-validator@2.2.2/node_modules/iso-datestring-validator/dist/index.js"(exports2) {
          (() => {
            "use strict";
            var e = { d: (t2, r2) => {
              for (var n2 in r2)
                e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
            }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
              typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
            } }, t = {};
            function r(e2, t2) {
              return t2 === void 0 && (t2 = "-"), new RegExp("^(?!0{4}" + t2 + "0{2}" + t2 + "0{2})((?=[0-9]{4}" + t2 + "(((0[^2])|1[0-2])|02(?=" + t2 + "(([0-1][0-9])|2[0-8])))" + t2 + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t2 + "02" + t2 + "29))([0-9]{4})" + t2 + "(?!((0[469])|11)" + t2 + "31)((0[1,3-9]|1[0-2])|(02(?!" + t2 + "3)))" + t2 + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e2);
            }
            function n(e2) {
              var t2 = /\D/.exec(e2);
              return t2 ? t2[0] : "";
            }
            function i(e2, t2, r2) {
              t2 === void 0 && (t2 = ":"), r2 === void 0 && (r2 = false);
              var i2 = new RegExp("^([0-1]|2(?=([0-3])|4" + t2 + "00))[0-9]" + t2 + "[0-5][0-9](" + t2 + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
              if (!r2 || !/[Z+\-]/.test(e2))
                return i2.test(e2);
              if (/Z$/.test(e2))
                return i2.test(e2.replace("Z", ""));
              var o2 = e2.includes("+"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];
              return i2.test(u2) && function(e3, t3, r3) {
                return r3 === void 0 && (r3 = ":"), new RegExp(t3 ? "^(0(?!(2" + r3 + "4)|0" + r3 + "3)|1(?=([0-1]|2(?=" + r3 + "[04])|[34](?=" + r3 + "0))))([03469](?=" + r3 + "[03])|[17](?=" + r3 + "0)|2(?=" + r3 + "[04])|5(?=" + r3 + "[034])|8(?=" + r3 + "[04]))" + r3 + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r3 + "[03])|[0-24-8](?=" + r3 + "00))" + r3 + "[03]0$").test(e3);
              }(d2, o2, n(d2));
            }
            function o(e2) {
              var t2 = e2.split("T"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));
              if (!a2)
                return false;
              var d2, s = (d2 = a2.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d2) ? d2[0] : "");
              return u2 && i(a2, s, true);
            }
            function a(e2, t2) {
              return t2 === void 0 && (t2 = "-"), new RegExp("^[0-9]{4}" + t2 + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e2);
            }
            e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });
            var u = exports2;
            for (var d in t)
              u[d] = t[d];
            t.__esModule && Object.defineProperty(u, "__esModule", { value: true });
          })();
        }
      });
      var src_exports2 = {};
      __export(src_exports2, {
        APP_BSKY_GRAPH: () => APP_BSKY_GRAPH,
        ActorNS: () => ActorNS,
        AdminNS: () => AdminNS,
        AppBskyActorDefs: () => defs_exports5,
        AppBskyActorGetPreferences: () => getPreferences_exports,
        AppBskyActorGetProfile: () => getProfile_exports,
        AppBskyActorGetProfiles: () => getProfiles_exports,
        AppBskyActorGetSuggestions: () => getSuggestions_exports,
        AppBskyActorProfile: () => profile_exports,
        AppBskyActorPutPreferences: () => putPreferences_exports,
        AppBskyActorSearchActors: () => searchActors_exports,
        AppBskyActorSearchActorsTypeahead: () => searchActorsTypeahead_exports,
        AppBskyEmbedExternal: () => external_exports,
        AppBskyEmbedImages: () => images_exports,
        AppBskyEmbedRecord: () => record_exports,
        AppBskyEmbedRecordWithMedia: () => recordWithMedia_exports,
        AppBskyFeedDefs: () => defs_exports6,
        AppBskyFeedDescribeFeedGenerator: () => describeFeedGenerator_exports,
        AppBskyFeedGenerator: () => generator_exports,
        AppBskyFeedGetActorFeeds: () => getActorFeeds_exports,
        AppBskyFeedGetActorLikes: () => getActorLikes_exports,
        AppBskyFeedGetAuthorFeed: () => getAuthorFeed_exports,
        AppBskyFeedGetFeed: () => getFeed_exports,
        AppBskyFeedGetFeedGenerator: () => getFeedGenerator_exports,
        AppBskyFeedGetFeedGenerators: () => getFeedGenerators_exports,
        AppBskyFeedGetFeedSkeleton: () => getFeedSkeleton_exports,
        AppBskyFeedGetLikes: () => getLikes_exports,
        AppBskyFeedGetListFeed: () => getListFeed_exports,
        AppBskyFeedGetPostThread: () => getPostThread_exports,
        AppBskyFeedGetPosts: () => getPosts_exports,
        AppBskyFeedGetRepostedBy: () => getRepostedBy_exports,
        AppBskyFeedGetSuggestedFeeds: () => getSuggestedFeeds_exports,
        AppBskyFeedGetTimeline: () => getTimeline_exports,
        AppBskyFeedLike: () => like_exports,
        AppBskyFeedPost: () => post_exports,
        AppBskyFeedRepost: () => repost_exports,
        AppBskyFeedSearchPosts: () => searchPosts_exports,
        AppBskyFeedThreadgate: () => threadgate_exports,
        AppBskyGraphBlock: () => block_exports,
        AppBskyGraphDefs: () => defs_exports7,
        AppBskyGraphFollow: () => follow_exports,
        AppBskyGraphGetBlocks: () => getBlocks_exports2,
        AppBskyGraphGetFollowers: () => getFollowers_exports,
        AppBskyGraphGetFollows: () => getFollows_exports,
        AppBskyGraphGetList: () => getList_exports,
        AppBskyGraphGetListBlocks: () => getListBlocks_exports,
        AppBskyGraphGetListMutes: () => getListMutes_exports,
        AppBskyGraphGetLists: () => getLists_exports,
        AppBskyGraphGetMutes: () => getMutes_exports,
        AppBskyGraphGetSuggestedFollowsByActor: () => getSuggestedFollowsByActor_exports,
        AppBskyGraphList: () => list_exports,
        AppBskyGraphListblock: () => listblock_exports,
        AppBskyGraphListitem: () => listitem_exports,
        AppBskyGraphMuteActor: () => muteActor_exports,
        AppBskyGraphMuteActorList: () => muteActorList_exports,
        AppBskyGraphUnmuteActor: () => unmuteActor_exports,
        AppBskyGraphUnmuteActorList: () => unmuteActorList_exports,
        AppBskyNotificationGetUnreadCount: () => getUnreadCount_exports,
        AppBskyNotificationListNotifications: () => listNotifications_exports,
        AppBskyNotificationRegisterPush: () => registerPush_exports,
        AppBskyNotificationUpdateSeen: () => updateSeen_exports,
        AppBskyRichtextFacet: () => facet_exports,
        AppBskyUnspeccedDefs: () => defs_exports8,
        AppBskyUnspeccedGetPopular: () => getPopular_exports,
        AppBskyUnspeccedGetPopularFeedGenerators: () => getPopularFeedGenerators_exports,
        AppBskyUnspeccedGetTimelineSkeleton: () => getTimelineSkeleton_exports,
        AppBskyUnspeccedSearchActorsSkeleton: () => searchActorsSkeleton_exports,
        AppBskyUnspeccedSearchPostsSkeleton: () => searchPostsSkeleton_exports,
        AppNS: () => AppNS,
        AtUri: () => AtUri,
        AtpAgent: () => AtpAgent,
        AtpBaseClient: () => AtpBaseClient,
        AtpServiceClient: () => AtpServiceClient,
        AtprotoNS: () => AtprotoNS,
        BlobRef: () => BlobRef,
        BlockRecord: () => BlockRecord,
        BskyAgent: () => BskyAgent2,
        BskyNS: () => BskyNS,
        COM_ATPROTO_ADMIN: () => COM_ATPROTO_ADMIN,
        COM_ATPROTO_MODERATION: () => COM_ATPROTO_MODERATION,
        ComAtprotoAdminDefs: () => defs_exports,
        ComAtprotoAdminDeleteAccount: () => deleteAccount_exports,
        ComAtprotoAdminDisableAccountInvites: () => disableAccountInvites_exports,
        ComAtprotoAdminDisableInviteCodes: () => disableInviteCodes_exports,
        ComAtprotoAdminEmitModerationEvent: () => emitModerationEvent_exports,
        ComAtprotoAdminEnableAccountInvites: () => enableAccountInvites_exports,
        ComAtprotoAdminGetAccountInfo: () => getAccountInfo_exports,
        ComAtprotoAdminGetInviteCodes: () => getInviteCodes_exports,
        ComAtprotoAdminGetModerationEvent: () => getModerationEvent_exports,
        ComAtprotoAdminGetRecord: () => getRecord_exports,
        ComAtprotoAdminGetRepo: () => getRepo_exports,
        ComAtprotoAdminGetSubjectStatus: () => getSubjectStatus_exports,
        ComAtprotoAdminQueryModerationEvents: () => queryModerationEvents_exports,
        ComAtprotoAdminQueryModerationStatuses: () => queryModerationStatuses_exports,
        ComAtprotoAdminSearchRepos: () => searchRepos_exports,
        ComAtprotoAdminSendEmail: () => sendEmail_exports,
        ComAtprotoAdminUpdateAccountEmail: () => updateAccountEmail_exports,
        ComAtprotoAdminUpdateAccountHandle: () => updateAccountHandle_exports,
        ComAtprotoAdminUpdateSubjectStatus: () => updateSubjectStatus_exports,
        ComAtprotoIdentityResolveHandle: () => resolveHandle_exports,
        ComAtprotoIdentityUpdateHandle: () => updateHandle_exports,
        ComAtprotoLabelDefs: () => defs_exports2,
        ComAtprotoLabelQueryLabels: () => queryLabels_exports,
        ComAtprotoLabelSubscribeLabels: () => subscribeLabels_exports,
        ComAtprotoModerationCreateReport: () => createReport_exports,
        ComAtprotoModerationDefs: () => defs_exports3,
        ComAtprotoRepoApplyWrites: () => applyWrites_exports,
        ComAtprotoRepoCreateRecord: () => createRecord_exports,
        ComAtprotoRepoDeleteRecord: () => deleteRecord_exports,
        ComAtprotoRepoDescribeRepo: () => describeRepo_exports,
        ComAtprotoRepoGetRecord: () => getRecord_exports2,
        ComAtprotoRepoListRecords: () => listRecords_exports,
        ComAtprotoRepoPutRecord: () => putRecord_exports,
        ComAtprotoRepoStrongRef: () => strongRef_exports,
        ComAtprotoRepoUploadBlob: () => uploadBlob_exports,
        ComAtprotoServerConfirmEmail: () => confirmEmail_exports,
        ComAtprotoServerCreateAccount: () => createAccount_exports,
        ComAtprotoServerCreateAppPassword: () => createAppPassword_exports,
        ComAtprotoServerCreateInviteCode: () => createInviteCode_exports,
        ComAtprotoServerCreateInviteCodes: () => createInviteCodes_exports,
        ComAtprotoServerCreateSession: () => createSession_exports,
        ComAtprotoServerDefs: () => defs_exports4,
        ComAtprotoServerDeleteAccount: () => deleteAccount_exports2,
        ComAtprotoServerDeleteSession: () => deleteSession_exports,
        ComAtprotoServerDescribeServer: () => describeServer_exports,
        ComAtprotoServerGetAccountInviteCodes: () => getAccountInviteCodes_exports,
        ComAtprotoServerGetSession: () => getSession_exports,
        ComAtprotoServerListAppPasswords: () => listAppPasswords_exports,
        ComAtprotoServerRefreshSession: () => refreshSession_exports,
        ComAtprotoServerRequestAccountDelete: () => requestAccountDelete_exports,
        ComAtprotoServerRequestEmailConfirmation: () => requestEmailConfirmation_exports,
        ComAtprotoServerRequestEmailUpdate: () => requestEmailUpdate_exports,
        ComAtprotoServerRequestPasswordReset: () => requestPasswordReset_exports,
        ComAtprotoServerReserveSigningKey: () => reserveSigningKey_exports,
        ComAtprotoServerResetPassword: () => resetPassword_exports,
        ComAtprotoServerRevokeAppPassword: () => revokeAppPassword_exports,
        ComAtprotoServerUpdateEmail: () => updateEmail_exports,
        ComAtprotoSyncGetBlob: () => getBlob_exports,
        ComAtprotoSyncGetBlocks: () => getBlocks_exports,
        ComAtprotoSyncGetCheckout: () => getCheckout_exports,
        ComAtprotoSyncGetHead: () => getHead_exports,
        ComAtprotoSyncGetLatestCommit: () => getLatestCommit_exports,
        ComAtprotoSyncGetRecord: () => getRecord_exports3,
        ComAtprotoSyncGetRepo: () => getRepo_exports2,
        ComAtprotoSyncListBlobs: () => listBlobs_exports,
        ComAtprotoSyncListRepos: () => listRepos_exports,
        ComAtprotoSyncNotifyOfUpdate: () => notifyOfUpdate_exports,
        ComAtprotoSyncRequestCrawl: () => requestCrawl_exports,
        ComAtprotoSyncSubscribeRepos: () => subscribeRepos_exports,
        ComAtprotoTempFetchLabels: () => fetchLabels_exports,
        ComAtprotoTempImportRepo: () => importRepo_exports,
        ComAtprotoTempPushBlob: () => pushBlob_exports,
        ComAtprotoTempTransferAccount: () => transferAccount_exports,
        ComNS: () => ComNS,
        EmbedNS: () => EmbedNS,
        FeedNS: () => FeedNS,
        FollowRecord: () => FollowRecord,
        GeneratorRecord: () => GeneratorRecord,
        GraphNS: () => GraphNS,
        IdentityNS: () => IdentityNS,
        LABELS: () => LABELS,
        LABEL_GROUPS: () => LABEL_GROUPS,
        LabelNS: () => LabelNS,
        LikeRecord: () => LikeRecord,
        ListRecord: () => ListRecord,
        ListblockRecord: () => ListblockRecord,
        ListitemRecord: () => ListitemRecord,
        ModerationDecision: () => ModerationDecision,
        ModerationNS: () => ModerationNS,
        NotificationNS: () => NotificationNS,
        PostRecord: () => PostRecord,
        ProfileRecord: () => ProfileRecord,
        RepoNS: () => RepoNS,
        RepostRecord: () => RepostRecord,
        RichText: () => RichText,
        RichTextSegment: () => RichTextSegment,
        RichtextNS: () => RichtextNS,
        ServerNS: () => ServerNS,
        SyncNS: () => SyncNS,
        TempNS: () => TempNS,
        ThreadgateRecord: () => ThreadgateRecord,
        UnicodeString: () => UnicodeString,
        UnspeccedNS: () => UnspeccedNS,
        default: () => AtpAgent,
        jsonStringToLex: () => jsonStringToLex,
        jsonToLex: () => jsonToLex,
        lexToJson: () => lexToJson,
        moderateFeedGenerator: () => moderateFeedGenerator,
        moderatePost: () => moderatePost,
        moderateProfile: () => moderateProfile,
        moderateUserList: () => moderateUserList,
        parseLanguage: () => parseLanguage,
        sanitizeRichText: () => sanitizeRichText,
        stringifyLex: () => stringifyLex
      });
      module.exports = __toCommonJS(src_exports2);
      var ensureValidHandle = (handle2) => {
        if (!/^[a-zA-Z0-9.-]*$/.test(handle2)) {
          throw new InvalidHandleError("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
        }
        if (handle2.length > 253) {
          throw new InvalidHandleError("Handle is too long (253 chars max)");
        }
        const labels = handle2.split(".");
        if (labels.length < 2) {
          throw new InvalidHandleError("Handle domain needs at least two parts");
        }
        for (let i = 0; i < labels.length; i++) {
          const l = labels[i];
          if (l.length < 1) {
            throw new InvalidHandleError("Handle parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidHandleError("Handle part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidHandleError("Handle parts can not start or end with hyphens");
          }
          if (i + 1 == labels.length && !/^[a-zA-Z]/.test(l)) {
            throw new InvalidHandleError("Handle final component (TLD) must start with ASCII letter");
          }
        }
      };
      var InvalidHandleError = class extends Error {
      };
      var ensureValidDid = (did2) => {
        if (!/^[a-zA-Z0-9._:%-]*$/.test(did2)) {
          throw new InvalidDidError("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
        }
        const parts = did2.split(":");
        if (parts.length < 3) {
          throw new InvalidDidError("DID requires prefix, method, and method-specific content");
        }
        if (parts[0] != "did") {
          throw new InvalidDidError('DID requires "did:" prefix');
        }
        if (!/^[a-z]+$/.test(parts[1])) {
          throw new InvalidDidError("DID method must be lower-case letters");
        }
        if (did2.endsWith(":") || did2.endsWith("%")) {
          throw new InvalidDidError('DID can not end with ":" or "%"');
        }
        if (did2.length > 2 * 1024) {
          throw new InvalidDidError("DID is too long (2048 chars max)");
        }
      };
      var InvalidDidError = class extends Error {
      };
      var NSID = class {
        constructor(nsid2) {
          this.segments = [];
          ensureValidNsid(nsid2);
          this.segments = nsid2.split(".");
        }
        static parse(nsid2) {
          return new NSID(nsid2);
        }
        static create(authority, name2) {
          const segments = [...authority.split(".").reverse(), name2].join(".");
          return new NSID(segments);
        }
        static isValid(nsid2) {
          try {
            NSID.parse(nsid2);
            return true;
          } catch (e) {
            return false;
          }
        }
        get authority() {
          return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
        }
        get name() {
          return this.segments.at(this.segments.length - 1);
        }
        toString() {
          return this.segments.join(".");
        }
      };
      var ensureValidNsid = (nsid2) => {
        const toCheck = nsid2;
        if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
          throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
        }
        if (toCheck.length > 253 + 1 + 63) {
          throw new InvalidNsidError("NSID is too long (317 chars max)");
        }
        const labels = toCheck.split(".");
        if (labels.length < 3) {
          throw new InvalidNsidError("NSID needs at least three parts");
        }
        for (let i = 0; i < labels.length; i++) {
          const l = labels[i];
          if (l.length < 1) {
            throw new InvalidNsidError("NSID parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidNsidError("NSID part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidNsidError("NSID parts can not start or end with hyphen");
          }
          if (/^[0-9]/.test(l) && i == 0) {
            throw new InvalidNsidError("NSID first part may not start with a digit");
          }
          if (!/^[a-zA-Z]+$/.test(l) && i + 1 == labels.length) {
            throw new InvalidNsidError("NSID name part must be only letters");
          }
        }
      };
      var InvalidNsidError = class extends Error {
      };
      var ensureValidAtUri = (uri2) => {
        const uriParts = uri2.split("#");
        if (uriParts.length > 2) {
          throw new Error('ATURI can have at most one "#", separating fragment out');
        }
        const fragmentPart = uriParts[1] || null;
        uri2 = uriParts[0];
        if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri2)) {
          throw new Error("Disallowed characters in ATURI (ASCII)");
        }
        const parts = uri2.split("/");
        if (parts.length >= 3 && (parts[0] != "at:" || parts[1].length != 0)) {
          throw new Error('ATURI must start with "at://"');
        }
        if (parts.length < 3) {
          throw new Error("ATURI requires at least method and authority sections");
        }
        try {
          if (parts[2].startsWith("did:")) {
            ensureValidDid(parts[2]);
          } else {
            ensureValidHandle(parts[2]);
          }
        } catch (e) {
          throw new Error("ATURI authority must be a valid handle or DID");
        }
        if (parts.length >= 4) {
          if (parts[3].length == 0) {
            throw new Error("ATURI can not have a slash after authority without a path segment");
          }
          try {
            ensureValidNsid(parts[3]);
          } catch (e) {
            throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
          }
        }
        if (parts.length >= 5) {
          if (parts[4].length == 0) {
            throw new Error("ATURI can not have a slash after collection, unless record key is provided");
          }
        }
        if (parts.length >= 6) {
          throw new Error("ATURI path can have at most two parts, and no trailing slash");
        }
        if (uriParts.length >= 2 && fragmentPart == null) {
          throw new Error("ATURI fragment must be non-empty and start with slash");
        }
        if (fragmentPart != null) {
          if (fragmentPart.length == 0 || fragmentPart[0] != "/") {
            throw new Error("ATURI fragment must be non-empty and start with slash");
          }
          if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
            throw new Error("Disallowed characters in ATURI fragment (ASCII)");
          }
        }
        if (uri2.length > 8 * 1024) {
          throw new Error("ATURI is far too long");
        }
      };
      var ATP_URI_REGEX = /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      var RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      var AtUri = class {
        constructor(uri2, base3) {
          let parsed;
          if (base3) {
            parsed = parse(base3);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${base3}`);
            }
            const relativep = parseRelative(uri2);
            if (!relativep) {
              throw new Error(`Invalid path: ${uri2}`);
            }
            Object.assign(parsed, relativep);
          } else {
            parsed = parse(uri2);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${uri2}`);
            }
          }
          this.hash = parsed.hash;
          this.host = parsed.host;
          this.pathname = parsed.pathname;
          this.searchParams = parsed.searchParams;
        }
        static make(handleOrDid, collection, rkey) {
          let str = handleOrDid;
          if (collection)
            str += "/" + collection;
          if (rkey)
            str += "/" + rkey;
          return new AtUri(str);
        }
        get protocol() {
          return "at:";
        }
        get origin() {
          return `at://${this.host}`;
        }
        get hostname() {
          return this.host;
        }
        set hostname(v) {
          this.host = v;
        }
        get search() {
          return this.searchParams.toString();
        }
        set search(v) {
          this.searchParams = new URLSearchParams(v);
        }
        get collection() {
          return this.pathname.split("/").filter(Boolean)[0] || "";
        }
        set collection(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          parts[0] = v;
          this.pathname = parts.join("/");
        }
        get rkey() {
          return this.pathname.split("/").filter(Boolean)[1] || "";
        }
        set rkey(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          if (!parts[0])
            parts[0] = "undefined";
          parts[1] = v;
          this.pathname = parts.join("/");
        }
        get href() {
          return this.toString();
        }
        toString() {
          let path = this.pathname || "/";
          if (!path.startsWith("/")) {
            path = `/${path}`;
          }
          let qs = this.searchParams.toString();
          if (qs && !qs.startsWith("?")) {
            qs = `?${qs}`;
          }
          let hash = this.hash;
          if (hash && !hash.startsWith("#")) {
            hash = `#${hash}`;
          }
          return `at://${this.host}${path}${qs}${hash}`;
        }
      };
      function parse(str) {
        const match = ATP_URI_REGEX.exec(str);
        if (match) {
          return {
            hash: match[5] || "",
            host: match[2] || "",
            pathname: match[3] || "",
            searchParams: new URLSearchParams(match[4] || "")
          };
        }
        return void 0;
      }
      function parseRelative(str) {
        const match = RELATIVE_REGEX.exec(str);
        if (match) {
          return {
            hash: match[3] || "",
            pathname: match[1] || "",
            searchParams: new URLSearchParams(match[2] || "")
          };
        }
        return void 0;
      }
      var util;
      (function(util2) {
        util2.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util2.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util2.assertNever = assertNever;
        util2.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util2.getValidEnumValues = (obj) => {
          const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
          const filtered = {};
          for (const k of validKeys) {
            filtered[k] = obj[k];
          }
          return util2.objectValues(filtered);
        };
        util2.objectValues = (obj) => {
          return util2.objectKeys(obj).map(function(e) {
            return obj[e];
          });
        };
        util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
          const keys = [];
          for (const key in object2) {
            if (Object.prototype.hasOwnProperty.call(object2, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        util2.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array2, separator = " | ") {
          return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util2.joinValues = joinValues;
        util2.jsonStringifyReplacer = (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util || (util = {}));
      var objectUtil;
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return __spreadValues(__spreadValues({}, first), second);
        };
      })(objectUtil || (objectUtil = {}));
      var ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      var getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "undefined":
            return ZodParsedType.undefined;
          case "string":
            return ZodParsedType.string;
          case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
          case "boolean":
            return ZodParsedType.boolean;
          case "function":
            return ZodParsedType.function;
          case "bigint":
            return ZodParsedType.bigint;
          case "symbol":
            return ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return ZodParsedType.array;
            }
            if (data === null) {
              return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return ZodParsedType.date;
            }
            return ZodParsedType.object;
          default:
            return ZodParsedType.unknown;
        }
      };
      var ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
      ]);
      var quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
      };
      var ZodError = class extends Error {
        constructor(issues) {
          super();
          this.issues = [];
          this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
          };
          this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
          };
          const actualProto = new.target.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
          } else {
            this.__proto__ = actualProto;
          }
          this.name = "ZodError";
          this.issues = issues;
        }
        get errors() {
          return this.issues;
        }
        format(_mapper) {
          const mapper = _mapper || function(issue) {
            return issue.message;
          };
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union") {
                issue.unionErrors.map(processError);
              } else if (issue.code === "invalid_return_type") {
                processError(issue.returnTypeError);
              } else if (issue.code === "invalid_arguments") {
                processError(issue.argumentsError);
              } else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              } else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                  const el = issue.path[i];
                  const terminal = i === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  } else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i++;
                }
              }
            }
          };
          processError(this);
          return fieldErrors;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub of this.issues) {
            if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
              formErrors.push(mapper(sub));
            }
          }
          return { formErrors, fieldErrors };
        }
        get formErrors() {
          return this.flatten();
        }
      };
      ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
      };
      var errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
          case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
              message = "Required";
            } else {
              message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
          case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
          case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
          case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
          case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
          case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
          case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
          case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
          case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
              if ("includes" in issue.validation) {
                message = `Invalid input: must include "${issue.validation.includes}"`;
                if (typeof issue.validation.position === "number") {
                  message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                }
              } else if ("startsWith" in issue.validation) {
                message = `Invalid input: must start with "${issue.validation.startsWith}"`;
              } else if ("endsWith" in issue.validation) {
                message = `Invalid input: must end with "${issue.validation.endsWith}"`;
              } else {
                util.assertNever(issue.validation);
              }
            } else if (issue.validation !== "regex") {
              message = `Invalid ${issue.validation}`;
            } else {
              message = "Invalid";
            }
            break;
          case ZodIssueCode.too_small:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.too_big:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
              message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
          case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
          case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
          default:
            message = _ctx.defaultError;
            util.assertNever(issue);
        }
        return { message };
      };
      var overrideErrorMap = errorMap;
      function setErrorMap(map) {
        overrideErrorMap = map;
      }
      function getErrorMap() {
        return overrideErrorMap;
      }
      var makeIssue = (params2) => {
        const { data, path, errorMaps, issueData } = params2;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = __spreadProps(__spreadValues({}, issueData), {
          path: fullPath
        });
        let errorMessage = "";
        const maps = errorMaps.filter((m) => !!m).slice().reverse();
        for (const map of maps) {
          errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return __spreadProps(__spreadValues({}, issueData), {
          path: fullPath,
          message: issueData.message || errorMessage
        });
      };
      var EMPTY_PATH = [];
      function addIssueToContext(ctx, issueData) {
        const issue = makeIssue({
          issueData,
          data: ctx.data,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x)
        });
        ctx.common.issues.push(issue);
      }
      var ParseStatus = class {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s of results) {
            if (s.status === "aborted")
              return INVALID;
            if (s.status === "dirty")
              status.dirty();
            arrayValue.push(s.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static mergeObjectAsync(status, pairs) {
          return __async(this, null, function* () {
            const syncPairs = [];
            for (const pair of pairs) {
              syncPairs.push({
                key: yield pair.key,
                value: yield pair.value
              });
            }
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return INVALID;
            if (value.status === "aborted")
              return INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      };
      var INVALID = Object.freeze({
        status: "aborted"
      });
      var DIRTY = (value) => ({ status: "dirty", value });
      var OK = (value) => ({ status: "valid", value });
      var isAborted = (x) => x.status === "aborted";
      var isDirty = (x) => x.status === "dirty";
      var isValid = (x) => x.status === "valid";
      var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
      var errorUtil;
      (function(errorUtil2) {
        errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
      })(errorUtil || (errorUtil = {}));
      var ParseInputLazyPath = class {
        constructor(parent, value, path, key) {
          this._cachedPath = [];
          this.parent = parent;
          this.data = value;
          this._path = path;
          this._key = key;
        }
        get path() {
          if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
              this._cachedPath.push(...this._path, ...this._key);
            } else {
              this._cachedPath.push(...this._path, this._key);
            }
          }
          return this._cachedPath;
        }
      };
      var handleResult = (ctx, result) => {
        if (isValid(result)) {
          return { success: true, data: result.value };
        } else {
          if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
          }
          return {
            success: false,
            get error() {
              if (this._error)
                return this._error;
              const error = new ZodError(ctx.common.issues);
              this._error = error;
              return this._error;
            }
          };
        }
      };
      function processCreateParams(params2) {
        if (!params2)
          return {};
        const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
        if (errorMap2 && (invalid_type_error || required_error)) {
          throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        }
        if (errorMap2)
          return { errorMap: errorMap2, description };
        const customMap = (iss, ctx) => {
          if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
          if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
          }
          return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
        };
        return { errorMap: customMap, description };
      }
      var ZodType = class {
        constructor(def2) {
          this.spa = this.safeParseAsync;
          this._def = def2;
          this.parse = this.parse.bind(this);
          this.safeParse = this.safeParse.bind(this);
          this.parseAsync = this.parseAsync.bind(this);
          this.safeParseAsync = this.safeParseAsync.bind(this);
          this.spa = this.spa.bind(this);
          this.refine = this.refine.bind(this);
          this.refinement = this.refinement.bind(this);
          this.superRefine = this.superRefine.bind(this);
          this.optional = this.optional.bind(this);
          this.nullable = this.nullable.bind(this);
          this.nullish = this.nullish.bind(this);
          this.array = this.array.bind(this);
          this.promise = this.promise.bind(this);
          this.or = this.or.bind(this);
          this.and = this.and.bind(this);
          this.transform = this.transform.bind(this);
          this.brand = this.brand.bind(this);
          this.default = this.default.bind(this);
          this.catch = this.catch.bind(this);
          this.describe = this.describe.bind(this);
          this.pipe = this.pipe.bind(this);
          this.isNullable = this.isNullable.bind(this);
          this.isOptional = this.isOptional.bind(this);
        }
        get description() {
          return this._def.description;
        }
        _getType(input) {
          return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
          return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          };
        }
        _processInputParams(input) {
          return {
            status: new ParseStatus(),
            ctx: {
              common: input.parent.common,
              data: input.data,
              parsedType: getParsedType(input.data),
              schemaErrorMap: this._def.errorMap,
              path: input.path,
              parent: input.parent
            }
          };
        }
        _parseSync(input) {
          const result = this._parse(input);
          if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
          }
          return result;
        }
        _parseAsync(input) {
          const result = this._parse(input);
          return Promise.resolve(result);
        }
        parse(data, params2) {
          const result = this.safeParse(data, params2);
          if (result.success)
            return result.data;
          throw result.error;
        }
        safeParse(data, params2) {
          var _a;
          const ctx = {
            common: {
              issues: [],
              async: (_a = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a !== void 0 ? _a : false,
              contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
            },
            path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const result = this._parseSync({ data, path: ctx.path, parent: ctx });
          return handleResult(ctx, result);
        }
        parseAsync(data, params2) {
          return __async(this, null, function* () {
            const result = yield this.safeParseAsync(data, params2);
            if (result.success)
              return result.data;
            throw result.error;
          });
        }
        safeParseAsync(data, params2) {
          return __async(this, null, function* () {
            const ctx = {
              common: {
                issues: [],
                contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
                async: true
              },
              path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data,
              parsedType: getParsedType(data)
            };
            const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
            const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
            return handleResult(ctx, result);
          });
        }
        refine(check, message) {
          const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
              return { message };
            } else if (typeof message === "function") {
              return message(val);
            } else {
              return message;
            }
          };
          return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue(__spreadValues({
              code: ZodIssueCode.custom
            }, getIssueProperties(val)));
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then((data) => {
                if (!data) {
                  setError();
                  return false;
                } else {
                  return true;
                }
              });
            }
            if (!result) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        refinement(check, refinementData) {
          return this._refinement((val, ctx) => {
            if (!check(val)) {
              ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
              return false;
            } else {
              return true;
            }
          });
        }
        _refinement(refinement) {
          return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement }
          });
        }
        superRefine(refinement) {
          return this._refinement(refinement);
        }
        optional() {
          return ZodOptional.create(this, this._def);
        }
        nullable() {
          return ZodNullable.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return ZodArray.create(this, this._def);
        }
        promise() {
          return ZodPromise.create(this, this._def);
        }
        or(option) {
          return ZodUnion.create([this, option], this._def);
        }
        and(incoming) {
          return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
          return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform }
          }));
        }
        default(def2) {
          const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
          return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
          }));
        }
        brand() {
          return new ZodBranded(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this
          }, processCreateParams(this._def)));
        }
        catch(def2) {
          const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
          return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
          }));
        }
        describe(description) {
          const This = this.constructor;
          return new This(__spreadProps(__spreadValues({}, this._def), {
            description
          }));
        }
        pipe(target) {
          return ZodPipeline.create(this, target);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      };
      var cuidRegex = /^c[^\s-]{8,}$/i;
      var cuid2Regex = /^[a-z][a-z0-9]*$/;
      var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
      var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
      var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
      var emojiRegex = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
      var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
      var datetimeRegex = (args) => {
        if (args.precision) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
          }
        } else if (args.precision === 0) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
          }
        } else {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
          }
        }
      };
      function isValidIP(ip, version2) {
        if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
          return true;
        }
        if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
          return true;
        }
        return false;
      }
      var ZodString = class extends ZodType {
        constructor() {
          super(...arguments);
          this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), __spreadValues({
            validation,
            code: ZodIssueCode.invalid_string
          }, errorUtil.errToObj(message)));
          this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
          this.trim = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "trim" }]
          }));
          this.toLowerCase = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toLowerCase" }]
          }));
          this.toUpperCase = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toUpperCase" }]
          }));
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = String(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.length < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.length > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "length") {
              const tooBig = input.data.length > check.value;
              const tooSmall = input.data.length < check.value;
              if (tooBig || tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                if (tooBig) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                } else if (tooSmall) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                }
                status.dirty();
              }
            } else if (check.kind === "email") {
              if (!emailRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "email",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "emoji") {
              if (!emojiRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "emoji",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "uuid") {
              if (!uuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "uuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid") {
              if (!cuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid2") {
              if (!cuid2Regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid2",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ulid") {
              if (!ulidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ulid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "url") {
              try {
                new URL(input.data);
              } catch (_a) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "url",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "regex") {
              check.regex.lastIndex = 0;
              const testResult = check.regex.test(input.data);
              if (!testResult) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "regex",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "trim") {
              input.data = input.data.trim();
            } else if (check.kind === "includes") {
              if (!input.data.includes(check.value, check.position)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { includes: check.value, position: check.position },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "toLowerCase") {
              input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
              input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
              if (!input.data.startsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { startsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "endsWith") {
              if (!input.data.endsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { endsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "datetime") {
              const regex = datetimeRegex(check);
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: "datetime",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ip") {
              if (!isValidIP(input.data, check.version)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ip",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        _addCheck(check) {
          return new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        email(message) {
          return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
        }
        url(message) {
          return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
        }
        emoji(message) {
          return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
        }
        uuid(message) {
          return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
        }
        cuid(message) {
          return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
        }
        cuid2(message) {
          return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
        }
        ulid(message) {
          return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
        }
        ip(options) {
          return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
        }
        datetime(options) {
          var _a;
          if (typeof options === "string") {
            return this._addCheck({
              kind: "datetime",
              precision: null,
              offset: false,
              message: options
            });
          }
          return this._addCheck(__spreadValues({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        regex(regex, message) {
          return this._addCheck(__spreadValues({
            kind: "regex",
            regex
          }, errorUtil.errToObj(message)));
        }
        includes(value, options) {
          return this._addCheck(__spreadValues({
            kind: "includes",
            value,
            position: options === null || options === void 0 ? void 0 : options.position
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        startsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "startsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        endsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "endsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        min(minLength, message) {
          return this._addCheck(__spreadValues({
            kind: "min",
            value: minLength
          }, errorUtil.errToObj(message)));
        }
        max(maxLength, message) {
          return this._addCheck(__spreadValues({
            kind: "max",
            value: maxLength
          }, errorUtil.errToObj(message)));
        }
        length(len, message) {
          return this._addCheck(__spreadValues({
            kind: "length",
            value: len
          }, errorUtil.errToObj(message)));
        }
        get isDatetime() {
          return !!this._def.checks.find((ch) => ch.kind === "datetime");
        }
        get isEmail() {
          return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
          return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isEmoji() {
          return !!this._def.checks.find((ch) => ch.kind === "emoji");
        }
        get isUUID() {
          return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get isCUID2() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid2");
        }
        get isULID() {
          return !!this._def.checks.find((ch) => ch.kind === "ulid");
        }
        get isIP() {
          return !!this._def.checks.find((ch) => ch.kind === "ip");
        }
        get minLength() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxLength() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodString.create = (params2) => {
        var _a;
        return new ZodString(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodString,
          coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false
        }, processCreateParams(params2)));
      };
      function floatSafeRemainder(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
        return valInt % stepInt / Math.pow(10, decCount);
      }
      var ZodNumber = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
          this.step = this.multipleOf;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = Number(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.number,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "int") {
              if (!util.isInteger(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (floatSafeRemainder(input.data, check.value) !== 0) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "finite") {
              if (!Number.isFinite(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_finite,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        int(message) {
          return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        finite(message) {
          return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message)
          });
        }
        safe(message) {
          return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message)
          })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
        get isInt() {
          return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
        }
        get isFinite() {
          let max = null, min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
              return true;
            } else if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            } else if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return Number.isFinite(min) && Number.isFinite(max);
        }
      };
      ZodNumber.create = (params2) => {
        return new ZodNumber(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodNumber,
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false
        }, processCreateParams(params2)));
      };
      var ZodBigInt = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = BigInt(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.bigint) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.bigint,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  type: "bigint",
                  minimum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  type: "bigint",
                  maximum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (input.data % check.value !== BigInt(0)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodBigInt.create = (params2) => {
        var _a;
        return new ZodBigInt(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodBigInt,
          coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false
        }, processCreateParams(params2)));
      };
      var ZodBoolean = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = Boolean(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.boolean,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodBoolean.create = (params2) => {
        return new ZodBoolean(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodBoolean,
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false
        }, processCreateParams(params2)));
      };
      var ZodDate = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = new Date(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.date,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          if (isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_date
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.getTime() < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  minimum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.getTime() > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  maximum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return {
            status: status.value,
            value: new Date(input.data.getTime())
          };
        }
        _addCheck(check) {
          return new ZodDate(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        min(minDate, message) {
          return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        max(maxDate, message) {
          return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        get minDate() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min != null ? new Date(min) : null;
        }
        get maxDate() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max != null ? new Date(max) : null;
        }
      };
      ZodDate.create = (params2) => {
        return new ZodDate(__spreadValues({
          checks: [],
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
          typeName: ZodFirstPartyTypeKind.ZodDate
        }, processCreateParams(params2)));
      };
      var ZodSymbol = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.symbol,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodSymbol.create = (params2) => {
        return new ZodSymbol(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodSymbol
        }, processCreateParams(params2)));
      };
      var ZodUndefined = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.undefined,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodUndefined.create = (params2) => {
        return new ZodUndefined(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUndefined
        }, processCreateParams(params2)));
      };
      var ZodNull = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.null,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodNull.create = (params2) => {
        return new ZodNull(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNull
        }, processCreateParams(params2)));
      };
      var ZodAny = class extends ZodType {
        constructor() {
          super(...arguments);
          this._any = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodAny.create = (params2) => {
        return new ZodAny(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodAny
        }, processCreateParams(params2)));
      };
      var ZodUnknown = class extends ZodType {
        constructor() {
          super(...arguments);
          this._unknown = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodUnknown.create = (params2) => {
        return new ZodUnknown(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUnknown
        }, processCreateParams(params2)));
      };
      var ZodNever = class extends ZodType {
        _parse(input) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
          });
          return INVALID;
        }
      };
      ZodNever.create = (params2) => {
        return new ZodNever(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNever
        }, processCreateParams(params2)));
      };
      var ZodVoid = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.void,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodVoid.create = (params2) => {
        return new ZodVoid(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodVoid
        }, processCreateParams(params2)));
      };
      var ZodArray = class extends ZodType {
        _parse(input) {
          const { ctx, status } = this._processInputParams(input);
          const def2 = this._def;
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (def2.exactLength !== null) {
            const tooBig = ctx.data.length > def2.exactLength.value;
            const tooSmall = ctx.data.length < def2.exactLength.value;
            if (tooBig || tooSmall) {
              addIssueToContext(ctx, {
                code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                minimum: tooSmall ? def2.exactLength.value : void 0,
                maximum: tooBig ? def2.exactLength.value : void 0,
                type: "array",
                inclusive: true,
                exact: true,
                message: def2.exactLength.message
              });
              status.dirty();
            }
          }
          if (def2.minLength !== null) {
            if (ctx.data.length < def2.minLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def2.minLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def2.minLength.message
              });
              status.dirty();
            }
          }
          if (def2.maxLength !== null) {
            if (ctx.data.length > def2.maxLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def2.maxLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def2.maxLength.message
              });
              status.dirty();
            }
          }
          if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
              return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result2) => {
              return ParseStatus.mergeArray(status, result2);
            });
          }
          const result = [...ctx.data].map((item, i) => {
            return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          });
          return ParseStatus.mergeArray(status, result);
        }
        get element() {
          return this._def.type;
        }
        min(minLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            minLength: { value: minLength, message: errorUtil.toString(message) }
          }));
        }
        max(maxLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            maxLength: { value: maxLength, message: errorUtil.toString(message) }
          }));
        }
        length(len, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            exactLength: { value: len, message: errorUtil.toString(message) }
          }));
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodArray.create = (schema2, params2) => {
        return new ZodArray(__spreadValues({
          type: schema2,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: ZodFirstPartyTypeKind.ZodArray
        }, processCreateParams(params2)));
      };
      function deepPartialify(schema2) {
        if (schema2 instanceof ZodObject) {
          const newShape = {};
          for (const key in schema2.shape) {
            const fieldSchema = schema2.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
          }
          return new ZodObject(__spreadProps(__spreadValues({}, schema2._def), {
            shape: () => newShape
          }));
        } else if (schema2 instanceof ZodArray) {
          return new ZodArray(__spreadProps(__spreadValues({}, schema2._def), {
            type: deepPartialify(schema2.element)
          }));
        } else if (schema2 instanceof ZodOptional) {
          return ZodOptional.create(deepPartialify(schema2.unwrap()));
        } else if (schema2 instanceof ZodNullable) {
          return ZodNullable.create(deepPartialify(schema2.unwrap()));
        } else if (schema2 instanceof ZodTuple) {
          return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
        } else {
          return schema2;
        }
      }
      var ZodObject = class extends ZodType {
        constructor() {
          super(...arguments);
          this._cached = null;
          this.nonstrict = this.passthrough;
          this.augment = this.extend;
        }
        _getCached() {
          if (this._cached !== null)
            return this._cached;
          const shape = this._def.shape();
          const keys = util.objectKeys(shape);
          return this._cached = { shape, keys };
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const { status, ctx } = this._processInputParams(input);
          const { shape, keys: shapeKeys } = this._getCached();
          const extraKeys = [];
          if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
              if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
              }
            }
          }
          const pairs = [];
          for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
              for (const key of extraKeys) {
                pairs.push({
                  key: { status: "valid", value: key },
                  value: { status: "valid", value: ctx.data[key] }
                });
              }
            } else if (unknownKeys === "strict") {
              if (extraKeys.length > 0) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.unrecognized_keys,
                  keys: extraKeys
                });
                status.dirty();
              }
            } else if (unknownKeys === "strip")
              ;
            else {
              throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
          } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
              const value = ctx.data[key];
              pairs.push({
                key: { status: "valid", value: key },
                value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
              });
            }
          }
          if (ctx.common.async) {
            return Promise.resolve().then(() => __async(this, null, function* () {
              const syncPairs = [];
              for (const pair of pairs) {
                const key = yield pair.key;
                syncPairs.push({
                  key,
                  value: yield pair.value,
                  alwaysSet: pair.alwaysSet
                });
              }
              return syncPairs;
            })).then((syncPairs) => {
              return ParseStatus.mergeObjectSync(status, syncPairs);
            });
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get shape() {
          return this._def.shape();
        }
        strict(message) {
          errorUtil.errToObj;
          return new ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strict"
          }), message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}));
        }
        strip() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strip"
          }));
        }
        passthrough() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "passthrough"
          }));
        }
        extend(augmentation) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
          }));
        }
        merge(merging) {
          const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject
          });
          return merged;
        }
        setKey(key, schema2) {
          return this.augment({ [key]: schema2 });
        }
        catchall(index) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            catchall: index
          }));
        }
        pick(mask) {
          const shape = {};
          util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        omit(mask) {
          const shape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        deepPartial() {
          return deepPartialify(this);
        }
        partial(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
              newShape[key] = fieldSchema;
            } else {
              newShape[key] = fieldSchema.optional();
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        required(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        keyof() {
          return createZodEnum(util.objectKeys(this.shape));
        }
      };
      ZodObject.create = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      ZodObject.strictCreate = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strict",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      ZodObject.lazycreate = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      var ZodUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const options = this._def.options;
          function handleResults(results) {
            for (const result of results) {
              if (result.result.status === "valid") {
                return result.result;
              }
            }
            for (const result of results) {
              if (result.result.status === "dirty") {
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
              }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return Promise.all(options.map((option) => __async(this, null, function* () {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              return {
                result: yield option._parseAsync({
                  data: ctx.data,
                  path: ctx.path,
                  parent: childCtx
                }),
                ctx: childCtx
              };
            }))).then(handleResults);
          } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              const result = option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              });
              if (result.status === "valid") {
                return result;
              } else if (result.status === "dirty" && !dirty) {
                dirty = { result, ctx: childCtx };
              }
              if (childCtx.common.issues.length) {
                issues.push(childCtx.common.issues);
              }
            }
            if (dirty) {
              ctx.common.issues.push(...dirty.ctx.common.issues);
              return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError(issues2));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      ZodUnion.create = (types, params2) => {
        return new ZodUnion(__spreadValues({
          options: types,
          typeName: ZodFirstPartyTypeKind.ZodUnion
        }, processCreateParams(params2)));
      };
      var getDiscriminator = (type) => {
        if (type instanceof ZodLazy) {
          return getDiscriminator(type.schema);
        } else if (type instanceof ZodEffects) {
          return getDiscriminator(type.innerType());
        } else if (type instanceof ZodLiteral) {
          return [type.value];
        } else if (type instanceof ZodEnum) {
          return type.options;
        } else if (type instanceof ZodNativeEnum) {
          return Object.keys(type.enum);
        } else if (type instanceof ZodDefault) {
          return getDiscriminator(type._def.innerType);
        } else if (type instanceof ZodUndefined) {
          return [void 0];
        } else if (type instanceof ZodNull) {
          return [null];
        } else {
          return null;
        }
      };
      var ZodDiscriminatedUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const discriminator = this.discriminator;
          const discriminatorValue = ctx.data[discriminator];
          const option = this.optionsMap.get(discriminatorValue);
          if (!option) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [discriminator]
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          } else {
            return option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(discriminator, options, params2) {
          const optionsMap = /* @__PURE__ */ new Map();
          for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
              throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
              if (optionsMap.has(value)) {
                throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
              }
              optionsMap.set(value, type);
            }
          }
          return new ZodDiscriminatedUnion(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap
          }, processCreateParams(params2)));
        }
      };
      function mergeValues(a, b) {
        const aType = getParsedType(a);
        const bType = getParsedType(b);
        if (a === b) {
          return { valid: true, data: a };
        } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
          const bKeys = util.objectKeys(b);
          const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
          const newObj = __spreadValues(__spreadValues({}, a), b);
          for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newObj[key] = sharedValue.data;
          }
          return { valid: true, data: newObj };
        } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
          if (a.length !== b.length) {
            return { valid: false };
          }
          const newArray = [];
          for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newArray.push(sharedValue.data);
          }
          return { valid: true, data: newArray };
        } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
          return { valid: true, data: a };
        } else {
          return { valid: false };
        }
      }
      var ZodIntersection = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
              return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_intersection_types
              });
              return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
              status.dirty();
            }
            return { status: status.value, value: merged.data };
          };
          if (ctx.common.async) {
            return Promise.all([
              this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              }),
              this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              })
            ]).then(([left, right]) => handleParsed(left, right));
          } else {
            return handleParsed(this._def.left._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }), this._def.right._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }));
          }
        }
      };
      ZodIntersection.create = (left, right, params2) => {
        return new ZodIntersection(__spreadValues({
          left,
          right,
          typeName: ZodFirstPartyTypeKind.ZodIntersection
        }, processCreateParams(params2)));
      };
      var ZodTuple = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            return INVALID;
          }
          const rest = this._def.rest;
          if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            status.dirty();
          }
          const items = [...ctx.data].map((item, itemIndex) => {
            const schema2 = this._def.items[itemIndex] || this._def.rest;
            if (!schema2)
              return null;
            return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
          }).filter((x) => !!x);
          if (ctx.common.async) {
            return Promise.all(items).then((results) => {
              return ParseStatus.mergeArray(status, results);
            });
          } else {
            return ParseStatus.mergeArray(status, items);
          }
        }
        get items() {
          return this._def.items;
        }
        rest(rest) {
          return new ZodTuple(__spreadProps(__spreadValues({}, this._def), {
            rest
          }));
        }
      };
      ZodTuple.create = (schemas2, params2) => {
        if (!Array.isArray(schemas2)) {
          throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple(__spreadValues({
          items: schemas2,
          typeName: ZodFirstPartyTypeKind.ZodTuple,
          rest: null
        }, processCreateParams(params2)));
      };
      var ZodRecord = class extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const pairs = [];
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          for (const key in ctx.data) {
            pairs.push({
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
              value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
            });
          }
          if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get element() {
          return this._def.valueType;
        }
        static create(first, second, third) {
          if (second instanceof ZodType) {
            return new ZodRecord(__spreadValues({
              keyType: first,
              valueType: second,
              typeName: ZodFirstPartyTypeKind.ZodRecord
            }, processCreateParams(third)));
          }
          return new ZodRecord(__spreadValues({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord
          }, processCreateParams(second)));
        }
      };
      var ZodMap = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.map,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
              value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
            };
          });
          if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(() => __async(this, null, function* () {
              for (const pair of pairs) {
                const key = yield pair.key;
                const value = yield pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                  return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                  status.dirty();
                }
                finalMap.set(key.value, value.value);
              }
              return { status: status.value, value: finalMap };
            }));
          } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
              const key = pair.key;
              const value = pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          }
        }
      };
      ZodMap.create = (keyType, valueType, params2) => {
        return new ZodMap(__spreadValues({
          valueType,
          keyType,
          typeName: ZodFirstPartyTypeKind.ZodMap
        }, processCreateParams(params2)));
      };
      var ZodSet = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.set,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const def2 = this._def;
          if (def2.minSize !== null) {
            if (ctx.data.size < def2.minSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def2.minSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def2.minSize.message
              });
              status.dirty();
            }
          }
          if (def2.maxSize !== null) {
            if (ctx.data.size > def2.maxSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def2.maxSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def2.maxSize.message
              });
              status.dirty();
            }
          }
          const valueType = this._def.valueType;
          function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
              if (element.status === "aborted")
                return INVALID;
              if (element.status === "dirty")
                status.dirty();
              parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
          }
          const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
          if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
          } else {
            return finalizeSet(elements);
          }
        }
        min(minSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            minSize: { value: minSize, message: errorUtil.toString(message) }
          }));
        }
        max(maxSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            maxSize: { value: maxSize, message: errorUtil.toString(message) }
          }));
        }
        size(size, message) {
          return this.min(size, message).max(size, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodSet.create = (valueType, params2) => {
        return new ZodSet(__spreadValues({
          valueType,
          minSize: null,
          maxSize: null,
          typeName: ZodFirstPartyTypeKind.ZodSet
        }, processCreateParams(params2)));
      };
      var ZodFunction = class extends ZodType {
        constructor() {
          super(...arguments);
          this.validate = this.implement;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.function,
              received: ctx.parsedType
            });
            return INVALID;
          }
          function makeArgsIssue(args, error) {
            return makeIssue({
              data: args,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_arguments,
                argumentsError: error
              }
            });
          }
          function makeReturnsIssue(returns, error) {
            return makeIssue({
              data: returns,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_return_type,
                returnTypeError: error
              }
            });
          }
          const params2 = { errorMap: ctx.common.contextualErrorMap };
          const fn = ctx.data;
          if (this._def.returns instanceof ZodPromise) {
            return OK((...args) => __async(this, null, function* () {
              const error = new ZodError([]);
              const parsedArgs = yield this._def.args.parseAsync(args, params2).catch((e) => {
                error.addIssue(makeArgsIssue(args, e));
                throw error;
              });
              const result = yield fn(...parsedArgs);
              const parsedReturns = yield this._def.returns._def.type.parseAsync(result, params2).catch((e) => {
                error.addIssue(makeReturnsIssue(result, e));
                throw error;
              });
              return parsedReturns;
            }));
          } else {
            return OK((...args) => {
              const parsedArgs = this._def.args.safeParse(args, params2);
              if (!parsedArgs.success) {
                throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
              }
              const result = fn(...parsedArgs.data);
              const parsedReturns = this._def.returns.safeParse(result, params2);
              if (!parsedReturns.success) {
                throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
              }
              return parsedReturns.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...items) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            args: ZodTuple.create(items).rest(ZodUnknown.create())
          }));
        }
        returns(returnType) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            returns: returnType
          }));
        }
        implement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        strictImplement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        static create(args, returns, params2) {
          return new ZodFunction(__spreadValues({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction
          }, processCreateParams(params2)));
        }
      };
      var ZodLazy = class extends ZodType {
        get schema() {
          return this._def.getter();
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const lazySchema = this._def.getter();
          return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
      };
      ZodLazy.create = (getter, params2) => {
        return new ZodLazy(__spreadValues({
          getter,
          typeName: ZodFirstPartyTypeKind.ZodLazy
        }, processCreateParams(params2)));
      };
      var ZodLiteral = class extends ZodType {
        _parse(input) {
          if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_literal,
              expected: this._def.value
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
        get value() {
          return this._def.value;
        }
      };
      ZodLiteral.create = (value, params2) => {
        return new ZodLiteral(__spreadValues({
          value,
          typeName: ZodFirstPartyTypeKind.ZodLiteral
        }, processCreateParams(params2)));
      };
      function createZodEnum(values, params2) {
        return new ZodEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodEnum
        }, processCreateParams(params2)));
      }
      var ZodEnum = class extends ZodType {
        _parse(input) {
          if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Values() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        extract(values) {
          return ZodEnum.create(values);
        }
        exclude(values) {
          return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
        }
      };
      ZodEnum.create = createZodEnum;
      var ZodNativeEnum = class extends ZodType {
        _parse(input) {
          const nativeEnumValues = util.getValidEnumValues(this._def.values);
          const ctx = this._getOrReturnCtx(input);
          if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      ZodNativeEnum.create = (values, params2) => {
        return new ZodNativeEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodNativeEnum
        }, processCreateParams(params2)));
      };
      var ZodPromise = class extends ZodType {
        unwrap() {
          return this._def.type;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.promise,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
          return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
              path: ctx.path,
              errorMap: ctx.common.contextualErrorMap
            });
          }));
        }
      };
      ZodPromise.create = (schema2, params2) => {
        return new ZodPromise(__spreadValues({
          type: schema2,
          typeName: ZodFirstPartyTypeKind.ZodPromise
        }, processCreateParams(params2)));
      };
      var ZodEffects = class extends ZodType {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const effect = this._def.effect || null;
          if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
              return Promise.resolve(processed).then((processed2) => {
                return this._def.schema._parseAsync({
                  data: processed2,
                  path: ctx.path,
                  parent: ctx
                });
              });
            } else {
              return this._def.schema._parseSync({
                data: processed,
                path: ctx.path,
                parent: ctx
              });
            }
          }
          const checkCtx = {
            addIssue: (arg) => {
              addIssueToContext(ctx, arg);
              if (arg.fatal) {
                status.abort();
              } else {
                status.dirty();
              }
            },
            get path() {
              return ctx.path;
            }
          };
          checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
          if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
              const result = effect.refinement(acc, checkCtx);
              if (ctx.common.async) {
                return Promise.resolve(result);
              }
              if (result instanceof Promise) {
                throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
              }
              return acc;
            };
            if (ctx.common.async === false) {
              const inner = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              executeRefinement(inner.value);
              return { status: status.value, value: inner.value };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                if (inner.status === "aborted")
                  return INVALID;
                if (inner.status === "dirty")
                  status.dirty();
                return executeRefinement(inner.value).then(() => {
                  return { status: status.value, value: inner.value };
                });
              });
            }
          }
          if (effect.type === "transform") {
            if (ctx.common.async === false) {
              const base3 = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (!isValid(base3))
                return base3;
              const result = effect.transform(base3.value, checkCtx);
              if (result instanceof Promise) {
                throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
              }
              return { status: status.value, value: result };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
                if (!isValid(base3))
                  return base3;
                return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
              });
            }
          }
          util.assertNever(effect);
        }
      };
      ZodEffects.create = (schema2, effect, params2) => {
        return new ZodEffects(__spreadValues({
          schema: schema2,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect
        }, processCreateParams(params2)));
      };
      ZodEffects.createWithPreprocess = (preprocess, schema2, params2) => {
        return new ZodEffects(__spreadValues({
          schema: schema2,
          effect: { type: "preprocess", transform: preprocess },
          typeName: ZodFirstPartyTypeKind.ZodEffects
        }, processCreateParams(params2)));
      };
      var ZodOptional = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.undefined) {
            return OK(void 0);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodOptional.create = (type, params2) => {
        return new ZodOptional(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodOptional
        }, processCreateParams(params2)));
      };
      var ZodNullable = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.null) {
            return OK(null);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodNullable.create = (type, params2) => {
        return new ZodNullable(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodNullable
        }, processCreateParams(params2)));
      };
      var ZodDefault = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          let data = ctx.data;
          if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
          }
          return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      ZodDefault.create = (type, params2) => {
        return new ZodDefault(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodDefault,
          defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default
        }, processCreateParams(params2)));
      };
      var ZodCatch = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const newCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            })
          });
          const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: __spreadValues({}, newCtx)
          });
          if (isAsync(result)) {
            return result.then((result2) => {
              return {
                status: "valid",
                value: result2.status === "valid" ? result2.value : this._def.catchValue({
                  get error() {
                    return new ZodError(newCtx.common.issues);
                  },
                  input: newCtx.data
                })
              };
            });
          } else {
            return {
              status: "valid",
              value: result.status === "valid" ? result.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          }
        }
        removeCatch() {
          return this._def.innerType;
        }
      };
      ZodCatch.create = (type, params2) => {
        return new ZodCatch(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodCatch,
          catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch
        }, processCreateParams(params2)));
      };
      var ZodNaN = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.nan,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
      };
      ZodNaN.create = (params2) => {
        return new ZodNaN(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNaN
        }, processCreateParams(params2)));
      };
      var BRAND = Symbol("zod_brand");
      var ZodBranded = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const data = ctx.data;
          return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        unwrap() {
          return this._def.type;
        }
      };
      var ZodPipeline = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.common.async) {
            const handleAsync = () => __async(this, null, function* () {
              const inResult = yield this._def.in._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inResult.status === "aborted")
                return INVALID;
              if (inResult.status === "dirty") {
                status.dirty();
                return DIRTY(inResult.value);
              } else {
                return this._def.out._parseAsync({
                  data: inResult.value,
                  path: ctx.path,
                  parent: ctx
                });
              }
            });
            return handleAsync();
          } else {
            const inResult = this._def.in._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return {
                status: "dirty",
                value: inResult.value
              };
            } else {
              return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }
        }
        static create(a, b) {
          return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
          });
        }
      };
      var custom = (check, params2 = {}, fatal) => {
        if (check)
          return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
              const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
              const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
              const p2 = typeof p === "string" ? { message: p } : p;
              ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal: _fatal }));
            }
          });
        return ZodAny.create();
      };
      var late = {
        object: ZodObject.lazycreate
      };
      var ZodFirstPartyTypeKind;
      (function(ZodFirstPartyTypeKind2) {
        ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
      var instanceOfType = (cls, params2 = {
        message: `Input not instance of ${cls.name}`
      }) => custom((data) => data instanceof cls, params2);
      var stringType = ZodString.create;
      var numberType = ZodNumber.create;
      var nanType = ZodNaN.create;
      var bigIntType = ZodBigInt.create;
      var booleanType = ZodBoolean.create;
      var dateType = ZodDate.create;
      var symbolType = ZodSymbol.create;
      var undefinedType = ZodUndefined.create;
      var nullType = ZodNull.create;
      var anyType = ZodAny.create;
      var unknownType = ZodUnknown.create;
      var neverType = ZodNever.create;
      var voidType = ZodVoid.create;
      var arrayType = ZodArray.create;
      var objectType = ZodObject.create;
      var strictObjectType = ZodObject.strictCreate;
      var unionType = ZodUnion.create;
      var discriminatedUnionType = ZodDiscriminatedUnion.create;
      var intersectionType = ZodIntersection.create;
      var tupleType = ZodTuple.create;
      var recordType = ZodRecord.create;
      var mapType = ZodMap.create;
      var setType = ZodSet.create;
      var functionType = ZodFunction.create;
      var lazyType = ZodLazy.create;
      var literalType = ZodLiteral.create;
      var enumType = ZodEnum.create;
      var nativeEnumType = ZodNativeEnum.create;
      var promiseType = ZodPromise.create;
      var effectsType = ZodEffects.create;
      var optionalType = ZodOptional.create;
      var nullableType = ZodNullable.create;
      var preprocessType = ZodEffects.createWithPreprocess;
      var pipelineType = ZodPipeline.create;
      var ostring = () => stringType().optional();
      var onumber = () => numberType().optional();
      var oboolean = () => booleanType().optional();
      var coerce = {
        string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
          coerce: true
        })),
        bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true }))
      };
      var NEVER = INVALID;
      var z = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        defaultErrorMap: errorMap,
        setErrorMap,
        getErrorMap,
        makeIssue,
        EMPTY_PATH,
        addIssueToContext,
        ParseStatus,
        INVALID,
        DIRTY,
        OK,
        isAborted,
        isDirty,
        isValid,
        isAsync,
        get util() {
          return util;
        },
        get objectUtil() {
          return objectUtil;
        },
        ZodParsedType,
        getParsedType,
        ZodType,
        ZodString,
        ZodNumber,
        ZodBigInt,
        ZodBoolean,
        ZodDate,
        ZodSymbol,
        ZodUndefined,
        ZodNull,
        ZodAny,
        ZodUnknown,
        ZodNever,
        ZodVoid,
        ZodArray,
        ZodObject,
        ZodUnion,
        ZodDiscriminatedUnion,
        ZodIntersection,
        ZodTuple,
        ZodRecord,
        ZodMap,
        ZodSet,
        ZodFunction,
        ZodLazy,
        ZodLiteral,
        ZodEnum,
        ZodNativeEnum,
        ZodPromise,
        ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional,
        ZodNullable,
        ZodDefault,
        ZodCatch,
        ZodNaN,
        BRAND,
        ZodBranded,
        ZodPipeline,
        custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late,
        get ZodFirstPartyTypeKind() {
          return ZodFirstPartyTypeKind;
        },
        coerce,
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        "enum": enumType,
        "function": functionType,
        "instanceof": instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        "null": nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean,
        onumber,
        optional: optionalType,
        ostring,
        pipeline: pipelineType,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        symbol: symbolType,
        transformer: effectsType,
        tuple: tupleType,
        "undefined": undefinedType,
        union: unionType,
        unknown: unknownType,
        "void": voidType,
        NEVER,
        ZodIssueCode,
        quotelessJson,
        ZodError
      });
      var check_exports = {};
      __export(check_exports, {
        assure: () => assure,
        is: () => is,
        isObject: () => isObject
      });
      var is = (obj, def2) => {
        return def2.safeParse(obj).success;
      };
      var assure = (def2, obj) => {
        return def2.parse(obj);
      };
      var isObject = (obj) => {
        return typeof obj === "object" && obj !== null;
      };
      var encode_1 = encode;
      var MSB = 128;
      var REST = 127;
      var MSBALL = ~REST;
      var INT = Math.pow(2, 31);
      function encode(num, out, offset) {
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT) {
          out[offset++] = num & 255 | MSB;
          num /= 128;
        }
        while (num & MSBALL) {
          out[offset++] = num & 255 | MSB;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode.bytes = offset - oldOffset + 1;
        return out;
      }
      var decode = read;
      var MSB$1 = 128;
      var REST$1 = 127;
      function read(buf, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
        do {
          if (counter >= l) {
            read.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf[counter++];
          res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB$1);
        read.bytes = counter - offset;
        return res;
      }
      var N1 = Math.pow(2, 7);
      var N2 = Math.pow(2, 14);
      var N3 = Math.pow(2, 21);
      var N4 = Math.pow(2, 28);
      var N5 = Math.pow(2, 35);
      var N6 = Math.pow(2, 42);
      var N7 = Math.pow(2, 49);
      var N8 = Math.pow(2, 56);
      var N9 = Math.pow(2, 63);
      var length = function(value) {
        return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
      };
      var varint = {
        encode: encode_1,
        decode,
        encodingLength: length
      };
      var _brrp_varint = varint;
      var varint_default = _brrp_varint;
      var decode2 = (data, offset = 0) => {
        const code2 = varint_default.decode(data, offset);
        return [
          code2,
          varint_default.decode.bytes
        ];
      };
      var encodeTo = (int, target, offset = 0) => {
        varint_default.encode(int, target, offset);
        return target;
      };
      var encodingLength = (int) => {
        return varint_default.encodingLength(int);
      };
      var empty = new Uint8Array(0);
      var equals = (aa, bb) => {
        if (aa === bb)
          return true;
        if (aa.byteLength !== bb.byteLength) {
          return false;
        }
        for (let ii = 0; ii < aa.byteLength; ii++) {
          if (aa[ii] !== bb[ii]) {
            return false;
          }
        }
        return true;
      };
      var coerce2 = (o) => {
        if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
          return o;
        if (o instanceof ArrayBuffer)
          return new Uint8Array(o);
        if (ArrayBuffer.isView(o)) {
          return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
        }
        throw new Error("Unknown type, must be binary type");
      };
      var fromString = (str) => new TextEncoder().encode(str);
      var toString = (b) => new TextDecoder().decode(b);
      var create = (code2, digest2) => {
        const size = digest2.byteLength;
        const sizeOffset = encodingLength(code2);
        const digestOffset = sizeOffset + encodingLength(size);
        const bytes2 = new Uint8Array(digestOffset + size);
        encodeTo(code2, bytes2, 0);
        encodeTo(size, bytes2, sizeOffset);
        bytes2.set(digest2, digestOffset);
        return new Digest(code2, size, digest2, bytes2);
      };
      var decode3 = (multihash) => {
        const bytes2 = coerce2(multihash);
        const [code2, sizeOffset] = decode2(bytes2);
        const [size, digestOffset] = decode2(bytes2.subarray(sizeOffset));
        const digest2 = bytes2.subarray(sizeOffset + digestOffset);
        if (digest2.byteLength !== size) {
          throw new Error("Incorrect length");
        }
        return new Digest(code2, size, digest2, bytes2);
      };
      var equals2 = (a, b) => {
        if (a === b) {
          return true;
        } else {
          return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
        }
      };
      var Digest = class {
        constructor(code2, size, digest2, bytes2) {
          this.code = code2;
          this.size = size;
          this.digest = digest2;
          this.bytes = bytes2;
        }
      };
      var base58_exports = {};
      __export(base58_exports, {
        base58btc: () => base58btc,
        base58flickr: () => base58flickr
      });
      function base(ALPHABET, name2) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode5(source) {
          if (source instanceof Uint8Array)
            ;
          else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length2 = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length2 = i2;
            pbegin++;
          }
          var it2 = size - length2;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          var psz = 0;
          if (source[psz] === " ") {
            return;
          }
          var zeroes = 0;
          var length2 = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length2 = i2;
            psz++;
          }
          if (source[psz] === " ") {
            return;
          }
          var it4 = size - length2;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = new Uint8Array(zeroes + (size - it4));
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode6(string3) {
          var buffer = decodeUnsafe(string3);
          if (buffer) {
            return buffer;
          }
          throw new Error(`Non-${name2} character`);
        }
        return {
          encode: encode5,
          decodeUnsafe,
          decode: decode6
        };
      }
      var src = base;
      var _brrp__multiformats_scope_baseX = src;
      var base_x_default = _brrp__multiformats_scope_baseX;
      var Encoder = class {
        constructor(name2, prefix, baseEncode) {
          this.name = name2;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes2) {
          if (bytes2 instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes2)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      var Decoder = class {
        constructor(name2, prefix, baseDecode) {
          this.name = name2;
          this.prefix = prefix;
          if (prefix.codePointAt(0) === void 0) {
            throw new Error("Invalid prefix character");
          }
          this.prefixCodePoint = prefix.codePointAt(0);
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder2) {
          return or(this, decoder2);
        }
      };
      var ComposedDecoder = class {
        constructor(decoders) {
          this.decoders = decoders;
        }
        or(decoder2) {
          return or(this, decoder2);
        }
        decode(input) {
          const prefix = input[0];
          const decoder2 = this.decoders[prefix];
          if (decoder2) {
            return decoder2.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      var or = (left, right) => new ComposedDecoder(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
      var Codec = class {
        constructor(name2, prefix, baseEncode, baseDecode) {
          this.name = name2;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder(name2, prefix, baseEncode);
          this.decoder = new Decoder(name2, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
      var from = ({ name: name2, prefix, encode: encode5, decode: decode6 }) => new Codec(name2, prefix, encode5, decode6);
      var baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
        const { encode: encode5, decode: decode6 } = base_x_default(alphabet2, name2);
        return from({
          prefix,
          name: name2,
          encode: encode5,
          decode: (text) => coerce2(decode6(text))
        });
      };
      var decode4 = (string3, alphabet2, bitsPerChar, name2) => {
        const codes = {};
        for (let i = 0; i < alphabet2.length; ++i) {
          codes[alphabet2[i]] = i;
        }
        let end = string3.length;
        while (string3[end - 1] === "=") {
          --end;
        }
        const out = new Uint8Array(end * bitsPerChar / 8 | 0);
        let bits = 0;
        let buffer = 0;
        let written = 0;
        for (let i = 0; i < end; ++i) {
          const value = codes[string3[i]];
          if (value === void 0) {
            throw new SyntaxError(`Non-${name2} character`);
          }
          buffer = buffer << bitsPerChar | value;
          bits += bitsPerChar;
          if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer >> bits;
          }
        }
        if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
          throw new SyntaxError("Unexpected end of data");
        }
        return out;
      };
      var encode2 = (data, alphabet2, bitsPerChar) => {
        const pad = alphabet2[alphabet2.length - 1] === "=";
        const mask = (1 << bitsPerChar) - 1;
        let out = "";
        let bits = 0;
        let buffer = 0;
        for (let i = 0; i < data.length; ++i) {
          buffer = buffer << 8 | data[i];
          bits += 8;
          while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet2[mask & buffer >> bits];
          }
        }
        if (bits) {
          out += alphabet2[mask & buffer << bitsPerChar - bits];
        }
        if (pad) {
          while (out.length * bitsPerChar & 7) {
            out += "=";
          }
        }
        return out;
      };
      var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
        return from({
          prefix,
          name: name2,
          encode(input) {
            return encode2(input, alphabet2, bitsPerChar);
          },
          decode(input) {
            return decode4(input, alphabet2, bitsPerChar, name2);
          }
        });
      };
      var base58btc = baseX({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      var base58flickr = baseX({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
      var base32_exports = {};
      __export(base32_exports, {
        base32: () => base32,
        base32hex: () => base32hex,
        base32hexpad: () => base32hexpad,
        base32hexpadupper: () => base32hexpadupper,
        base32hexupper: () => base32hexupper,
        base32pad: () => base32pad,
        base32padupper: () => base32padupper,
        base32upper: () => base32upper,
        base32z: () => base32z
      });
      var base32 = rfc4648({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      });
      var base32upper = rfc4648({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      });
      var base32pad = rfc4648({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      });
      var base32padupper = rfc4648({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      });
      var base32hex = rfc4648({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      });
      var base32hexupper = rfc4648({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      });
      var base32hexpad = rfc4648({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      });
      var base32hexpadupper = rfc4648({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      });
      var base32z = rfc4648({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
      var CID = class {
        constructor(version2, code2, multihash, bytes2) {
          this.code = code2;
          this.version = version2;
          this.multihash = multihash;
          this.bytes = bytes2;
          this.byteOffset = bytes2.byteOffset;
          this.byteLength = bytes2.byteLength;
          this.asCID = this;
          this._baseCache = /* @__PURE__ */ new Map();
          Object.defineProperties(this, {
            byteOffset: hidden,
            byteLength: hidden,
            code: readonly,
            version: readonly,
            multihash: readonly,
            bytes: readonly,
            _baseCache: hidden,
            asCID: hidden
          });
        }
        toV0() {
          switch (this.version) {
            case 0: {
              return this;
            }
            default: {
              const { code: code2, multihash } = this;
              if (code2 !== DAG_PB_CODE) {
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              }
              if (multihash.code !== SHA_256_CODE) {
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              }
              return CID.createV0(multihash);
            }
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              const { code: code2, digest: digest2 } = this.multihash;
              const multihash = create(code2, digest2);
              return CID.createV1(this.code, multihash);
            }
            case 1: {
              return this;
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
          }
        }
        equals(other) {
          return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
        }
        toString(base3) {
          const { bytes: bytes2, version: version2, _baseCache } = this;
          switch (version2) {
            case 0:
              return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);
            default:
              return toStringV1(bytes2, _baseCache, base3 || base32.encoder);
          }
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(value) {
          deprecate(/^0\.0/, IS_CID_DEPRECATION);
          return !!(value && (value[cidSymbol] || value.asCID === value));
        }
        get toBaseEncodedString() {
          throw new Error("Deprecated, use .toString()");
        }
        get codec() {
          throw new Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
        }
        get multibaseName() {
          throw new Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw new Error('"prefix" property is deprecated');
        }
        static asCID(value) {
          if (value instanceof CID) {
            return value;
          } else if (value != null && value.asCID === value) {
            const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
            return new CID(version2, code2, multihash, bytes2 || encodeCID(version2, code2, multihash.bytes));
          } else if (value != null && value[cidSymbol] === true) {
            const { version: version2, multihash, code: code2 } = value;
            const digest2 = decode3(multihash);
            return CID.create(version2, code2, digest2);
          } else {
            return null;
          }
        }
        static create(version2, code2, digest2) {
          if (typeof code2 !== "number") {
            throw new Error("String codecs are no longer supported");
          }
          switch (version2) {
            case 0: {
              if (code2 !== DAG_PB_CODE) {
                throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
              } else {
                return new CID(version2, code2, digest2, digest2.bytes);
              }
            }
            case 1: {
              const bytes2 = encodeCID(version2, code2, digest2.bytes);
              return new CID(version2, code2, digest2, bytes2);
            }
            default: {
              throw new Error("Invalid version");
            }
          }
        }
        static createV0(digest2) {
          return CID.create(0, DAG_PB_CODE, digest2);
        }
        static createV1(code2, digest2) {
          return CID.create(1, code2, digest2);
        }
        static decode(bytes2) {
          const [cid2, remainder] = CID.decodeFirst(bytes2);
          if (remainder.length) {
            throw new Error("Incorrect length");
          }
          return cid2;
        }
        static decodeFirst(bytes2) {
          const specs = CID.inspectBytes(bytes2);
          const prefixSize = specs.size - specs.multihashSize;
          const multihashBytes = coerce2(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
          if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
          }
          const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
          const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
          const cid2 = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
          return [
            cid2,
            bytes2.subarray(specs.size)
          ];
        }
        static inspectBytes(initialBytes) {
          let offset = 0;
          const next = () => {
            const [i, length2] = decode2(initialBytes.subarray(offset));
            offset += length2;
            return i;
          };
          let version2 = next();
          let codec = DAG_PB_CODE;
          if (version2 === 18) {
            version2 = 0;
            offset = 0;
          } else if (version2 === 1) {
            codec = next();
          }
          if (version2 !== 0 && version2 !== 1) {
            throw new RangeError(`Invalid CID version ${version2}`);
          }
          const prefixSize = offset;
          const multihashCode = next();
          const digestSize = next();
          const size = offset + digestSize;
          const multihashSize = size - prefixSize;
          return {
            version: version2,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
          };
        }
        static parse(source, base3) {
          const [prefix, bytes2] = parseCIDtoBytes(source, base3);
          const cid2 = CID.decode(bytes2);
          cid2._baseCache.set(prefix, source);
          return cid2;
        }
      };
      var parseCIDtoBytes = (source, base3) => {
        switch (source[0]) {
          case "Q": {
            const decoder2 = base3 || base58btc;
            return [
              base58btc.prefix,
              decoder2.decode(`${base58btc.prefix}${source}`)
            ];
          }
          case base58btc.prefix: {
            const decoder2 = base3 || base58btc;
            return [
              base58btc.prefix,
              decoder2.decode(source)
            ];
          }
          case base32.prefix: {
            const decoder2 = base3 || base32;
            return [
              base32.prefix,
              decoder2.decode(source)
            ];
          }
          default: {
            if (base3 == null) {
              throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            }
            return [
              source[0],
              base3.decode(source)
            ];
          }
        }
      };
      var toStringV0 = (bytes2, cache, base3) => {
        const { prefix } = base3;
        if (prefix !== base58btc.prefix) {
          throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
        }
        const cid2 = cache.get(prefix);
        if (cid2 == null) {
          const cid3 = base3.encode(bytes2).slice(1);
          cache.set(prefix, cid3);
          return cid3;
        } else {
          return cid2;
        }
      };
      var toStringV1 = (bytes2, cache, base3) => {
        const { prefix } = base3;
        const cid2 = cache.get(prefix);
        if (cid2 == null) {
          const cid3 = base3.encode(bytes2);
          cache.set(prefix, cid3);
          return cid3;
        } else {
          return cid2;
        }
      };
      var DAG_PB_CODE = 112;
      var SHA_256_CODE = 18;
      var encodeCID = (version2, code2, multihash) => {
        const codeOffset = encodingLength(version2);
        const hashOffset = codeOffset + encodingLength(code2);
        const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
        encodeTo(version2, bytes2, 0);
        encodeTo(code2, bytes2, codeOffset);
        bytes2.set(multihash, hashOffset);
        return bytes2;
      };
      var cidSymbol = Symbol.for("@ipld/js-cid/CID");
      var readonly = {
        writable: false,
        configurable: false,
        enumerable: true
      };
      var hidden = {
        writable: false,
        enumerable: false,
        configurable: false
      };
      var version = "0.0.0-dev";
      var deprecate = (range, message) => {
        if (range.test(version)) {
          console.warn(message);
        } else {
          throw new Error(message);
        }
      };
      var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
      var identity_exports = {};
      __export(identity_exports, {
        identity: () => identity
      });
      var identity = from({
        prefix: "\0",
        name: "identity",
        encode: (buf) => toString(buf),
        decode: (str) => fromString(str)
      });
      var base2_exports = {};
      __export(base2_exports, {
        base2: () => base2
      });
      var base2 = rfc4648({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
      });
      var base8_exports = {};
      __export(base8_exports, {
        base8: () => base8
      });
      var base8 = rfc4648({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
      });
      var base10_exports = {};
      __export(base10_exports, {
        base10: () => base10
      });
      var base10 = baseX({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
      });
      var base16_exports = {};
      __export(base16_exports, {
        base16: () => base16,
        base16upper: () => base16upper
      });
      var base16 = rfc4648({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
      });
      var base16upper = rfc4648({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      });
      var base36_exports = {};
      __export(base36_exports, {
        base36: () => base36,
        base36upper: () => base36upper
      });
      var base36 = baseX({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
      });
      var base36upper = baseX({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      });
      var base64_exports = {};
      __export(base64_exports, {
        base64: () => base64,
        base64pad: () => base64pad,
        base64url: () => base64url,
        base64urlpad: () => base64urlpad
      });
      var base64 = rfc4648({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
      });
      var base64pad = rfc4648({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      });
      var base64url = rfc4648({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      });
      var base64urlpad = rfc4648({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      });
      var base256emoji_exports = {};
      __export(base256emoji_exports, {
        base256emoji: () => base256emoji
      });
      var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
      var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
        p[i] = c;
        return p;
      }, []);
      var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
        p[c.codePointAt(0)] = i;
        return p;
      }, []);
      function encode3(data) {
        return data.reduce((p, c) => {
          p += alphabetBytesToChars[c];
          return p;
        }, "");
      }
      function decode5(str) {
        const byts = [];
        for (const char of str) {
          const byt = alphabetCharsToBytes[char.codePointAt(0)];
          if (byt === void 0) {
            throw new Error(`Non-base256emoji character: ${char}`);
          }
          byts.push(byt);
        }
        return new Uint8Array(byts);
      }
      var base256emoji = from({
        prefix: "\u{1F680}",
        name: "base256emoji",
        encode: encode3,
        decode: decode5
      });
      var sha2_browser_exports = {};
      __export(sha2_browser_exports, {
        sha256: () => sha256,
        sha512: () => sha512
      });
      var from2 = ({ name: name2, code: code2, encode: encode5 }) => new Hasher(name2, code2, encode5);
      var Hasher = class {
        constructor(name2, code2, encode5) {
          this.name = name2;
          this.code = code2;
          this.encode = encode5;
        }
        digest(input) {
          if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      var sha = (name2) => (data) => __async(exports, null, function* () {
        return new Uint8Array(yield crypto.subtle.digest(name2, data));
      });
      var sha256 = from2({
        name: "sha2-256",
        code: 18,
        encode: sha("SHA-256")
      });
      var sha512 = from2({
        name: "sha2-512",
        code: 19,
        encode: sha("SHA-512")
      });
      var identity_exports2 = {};
      __export(identity_exports2, {
        identity: () => identity2
      });
      var code = 0;
      var name = "identity";
      var encode4 = coerce2;
      var digest = (input) => create(code, encode4(input));
      var identity2 = {
        code,
        name,
        encode: encode4,
        digest
      };
      var textEncoder = new TextEncoder();
      var textDecoder = new TextDecoder();
      var bases = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity_exports), base2_exports), base8_exports), base10_exports), base16_exports), base32_exports), base36_exports), base58_exports), base64_exports), base256emoji_exports);
      var hashes = __spreadValues(__spreadValues({}, sha2_browser_exports), identity_exports2);
      function createCodec(name2, prefix, encode5, decode6) {
        return {
          name: name2,
          prefix,
          encoder: {
            name: name2,
            prefix,
            encode: encode5
          },
          decoder: { decode: decode6 }
        };
      }
      var string = createCodec("utf8", "u", (buf) => {
        const decoder2 = new TextDecoder("utf8");
        return "u" + decoder2.decode(buf);
      }, (str) => {
        const encoder2 = new TextEncoder();
        return encoder2.encode(str.substring(1));
      });
      var ascii = createCodec("ascii", "a", (buf) => {
        let string3 = "a";
        for (let i = 0; i < buf.length; i++) {
          string3 += String.fromCharCode(buf[i]);
        }
        return string3;
      }, (str) => {
        str = str.substring(1);
        const buf = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          buf[i] = str.charCodeAt(i);
        }
        return buf;
      });
      var BASES = __spreadValues({
        utf8: string,
        "utf-8": string,
        hex: bases.base16,
        latin1: ascii,
        ascii,
        binary: ascii
      }, bases);
      var bases_default = BASES;
      function fromString2(string3, encoding = "utf8") {
        const base3 = bases_default[encoding];
        if (!base3) {
          throw new Error(`Unsupported encoding "${encoding}"`);
        }
        return base3.decoder.decode(`${base3.prefix}${string3}`);
      }
      function toString2(array2, encoding = "utf8") {
        const base3 = bases_default[encoding];
        if (!base3) {
          throw new Error(`Unsupported encoding "${encoding}"`);
        }
        return base3.encoder.encode(array2).substring(1);
      }
      var jsonToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => jsonToIpld(item));
        }
        if (val && typeof val === "object") {
          if (typeof val["$link"] === "string" && Object.keys(val).length === 1) {
            return CID.parse(val["$link"]);
          }
          if (typeof val["$bytes"] === "string" && Object.keys(val).length === 1) {
            return fromString2(val["$bytes"], "base64");
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = jsonToIpld(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var ipldToJson = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => ipldToJson(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof Uint8Array) {
            return {
              $bytes: toString2(val, "base64")
            };
          }
          if (CID.asCID(val)) {
            return {
              $link: val.toString()
            };
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = ipldToJson(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var cidSchema = z.any().refine((obj) => CID.asCID(obj) !== null, {
        message: "Not a CID"
      }).transform((obj) => CID.asCID(obj));
      var schema = {
        cid: cidSchema,
        bytes: z.instanceof(Uint8Array),
        string: z.string(),
        array: z.array(z.unknown()),
        map: z.record(z.string(), z.unknown()),
        unknown: z.unknown()
      };
      var def = {
        cid: {
          name: "cid",
          schema: schema.cid
        },
        bytes: {
          name: "bytes",
          schema: schema.bytes
        },
        string: {
          name: "string",
          schema: schema.string
        },
        map: {
          name: "map",
          schema: schema.map
        },
        unknown: {
          name: "unknown",
          schema: schema.unknown
        }
      };
      var SECOND = 1e3;
      var MINUTE = SECOND * 60;
      var HOUR = MINUTE * 60;
      var DAY = HOUR * 24;
      var import_graphemer = __toESM2(require_lib());
      var utf8Len = (str) => {
        return new TextEncoder().encode(str).byteLength;
      };
      var graphemeLen = (str) => {
        const splitter = new import_graphemer.default();
        return splitter.countGraphemes(str);
      };
      var parseLanguage = (langTag) => {
        const parsed = langTag.match(bcp47Regexp);
        if (!(parsed == null ? void 0 : parsed.groups))
          return null;
        const parts = parsed.groups;
        return {
          grandfathered: parts.grandfathered,
          language: parts.language,
          extlang: parts.extlang,
          script: parts.script,
          region: parts.region,
          variant: parts.variant,
          extension: parts.extension,
          privateUse: parts.privateUseA || parts.privateUseB
        };
      };
      var validateLanguage = (langTag) => {
        return bcp47Regexp.test(langTag);
      };
      var bcp47Regexp = new RegExp("^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$");
      var isValidDidDoc = (doc) => {
        return didDocument.safeParse(doc).success;
      };
      var getDid = (doc) => {
        const id = doc.id;
        if (typeof id !== "string") {
          throw new Error("No `id` on document");
        }
        return id;
      };
      var getPdsEndpoint = (doc) => {
        return getServiceEndpoint(doc, {
          id: "#atproto_pds",
          type: "AtprotoPersonalDataServer"
        });
      };
      var getServiceEndpoint = (doc, opts) => {
        const did2 = getDid(doc);
        let services = doc.service;
        if (!services)
          return void 0;
        if (typeof services !== "object")
          return void 0;
        if (!Array.isArray(services)) {
          services = [services];
        }
        const found = services.find((service2) => service2.id === opts.id || service2.id === `${did2}${opts.id}`);
        if (!found)
          return void 0;
        if (found.type !== opts.type) {
          return void 0;
        }
        if (typeof found.serviceEndpoint !== "string") {
          return void 0;
        }
        return validateUrl(found.serviceEndpoint);
      };
      var validateUrl = (urlStr) => {
        let url;
        try {
          url = new URL(urlStr);
        } catch (e) {
          return void 0;
        }
        if (!["http:", "https:"].includes(url.protocol)) {
          return void 0;
        } else if (!url.hostname) {
          return void 0;
        } else {
          return urlStr;
        }
      };
      var verificationMethod = z.object({
        id: z.string(),
        type: z.string(),
        controller: z.string(),
        publicKeyMultibase: z.string().optional()
      });
      var service = z.object({
        id: z.string(),
        type: z.string(),
        serviceEndpoint: z.union([z.string(), z.record(z.unknown())])
      });
      var didDocument = z.object({
        id: z.string(),
        alsoKnownAs: z.array(z.string()).optional(),
        verificationMethod: z.array(verificationMethod).optional(),
        service: z.array(service).optional()
      });
      var import_iso_datestring_validator = __toESM2(require_dist3());
      function datetime(path, value) {
        try {
          if (!(0, import_iso_datestring_validator.isValidISODateString)(value)) {
            throw new Error();
          }
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
          };
        }
        return { success: true, value };
      }
      function uri(path, value) {
        const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
        if (!isUri) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a uri`)
          };
        }
        return { success: true, value };
      }
      function atUri(path, value) {
        try {
          ensureValidAtUri(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid at-uri`)
          };
        }
        return { success: true, value };
      }
      function did(path, value) {
        try {
          ensureValidDid(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid did`)
          };
        }
        return { success: true, value };
      }
      function handle(path, value) {
        try {
          ensureValidHandle(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid handle`)
          };
        }
        return { success: true, value };
      }
      function atIdentifier(path, value) {
        const isDid = did(path, value);
        if (!isDid.success) {
          const isHandle2 = handle(path, value);
          if (!isHandle2.success) {
            return {
              success: false,
              error: new ValidationError(`${path} must be a valid did or a handle`)
            };
          }
        }
        return { success: true, value };
      }
      function nsid(path, value) {
        try {
          ensureValidNsid(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid nsid`)
          };
        }
        return { success: true, value };
      }
      function cid(path, value) {
        try {
          CID.parse(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a cid string`)
          };
        }
        return { success: true, value };
      }
      function language(path, value) {
        if (validateLanguage(value)) {
          return { success: true, value };
        }
        return {
          success: false,
          error: new ValidationError(`${path} must be a well-formed BCP 47 language tag`)
        };
      }
      function validate(lexicons2, path, def2, value) {
        switch (def2.type) {
          case "boolean":
            return boolean(lexicons2, path, def2, value);
          case "integer":
            return integer(lexicons2, path, def2, value);
          case "string":
            return string2(lexicons2, path, def2, value);
          case "bytes":
            return bytes(lexicons2, path, def2, value);
          case "cid-link":
            return cidLink(lexicons2, path, def2, value);
          case "unknown":
            return unknown(lexicons2, path, def2, value);
          default:
            return {
              success: false,
              error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)
            };
        }
      }
      function boolean(lexicons2, path, def2, value) {
        def2 = def2;
        const type = typeof value;
        if (type === "undefined") {
          if (typeof def2.default === "boolean") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be a boolean`)
          };
        } else if (type !== "boolean") {
          return {
            success: false,
            error: new ValidationError(`${path} must be a boolean`)
          };
        }
        if (typeof def2.const === "boolean") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        return { success: true, value };
      }
      function integer(lexicons2, path, def2, value) {
        def2 = def2;
        const type = typeof value;
        if (type === "undefined") {
          if (typeof def2.default === "number") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be an integer`)
          };
        } else if (!Number.isInteger(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an integer`)
          };
        }
        if (typeof def2.const === "number") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        if (Array.isArray(def2.enum)) {
          if (!def2.enum.includes(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be one of (${def2.enum.join("|")})`)
            };
          }
        }
        if (typeof def2.maximum === "number") {
          if (value > def2.maximum) {
            return {
              success: false,
              error: new ValidationError(`${path} can not be greater than ${def2.maximum}`)
            };
          }
        }
        if (typeof def2.minimum === "number") {
          if (value < def2.minimum) {
            return {
              success: false,
              error: new ValidationError(`${path} can not be less than ${def2.minimum}`)
            };
          }
        }
        return { success: true, value };
      }
      function string2(lexicons2, path, def2, value) {
        def2 = def2;
        if (typeof value === "undefined") {
          if (typeof def2.default === "string") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be a string`)
          };
        } else if (typeof value !== "string") {
          return {
            success: false,
            error: new ValidationError(`${path} must be a string`)
          };
        }
        if (typeof def2.const === "string") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        if (Array.isArray(def2.enum)) {
          if (!def2.enum.includes(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be one of (${def2.enum.join("|")})`)
            };
          }
        }
        if (typeof def2.maxLength === "number") {
          if (utf8Len(value) > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be longer than ${def2.maxLength} characters`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (utf8Len(value) < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be shorter than ${def2.minLength} characters`)
            };
          }
        }
        if (typeof def2.maxGraphemes === "number") {
          if (graphemeLen(value) > def2.maxGraphemes) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be longer than ${def2.maxGraphemes} graphemes`)
            };
          }
        }
        if (typeof def2.minGraphemes === "number") {
          if (graphemeLen(value) < def2.minGraphemes) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be shorter than ${def2.minGraphemes} graphemes`)
            };
          }
        }
        if (typeof def2.format === "string") {
          switch (def2.format) {
            case "datetime":
              return datetime(path, value);
            case "uri":
              return uri(path, value);
            case "at-uri":
              return atUri(path, value);
            case "did":
              return did(path, value);
            case "handle":
              return handle(path, value);
            case "at-identifier":
              return atIdentifier(path, value);
            case "nsid":
              return nsid(path, value);
            case "cid":
              return cid(path, value);
            case "language":
              return language(path, value);
          }
        }
        return { success: true, value };
      }
      function bytes(lexicons2, path, def2, value) {
        def2 = def2;
        if (!value || !(value instanceof Uint8Array)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a byte array`)
          };
        }
        if (typeof def2.maxLength === "number") {
          if (value.byteLength > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be larger than ${def2.maxLength} bytes`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (value.byteLength < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be smaller than ${def2.minLength} bytes`)
            };
          }
        }
        return { success: true, value };
      }
      function cidLink(lexicons2, path, def2, value) {
        if (CID.asCID(value) === null) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a CID`)
          };
        }
        return { success: true, value };
      }
      function unknown(lexicons2, path, def2, value) {
        if (!value || typeof value !== "object") {
          return {
            success: false,
            error: new ValidationError(`${path} must be an object`)
          };
        }
        return { success: true, value };
      }
      var typedJsonBlobRef = z.object({
        $type: z.literal("blob"),
        ref: schema.cid,
        mimeType: z.string(),
        size: z.number()
      }).strict();
      var untypedJsonBlobRef = z.object({
        cid: z.string(),
        mimeType: z.string()
      }).strict();
      var jsonBlobRef = z.union([typedJsonBlobRef, untypedJsonBlobRef]);
      var BlobRef = class {
        constructor(ref, mimeType, size, original) {
          this.ref = ref;
          this.mimeType = mimeType;
          this.size = size;
          this.original = original != null ? original : {
            $type: "blob",
            ref,
            mimeType,
            size
          };
        }
        static asBlobRef(obj) {
          if (check_exports.is(obj, jsonBlobRef)) {
            return BlobRef.fromJsonRef(obj);
          }
          return null;
        }
        static fromJsonRef(json) {
          if (check_exports.is(json, typedJsonBlobRef)) {
            return new BlobRef(json.ref, json.mimeType, json.size);
          } else {
            return new BlobRef(CID.parse(json.cid), json.mimeType, -1, json);
          }
        }
        ipld() {
          return {
            $type: "blob",
            ref: this.ref,
            mimeType: this.mimeType,
            size: this.size
          };
        }
        toJSON() {
          return ipldToJson(this.ipld());
        }
      };
      function blob(lexicons2, path, def2, value) {
        if (!value || !(value instanceof BlobRef)) {
          return {
            success: false,
            error: new ValidationError(`${path} should be a blob ref`)
          };
        }
        return { success: true, value };
      }
      function validate2(lexicons2, path, def2, value) {
        switch (def2.type) {
          case "boolean":
            return boolean(lexicons2, path, def2, value);
          case "integer":
            return integer(lexicons2, path, def2, value);
          case "string":
            return string2(lexicons2, path, def2, value);
          case "bytes":
            return bytes(lexicons2, path, def2, value);
          case "cid-link":
            return cidLink(lexicons2, path, def2, value);
          case "unknown":
            return unknown(lexicons2, path, def2, value);
          case "object":
            return object(lexicons2, path, def2, value);
          case "array":
            return array(lexicons2, path, def2, value);
          case "blob":
            return blob(lexicons2, path, def2, value);
          default:
            return {
              success: false,
              error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)
            };
        }
      }
      function array(lexicons2, path, def2, value) {
        if (!Array.isArray(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an array`)
          };
        }
        if (typeof def2.maxLength === "number") {
          if (value.length > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not have more than ${def2.maxLength} elements`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (value.length < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not have fewer than ${def2.minLength} elements`)
            };
          }
        }
        const itemsDef = def2.items;
        for (let i = 0; i < value.length; i++) {
          const itemValue = value[i];
          const itemPath = `${path}/${i}`;
          const res = validateOneOf(lexicons2, itemPath, itemsDef, itemValue);
          if (!res.success) {
            return res;
          }
        }
        return { success: true, value };
      }
      function object(lexicons2, path, def2, value) {
        def2 = def2;
        if (!value || typeof value !== "object") {
          return {
            success: false,
            error: new ValidationError(`${path} must be an object`)
          };
        }
        const requiredProps = new Set(def2.required);
        const nullableProps = new Set(def2.nullable);
        let resultValue = value;
        if (typeof def2.properties === "object") {
          for (const key in def2.properties) {
            if (value[key] === null && nullableProps.has(key)) {
              continue;
            }
            const propDef = def2.properties[key];
            const propPath = `${path}/${key}`;
            const validated = validateOneOf(lexicons2, propPath, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === "undefined";
            if (propIsUndefined && requiredProps.has(key)) {
              return {
                success: false,
                error: new ValidationError(`${path} must have the property "${key}"`)
              };
            } else if (!propIsUndefined && !validated.success) {
              return validated;
            }
            if (propValue !== value[key]) {
              if (resultValue === value) {
                resultValue = __spreadValues({}, value);
              }
              resultValue[key] = propValue;
            }
          }
        }
        return { success: true, value: resultValue };
      }
      function toLexUri(str, baseUri) {
        if (str.split("#").length > 2) {
          throw new Error("Uri can only have one hash segment");
        }
        if (str.startsWith("lex:")) {
          return str;
        }
        if (str.startsWith("#")) {
          if (!baseUri) {
            throw new Error(`Unable to resolve uri without anchor: ${str}`);
          }
          return `${baseUri}${str}`;
        }
        return `lex:${str}`;
      }
      function validateOneOf(lexicons2, path, def2, value, mustBeObj = false) {
        let error;
        let concreteDefs;
        if (def2.type === "union") {
          if (!isDiscriminatedObject(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be an object which includes the "$type" property`)
            };
          }
          if (!refsContainType(def2.refs, value.$type)) {
            if (def2.closed) {
              return {
                success: false,
                error: new ValidationError(`${path} $type must be one of ${def2.refs.join(", ")}`)
              };
            }
            return { success: true, value };
          } else {
            concreteDefs = toConcreteTypes(lexicons2, {
              type: "ref",
              ref: value.$type
            });
          }
        } else {
          concreteDefs = toConcreteTypes(lexicons2, def2);
        }
        for (const concreteDef of concreteDefs) {
          const result = mustBeObj ? object(lexicons2, path, concreteDef, value) : validate2(lexicons2, path, concreteDef, value);
          if (result.success) {
            return result;
          }
          error != null ? error : error = result.error;
        }
        if (concreteDefs.length > 1) {
          return {
            success: false,
            error: new ValidationError(`${path} did not match any of the expected definitions`)
          };
        }
        return { success: false, error };
      }
      function assertValidOneOf(lexicons2, path, def2, value, mustBeObj = false) {
        const res = validateOneOf(lexicons2, path, def2, value, mustBeObj);
        if (!res.success)
          throw res.error;
        return res.value;
      }
      function toConcreteTypes(lexicons2, def2) {
        if (def2.type === "ref") {
          return [lexicons2.getDefOrThrow(def2.ref)];
        } else if (def2.type === "union") {
          return def2.refs.map((ref) => lexicons2.getDefOrThrow(ref)).flat();
        } else {
          return [def2];
        }
      }
      function requiredPropertiesRefinement(object2, ctx) {
        if (object2.required === void 0) {
          return;
        }
        if (!Array.isArray(object2.required)) {
          ctx.addIssue({
            code: z.ZodIssueCode.invalid_type,
            received: typeof object2.required,
            expected: "array"
          });
          return;
        }
        if (object2.properties === void 0) {
          if (object2.required.length > 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Required fields defined but no properties defined`
            });
          }
          return;
        }
        for (const field of object2.required) {
          if (object2.properties[field] === void 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Required field "${field}" not defined`
            });
          }
        }
      }
      var refsContainType = (refs, type) => {
        const lexUri = toLexUri(type);
        if (refs.includes(lexUri)) {
          return true;
        }
        if (lexUri.endsWith("#main")) {
          return refs.includes(lexUri.replace("#main", ""));
        } else {
          return refs.includes(lexUri + "#main");
        }
      };
      var lexBoolean = z.object({
        type: z.literal("boolean"),
        description: z.string().optional(),
        default: z.boolean().optional(),
        const: z.boolean().optional()
      }).strict();
      var lexInteger = z.object({
        type: z.literal("integer"),
        description: z.string().optional(),
        default: z.number().int().optional(),
        minimum: z.number().int().optional(),
        maximum: z.number().int().optional(),
        enum: z.number().int().array().optional(),
        const: z.number().int().optional()
      }).strict();
      var lexStringFormat = z.enum([
        "datetime",
        "uri",
        "at-uri",
        "did",
        "handle",
        "at-identifier",
        "nsid",
        "cid",
        "language"
      ]);
      var lexString = z.object({
        type: z.literal("string"),
        format: lexStringFormat.optional(),
        description: z.string().optional(),
        default: z.string().optional(),
        minLength: z.number().int().optional(),
        maxLength: z.number().int().optional(),
        minGraphemes: z.number().int().optional(),
        maxGraphemes: z.number().int().optional(),
        enum: z.string().array().optional(),
        const: z.string().optional(),
        knownValues: z.string().array().optional()
      }).strict();
      var lexUnknown = z.object({
        type: z.literal("unknown"),
        description: z.string().optional()
      }).strict();
      var lexPrimitive = z.discriminatedUnion("type", [
        lexBoolean,
        lexInteger,
        lexString,
        lexUnknown
      ]);
      var lexBytes = z.object({
        type: z.literal("bytes"),
        description: z.string().optional(),
        maxLength: z.number().optional(),
        minLength: z.number().optional()
      }).strict();
      var lexCidLink = z.object({
        type: z.literal("cid-link"),
        description: z.string().optional()
      }).strict();
      var lexIpldType = z.discriminatedUnion("type", [lexBytes, lexCidLink]);
      var lexRef = z.object({
        type: z.literal("ref"),
        description: z.string().optional(),
        ref: z.string()
      }).strict();
      var lexRefUnion = z.object({
        type: z.literal("union"),
        description: z.string().optional(),
        refs: z.string().array(),
        closed: z.boolean().optional()
      }).strict();
      var lexRefVariant = z.discriminatedUnion("type", [lexRef, lexRefUnion]);
      var lexBlob = z.object({
        type: z.literal("blob"),
        description: z.string().optional(),
        accept: z.string().array().optional(),
        maxSize: z.number().optional()
      }).strict();
      var lexArray = z.object({
        type: z.literal("array"),
        description: z.string().optional(),
        items: z.union([lexPrimitive, lexIpldType, lexBlob, lexRefVariant]),
        minLength: z.number().int().optional(),
        maxLength: z.number().int().optional()
      }).strict();
      var lexPrimitiveArray = lexArray.merge(z.object({
        items: lexPrimitive
      }).strict());
      var lexToken = z.object({
        type: z.literal("token"),
        description: z.string().optional()
      }).strict();
      var lexObject = z.object({
        type: z.literal("object"),
        description: z.string().optional(),
        required: z.string().array().optional(),
        nullable: z.string().array().optional(),
        properties: z.record(z.union([lexRefVariant, lexIpldType, lexArray, lexBlob, lexPrimitive]))
      }).strict().superRefine(requiredPropertiesRefinement);
      var lexXrpcParameters = z.object({
        type: z.literal("params"),
        description: z.string().optional(),
        required: z.string().array().optional(),
        properties: z.record(z.union([lexPrimitive, lexPrimitiveArray]))
      }).strict().superRefine(requiredPropertiesRefinement);
      var lexXrpcBody = z.object({
        description: z.string().optional(),
        encoding: z.string(),
        schema: z.union([lexRefVariant, lexObject]).optional()
      }).strict();
      var lexXrpcSubscriptionMessage = z.object({
        description: z.string().optional(),
        schema: z.union([lexRefVariant, lexObject]).optional()
      }).strict();
      var lexXrpcError = z.object({
        name: z.string(),
        description: z.string().optional()
      }).strict();
      var lexXrpcQuery = z.object({
        type: z.literal("query"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        output: lexXrpcBody.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexXrpcProcedure = z.object({
        type: z.literal("procedure"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        input: lexXrpcBody.optional(),
        output: lexXrpcBody.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexXrpcSubscription = z.object({
        type: z.literal("subscription"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        message: lexXrpcSubscriptionMessage.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexRecord = z.object({
        type: z.literal("record"),
        description: z.string().optional(),
        key: z.string().optional(),
        record: lexObject
      }).strict();
      var lexUserType = z.custom((val) => {
        if (!val || typeof val !== "object") {
          return;
        }
        if (val["type"] === void 0) {
          return;
        }
        switch (val["type"]) {
          case "record":
            return lexRecord.parse(val);
          case "query":
            return lexXrpcQuery.parse(val);
          case "procedure":
            return lexXrpcProcedure.parse(val);
          case "subscription":
            return lexXrpcSubscription.parse(val);
          case "blob":
            return lexBlob.parse(val);
          case "array":
            return lexArray.parse(val);
          case "token":
            return lexToken.parse(val);
          case "object":
            return lexObject.parse(val);
          case "boolean":
            return lexBoolean.parse(val);
          case "integer":
            return lexInteger.parse(val);
          case "string":
            return lexString.parse(val);
          case "bytes":
            return lexBytes.parse(val);
          case "cid-link":
            return lexCidLink.parse(val);
          case "unknown":
            return lexUnknown.parse(val);
        }
      }, (val) => {
        if (!val || typeof val !== "object") {
          return {
            message: "Must be an object",
            fatal: true
          };
        }
        if (val["type"] === void 0) {
          return {
            message: "Must have a type",
            fatal: true
          };
        }
        return {
          message: `Invalid type: ${val["type"]} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
          fatal: true
        };
      });
      var lexiconDoc = z.object({
        lexicon: z.literal(1),
        id: z.string().refine((v) => NSID.isValid(v), {
          message: "Must be a valid NSID"
        }),
        revision: z.number().optional(),
        description: z.string().optional(),
        defs: z.record(lexUserType)
      }).strict().superRefine((doc, ctx) => {
        for (const defId in doc.defs) {
          const def2 = doc.defs[defId];
          if (defId !== "main" && (def2.type === "record" || def2.type === "procedure" || def2.type === "query" || def2.type === "subscription")) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Records, procedures, queries, and subscriptions must be the main definition.`
            });
          }
        }
      });
      function isObj(obj) {
        return obj !== null && typeof obj === "object";
      }
      function hasProp(data, prop) {
        return prop in data;
      }
      var discriminatedObject = z.object({ $type: z.string() });
      function isDiscriminatedObject(value) {
        return discriminatedObject.safeParse(value).success;
      }
      var ValidationError = class extends Error {
      };
      var InvalidLexiconError = class extends Error {
      };
      var LexiconDefNotFoundError = class extends Error {
      };
      function params(lexicons2, path, def2, val) {
        var _a;
        const value = val && typeof val === "object" ? val : {};
        const requiredProps = new Set((_a = def2.required) != null ? _a : []);
        let resultValue = value;
        if (typeof def2.properties === "object") {
          for (const key in def2.properties) {
            const propDef = def2.properties[key];
            const validated = propDef.type === "array" ? array(lexicons2, key, propDef, value[key]) : validate(lexicons2, key, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === "undefined";
            if (propIsUndefined && requiredProps.has(key)) {
              return {
                success: false,
                error: new ValidationError(`${path} must have the property "${key}"`)
              };
            } else if (!propIsUndefined && !validated.success) {
              return validated;
            }
            if (propValue !== value[key]) {
              if (resultValue === value) {
                resultValue = __spreadValues({}, value);
              }
              resultValue[key] = propValue;
            }
          }
        }
        return { success: true, value: resultValue };
      }
      function assertValidRecord(lexicons2, def2, value) {
        const res = object(lexicons2, "Record", def2.record, value);
        if (!res.success)
          throw res.error;
        return res.value;
      }
      function assertValidXrpcParams(lexicons2, def2, value) {
        if (def2.parameters) {
          const res = params(lexicons2, "Params", def2.parameters, value);
          if (!res.success)
            throw res.error;
          return res.value;
        }
      }
      function assertValidXrpcInput(lexicons2, def2, value) {
        var _a;
        if ((_a = def2.input) == null ? void 0 : _a.schema) {
          return assertValidOneOf(lexicons2, "Input", def2.input.schema, value, true);
        }
      }
      function assertValidXrpcOutput(lexicons2, def2, value) {
        var _a;
        if ((_a = def2.output) == null ? void 0 : _a.schema) {
          return assertValidOneOf(lexicons2, "Output", def2.output.schema, value, true);
        }
      }
      function assertValidXrpcMessage(lexicons2, def2, value) {
        var _a;
        if ((_a = def2.message) == null ? void 0 : _a.schema) {
          return assertValidOneOf(lexicons2, "Message", def2.message.schema, value, true);
        }
      }
      var Lexicons = class {
        constructor(docs) {
          this.docs = /* @__PURE__ */ new Map();
          this.defs = /* @__PURE__ */ new Map();
          if (docs == null ? void 0 : docs.length) {
            for (const doc of docs) {
              this.add(doc);
            }
          }
        }
        add(doc) {
          const uri2 = toLexUri(doc.id);
          if (this.docs.has(uri2)) {
            throw new Error(`${uri2} has already been registered`);
          }
          resolveRefUris(doc, uri2);
          this.docs.set(uri2, doc);
          for (const [defUri, def2] of iterDefs(doc)) {
            this.defs.set(defUri, def2);
          }
        }
        remove(uri2) {
          uri2 = toLexUri(uri2);
          const doc = this.docs.get(uri2);
          if (!doc) {
            throw new Error(`Unable to remove "${uri2}": does not exist`);
          }
          for (const [defUri, _def] of iterDefs(doc)) {
            this.defs.delete(defUri);
          }
          this.docs.delete(uri2);
        }
        get(uri2) {
          uri2 = toLexUri(uri2);
          return this.docs.get(uri2);
        }
        getDef(uri2) {
          uri2 = toLexUri(uri2);
          return this.defs.get(uri2);
        }
        getDefOrThrow(uri2, types) {
          const def2 = this.getDef(uri2);
          if (!def2) {
            throw new LexiconDefNotFoundError(`Lexicon not found: ${uri2}`);
          }
          if (types && !types.includes(def2.type)) {
            throw new InvalidLexiconError(`Not a ${types.join(" or ")} lexicon: ${uri2}`);
          }
          return def2;
        }
        validate(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["record", "object"]);
          if (!isObj(value)) {
            throw new ValidationError(`Value must be an object`);
          }
          if (def2.type === "record") {
            return object(this, "Record", def2.record, value);
          } else if (def2.type === "object") {
            return object(this, "Object", def2, value);
          } else {
            throw new InvalidLexiconError("Definition must be a record or object");
          }
        }
        assertValidRecord(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["record"]);
          if (!isObj(value)) {
            throw new ValidationError(`Record must be an object`);
          }
          if (!hasProp(value, "$type") || typeof value.$type !== "string") {
            throw new ValidationError(`Record/$type must be a string`);
          }
          const $type = value.$type || "";
          if (toLexUri($type) !== lexUri) {
            throw new ValidationError(`Invalid $type: must be ${lexUri}, got ${$type}`);
          }
          return assertValidRecord(this, def2, value);
        }
        assertValidXrpcParams(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, [
            "query",
            "procedure",
            "subscription"
          ]);
          return assertValidXrpcParams(this, def2, value);
        }
        assertValidXrpcInput(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["procedure"]);
          return assertValidXrpcInput(this, def2, value);
        }
        assertValidXrpcOutput(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["query", "procedure"]);
          return assertValidXrpcOutput(this, def2, value);
        }
        assertValidXrpcMessage(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["subscription"]);
          return assertValidXrpcMessage(this, def2, value);
        }
        resolveLexUri(lexUri, ref) {
          lexUri = toLexUri(lexUri);
          return toLexUri(ref, lexUri);
        }
      };
      function* iterDefs(doc) {
        for (const defId in doc.defs) {
          yield [`lex:${doc.id}#${defId}`, doc.defs[defId]];
          if (defId === "main") {
            yield [`lex:${doc.id}`, doc.defs[defId]];
          }
        }
      }
      function resolveRefUris(obj, baseUri) {
        for (const k in obj) {
          if (obj.type === "ref") {
            obj.ref = toLexUri(obj.ref, baseUri);
          } else if (obj.type === "union") {
            obj.refs = obj.refs.map((ref) => toLexUri(ref, baseUri));
          } else if (Array.isArray(obj[k])) {
            obj[k] = obj[k].map((item) => {
              if (typeof item === "string") {
                return item.startsWith("#") ? toLexUri(item, baseUri) : item;
              } else if (item && typeof item === "object") {
                return resolveRefUris(item, baseUri);
              }
              return item;
            });
          } else if (obj[k] && typeof obj[k] === "object") {
            obj[k] = resolveRefUris(obj[k], baseUri);
          }
        }
        return obj;
      }
      var lexToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => lexToIpld(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof BlobRef) {
            return val.original;
          }
          if (CID.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = lexToIpld(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var ipldToLex = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => ipldToLex(item));
        }
        if (val && typeof val === "object") {
          if ((val["$type"] === "blob" || typeof val["cid"] === "string" && typeof val["mimeType"] === "string") && check_exports.is(val, jsonBlobRef)) {
            return BlobRef.fromJsonRef(val);
          }
          if (CID.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = ipldToLex(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var lexToJson = (val) => {
        return ipldToJson(lexToIpld(val));
      };
      var stringifyLex = (val) => {
        return JSON.stringify(lexToJson(val));
      };
      var jsonToLex = (val) => {
        return ipldToLex(jsonToIpld(val));
      };
      var jsonStringToLex = (val) => {
        return jsonToLex(JSON.parse(val));
      };
      var errorResponseBody = z.object({
        error: z.string().optional(),
        message: z.string().optional()
      });
      var ResponseType = /* @__PURE__ */ ((ResponseType2) => {
        ResponseType2[ResponseType2["Unknown"] = 1] = "Unknown";
        ResponseType2[ResponseType2["InvalidResponse"] = 2] = "InvalidResponse";
        ResponseType2[ResponseType2["Success"] = 200] = "Success";
        ResponseType2[ResponseType2["InvalidRequest"] = 400] = "InvalidRequest";
        ResponseType2[ResponseType2["AuthRequired"] = 401] = "AuthRequired";
        ResponseType2[ResponseType2["Forbidden"] = 403] = "Forbidden";
        ResponseType2[ResponseType2["XRPCNotSupported"] = 404] = "XRPCNotSupported";
        ResponseType2[ResponseType2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
        ResponseType2[ResponseType2["RateLimitExceeded"] = 429] = "RateLimitExceeded";
        ResponseType2[ResponseType2["InternalServerError"] = 500] = "InternalServerError";
        ResponseType2[ResponseType2["MethodNotImplemented"] = 501] = "MethodNotImplemented";
        ResponseType2[ResponseType2["UpstreamFailure"] = 502] = "UpstreamFailure";
        ResponseType2[ResponseType2["NotEnoughResources"] = 503] = "NotEnoughResources";
        ResponseType2[ResponseType2["UpstreamTimeout"] = 504] = "UpstreamTimeout";
        return ResponseType2;
      })(ResponseType || {});
      var ResponseTypeNames = {
        [
          2
          /* InvalidResponse */
        ]: "InvalidResponse",
        [
          200
          /* Success */
        ]: "Success",
        [
          400
          /* InvalidRequest */
        ]: "InvalidRequest",
        [
          401
          /* AuthRequired */
        ]: "AuthenticationRequired",
        [
          403
          /* Forbidden */
        ]: "Forbidden",
        [
          404
          /* XRPCNotSupported */
        ]: "XRPCNotSupported",
        [
          413
          /* PayloadTooLarge */
        ]: "PayloadTooLarge",
        [
          429
          /* RateLimitExceeded */
        ]: "RateLimitExceeded",
        [
          500
          /* InternalServerError */
        ]: "InternalServerError",
        [
          501
          /* MethodNotImplemented */
        ]: "MethodNotImplemented",
        [
          502
          /* UpstreamFailure */
        ]: "UpstreamFailure",
        [
          503
          /* NotEnoughResources */
        ]: "NotEnoughResources",
        [
          504
          /* UpstreamTimeout */
        ]: "UpstreamTimeout"
      };
      var ResponseTypeStrings = {
        [
          2
          /* InvalidResponse */
        ]: "Invalid Response",
        [
          200
          /* Success */
        ]: "Success",
        [
          400
          /* InvalidRequest */
        ]: "Invalid Request",
        [
          401
          /* AuthRequired */
        ]: "Authentication Required",
        [
          403
          /* Forbidden */
        ]: "Forbidden",
        [
          404
          /* XRPCNotSupported */
        ]: "XRPC Not Supported",
        [
          413
          /* PayloadTooLarge */
        ]: "Payload Too Large",
        [
          429
          /* RateLimitExceeded */
        ]: "Rate Limit Exceeded",
        [
          500
          /* InternalServerError */
        ]: "Internal Server Error",
        [
          501
          /* MethodNotImplemented */
        ]: "Method Not Implemented",
        [
          502
          /* UpstreamFailure */
        ]: "Upstream Failure",
        [
          503
          /* NotEnoughResources */
        ]: "Not Enough Resources",
        [
          504
          /* UpstreamTimeout */
        ]: "Upstream Timeout"
      };
      var XRPCResponse = class {
        constructor(data, headers) {
          this.data = data;
          this.headers = headers;
          this.success = true;
        }
      };
      var XRPCError = class extends Error {
        constructor(status, error, message, headers) {
          super(message || error || ResponseTypeStrings[status]);
          this.status = status;
          this.error = error;
          this.success = false;
          if (!this.error) {
            this.error = ResponseTypeNames[status];
          }
          this.headers = headers;
        }
      };
      var XRPCInvalidResponseError = class extends XRPCError {
        constructor(lexiconNsid, validationError, responseBody) {
          super(2, ResponseTypeStrings[
            2
            /* InvalidResponse */
          ], `The server gave an invalid response and may be out of date.`);
          this.lexiconNsid = lexiconNsid;
          this.validationError = validationError;
          this.responseBody = responseBody;
        }
      };
      function getMethodSchemaHTTPMethod(schema2) {
        if (schema2.type === "procedure") {
          return "post";
        }
        return "get";
      }
      function constructMethodCallUri(nsid2, schema2, serviceUri, params2) {
        var _a, _b;
        const uri2 = new URL(serviceUri);
        uri2.pathname = `/xrpc/${nsid2}`;
        if (params2) {
          for (const [key, value] of Object.entries(params2)) {
            const paramSchema = (_b = (_a = schema2.parameters) == null ? void 0 : _a.properties) == null ? void 0 : _b[key];
            if (!paramSchema) {
              throw new Error(`Invalid query parameter: ${key}`);
            }
            if (value !== void 0) {
              if (paramSchema.type === "array") {
                const vals = [];
                vals.concat(value).forEach((val) => {
                  uri2.searchParams.append(key, encodeQueryParam(paramSchema.items.type, val));
                });
              } else {
                uri2.searchParams.set(key, encodeQueryParam(paramSchema.type, value));
              }
            }
          }
        }
        return uri2.toString();
      }
      function encodeQueryParam(type, value) {
        if (type === "string" || type === "unknown") {
          return String(value);
        }
        if (type === "float") {
          return String(Number(value));
        } else if (type === "integer") {
          return String(Number(value) | 0);
        } else if (type === "boolean") {
          return value ? "true" : "false";
        } else if (type === "datetime") {
          if (value instanceof Date) {
            return value.toISOString();
          }
          return String(value);
        }
        throw new Error(`Unsupported query param type: ${type}`);
      }
      function normalizeHeaders(headers) {
        const normalized = {};
        for (const [header, value] of Object.entries(headers)) {
          normalized[header.toLowerCase()] = value;
        }
        return normalized;
      }
      function constructMethodCallHeaders(schema2, data, opts) {
        const headers = (opts == null ? void 0 : opts.headers) || {};
        if (schema2.type === "procedure") {
          if (opts == null ? void 0 : opts.encoding) {
            headers["Content-Type"] = opts.encoding;
          }
          if (data && typeof data === "object") {
            if (!headers["Content-Type"]) {
              headers["Content-Type"] = "application/json";
            }
          }
        }
        return headers;
      }
      function encodeMethodCallBody(headers, data) {
        if (!headers["content-type"] || typeof data === "undefined") {
          return void 0;
        }
        if (data instanceof ArrayBuffer) {
          return data;
        }
        if (headers["content-type"].startsWith("text/")) {
          return new TextEncoder().encode(data.toString());
        }
        if (headers["content-type"].startsWith("application/json")) {
          return new TextEncoder().encode(stringifyLex(data));
        }
        return data;
      }
      function httpResponseCodeToEnum(status) {
        let resCode;
        if (status in ResponseType) {
          resCode = status;
        } else if (status >= 100 && status < 200) {
          resCode = 404;
        } else if (status >= 200 && status < 300) {
          resCode = 200;
        } else if (status >= 300 && status < 400) {
          resCode = 404;
        } else if (status >= 400 && status < 500) {
          resCode = 400;
        } else {
          resCode = 500;
        }
        return resCode;
      }
      function httpResponseBodyParse(mimeType, data) {
        if (mimeType) {
          if (mimeType.includes("application/json") && (data == null ? void 0 : data.byteLength)) {
            try {
              const str = new TextDecoder().decode(data);
              return jsonStringToLex(str);
            } catch (e) {
              throw new XRPCError(2, `Failed to parse response body: ${String(e)}`);
            }
          }
          if (mimeType.startsWith("text/") && (data == null ? void 0 : data.byteLength)) {
            try {
              return new TextDecoder().decode(data);
            } catch (e) {
              throw new XRPCError(2, `Failed to parse response body: ${String(e)}`);
            }
          }
        }
        if (data instanceof ArrayBuffer) {
          return new Uint8Array(data);
        }
        return data;
      }
      var Client = class {
        constructor() {
          this.fetch = defaultFetchHandler;
          this.lex = new Lexicons();
        }
        call(serviceUri, methodNsid, params2, data, opts) {
          return __async(this, null, function* () {
            return this.service(serviceUri).call(methodNsid, params2, data, opts);
          });
        }
        service(serviceUri) {
          return new ServiceClient(this, serviceUri);
        }
        addLexicon(doc) {
          this.lex.add(doc);
        }
        addLexicons(docs) {
          for (const doc of docs) {
            this.addLexicon(doc);
          }
        }
        removeLexicon(uri2) {
          this.lex.remove(uri2);
        }
      };
      var ServiceClient = class {
        constructor(baseClient, serviceUri) {
          this.headers = {};
          this.baseClient = baseClient;
          this.uri = typeof serviceUri === "string" ? new URL(serviceUri) : serviceUri;
        }
        setHeader(key, value) {
          this.headers[key] = value;
        }
        unsetHeader(key) {
          delete this.headers[key];
        }
        call(methodNsid, params2, data, opts) {
          return __async(this, null, function* () {
            const def2 = this.baseClient.lex.getDefOrThrow(methodNsid);
            if (!def2 || def2.type !== "query" && def2.type !== "procedure") {
              throw new Error(`Invalid lexicon: ${methodNsid}. Must be a query or procedure.`);
            }
            const httpMethod = getMethodSchemaHTTPMethod(def2);
            const httpUri = constructMethodCallUri(methodNsid, def2, this.uri, params2);
            const httpHeaders = constructMethodCallHeaders(def2, data, {
              headers: __spreadValues(__spreadValues({}, this.headers), opts == null ? void 0 : opts.headers),
              encoding: opts == null ? void 0 : opts.encoding
            });
            const res = yield this.baseClient.fetch(httpUri, httpMethod, httpHeaders, data);
            const resCode = httpResponseCodeToEnum(res.status);
            if (resCode === 200) {
              try {
                this.baseClient.lex.assertValidXrpcOutput(methodNsid, res.body);
              } catch (e) {
                if (e instanceof ValidationError) {
                  throw new XRPCInvalidResponseError(methodNsid, e, res.body);
                } else {
                  throw e;
                }
              }
              return new XRPCResponse(res.body, res.headers);
            } else {
              if (res.body && isErrorResponseBody(res.body)) {
                throw new XRPCError(resCode, res.body.error, res.body.message, res.headers);
              } else {
                throw new XRPCError(resCode);
              }
            }
          });
        }
      };
      function defaultFetchHandler(httpUri, httpMethod, httpHeaders, httpReqBody) {
        return __async(this, null, function* () {
          try {
            const headers = normalizeHeaders(httpHeaders);
            const reqInit = {
              method: httpMethod,
              headers,
              body: encodeMethodCallBody(headers, httpReqBody),
              duplex: "half"
            };
            const res = yield fetch(httpUri, reqInit);
            const resBody = yield res.arrayBuffer();
            return {
              status: res.status,
              headers: Object.fromEntries(res.headers.entries()),
              body: httpResponseBodyParse(res.headers.get("content-type"), resBody)
            };
          } catch (e) {
            throw new XRPCError(1, String(e));
          }
        });
      }
      function isErrorResponseBody(v) {
        return errorResponseBody.safeParse(v).success;
      }
      var defaultInst = new Client();
      var schemaDict = {
        ComAtprotoAdminDefs: {
          lexicon: 1,
          id: "com.atproto.admin.defs",
          defs: {
            statusAttr: {
              type: "object",
              required: ["applied"],
              properties: {
                applied: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            },
            modEventView: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobCids",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#modEventTakedown",
                    "lex:com.atproto.admin.defs#modEventReverseTakedown",
                    "lex:com.atproto.admin.defs#modEventComment",
                    "lex:com.atproto.admin.defs#modEventReport",
                    "lex:com.atproto.admin.defs#modEventLabel",
                    "lex:com.atproto.admin.defs#modEventAcknowledge",
                    "lex:com.atproto.admin.defs#modEventEscalate",
                    "lex:com.atproto.admin.defs#modEventMute",
                    "lex:com.atproto.admin.defs#modEventEmail"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                creatorHandle: {
                  type: "string"
                },
                subjectHandle: {
                  type: "string"
                }
              }
            },
            modEventViewDetail: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobs",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#modEventTakedown",
                    "lex:com.atproto.admin.defs#modEventReverseTakedown",
                    "lex:com.atproto.admin.defs#modEventComment",
                    "lex:com.atproto.admin.defs#modEventReport",
                    "lex:com.atproto.admin.defs#modEventLabel",
                    "lex:com.atproto.admin.defs#modEventAcknowledge",
                    "lex:com.atproto.admin.defs#modEventEscalate",
                    "lex:com.atproto.admin.defs#modEventMute",
                    "lex:com.atproto.admin.defs#modEventResolveAppeal"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoView",
                    "lex:com.atproto.admin.defs#repoViewNotFound",
                    "lex:com.atproto.admin.defs#recordView",
                    "lex:com.atproto.admin.defs#recordViewNotFound"
                  ]
                },
                subjectBlobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#blobView"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            reportView: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt",
                "resolvedByActionIds"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                comment: {
                  type: "string"
                },
                subjectRepoHandle: {
                  type: "string"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                resolvedByActionIds: {
                  type: "array",
                  items: {
                    type: "integer"
                  }
                }
              }
            },
            subjectStatusView: {
              type: "object",
              required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
              properties: {
                id: {
                  type: "integer"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                subjectRepoHandle: {
                  type: "string"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the last update was made to the moderation status of the subject"
                },
                createdAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
                },
                reviewState: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectReviewState"
                },
                comment: {
                  type: "string",
                  description: "Sticky comment on the subject."
                },
                muteUntil: {
                  type: "string",
                  format: "datetime"
                },
                lastReviewedBy: {
                  type: "string",
                  format: "did"
                },
                lastReviewedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastReportedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastAppealedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the author of the subject appealed a moderation action"
                },
                takendown: {
                  type: "boolean"
                },
                appealed: {
                  type: "boolean",
                  description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
                },
                suspendUntil: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            reportViewDetail: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt",
                "resolvedByActions"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                comment: {
                  type: "string"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoView",
                    "lex:com.atproto.admin.defs#repoViewNotFound",
                    "lex:com.atproto.admin.defs#recordView",
                    "lex:com.atproto.admin.defs#recordViewNotFound"
                  ]
                },
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                resolvedByActions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#modEventView"
                  }
                }
              }
            },
            repoView: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                }
              }
            },
            repoViewDetail: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderationDetail"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            accountView: {
              type: "object",
              required: ["did", "handle", "indexedAt"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                },
                inviteNote: {
                  type: "string"
                }
              }
            },
            repoViewNotFound: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            repoRef: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            repoBlobRef: {
              type: "object",
              required: ["did", "cid"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                recordUri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            recordView: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobCids",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                },
                repo: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoView"
                }
              }
            },
            recordViewDetail: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobs",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#blobView"
                  }
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderationDetail"
                },
                repo: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoView"
                }
              }
            },
            recordViewNotFound: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            moderation: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                }
              }
            },
            moderationDetail: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                }
              }
            },
            blobView: {
              type: "object",
              required: ["cid", "mimeType", "size", "createdAt"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                mimeType: {
                  type: "string"
                },
                size: {
                  type: "integer"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                details: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#imageDetails",
                    "lex:com.atproto.admin.defs#videoDetails"
                  ]
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                }
              }
            },
            imageDetails: {
              type: "object",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                }
              }
            },
            videoDetails: {
              type: "object",
              required: ["width", "height", "length"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                },
                length: {
                  type: "integer"
                }
              }
            },
            subjectReviewState: {
              type: "string",
              knownValues: [
                "lex:com.atproto.admin.defs#reviewOpen",
                "lex:com.atproto.admin.defs#reviewEscalated",
                "lex:com.atproto.admin.defs#reviewClosed"
              ]
            },
            reviewOpen: {
              type: "token",
              description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
            },
            reviewEscalated: {
              type: "token",
              description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
            },
            reviewClosed: {
              type: "token",
              description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
            },
            modEventTakedown: {
              type: "object",
              description: "Take down a subject permanently or temporarily",
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the takedown should be in effect before automatically expiring."
                }
              }
            },
            modEventReverseTakedown: {
              type: "object",
              description: "Revert take down action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventResolveAppeal: {
              type: "object",
              description: "Resolve appeal on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe resolution."
                }
              }
            },
            modEventComment: {
              type: "object",
              description: "Add a comment to a subject",
              required: ["comment"],
              properties: {
                comment: {
                  type: "string"
                },
                sticky: {
                  type: "boolean",
                  description: "Make the comment persistent on the subject"
                }
              }
            },
            modEventReport: {
              type: "object",
              description: "Report a subject",
              required: ["reportType"],
              properties: {
                comment: {
                  type: "string"
                },
                reportType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                }
              }
            },
            modEventLabel: {
              type: "object",
              description: "Apply/Negate labels on a subject",
              required: ["createLabelVals", "negateLabelVals"],
              properties: {
                comment: {
                  type: "string"
                },
                createLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                negateLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            },
            modEventAcknowledge: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventEscalate: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventMute: {
              type: "object",
              description: "Mute incoming reports on a subject",
              required: ["durationInHours"],
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the subject should remain muted."
                }
              }
            },
            modEventUnmute: {
              type: "object",
              description: "Unmute action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventEmail: {
              type: "object",
              description: "Keep a log of outgoing email to a user",
              required: ["subjectLine"],
              properties: {
                subjectLine: {
                  type: "string",
                  description: "The subject line of the email sent to the user."
                },
                comment: {
                  type: "string",
                  description: "Additional comment about the outgoing comm."
                }
              }
            }
          }
        },
        ComAtprotoAdminDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.admin.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a user account as an administrator.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.disableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for disabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.disableInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Disable some set of codes and/or all codes associated with a set of users.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminEmitModerationEvent: {
          lexicon: 1,
          id: "com.atproto.admin.emitModerationEvent",
          defs: {
            main: {
              type: "procedure",
              description: "Take a moderation action on an actor.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["event", "subject", "createdBy"],
                  properties: {
                    event: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#modEventTakedown",
                        "lex:com.atproto.admin.defs#modEventAcknowledge",
                        "lex:com.atproto.admin.defs#modEventEscalate",
                        "lex:com.atproto.admin.defs#modEventComment",
                        "lex:com.atproto.admin.defs#modEventLabel",
                        "lex:com.atproto.admin.defs#modEventReport",
                        "lex:com.atproto.admin.defs#modEventMute",
                        "lex:com.atproto.admin.defs#modEventReverseTakedown",
                        "lex:com.atproto.admin.defs#modEventUnmute",
                        "lex:com.atproto.admin.defs#modEventEmail"
                      ]
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    subjectBlobCids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    },
                    createdBy: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#modEventView"
                }
              },
              errors: [
                {
                  name: "SubjectHasAction"
                }
              ]
            }
          }
        },
        ComAtprotoAdminEnableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.enableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Re-enable an account's ability to receive invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for enabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetAccountInfo: {
          lexicon: 1,
          id: "com.atproto.admin.getAccountInfo",
          defs: {
            main: {
              type: "query",
              description: "Get details about an account.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#accountView"
                }
              }
            }
          }
        },
        ComAtprotoAdminGetInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.getInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get an admin view of invite codes.",
              parameters: {
                type: "params",
                properties: {
                  sort: {
                    type: "string",
                    knownValues: ["recent", "usage"],
                    default: "recent"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 500,
                    default: 100
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetModerationEvent: {
          lexicon: 1,
          id: "com.atproto.admin.getModerationEvent",
          defs: {
            main: {
              type: "query",
              description: "Get details about a moderation event.",
              parameters: {
                type: "params",
                required: ["id"],
                properties: {
                  id: {
                    type: "integer"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#modEventViewDetail"
                }
              }
            }
          }
        },
        ComAtprotoAdminGetRecord: {
          lexicon: 1,
          id: "com.atproto.admin.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get details about a record.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#recordViewDetail"
                }
              },
              errors: [
                {
                  name: "RecordNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoAdminGetRepo: {
          lexicon: 1,
          id: "com.atproto.admin.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Get details about a repository.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoViewDetail"
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoAdminGetSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.getSubjectStatus",
          defs: {
            main: {
              type: "query",
              description: "Get the service-specific admin status of a subject (account, record, or blob).",
              parameters: {
                type: "params",
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  blob: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminQueryModerationEvents: {
          lexicon: 1,
          id: "com.atproto.admin.queryModerationEvents",
          defs: {
            main: {
              type: "query",
              description: "List moderation events related to a subject.",
              parameters: {
                type: "params",
                properties: {
                  types: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "The types of events (fully qualified string in the format of com.atproto.admin#modEvent<name>) to filter by. If not specified, all events are returned."
                  },
                  createdBy: {
                    type: "string",
                    format: "did"
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"],
                    description: "Sort direction for the events. Defaults to descending order of created at timestamp."
                  },
                  subject: {
                    type: "string",
                    format: "uri"
                  },
                  includeAllUserRecords: {
                    type: "boolean",
                    default: false,
                    description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["events"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    events: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#modEventView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminQueryModerationStatuses: {
          lexicon: 1,
          id: "com.atproto.admin.queryModerationStatuses",
          defs: {
            main: {
              type: "query",
              description: "View moderation statuses of subjects (record or repo).",
              parameters: {
                type: "params",
                properties: {
                  subject: {
                    type: "string",
                    format: "uri"
                  },
                  comment: {
                    type: "string",
                    description: "Search subjects by keyword from comments"
                  },
                  reportedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported after a given timestamp"
                  },
                  reportedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported before a given timestamp"
                  },
                  reviewedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed after a given timestamp"
                  },
                  reviewedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed before a given timestamp"
                  },
                  includeMuted: {
                    type: "boolean",
                    description: "By default, we don't include muted subjects in the results. Set this to true to include them."
                  },
                  reviewState: {
                    type: "string",
                    description: "Specify when fetching subjects in a certain state"
                  },
                  ignoreSubjects: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "uri"
                    }
                  },
                  lastReviewedBy: {
                    type: "string",
                    format: "did",
                    description: "Get all subject statuses that were reviewed by a specific moderator"
                  },
                  sortField: {
                    type: "string",
                    default: "lastReportedAt",
                    enum: ["lastReviewedAt", "lastReportedAt"]
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"]
                  },
                  takendown: {
                    type: "boolean",
                    description: "Get subjects that were taken down"
                  },
                  appealed: {
                    type: "boolean",
                    description: "Get subjects in unresolved appealed status"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subjectStatuses"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    subjectStatuses: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#subjectStatusView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSearchRepos: {
          lexicon: 1,
          id: "com.atproto.admin.searchRepos",
          defs: {
            main: {
              type: "query",
              description: "Find repositories based on a search term.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead"
                  },
                  q: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#repoView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSendEmail: {
          lexicon: 1,
          id: "com.atproto.admin.sendEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Send email to a user's account email address.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["recipientDid", "content", "senderDid"],
                  properties: {
                    recipientDid: {
                      type: "string",
                      format: "did"
                    },
                    content: {
                      type: "string"
                    },
                    subject: {
                      type: "string"
                    },
                    senderDid: {
                      type: "string",
                      format: "did"
                    },
                    comment: {
                      type: "string",
                      description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["sent"],
                  properties: {
                    sent: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountEmail: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account", "email"],
                  properties: {
                    account: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountHandle: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "handle"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.updateSubjectStatus",
          defs: {
            main: {
              type: "procedure",
              description: "Update the service-specific admin status of a subject (account, record, or blob).",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityResolveHandle: {
          lexicon: 1,
          id: "com.atproto.identity.resolveHandle",
          defs: {
            main: {
              type: "query",
              description: "Provides the DID of a repo.",
              parameters: {
                type: "params",
                required: ["handle"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle",
                    description: "The handle to resolve."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityUpdateHandle: {
          lexicon: 1,
          id: "com.atproto.identity.updateHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Updates the handle of the account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelDefs: {
          lexicon: 1,
          id: "com.atproto.label.defs",
          defs: {
            label: {
              type: "object",
              description: "Metadata tag on an atproto resource (eg, repo or record).",
              required: ["src", "uri", "val", "cts"],
              properties: {
                src: {
                  type: "string",
                  format: "did",
                  description: "DID of the actor who created this label."
                },
                uri: {
                  type: "string",
                  format: "uri",
                  description: "AT URI of the record, repository (account), or other resource that this label applies to."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
                },
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                },
                neg: {
                  type: "boolean",
                  description: "If true, this is a negation label, overwriting a previous label."
                },
                cts: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp when this label was created."
                }
              }
            },
            selfLabels: {
              type: "object",
              description: "Metadata tags on an atproto record, published by the author within the record.",
              required: ["values"],
              properties: {
                values: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#selfLabel"
                  },
                  maxLength: 10
                }
              }
            },
            selfLabel: {
              type: "object",
              description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
              required: ["val"],
              properties: {
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                }
              }
            }
          }
        },
        ComAtprotoLabelQueryLabels: {
          lexicon: 1,
          id: "com.atproto.label.queryLabels",
          defs: {
            main: {
              type: "query",
              description: "Find labels relevant to the provided URI patterns.",
              parameters: {
                type: "params",
                required: ["uriPatterns"],
                properties: {
                  uriPatterns: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
                  },
                  sources: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    },
                    description: "Optional list of label sources (DIDs) to filter on."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelSubscribeLabels: {
          lexicon: 1,
          id: "com.atproto.label.subscribeLabels",
          defs: {
            main: {
              type: "subscription",
              description: "Subscribe to label updates.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.label.subscribeLabels#labels",
                    "lex:com.atproto.label.subscribeLabels#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                }
              ]
            },
            labels: {
              type: "object",
              required: ["seq", "labels"],
              properties: {
                seq: {
                  type: "integer"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoModerationCreateReport: {
          lexicon: 1,
          id: "com.atproto.moderation.createReport",
          defs: {
            main: {
              type: "procedure",
              description: "Report a repo or a record.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["reasonType", "subject"],
                  properties: {
                    reasonType: {
                      type: "ref",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string"
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "id",
                    "reasonType",
                    "subject",
                    "reportedBy",
                    "createdAt"
                  ],
                  properties: {
                    id: {
                      type: "integer"
                    },
                    reasonType: {
                      type: "ref",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string",
                      maxGraphemes: 2e3,
                      maxLength: 2e4
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    reportedBy: {
                      type: "string",
                      format: "did"
                    },
                    createdAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoModerationDefs: {
          lexicon: 1,
          id: "com.atproto.moderation.defs",
          defs: {
            reasonType: {
              type: "string",
              knownValues: [
                "com.atproto.moderation.defs#reasonSpam",
                "com.atproto.moderation.defs#reasonViolation",
                "com.atproto.moderation.defs#reasonMisleading",
                "com.atproto.moderation.defs#reasonSexual",
                "com.atproto.moderation.defs#reasonRude",
                "com.atproto.moderation.defs#reasonOther",
                "com.atproto.moderation.defs#reasonAppeal"
              ]
            },
            reasonSpam: {
              type: "token",
              description: "Spam: frequent unwanted promotion, replies, mentions"
            },
            reasonViolation: {
              type: "token",
              description: "Direct violation of server rules, laws, terms of service"
            },
            reasonMisleading: {
              type: "token",
              description: "Misleading identity, affiliation, or content"
            },
            reasonSexual: {
              type: "token",
              description: "Unwanted or mislabeled sexual content"
            },
            reasonRude: {
              type: "token",
              description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
            },
            reasonOther: {
              type: "token",
              description: "Other: reports not falling under another report category"
            },
            reasonAppeal: {
              type: "token",
              description: "Appeal: appeal a previously taken moderation action"
            }
          }
        },
        ComAtprotoRepoApplyWrites: {
          lexicon: 1,
          id: "com.atproto.repo.applyWrites",
          defs: {
            main: {
              type: "procedure",
              description: "Apply a batch transaction of creates, updates, and deletes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "writes"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the records."
                    },
                    writes: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:com.atproto.repo.applyWrites#create",
                          "lex:com.atproto.repo.applyWrites#update",
                          "lex:com.atproto.repo.applyWrites#delete"
                        ],
                        closed: true
                      }
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            },
            create: {
              type: "object",
              description: "Create a new record.",
              required: ["collection", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string",
                  maxLength: 15
                },
                value: {
                  type: "unknown"
                }
              }
            },
            update: {
              type: "object",
              description: "Update an existing record.",
              required: ["collection", "rkey", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                },
                value: {
                  type: "unknown"
                }
              }
            },
            delete: {
              type: "object",
              description: "Delete an existing record.",
              required: ["collection", "rkey"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoRepoCreateRecord: {
          lexicon: 1,
          id: "com.atproto.repo.createRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Create a new record.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "record"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record.",
                      maxLength: 15
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the record."
                    },
                    record: {
                      type: "unknown",
                      description: "The record to create."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoDeleteRecord: {
          lexicon: 1,
          id: "com.atproto.repo.deleteRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a record, or ensure it doesn't exist.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoDescribeRepo: {
          lexicon: 1,
          id: "com.atproto.repo.describeRepo",
          defs: {
            main: {
              type: "query",
              description: "Get information about the repo, including the list of collections.",
              parameters: {
                type: "params",
                required: ["repo"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "handle",
                    "did",
                    "didDoc",
                    "collections",
                    "handleIsCorrect"
                  ],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    collections: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "nsid"
                      }
                    },
                    handleIsCorrect: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoRepoGetRecord: {
          lexicon: 1,
          id: "com.atproto.repo.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get a record.",
              parameters: {
                type: "params",
                required: ["repo", "collection", "rkey"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    description: "The key of the record."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the version of the record. If not specified, then return the most recent version."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "value"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    value: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoRepoListRecords: {
          lexicon: 1,
          id: "com.atproto.repo.listRecords",
          defs: {
            main: {
              type: "query",
              description: "List a range of records in a collection.",
              parameters: {
                type: "params",
                required: ["repo", "collection"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record type."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50,
                    description: "The number of records to return."
                  },
                  cursor: {
                    type: "string"
                  },
                  rkeyStart: {
                    type: "string",
                    description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
                  },
                  rkeyEnd: {
                    type: "string",
                    description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
                  },
                  reverse: {
                    type: "boolean",
                    description: "Flag to reverse the order of the returned records."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["records"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    records: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.repo.listRecords#record"
                      }
                    }
                  }
                }
              }
            },
            record: {
              type: "object",
              required: ["uri", "cid", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        },
        ComAtprotoRepoPutRecord: {
          lexicon: 1,
          id: "com.atproto.repo.putRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Write a record, creating or updating it as needed.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey", "record"],
                  nullable: ["swapRecord"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record.",
                      maxLength: 15
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the record."
                    },
                    record: {
                      type: "unknown",
                      description: "The record to write."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoStrongRef: {
          lexicon: 1,
          id: "com.atproto.repo.strongRef",
          description: "A URI with a content-hash fingerprint.",
          defs: {
            main: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          }
        },
        ComAtprotoRepoUploadBlob: {
          lexicon: 1,
          id: "com.atproto.repo.uploadBlob",
          defs: {
            main: {
              type: "procedure",
              description: "Upload a new blob to be added to repo in a later request.",
              input: {
                encoding: "*/*"
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blob"],
                  properties: {
                    blob: {
                      type: "blob"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerConfirmEmail: {
          lexicon: 1,
          id: "com.atproto.server.confirmEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email", "token"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountNotFound"
                },
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "InvalidEmail"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAccount: {
          lexicon: 1,
          id: "com.atproto.server.createAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Create an account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    inviteCode: {
                      type: "string"
                    },
                    password: {
                      type: "string"
                    },
                    recoveryKey: {
                      type: "string"
                    },
                    plcOp: {
                      type: "unknown"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidHandle"
                },
                {
                  name: "InvalidPassword"
                },
                {
                  name: "InvalidInviteCode"
                },
                {
                  name: "HandleNotAvailable"
                },
                {
                  name: "UnsupportedDomain"
                },
                {
                  name: "UnresolvableDid"
                },
                {
                  name: "IncompatibleDidDoc"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.createAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Create an App Password.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.server.createAppPassword#appPassword"
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "password", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                password: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCode: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCode",
          defs: {
            main: {
              type: "procedure",
              description: "Create an invite code.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["useCount"],
                  properties: {
                    useCount: {
                      type: "integer"
                    },
                    forAccount: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["code"],
                  properties: {
                    code: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Create invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codeCount", "useCount"],
                  properties: {
                    codeCount: {
                      type: "integer",
                      default: 1
                    },
                    useCount: {
                      type: "integer"
                    },
                    forAccounts: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "did"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                      }
                    }
                  }
                }
              }
            },
            accountCodes: {
              type: "object",
              required: ["account", "codes"],
              properties: {
                account: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateSession: {
          lexicon: 1,
          id: "com.atproto.server.createSession",
          defs: {
            main: {
              type: "procedure",
              description: "Create an authentication session.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["identifier", "password"],
                  properties: {
                    identifier: {
                      type: "string",
                      description: "Handle or other identifier supported by the server for the authenticating user."
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            }
          }
        },
        ComAtprotoServerDefs: {
          lexicon: 1,
          id: "com.atproto.server.defs",
          defs: {
            inviteCode: {
              type: "object",
              required: [
                "code",
                "available",
                "disabled",
                "forAccount",
                "createdBy",
                "createdAt",
                "uses"
              ],
              properties: {
                code: {
                  type: "string"
                },
                available: {
                  type: "integer"
                },
                disabled: {
                  type: "boolean"
                },
                forAccount: {
                  type: "string"
                },
                createdBy: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                uses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCodeUse"
                  }
                }
              }
            },
            inviteCodeUse: {
              type: "object",
              required: ["usedBy", "usedAt"],
              properties: {
                usedBy: {
                  type: "string",
                  format: "did"
                },
                usedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.server.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete an actor's account with a token and password.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "password", "token"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    password: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerDeleteSession: {
          lexicon: 1,
          id: "com.atproto.server.deleteSession",
          defs: {
            main: {
              type: "procedure",
              description: "Delete the current session."
            }
          }
        },
        ComAtprotoServerDescribeServer: {
          lexicon: 1,
          id: "com.atproto.server.describeServer",
          defs: {
            main: {
              type: "query",
              description: "Get a document describing the service's accounts configuration.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["availableUserDomains"],
                  properties: {
                    inviteCodeRequired: {
                      type: "boolean"
                    },
                    availableUserDomains: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    links: {
                      type: "ref",
                      ref: "lex:com.atproto.server.describeServer#links"
                    }
                  }
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string"
                },
                termsOfService: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoServerGetAccountInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.getAccountInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get all invite codes for a given account.",
              parameters: {
                type: "params",
                properties: {
                  includeUsed: {
                    type: "boolean",
                    default: true
                  },
                  createAvailable: {
                    type: "boolean",
                    default: true
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "DuplicateCreate"
                }
              ]
            }
          }
        },
        ComAtprotoServerGetSession: {
          lexicon: 1,
          id: "com.atproto.server.getSession",
          defs: {
            main: {
              type: "query",
              description: "Get information about the current session.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle", "did"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerListAppPasswords: {
          lexicon: 1,
          id: "com.atproto.server.listAppPasswords",
          defs: {
            main: {
              type: "query",
              description: "List all App Passwords.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["passwords"],
                  properties: {
                    passwords: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerRefreshSession: {
          lexicon: 1,
          id: "com.atproto.server.refreshSession",
          defs: {
            main: {
              type: "procedure",
              description: "Refresh an authentication session.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            }
          }
        },
        ComAtprotoServerRequestAccountDelete: {
          lexicon: 1,
          id: "com.atproto.server.requestAccountDelete",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account deletion via email."
            }
          }
        },
        ComAtprotoServerRequestEmailConfirmation: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailConfirmation",
          defs: {
            main: {
              type: "procedure",
              description: "Request an email with a code to confirm ownership of email."
            }
          }
        },
        ComAtprotoServerRequestEmailUpdate: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Request a token in order to update email.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["tokenRequired"],
                  properties: {
                    tokenRequired: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerRequestPasswordReset: {
          lexicon: 1,
          id: "com.atproto.server.requestPasswordReset",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account password reset via email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerReserveSigningKey: {
          lexicon: 1,
          id: "com.atproto.server.reserveSigningKey",
          defs: {
            main: {
              type: "procedure",
              description: "Reserve a repo signing key for account creation.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    did: {
                      type: "string",
                      description: "The did to reserve a new did:key for"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["signingKey"],
                  properties: {
                    signingKey: {
                      type: "string",
                      description: "Public signing key in the form of a did:key."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerResetPassword: {
          lexicon: 1,
          id: "com.atproto.server.resetPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Reset a user account password using a token.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["token", "password"],
                  properties: {
                    token: {
                      type: "string"
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerRevokeAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.revokeAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Revoke an App Password by name.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerUpdateEmail: {
          lexicon: 1,
          id: "com.atproto.server.updateEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    token: {
                      type: "string",
                      description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "TokenRequired"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetBlob: {
          lexicon: 1,
          id: "com.atproto.sync.getBlob",
          defs: {
            main: {
              type: "query",
              description: "Get a blob associated with a given repo.",
              parameters: {
                type: "params",
                required: ["did", "cid"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the blob to fetch"
                  }
                }
              },
              output: {
                encoding: "*/*"
              }
            }
          }
        },
        ComAtprotoSyncGetBlocks: {
          lexicon: 1,
          id: "com.atproto.sync.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get blocks from a given repo.",
              parameters: {
                type: "params",
                required: ["did", "cids"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  cids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetCheckout: {
          lexicon: 1,
          id: "com.atproto.sync.getCheckout",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetHead: {
          lexicon: 1,
          id: "com.atproto.sync.getHead",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "HeadNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetLatestCommit: {
          lexicon: 1,
          id: "com.atproto.sync.getLatestCommit",
          defs: {
            main: {
              type: "query",
              description: "Get the current commit CID & revision of the repo.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cid", "rev"],
                  properties: {
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    rev: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRecord: {
          lexicon: 1,
          id: "com.atproto.sync.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get blocks needed for existence or non-existence of record.",
              parameters: {
                type: "params",
                required: ["did", "collection", "rkey"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid"
                  },
                  rkey: {
                    type: "string"
                  },
                  commit: {
                    type: "string",
                    format: "cid",
                    description: "An optional past commit CID."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetRepo: {
          lexicon: 1,
          id: "com.atproto.sync.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Gets the DID's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "The revision of the repo to catch up from."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncListBlobs: {
          lexicon: 1,
          id: "com.atproto.sync.listBlobs",
          defs: {
            main: {
              type: "query",
              description: "List blob CIDs since some revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "Optional revision of the repo to list blobs since."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cids"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    cids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncListRepos: {
          lexicon: 1,
          id: "com.atproto.sync.listRepos",
          defs: {
            main: {
              type: "query",
              description: "List DIDs and root CIDs of hosted repos.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.sync.listRepos#repo"
                      }
                    }
                  }
                }
              }
            },
            repo: {
              type: "object",
              required: ["did", "head", "rev"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                head: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoSyncNotifyOfUpdate: {
          lexicon: 1,
          id: "com.atproto.sync.notifyOfUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Notify a crawling service of a recent update; often when a long break between updates causes the connection with the crawling service to break.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the service that is notifying of update."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncRequestCrawl: {
          lexicon: 1,
          id: "com.atproto.sync.requestCrawl",
          defs: {
            main: {
              type: "procedure",
              description: "Request a service to persistently crawl hosted repos.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the service that is requesting to be crawled."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncSubscribeRepos: {
          lexicon: 1,
          id: "com.atproto.sync.subscribeRepos",
          defs: {
            main: {
              type: "subscription",
              description: "Subscribe to repo updates.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.sync.subscribeRepos#commit",
                    "lex:com.atproto.sync.subscribeRepos#handle",
                    "lex:com.atproto.sync.subscribeRepos#migrate",
                    "lex:com.atproto.sync.subscribeRepos#tombstone",
                    "lex:com.atproto.sync.subscribeRepos#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                },
                {
                  name: "ConsumerTooSlow"
                }
              ]
            },
            commit: {
              type: "object",
              required: [
                "seq",
                "rebase",
                "tooBig",
                "repo",
                "commit",
                "rev",
                "since",
                "blocks",
                "ops",
                "blobs",
                "time"
              ],
              nullable: ["prev", "since"],
              properties: {
                seq: {
                  type: "integer"
                },
                rebase: {
                  type: "boolean"
                },
                tooBig: {
                  type: "boolean"
                },
                repo: {
                  type: "string",
                  format: "did"
                },
                commit: {
                  type: "cid-link"
                },
                prev: {
                  type: "cid-link"
                },
                rev: {
                  type: "string",
                  description: "The rev of the emitted commit."
                },
                since: {
                  type: "string",
                  description: "The rev of the last emitted commit from this repo."
                },
                blocks: {
                  type: "bytes",
                  description: "CAR file containing relevant blocks.",
                  maxLength: 1e6
                },
                ops: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.subscribeRepos#repoOp"
                  },
                  maxLength: 200
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "cid-link"
                  }
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            handle: {
              type: "object",
              required: ["seq", "did", "handle", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            migrate: {
              type: "object",
              required: ["seq", "did", "migrateTo", "time"],
              nullable: ["migrateTo"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                migrateTo: {
                  type: "string"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            tombstone: {
              type: "object",
              required: ["seq", "did", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            },
            repoOp: {
              type: "object",
              description: "A repo operation, ie a write of a single record. For creates and updates, CID is the record's CID as of this operation. For deletes, it's null.",
              required: ["action", "path", "cid"],
              nullable: ["cid"],
              properties: {
                action: {
                  type: "string",
                  knownValues: ["create", "update", "delete"]
                },
                path: {
                  type: "string"
                },
                cid: {
                  type: "cid-link"
                }
              }
            }
          }
        },
        ComAtprotoTempFetchLabels: {
          lexicon: 1,
          id: "com.atproto.temp.fetchLabels",
          defs: {
            main: {
              type: "query",
              description: "Fetch all labels from a labeler created after a certain date.",
              parameters: {
                type: "params",
                properties: {
                  since: {
                    type: "integer"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoTempImportRepo: {
          lexicon: 1,
          id: "com.atproto.temp.importRepo",
          defs: {
            main: {
              type: "procedure",
              description: "Gets the did's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              input: {
                encoding: "application/vnd.ipld.car"
              },
              output: {
                encoding: "text/plain"
              }
            }
          }
        },
        ComAtprotoTempPushBlob: {
          lexicon: 1,
          id: "com.atproto.temp.pushBlob",
          defs: {
            main: {
              type: "procedure",
              description: "Gets the did's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              input: {
                encoding: "*/*"
              }
            }
          }
        },
        ComAtprotoTempTransferAccount: {
          lexicon: 1,
          id: "com.atproto.temp.transferAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Transfer an account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle", "did", "plcOp"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    plcOp: {
                      type: "unknown"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidHandle"
                },
                {
                  name: "InvalidPassword"
                },
                {
                  name: "InvalidInviteCode"
                },
                {
                  name: "HandleNotAvailable"
                },
                {
                  name: "UnsupportedDomain"
                },
                {
                  name: "UnresolvableDid"
                },
                {
                  name: "IncompatibleDidDoc"
                }
              ]
            }
          }
        },
        AppBskyActorDefs: {
          lexicon: 1,
          id: "app.bsky.actor.defs",
          description: "A reference to an actor in the network.",
          defs: {
            profileViewBasic: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            profileView: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            profileViewDetailed: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string"
                },
                banner: {
                  type: "string"
                },
                followersCount: {
                  type: "integer"
                },
                followsCount: {
                  type: "integer"
                },
                postsCount: {
                  type: "integer"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            viewerState: {
              type: "object",
              properties: {
                muted: {
                  type: "boolean"
                },
                mutedByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                blockedBy: {
                  type: "boolean"
                },
                blocking: {
                  type: "string",
                  format: "at-uri"
                },
                blockingByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                following: {
                  type: "string",
                  format: "at-uri"
                },
                followedBy: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            preferences: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.actor.defs#adultContentPref",
                  "lex:app.bsky.actor.defs#contentLabelPref",
                  "lex:app.bsky.actor.defs#savedFeedsPref",
                  "lex:app.bsky.actor.defs#personalDetailsPref",
                  "lex:app.bsky.actor.defs#feedViewPref",
                  "lex:app.bsky.actor.defs#threadViewPref"
                ]
              }
            },
            adultContentPref: {
              type: "object",
              required: ["enabled"],
              properties: {
                enabled: {
                  type: "boolean",
                  default: false
                }
              }
            },
            contentLabelPref: {
              type: "object",
              required: ["label", "visibility"],
              properties: {
                label: {
                  type: "string"
                },
                visibility: {
                  type: "string",
                  knownValues: ["show", "warn", "hide"]
                }
              }
            },
            savedFeedsPref: {
              type: "object",
              required: ["pinned", "saved"],
              properties: {
                pinned: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                },
                saved: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            },
            personalDetailsPref: {
              type: "object",
              properties: {
                birthDate: {
                  type: "string",
                  format: "datetime",
                  description: "The birth date of account owner."
                }
              }
            },
            feedViewPref: {
              type: "object",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  description: "The URI of the feed, or an identifier which describes the feed."
                },
                hideReplies: {
                  type: "boolean",
                  description: "Hide replies in the feed."
                },
                hideRepliesByUnfollowed: {
                  type: "boolean",
                  description: "Hide replies in the feed if they are not by followed users."
                },
                hideRepliesByLikeCount: {
                  type: "integer",
                  description: "Hide replies in the feed if they do not have this number of likes."
                },
                hideReposts: {
                  type: "boolean",
                  description: "Hide reposts in the feed."
                },
                hideQuotePosts: {
                  type: "boolean",
                  description: "Hide quote posts in the feed."
                }
              }
            },
            threadViewPref: {
              type: "object",
              properties: {
                sort: {
                  type: "string",
                  description: "Sorting mode for threads.",
                  knownValues: ["oldest", "newest", "most-likes", "random"]
                },
                prioritizeFollowedUsers: {
                  type: "boolean",
                  description: "Show followed users at the top of all replies."
                }
              }
            }
          }
        },
        AppBskyActorGetPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.getPreferences",
          defs: {
            main: {
              type: "query",
              description: "Get private preferences attached to the account.",
              parameters: {
                type: "params",
                properties: {}
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetProfile: {
          lexicon: 1,
          id: "app.bsky.actor.getProfile",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile view of an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                }
              }
            }
          }
        },
        AppBskyActorGetProfiles: {
          lexicon: 1,
          id: "app.bsky.actor.getProfiles",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile views of multiple actors.",
              parameters: {
                type: "params",
                required: ["actors"],
                properties: {
                  actors: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-identifier"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["profiles"],
                  properties: {
                    profiles: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetSuggestions: {
          lexicon: 1,
          id: "app.bsky.actor.getSuggestions",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested actors, used for discovery.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorProfile: {
          lexicon: 1,
          id: "app.bsky.actor.profile",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a profile.",
              key: "literal:self",
              record: {
                type: "object",
                properties: {
                  displayName: {
                    type: "string",
                    maxGraphemes: 64,
                    maxLength: 640
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 256,
                    maxLength: 2560
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  banner: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  }
                }
              }
            }
          }
        },
        AppBskyActorPutPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.putPreferences",
          defs: {
            main: {
              type: "procedure",
              description: "Set the private preferences attached to the account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActors: {
          lexicon: 1,
          id: "app.bsky.actor.searchActors",
          defs: {
            main: {
              type: "query",
              description: "Find actors (profiles) matching search criteria.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActorsTypeahead: {
          lexicon: 1,
          id: "app.bsky.actor.searchActorsTypeahead",
          defs: {
            main: {
              type: "query",
              description: "Find actor suggestions for a prefix search term.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query prefix; not a full query string."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 10
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyEmbedExternal: {
          lexicon: 1,
          id: "app.bsky.embed.external",
          description: "A representation of some externally linked content, embedded in another form of content.",
          defs: {
            main: {
              type: "object",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#external"
                }
              }
            },
            external: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                }
              }
            },
            view: {
              type: "object",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#viewExternal"
                }
              }
            },
            viewExternal: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyEmbedImages: {
          lexicon: 1,
          id: "app.bsky.embed.images",
          description: "A set of images embedded in some other form of content.",
          defs: {
            main: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#image"
                  },
                  maxLength: 4
                }
              }
            },
            image: {
              type: "object",
              required: ["image", "alt"],
              properties: {
                image: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                },
                alt: {
                  type: "string"
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#aspectRatio"
                }
              }
            },
            aspectRatio: {
              type: "object",
              description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer",
                  minimum: 1
                },
                height: {
                  type: "integer",
                  minimum: 1
                }
              }
            },
            view: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#viewImage"
                  },
                  maxLength: 4
                }
              }
            },
            viewImage: {
              type: "object",
              required: ["thumb", "fullsize", "alt"],
              properties: {
                thumb: {
                  type: "string"
                },
                fullsize: {
                  type: "string"
                },
                alt: {
                  type: "string"
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#aspectRatio"
                }
              }
            }
          }
        },
        AppBskyEmbedRecord: {
          lexicon: 1,
          id: "app.bsky.embed.record",
          description: "A representation of a record embedded in another form of content.",
          defs: {
            main: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            view: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.record#viewRecord",
                    "lex:app.bsky.embed.record#viewNotFound",
                    "lex:app.bsky.embed.record#viewBlocked",
                    "lex:app.bsky.feed.defs#generatorView",
                    "lex:app.bsky.graph.defs#listView"
                  ]
                }
              }
            },
            viewRecord: {
              type: "object",
              required: ["uri", "cid", "author", "value", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                value: {
                  type: "unknown"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                embeds: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images#view",
                      "lex:app.bsky.embed.external#view",
                      "lex:app.bsky.embed.record#view",
                      "lex:app.bsky.embed.recordWithMedia#view"
                    ]
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            viewNotFound: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            viewBlocked: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            }
          }
        },
        AppBskyEmbedRecordWithMedia: {
          lexicon: 1,
          id: "app.bsky.embed.recordWithMedia",
          description: "A representation of a record embedded in another form of content, alongside other compatible embeds.",
          defs: {
            main: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record"
                },
                media: {
                  type: "union",
                  refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
                }
              }
            },
            view: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record#view"
                },
                media: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.external#view"
                  ]
                }
              }
            }
          }
        },
        AppBskyFeedDefs: {
          lexicon: 1,
          id: "app.bsky.feed.defs",
          defs: {
            postView: {
              type: "object",
              required: ["uri", "cid", "author", "record", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                record: {
                  type: "unknown"
                },
                embed: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.external#view",
                    "lex:app.bsky.embed.record#view",
                    "lex:app.bsky.embed.recordWithMedia#view"
                  ]
                },
                replyCount: {
                  type: "integer"
                },
                repostCount: {
                  type: "integer"
                },
                likeCount: {
                  type: "integer"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                threadgate: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#threadgateView"
                }
              }
            },
            viewerState: {
              type: "object",
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                },
                like: {
                  type: "string",
                  format: "at-uri"
                },
                replyDisabled: {
                  type: "boolean"
                }
              }
            },
            feedViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                reply: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#replyRef"
                },
                reason: {
                  type: "union",
                  refs: ["lex:app.bsky.feed.defs#reasonRepost"]
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            },
            reasonRepost: {
              type: "object",
              required: ["by", "indexedAt"],
              properties: {
                by: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            threadViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                replies: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.defs#threadViewPost",
                      "lex:app.bsky.feed.defs#notFoundPost",
                      "lex:app.bsky.feed.defs#blockedPost"
                    ]
                  }
                }
              }
            },
            notFoundPost: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            blockedPost: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            },
            blockedAuthor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                }
              }
            },
            generatorView: {
              type: "object",
              required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                displayName: {
                  type: "string"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            generatorViewerState: {
              type: "object",
              properties: {
                like: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonFeedPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "string",
                  format: "at-uri"
                },
                reason: {
                  type: "union",
                  refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
                }
              }
            },
            skeletonReasonRepost: {
              type: "object",
              required: ["repost"],
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            threadgateView: {
              type: "object",
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listViewBasic"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedDescribeFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.describeFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator, including policies and offered feed URIs.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "feeds"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                      }
                    },
                    links: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                    }
                  }
                }
              }
            },
            feed: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string"
                },
                termsOfService: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.generator",
          defs: {
            main: {
              type: "record",
              description: "A declaration of the existence of a feed generator.",
              key: "any",
              record: {
                type: "object",
                required: ["did", "displayName", "createdAt"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  displayName: {
                    type: "string",
                    maxGraphemes: 24,
                    maxLength: 240
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getActorFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of feeds created by the actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getActorLikes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of posts liked by an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetAuthorFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getAuthorFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a view of an actor's feed.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  filter: {
                    type: "string",
                    knownValues: [
                      "posts_with_replies",
                      "posts_no_replies",
                      "posts_with_media",
                      "posts_and_author_threads"
                    ],
                    default: "posts_with_replies"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a hydrated feed from an actor's selected feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["view", "isOnline", "isValid"],
                  properties: {
                    view: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    },
                    isOnline: {
                      type: "boolean"
                    },
                    isValid: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "Get information about a list of feed generators.",
              parameters: {
                type: "params",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedSkeleton: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Get a skeleton of a feed provided by a feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getLikes",
          defs: {
            main: {
              type: "query",
              description: "Get the list of likes.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "likes"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    likes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.getLikes#like"
                      }
                    }
                  }
                }
              }
            },
            like: {
              type: "object",
              required: ["indexedAt", "createdAt", "actor"],
              properties: {
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                actor: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            }
          }
        },
        AppBskyFeedGetListFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getListFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a view of a recent posts from actors in a list.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownList"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPostThread: {
          lexicon: 1,
          id: "app.bsky.feed.getPostThread",
          defs: {
            main: {
              type: "query",
              description: "Get posts in a thread.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  depth: {
                    type: "integer",
                    default: 6,
                    minimum: 0,
                    maximum: 1e3
                  },
                  parentHeight: {
                    type: "integer",
                    default: 80,
                    minimum: 0,
                    maximum: 1e3
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["thread"],
                  properties: {
                    thread: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.defs#threadViewPost",
                        "lex:app.bsky.feed.defs#notFoundPost",
                        "lex:app.bsky.feed.defs#blockedPost"
                      ]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "NotFound"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPosts: {
          lexicon: 1,
          id: "app.bsky.feed.getPosts",
          defs: {
            main: {
              type: "query",
              description: "Get a view of an actor's feed.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetRepostedBy: {
          lexicon: 1,
          id: "app.bsky.feed.getRepostedBy",
          defs: {
            main: {
              type: "query",
              description: "Get a list of reposts.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "repostedBy"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    repostedBy: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetSuggestedFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getSuggestedFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested feeds for the viewer.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetTimeline: {
          lexicon: 1,
          id: "app.bsky.feed.getTimeline",
          defs: {
            main: {
              type: "query",
              description: "Get a view of the actor's home timeline.",
              parameters: {
                type: "params",
                properties: {
                  algorithm: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedLike: {
          lexicon: 1,
          id: "app.bsky.feed.like",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a like.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedPost: {
          lexicon: 1,
          id: "app.bsky.feed.post",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a post.",
              key: "tid",
              record: {
                type: "object",
                required: ["text", "createdAt"],
                properties: {
                  text: {
                    type: "string",
                    maxLength: 3e3,
                    maxGraphemes: 300
                  },
                  entities: {
                    type: "array",
                    description: "Deprecated: replaced by app.bsky.richtext.facet.",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.post#entity"
                    }
                  },
                  facets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  reply: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.post#replyRef"
                  },
                  embed: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images",
                      "lex:app.bsky.embed.external",
                      "lex:app.bsky.embed.record",
                      "lex:app.bsky.embed.recordWithMedia"
                    ]
                  },
                  langs: {
                    type: "array",
                    maxLength: 3,
                    items: {
                      type: "string",
                      format: "language"
                    }
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  tags: {
                    type: "array",
                    maxLength: 8,
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    },
                    description: "Additional non-inline tags describing this post."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                parent: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            entity: {
              type: "object",
              description: "Deprecated: use facets instead.",
              required: ["index", "type", "value"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#textSlice"
                },
                type: {
                  type: "string",
                  description: "Expected values are 'mention' and 'link'."
                },
                value: {
                  type: "string"
                }
              }
            },
            textSlice: {
              type: "object",
              description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
              required: ["start", "end"],
              properties: {
                start: {
                  type: "integer",
                  minimum: 0
                },
                end: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyFeedRepost: {
          lexicon: 1,
          id: "app.bsky.feed.repost",
          defs: {
            main: {
              description: "A declaration of a repost.",
              type: "record",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedSearchPosts: {
          lexicon: 1,
          id: "app.bsky.feed.searchPosts",
          defs: {
            main: {
              type: "query",
              description: "Find posts matching search criteria.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyFeedThreadgate: {
          lexicon: 1,
          id: "app.bsky.feed.threadgate",
          defs: {
            main: {
              type: "record",
              key: "tid",
              description: "Defines interaction gating rules for a thread. The rkey of the threadgate record should match the rkey of the thread's root post.",
              record: {
                type: "object",
                required: ["post", "createdAt"],
                properties: {
                  post: {
                    type: "string",
                    format: "at-uri"
                  },
                  allow: {
                    type: "array",
                    maxLength: 5,
                    items: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.threadgate#mentionRule",
                        "lex:app.bsky.feed.threadgate#followingRule",
                        "lex:app.bsky.feed.threadgate#listRule"
                      ]
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            },
            mentionRule: {
              type: "object",
              description: "Allow replies from actors mentioned in your post.",
              properties: {}
            },
            followingRule: {
              type: "object",
              description: "Allow replies from actors you follow.",
              properties: {}
            },
            listRule: {
              type: "object",
              description: "Allow replies from actors on a list.",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphBlock: {
          lexicon: 1,
          id: "app.bsky.graph.block",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a block.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphDefs: {
          lexicon: 1,
          id: "app.bsky.graph.defs",
          defs: {
            listViewBasic: {
              type: "object",
              required: ["uri", "cid", "name", "purpose"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listView: {
              type: "object",
              required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listItemView: {
              type: "object",
              required: ["uri", "subject"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            },
            listPurpose: {
              type: "string",
              knownValues: [
                "app.bsky.graph.defs#modlist",
                "app.bsky.graph.defs#curatelist"
              ]
            },
            modlist: {
              type: "token",
              description: "A list of actors to apply an aggregate moderation action (mute/block) on."
            },
            curatelist: {
              type: "token",
              description: "A list of actors used for curation purposes such as list feeds or interaction gating."
            },
            listViewerState: {
              type: "object",
              properties: {
                muted: {
                  type: "boolean"
                },
                blocked: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphFollow: {
          lexicon: 1,
          id: "app.bsky.graph.follow",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a social follow.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor is blocking.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blocks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    blocks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollowers: {
          lexicon: 1,
          id: "app.bsky.graph.getFollowers",
          defs: {
            main: {
              type: "query",
              description: "Get a list of an actor's followers.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "followers"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    followers: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollows: {
          lexicon: 1,
          id: "app.bsky.graph.getFollows",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor follows.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "follows"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    follows: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetList: {
          lexicon: 1,
          id: "app.bsky.graph.getList",
          defs: {
            main: {
              type: "query",
              description: "Get a list of actors.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list", "items"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    list: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    },
                    items: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listItemView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getListBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get lists that the actor is blocking.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getListMutes",
          defs: {
            main: {
              type: "query",
              description: "Get lists that the actor is muting.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetLists: {
          lexicon: 1,
          id: "app.bsky.graph.getLists",
          defs: {
            main: {
              type: "query",
              description: "Get a list of lists that belong to an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getMutes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor mutes.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["mutes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    mutes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetSuggestedFollowsByActor: {
          lexicon: 1,
          id: "app.bsky.graph.getSuggestedFollowsByActor",
          defs: {
            main: {
              type: "query",
              description: "Get suggested follows related to a given actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["suggestions"],
                  properties: {
                    suggestions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphList: {
          lexicon: 1,
          id: "app.bsky.graph.list",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["name", "purpose", "createdAt"],
                properties: {
                  purpose: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listPurpose"
                  },
                  name: {
                    type: "string",
                    maxLength: 64,
                    minLength: 1
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListblock: {
          lexicon: 1,
          id: "app.bsky.graph.listblock",
          defs: {
            main: {
              type: "record",
              description: "A block of an entire list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "at-uri"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListitem: {
          lexicon: 1,
          id: "app.bsky.graph.listitem",
          defs: {
            main: {
              type: "record",
              description: "An item under a declared list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "list", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.muteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Mute an actor by DID or handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.muteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Mute a list of actors.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Unmute an actor by DID or handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Unmute a list of actors.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationGetUnreadCount: {
          lexicon: 1,
          id: "app.bsky.notification.getUnreadCount",
          defs: {
            main: {
              type: "query",
              description: "Get the count of unread notifications.",
              parameters: {
                type: "params",
                properties: {
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["count"],
                  properties: {
                    count: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationListNotifications: {
          lexicon: 1,
          id: "app.bsky.notification.listNotifications",
          defs: {
            main: {
              type: "query",
              description: "Get a list of notifications.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["notifications"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    notifications: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.notification.listNotifications#notification"
                      }
                    },
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            },
            notification: {
              type: "object",
              required: [
                "uri",
                "cid",
                "author",
                "reason",
                "record",
                "isRead",
                "indexedAt"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                reason: {
                  type: "string",
                  description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.",
                  knownValues: [
                    "like",
                    "repost",
                    "follow",
                    "mention",
                    "reply",
                    "quote"
                  ]
                },
                reasonSubject: {
                  type: "string",
                  format: "at-uri"
                },
                record: {
                  type: "unknown"
                },
                isRead: {
                  type: "boolean"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationRegisterPush: {
          lexicon: 1,
          id: "app.bsky.notification.registerPush",
          defs: {
            main: {
              type: "procedure",
              description: "Register for push notifications with a service.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["serviceDid", "token", "platform", "appId"],
                  properties: {
                    serviceDid: {
                      type: "string",
                      format: "did"
                    },
                    token: {
                      type: "string"
                    },
                    platform: {
                      type: "string",
                      knownValues: ["ios", "android", "web"]
                    },
                    appId: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationUpdateSeen: {
          lexicon: 1,
          id: "app.bsky.notification.updateSeen",
          defs: {
            main: {
              type: "procedure",
              description: "Notify server that the user has seen notifications.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["seenAt"],
                  properties: {
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyRichtextFacet: {
          lexicon: 1,
          id: "app.bsky.richtext.facet",
          defs: {
            main: {
              type: "object",
              required: ["index", "features"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet#byteSlice"
                },
                features: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.richtext.facet#mention",
                      "lex:app.bsky.richtext.facet#link",
                      "lex:app.bsky.richtext.facet#tag"
                    ]
                  }
                }
              }
            },
            mention: {
              type: "object",
              description: "A facet feature for actor mentions.",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            link: {
              type: "object",
              description: "A facet feature for links.",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            tag: {
              type: "object",
              description: "A hashtag.",
              required: ["tag"],
              properties: {
                tag: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              }
            },
            byteSlice: {
              type: "object",
              description: "A text segment. Start is inclusive, end is exclusive. Indices are for utf8-encoded strings.",
              required: ["byteStart", "byteEnd"],
              properties: {
                byteStart: {
                  type: "integer",
                  minimum: 0
                },
                byteEnd: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyUnspeccedDefs: {
          lexicon: 1,
          id: "app.bsky.unspecced.defs",
          defs: {
            skeletonSearchPost: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonSearchActor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetPopular: {
          lexicon: 1,
          id: "app.bsky.unspecced.getPopular",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED: will be removed soon. Use a feed generator alternative.",
              parameters: {
                type: "params",
                properties: {
                  includeNsfw: {
                    type: "boolean",
                    default: false
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetPopularFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.unspecced.getPopularFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "An unspecced view of globally popular feed generators.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  query: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetTimelineSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.getTimelineSkeleton",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED: a skeleton of a timeline. Unspecced and will be unavailable soon.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchActorsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchActorsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Actors (profile) search, returns only skeleton.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
                  },
                  typeahead: {
                    type: "boolean",
                    description: "If true, acts as fast/simple 'typeahead' query."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchPostsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchPostsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Posts search, returns only skeleton",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        }
      };
      var schemas = Object.values(schemaDict);
      var lexicons = new Lexicons(schemas);
      var deleteAccount_exports = {};
      __export(deleteAccount_exports, {
        toKnownErr: () => toKnownErr
      });
      function toKnownErr(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var disableAccountInvites_exports = {};
      __export(disableAccountInvites_exports, {
        toKnownErr: () => toKnownErr2
      });
      function toKnownErr2(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var disableInviteCodes_exports = {};
      __export(disableInviteCodes_exports, {
        toKnownErr: () => toKnownErr3
      });
      function toKnownErr3(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var emitModerationEvent_exports = {};
      __export(emitModerationEvent_exports, {
        SubjectHasActionError: () => SubjectHasActionError,
        toKnownErr: () => toKnownErr4
      });
      var SubjectHasActionError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr4(e) {
        if (e instanceof XRPCError) {
          if (e.error === "SubjectHasAction")
            return new SubjectHasActionError(e);
        }
        return e;
      }
      var enableAccountInvites_exports = {};
      __export(enableAccountInvites_exports, {
        toKnownErr: () => toKnownErr5
      });
      function toKnownErr5(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getAccountInfo_exports = {};
      __export(getAccountInfo_exports, {
        toKnownErr: () => toKnownErr6
      });
      function toKnownErr6(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getInviteCodes_exports = {};
      __export(getInviteCodes_exports, {
        toKnownErr: () => toKnownErr7
      });
      function toKnownErr7(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getModerationEvent_exports = {};
      __export(getModerationEvent_exports, {
        toKnownErr: () => toKnownErr8
      });
      function toKnownErr8(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRecord_exports = {};
      __export(getRecord_exports, {
        RecordNotFoundError: () => RecordNotFoundError,
        toKnownErr: () => toKnownErr9
      });
      var RecordNotFoundError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr9(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RecordNotFound")
            return new RecordNotFoundError(e);
        }
        return e;
      }
      var getRepo_exports = {};
      __export(getRepo_exports, {
        RepoNotFoundError: () => RepoNotFoundError,
        toKnownErr: () => toKnownErr10
      });
      var RepoNotFoundError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr10(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RepoNotFound")
            return new RepoNotFoundError(e);
        }
        return e;
      }
      var getSubjectStatus_exports = {};
      __export(getSubjectStatus_exports, {
        toKnownErr: () => toKnownErr11
      });
      function toKnownErr11(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryModerationEvents_exports = {};
      __export(queryModerationEvents_exports, {
        toKnownErr: () => toKnownErr12
      });
      function toKnownErr12(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryModerationStatuses_exports = {};
      __export(queryModerationStatuses_exports, {
        toKnownErr: () => toKnownErr13
      });
      function toKnownErr13(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchRepos_exports = {};
      __export(searchRepos_exports, {
        toKnownErr: () => toKnownErr14
      });
      function toKnownErr14(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var sendEmail_exports = {};
      __export(sendEmail_exports, {
        toKnownErr: () => toKnownErr15
      });
      function toKnownErr15(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateAccountEmail_exports = {};
      __export(updateAccountEmail_exports, {
        toKnownErr: () => toKnownErr16
      });
      function toKnownErr16(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateAccountHandle_exports = {};
      __export(updateAccountHandle_exports, {
        toKnownErr: () => toKnownErr17
      });
      function toKnownErr17(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateSubjectStatus_exports = {};
      __export(updateSubjectStatus_exports, {
        toKnownErr: () => toKnownErr18
      });
      function toKnownErr18(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var resolveHandle_exports = {};
      __export(resolveHandle_exports, {
        toKnownErr: () => toKnownErr19
      });
      function toKnownErr19(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateHandle_exports = {};
      __export(updateHandle_exports, {
        toKnownErr: () => toKnownErr20
      });
      function toKnownErr20(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryLabels_exports = {};
      __export(queryLabels_exports, {
        toKnownErr: () => toKnownErr21
      });
      function toKnownErr21(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var createReport_exports = {};
      __export(createReport_exports, {
        toKnownErr: () => toKnownErr22
      });
      function toKnownErr22(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var applyWrites_exports = {};
      __export(applyWrites_exports, {
        InvalidSwapError: () => InvalidSwapError,
        isCreate: () => isCreate,
        isDelete: () => isDelete,
        isUpdate: () => isUpdate,
        toKnownErr: () => toKnownErr23,
        validateCreate: () => validateCreate,
        validateDelete: () => validateDelete,
        validateUpdate: () => validateUpdate
      });
      function isObj2(v) {
        return typeof v === "object" && v !== null;
      }
      function hasProp2(data, prop) {
        return prop in data;
      }
      var InvalidSwapError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr23(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError(e);
        }
        return e;
      }
      function isCreate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#create";
      }
      function validateCreate(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#create", v);
      }
      function isUpdate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#update";
      }
      function validateUpdate(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#update", v);
      }
      function isDelete(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#delete";
      }
      function validateDelete(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#delete", v);
      }
      var createRecord_exports = {};
      __export(createRecord_exports, {
        InvalidSwapError: () => InvalidSwapError2,
        toKnownErr: () => toKnownErr24
      });
      var InvalidSwapError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr24(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError2(e);
        }
        return e;
      }
      var deleteRecord_exports = {};
      __export(deleteRecord_exports, {
        InvalidSwapError: () => InvalidSwapError3,
        toKnownErr: () => toKnownErr25
      });
      var InvalidSwapError3 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr25(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError3(e);
        }
        return e;
      }
      var describeRepo_exports = {};
      __export(describeRepo_exports, {
        toKnownErr: () => toKnownErr26
      });
      function toKnownErr26(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRecord_exports2 = {};
      __export(getRecord_exports2, {
        toKnownErr: () => toKnownErr27
      });
      function toKnownErr27(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listRecords_exports = {};
      __export(listRecords_exports, {
        isRecord: () => isRecord,
        toKnownErr: () => toKnownErr28,
        validateRecord: () => validateRecord
      });
      function toKnownErr28(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isRecord(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.listRecords#record";
      }
      function validateRecord(v) {
        return lexicons.validate("com.atproto.repo.listRecords#record", v);
      }
      var putRecord_exports = {};
      __export(putRecord_exports, {
        InvalidSwapError: () => InvalidSwapError4,
        toKnownErr: () => toKnownErr29
      });
      var InvalidSwapError4 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr29(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError4(e);
        }
        return e;
      }
      var uploadBlob_exports = {};
      __export(uploadBlob_exports, {
        toKnownErr: () => toKnownErr30
      });
      function toKnownErr30(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var confirmEmail_exports = {};
      __export(confirmEmail_exports, {
        AccountNotFoundError: () => AccountNotFoundError,
        ExpiredTokenError: () => ExpiredTokenError,
        InvalidEmailError: () => InvalidEmailError,
        InvalidTokenError: () => InvalidTokenError,
        toKnownErr: () => toKnownErr31
      });
      var AccountNotFoundError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var ExpiredTokenError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidTokenError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidEmailError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr31(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountNotFound")
            return new AccountNotFoundError(e);
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError(e);
          if (e.error === "InvalidEmail")
            return new InvalidEmailError(e);
        }
        return e;
      }
      var createAccount_exports = {};
      __export(createAccount_exports, {
        HandleNotAvailableError: () => HandleNotAvailableError,
        IncompatibleDidDocError: () => IncompatibleDidDocError,
        InvalidHandleError: () => InvalidHandleError2,
        InvalidInviteCodeError: () => InvalidInviteCodeError,
        InvalidPasswordError: () => InvalidPasswordError,
        UnresolvableDidError: () => UnresolvableDidError,
        UnsupportedDomainError: () => UnsupportedDomainError,
        toKnownErr: () => toKnownErr32
      });
      var InvalidHandleError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidPasswordError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidInviteCodeError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var HandleNotAvailableError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var UnsupportedDomainError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var UnresolvableDidError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var IncompatibleDidDocError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr32(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidHandle")
            return new InvalidHandleError2(e);
          if (e.error === "InvalidPassword")
            return new InvalidPasswordError(e);
          if (e.error === "InvalidInviteCode")
            return new InvalidInviteCodeError(e);
          if (e.error === "HandleNotAvailable")
            return new HandleNotAvailableError(e);
          if (e.error === "UnsupportedDomain")
            return new UnsupportedDomainError(e);
          if (e.error === "UnresolvableDid")
            return new UnresolvableDidError(e);
          if (e.error === "IncompatibleDidDoc")
            return new IncompatibleDidDocError(e);
        }
        return e;
      }
      var createAppPassword_exports = {};
      __export(createAppPassword_exports, {
        AccountTakedownError: () => AccountTakedownError,
        isAppPassword: () => isAppPassword,
        toKnownErr: () => toKnownErr33,
        validateAppPassword: () => validateAppPassword
      });
      var AccountTakedownError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr33(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError(e);
        }
        return e;
      }
      function isAppPassword(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.createAppPassword#appPassword";
      }
      function validateAppPassword(v) {
        return lexicons.validate("com.atproto.server.createAppPassword#appPassword", v);
      }
      var createInviteCode_exports = {};
      __export(createInviteCode_exports, {
        toKnownErr: () => toKnownErr34
      });
      function toKnownErr34(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var createInviteCodes_exports = {};
      __export(createInviteCodes_exports, {
        isAccountCodes: () => isAccountCodes,
        toKnownErr: () => toKnownErr35,
        validateAccountCodes: () => validateAccountCodes
      });
      function toKnownErr35(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isAccountCodes(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.createInviteCodes#accountCodes";
      }
      function validateAccountCodes(v) {
        return lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", v);
      }
      var createSession_exports = {};
      __export(createSession_exports, {
        AccountTakedownError: () => AccountTakedownError2,
        toKnownErr: () => toKnownErr36
      });
      var AccountTakedownError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr36(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError2(e);
        }
        return e;
      }
      var deleteAccount_exports2 = {};
      __export(deleteAccount_exports2, {
        ExpiredTokenError: () => ExpiredTokenError2,
        InvalidTokenError: () => InvalidTokenError2,
        toKnownErr: () => toKnownErr37
      });
      var ExpiredTokenError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidTokenError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr37(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError2(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError2(e);
        }
        return e;
      }
      var deleteSession_exports = {};
      __export(deleteSession_exports, {
        toKnownErr: () => toKnownErr38
      });
      function toKnownErr38(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var describeServer_exports = {};
      __export(describeServer_exports, {
        isLinks: () => isLinks,
        toKnownErr: () => toKnownErr39,
        validateLinks: () => validateLinks
      });
      function toKnownErr39(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isLinks(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.describeServer#links";
      }
      function validateLinks(v) {
        return lexicons.validate("com.atproto.server.describeServer#links", v);
      }
      var getAccountInviteCodes_exports = {};
      __export(getAccountInviteCodes_exports, {
        DuplicateCreateError: () => DuplicateCreateError,
        toKnownErr: () => toKnownErr40
      });
      var DuplicateCreateError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr40(e) {
        if (e instanceof XRPCError) {
          if (e.error === "DuplicateCreate")
            return new DuplicateCreateError(e);
        }
        return e;
      }
      var getSession_exports = {};
      __export(getSession_exports, {
        toKnownErr: () => toKnownErr41
      });
      function toKnownErr41(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listAppPasswords_exports = {};
      __export(listAppPasswords_exports, {
        AccountTakedownError: () => AccountTakedownError3,
        isAppPassword: () => isAppPassword2,
        toKnownErr: () => toKnownErr42,
        validateAppPassword: () => validateAppPassword2
      });
      var AccountTakedownError3 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr42(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError3(e);
        }
        return e;
      }
      function isAppPassword2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.listAppPasswords#appPassword";
      }
      function validateAppPassword2(v) {
        return lexicons.validate("com.atproto.server.listAppPasswords#appPassword", v);
      }
      var refreshSession_exports = {};
      __export(refreshSession_exports, {
        AccountTakedownError: () => AccountTakedownError4,
        toKnownErr: () => toKnownErr43
      });
      var AccountTakedownError4 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr43(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError4(e);
        }
        return e;
      }
      var requestAccountDelete_exports = {};
      __export(requestAccountDelete_exports, {
        toKnownErr: () => toKnownErr44
      });
      function toKnownErr44(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestEmailConfirmation_exports = {};
      __export(requestEmailConfirmation_exports, {
        toKnownErr: () => toKnownErr45
      });
      function toKnownErr45(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestEmailUpdate_exports = {};
      __export(requestEmailUpdate_exports, {
        toKnownErr: () => toKnownErr46
      });
      function toKnownErr46(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestPasswordReset_exports = {};
      __export(requestPasswordReset_exports, {
        toKnownErr: () => toKnownErr47
      });
      function toKnownErr47(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var reserveSigningKey_exports = {};
      __export(reserveSigningKey_exports, {
        toKnownErr: () => toKnownErr48
      });
      function toKnownErr48(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var resetPassword_exports = {};
      __export(resetPassword_exports, {
        ExpiredTokenError: () => ExpiredTokenError3,
        InvalidTokenError: () => InvalidTokenError3,
        toKnownErr: () => toKnownErr49
      });
      var ExpiredTokenError3 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidTokenError3 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr49(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError3(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError3(e);
        }
        return e;
      }
      var revokeAppPassword_exports = {};
      __export(revokeAppPassword_exports, {
        toKnownErr: () => toKnownErr50
      });
      function toKnownErr50(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateEmail_exports = {};
      __export(updateEmail_exports, {
        ExpiredTokenError: () => ExpiredTokenError4,
        InvalidTokenError: () => InvalidTokenError4,
        TokenRequiredError: () => TokenRequiredError,
        toKnownErr: () => toKnownErr51
      });
      var ExpiredTokenError4 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidTokenError4 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var TokenRequiredError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr51(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError4(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError4(e);
          if (e.error === "TokenRequired")
            return new TokenRequiredError(e);
        }
        return e;
      }
      var getBlob_exports = {};
      __export(getBlob_exports, {
        toKnownErr: () => toKnownErr52
      });
      function toKnownErr52(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getBlocks_exports = {};
      __export(getBlocks_exports, {
        toKnownErr: () => toKnownErr53
      });
      function toKnownErr53(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getCheckout_exports = {};
      __export(getCheckout_exports, {
        toKnownErr: () => toKnownErr54
      });
      function toKnownErr54(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getHead_exports = {};
      __export(getHead_exports, {
        HeadNotFoundError: () => HeadNotFoundError,
        toKnownErr: () => toKnownErr55
      });
      var HeadNotFoundError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr55(e) {
        if (e instanceof XRPCError) {
          if (e.error === "HeadNotFound")
            return new HeadNotFoundError(e);
        }
        return e;
      }
      var getLatestCommit_exports = {};
      __export(getLatestCommit_exports, {
        RepoNotFoundError: () => RepoNotFoundError2,
        toKnownErr: () => toKnownErr56
      });
      var RepoNotFoundError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr56(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RepoNotFound")
            return new RepoNotFoundError2(e);
        }
        return e;
      }
      var getRecord_exports3 = {};
      __export(getRecord_exports3, {
        toKnownErr: () => toKnownErr57
      });
      function toKnownErr57(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRepo_exports2 = {};
      __export(getRepo_exports2, {
        toKnownErr: () => toKnownErr58
      });
      function toKnownErr58(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listBlobs_exports = {};
      __export(listBlobs_exports, {
        toKnownErr: () => toKnownErr59
      });
      function toKnownErr59(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listRepos_exports = {};
      __export(listRepos_exports, {
        isRepo: () => isRepo,
        toKnownErr: () => toKnownErr60,
        validateRepo: () => validateRepo
      });
      function toKnownErr60(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isRepo(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.listRepos#repo";
      }
      function validateRepo(v) {
        return lexicons.validate("com.atproto.sync.listRepos#repo", v);
      }
      var notifyOfUpdate_exports = {};
      __export(notifyOfUpdate_exports, {
        toKnownErr: () => toKnownErr61
      });
      function toKnownErr61(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestCrawl_exports = {};
      __export(requestCrawl_exports, {
        toKnownErr: () => toKnownErr62
      });
      function toKnownErr62(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var fetchLabels_exports = {};
      __export(fetchLabels_exports, {
        toKnownErr: () => toKnownErr63
      });
      function toKnownErr63(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var importRepo_exports = {};
      __export(importRepo_exports, {
        toKnownErr: () => toKnownErr64
      });
      function toKnownErr64(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var pushBlob_exports = {};
      __export(pushBlob_exports, {
        toKnownErr: () => toKnownErr65
      });
      function toKnownErr65(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var transferAccount_exports = {};
      __export(transferAccount_exports, {
        HandleNotAvailableError: () => HandleNotAvailableError2,
        IncompatibleDidDocError: () => IncompatibleDidDocError2,
        InvalidHandleError: () => InvalidHandleError3,
        InvalidInviteCodeError: () => InvalidInviteCodeError2,
        InvalidPasswordError: () => InvalidPasswordError2,
        UnresolvableDidError: () => UnresolvableDidError2,
        UnsupportedDomainError: () => UnsupportedDomainError2,
        toKnownErr: () => toKnownErr66
      });
      var InvalidHandleError3 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidPasswordError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var InvalidInviteCodeError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var HandleNotAvailableError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var UnsupportedDomainError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var UnresolvableDidError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var IncompatibleDidDocError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr66(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidHandle")
            return new InvalidHandleError3(e);
          if (e.error === "InvalidPassword")
            return new InvalidPasswordError2(e);
          if (e.error === "InvalidInviteCode")
            return new InvalidInviteCodeError2(e);
          if (e.error === "HandleNotAvailable")
            return new HandleNotAvailableError2(e);
          if (e.error === "UnsupportedDomain")
            return new UnsupportedDomainError2(e);
          if (e.error === "UnresolvableDid")
            return new UnresolvableDidError2(e);
          if (e.error === "IncompatibleDidDoc")
            return new IncompatibleDidDocError2(e);
        }
        return e;
      }
      var getPreferences_exports = {};
      __export(getPreferences_exports, {
        toKnownErr: () => toKnownErr67
      });
      function toKnownErr67(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getProfile_exports = {};
      __export(getProfile_exports, {
        toKnownErr: () => toKnownErr68
      });
      function toKnownErr68(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getProfiles_exports = {};
      __export(getProfiles_exports, {
        toKnownErr: () => toKnownErr69
      });
      function toKnownErr69(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestions_exports = {};
      __export(getSuggestions_exports, {
        toKnownErr: () => toKnownErr70
      });
      function toKnownErr70(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var putPreferences_exports = {};
      __export(putPreferences_exports, {
        toKnownErr: () => toKnownErr71
      });
      function toKnownErr71(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchActors_exports = {};
      __export(searchActors_exports, {
        toKnownErr: () => toKnownErr72
      });
      function toKnownErr72(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchActorsTypeahead_exports = {};
      __export(searchActorsTypeahead_exports, {
        toKnownErr: () => toKnownErr73
      });
      function toKnownErr73(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var describeFeedGenerator_exports = {};
      __export(describeFeedGenerator_exports, {
        isFeed: () => isFeed,
        isLinks: () => isLinks2,
        toKnownErr: () => toKnownErr74,
        validateFeed: () => validateFeed,
        validateLinks: () => validateLinks2
      });
      function toKnownErr74(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isFeed(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.describeFeedGenerator#feed";
      }
      function validateFeed(v) {
        return lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", v);
      }
      function isLinks2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.describeFeedGenerator#links";
      }
      function validateLinks2(v) {
        return lexicons.validate("app.bsky.feed.describeFeedGenerator#links", v);
      }
      var getActorFeeds_exports = {};
      __export(getActorFeeds_exports, {
        toKnownErr: () => toKnownErr75
      });
      function toKnownErr75(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getActorLikes_exports = {};
      __export(getActorLikes_exports, {
        BlockedActorError: () => BlockedActorError,
        BlockedByActorError: () => BlockedByActorError,
        toKnownErr: () => toKnownErr76
      });
      var BlockedActorError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var BlockedByActorError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr76(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BlockedActor")
            return new BlockedActorError(e);
          if (e.error === "BlockedByActor")
            return new BlockedByActorError(e);
        }
        return e;
      }
      var getAuthorFeed_exports = {};
      __export(getAuthorFeed_exports, {
        BlockedActorError: () => BlockedActorError2,
        BlockedByActorError: () => BlockedByActorError2,
        toKnownErr: () => toKnownErr77
      });
      var BlockedActorError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      var BlockedByActorError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr77(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BlockedActor")
            return new BlockedActorError2(e);
          if (e.error === "BlockedByActor")
            return new BlockedByActorError2(e);
        }
        return e;
      }
      var getFeed_exports = {};
      __export(getFeed_exports, {
        UnknownFeedError: () => UnknownFeedError,
        toKnownErr: () => toKnownErr78
      });
      var UnknownFeedError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr78(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError(e);
        }
        return e;
      }
      var getFeedGenerator_exports = {};
      __export(getFeedGenerator_exports, {
        toKnownErr: () => toKnownErr79
      });
      function toKnownErr79(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFeedGenerators_exports = {};
      __export(getFeedGenerators_exports, {
        toKnownErr: () => toKnownErr80
      });
      function toKnownErr80(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFeedSkeleton_exports = {};
      __export(getFeedSkeleton_exports, {
        UnknownFeedError: () => UnknownFeedError2,
        toKnownErr: () => toKnownErr81
      });
      var UnknownFeedError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr81(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError2(e);
        }
        return e;
      }
      var getLikes_exports = {};
      __export(getLikes_exports, {
        isLike: () => isLike,
        toKnownErr: () => toKnownErr82,
        validateLike: () => validateLike
      });
      function toKnownErr82(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isLike(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.getLikes#like";
      }
      function validateLike(v) {
        return lexicons.validate("app.bsky.feed.getLikes#like", v);
      }
      var getListFeed_exports = {};
      __export(getListFeed_exports, {
        UnknownListError: () => UnknownListError,
        toKnownErr: () => toKnownErr83
      });
      var UnknownListError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr83(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownList")
            return new UnknownListError(e);
        }
        return e;
      }
      var getPostThread_exports = {};
      __export(getPostThread_exports, {
        NotFoundError: () => NotFoundError,
        toKnownErr: () => toKnownErr84
      });
      var NotFoundError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr84(e) {
        if (e instanceof XRPCError) {
          if (e.error === "NotFound")
            return new NotFoundError(e);
        }
        return e;
      }
      var getPosts_exports = {};
      __export(getPosts_exports, {
        toKnownErr: () => toKnownErr85
      });
      function toKnownErr85(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRepostedBy_exports = {};
      __export(getRepostedBy_exports, {
        toKnownErr: () => toKnownErr86
      });
      function toKnownErr86(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestedFeeds_exports = {};
      __export(getSuggestedFeeds_exports, {
        toKnownErr: () => toKnownErr87
      });
      function toKnownErr87(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getTimeline_exports = {};
      __export(getTimeline_exports, {
        toKnownErr: () => toKnownErr88
      });
      function toKnownErr88(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchPosts_exports = {};
      __export(searchPosts_exports, {
        BadQueryStringError: () => BadQueryStringError,
        toKnownErr: () => toKnownErr89
      });
      var BadQueryStringError = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr89(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError(e);
        }
        return e;
      }
      var getBlocks_exports2 = {};
      __export(getBlocks_exports2, {
        toKnownErr: () => toKnownErr90
      });
      function toKnownErr90(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFollowers_exports = {};
      __export(getFollowers_exports, {
        toKnownErr: () => toKnownErr91
      });
      function toKnownErr91(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFollows_exports = {};
      __export(getFollows_exports, {
        toKnownErr: () => toKnownErr92
      });
      function toKnownErr92(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getList_exports = {};
      __export(getList_exports, {
        toKnownErr: () => toKnownErr93
      });
      function toKnownErr93(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getListBlocks_exports = {};
      __export(getListBlocks_exports, {
        toKnownErr: () => toKnownErr94
      });
      function toKnownErr94(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getListMutes_exports = {};
      __export(getListMutes_exports, {
        toKnownErr: () => toKnownErr95
      });
      function toKnownErr95(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getLists_exports = {};
      __export(getLists_exports, {
        toKnownErr: () => toKnownErr96
      });
      function toKnownErr96(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getMutes_exports = {};
      __export(getMutes_exports, {
        toKnownErr: () => toKnownErr97
      });
      function toKnownErr97(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestedFollowsByActor_exports = {};
      __export(getSuggestedFollowsByActor_exports, {
        toKnownErr: () => toKnownErr98
      });
      function toKnownErr98(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var muteActor_exports = {};
      __export(muteActor_exports, {
        toKnownErr: () => toKnownErr99
      });
      function toKnownErr99(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var muteActorList_exports = {};
      __export(muteActorList_exports, {
        toKnownErr: () => toKnownErr100
      });
      function toKnownErr100(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var unmuteActor_exports = {};
      __export(unmuteActor_exports, {
        toKnownErr: () => toKnownErr101
      });
      function toKnownErr101(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var unmuteActorList_exports = {};
      __export(unmuteActorList_exports, {
        toKnownErr: () => toKnownErr102
      });
      function toKnownErr102(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getUnreadCount_exports = {};
      __export(getUnreadCount_exports, {
        toKnownErr: () => toKnownErr103
      });
      function toKnownErr103(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listNotifications_exports = {};
      __export(listNotifications_exports, {
        isNotification: () => isNotification,
        toKnownErr: () => toKnownErr104,
        validateNotification: () => validateNotification
      });
      function toKnownErr104(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isNotification(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.notification.listNotifications#notification";
      }
      function validateNotification(v) {
        return lexicons.validate("app.bsky.notification.listNotifications#notification", v);
      }
      var registerPush_exports = {};
      __export(registerPush_exports, {
        toKnownErr: () => toKnownErr105
      });
      function toKnownErr105(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateSeen_exports = {};
      __export(updateSeen_exports, {
        toKnownErr: () => toKnownErr106
      });
      function toKnownErr106(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getPopular_exports = {};
      __export(getPopular_exports, {
        toKnownErr: () => toKnownErr107
      });
      function toKnownErr107(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getPopularFeedGenerators_exports = {};
      __export(getPopularFeedGenerators_exports, {
        toKnownErr: () => toKnownErr108
      });
      function toKnownErr108(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getTimelineSkeleton_exports = {};
      __export(getTimelineSkeleton_exports, {
        UnknownFeedError: () => UnknownFeedError3,
        toKnownErr: () => toKnownErr109
      });
      var UnknownFeedError3 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr109(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError3(e);
        }
        return e;
      }
      var searchActorsSkeleton_exports = {};
      __export(searchActorsSkeleton_exports, {
        BadQueryStringError: () => BadQueryStringError2,
        toKnownErr: () => toKnownErr110
      });
      var BadQueryStringError2 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr110(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError2(e);
        }
        return e;
      }
      var searchPostsSkeleton_exports = {};
      __export(searchPostsSkeleton_exports, {
        BadQueryStringError: () => BadQueryStringError3,
        toKnownErr: () => toKnownErr111
      });
      var BadQueryStringError3 = class extends XRPCError {
        constructor(src2) {
          super(src2.status, src2.error, src2.message, src2.headers);
        }
      };
      function toKnownErr111(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError3(e);
        }
        return e;
      }
      var defs_exports = {};
      __export(defs_exports, {
        REVIEWCLOSED: () => REVIEWCLOSED,
        REVIEWESCALATED: () => REVIEWESCALATED,
        REVIEWOPEN: () => REVIEWOPEN,
        isAccountView: () => isAccountView,
        isBlobView: () => isBlobView,
        isImageDetails: () => isImageDetails,
        isModEventAcknowledge: () => isModEventAcknowledge,
        isModEventComment: () => isModEventComment,
        isModEventEmail: () => isModEventEmail,
        isModEventEscalate: () => isModEventEscalate,
        isModEventLabel: () => isModEventLabel,
        isModEventMute: () => isModEventMute,
        isModEventReport: () => isModEventReport,
        isModEventResolveAppeal: () => isModEventResolveAppeal,
        isModEventReverseTakedown: () => isModEventReverseTakedown,
        isModEventTakedown: () => isModEventTakedown,
        isModEventUnmute: () => isModEventUnmute,
        isModEventView: () => isModEventView,
        isModEventViewDetail: () => isModEventViewDetail,
        isModeration: () => isModeration,
        isModerationDetail: () => isModerationDetail,
        isRecordView: () => isRecordView,
        isRecordViewDetail: () => isRecordViewDetail,
        isRecordViewNotFound: () => isRecordViewNotFound,
        isRepoBlobRef: () => isRepoBlobRef,
        isRepoRef: () => isRepoRef,
        isRepoView: () => isRepoView,
        isRepoViewDetail: () => isRepoViewDetail,
        isRepoViewNotFound: () => isRepoViewNotFound,
        isReportView: () => isReportView,
        isReportViewDetail: () => isReportViewDetail,
        isStatusAttr: () => isStatusAttr,
        isSubjectStatusView: () => isSubjectStatusView,
        isVideoDetails: () => isVideoDetails,
        validateAccountView: () => validateAccountView,
        validateBlobView: () => validateBlobView,
        validateImageDetails: () => validateImageDetails,
        validateModEventAcknowledge: () => validateModEventAcknowledge,
        validateModEventComment: () => validateModEventComment,
        validateModEventEmail: () => validateModEventEmail,
        validateModEventEscalate: () => validateModEventEscalate,
        validateModEventLabel: () => validateModEventLabel,
        validateModEventMute: () => validateModEventMute,
        validateModEventReport: () => validateModEventReport,
        validateModEventResolveAppeal: () => validateModEventResolveAppeal,
        validateModEventReverseTakedown: () => validateModEventReverseTakedown,
        validateModEventTakedown: () => validateModEventTakedown,
        validateModEventUnmute: () => validateModEventUnmute,
        validateModEventView: () => validateModEventView,
        validateModEventViewDetail: () => validateModEventViewDetail,
        validateModeration: () => validateModeration,
        validateModerationDetail: () => validateModerationDetail,
        validateRecordView: () => validateRecordView,
        validateRecordViewDetail: () => validateRecordViewDetail,
        validateRecordViewNotFound: () => validateRecordViewNotFound,
        validateRepoBlobRef: () => validateRepoBlobRef,
        validateRepoRef: () => validateRepoRef,
        validateRepoView: () => validateRepoView,
        validateRepoViewDetail: () => validateRepoViewDetail,
        validateRepoViewNotFound: () => validateRepoViewNotFound,
        validateReportView: () => validateReportView,
        validateReportViewDetail: () => validateReportViewDetail,
        validateStatusAttr: () => validateStatusAttr,
        validateSubjectStatusView: () => validateSubjectStatusView,
        validateVideoDetails: () => validateVideoDetails
      });
      function isStatusAttr(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#statusAttr";
      }
      function validateStatusAttr(v) {
        return lexicons.validate("com.atproto.admin.defs#statusAttr", v);
      }
      function isModEventView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventView";
      }
      function validateModEventView(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventView", v);
      }
      function isModEventViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventViewDetail";
      }
      function validateModEventViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventViewDetail", v);
      }
      function isReportView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#reportView";
      }
      function validateReportView(v) {
        return lexicons.validate("com.atproto.admin.defs#reportView", v);
      }
      function isSubjectStatusView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#subjectStatusView";
      }
      function validateSubjectStatusView(v) {
        return lexicons.validate("com.atproto.admin.defs#subjectStatusView", v);
      }
      function isReportViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#reportViewDetail";
      }
      function validateReportViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#reportViewDetail", v);
      }
      function isRepoView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoView";
      }
      function validateRepoView(v) {
        return lexicons.validate("com.atproto.admin.defs#repoView", v);
      }
      function isRepoViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoViewDetail";
      }
      function validateRepoViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#repoViewDetail", v);
      }
      function isAccountView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#accountView";
      }
      function validateAccountView(v) {
        return lexicons.validate("com.atproto.admin.defs#accountView", v);
      }
      function isRepoViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoViewNotFound";
      }
      function validateRepoViewNotFound(v) {
        return lexicons.validate("com.atproto.admin.defs#repoViewNotFound", v);
      }
      function isRepoRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoRef";
      }
      function validateRepoRef(v) {
        return lexicons.validate("com.atproto.admin.defs#repoRef", v);
      }
      function isRepoBlobRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoBlobRef";
      }
      function validateRepoBlobRef(v) {
        return lexicons.validate("com.atproto.admin.defs#repoBlobRef", v);
      }
      function isRecordView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordView";
      }
      function validateRecordView(v) {
        return lexicons.validate("com.atproto.admin.defs#recordView", v);
      }
      function isRecordViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordViewDetail";
      }
      function validateRecordViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#recordViewDetail", v);
      }
      function isRecordViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordViewNotFound";
      }
      function validateRecordViewNotFound(v) {
        return lexicons.validate("com.atproto.admin.defs#recordViewNotFound", v);
      }
      function isModeration(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#moderation";
      }
      function validateModeration(v) {
        return lexicons.validate("com.atproto.admin.defs#moderation", v);
      }
      function isModerationDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#moderationDetail";
      }
      function validateModerationDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#moderationDetail", v);
      }
      function isBlobView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#blobView";
      }
      function validateBlobView(v) {
        return lexicons.validate("com.atproto.admin.defs#blobView", v);
      }
      function isImageDetails(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#imageDetails";
      }
      function validateImageDetails(v) {
        return lexicons.validate("com.atproto.admin.defs#imageDetails", v);
      }
      function isVideoDetails(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#videoDetails";
      }
      function validateVideoDetails(v) {
        return lexicons.validate("com.atproto.admin.defs#videoDetails", v);
      }
      var REVIEWOPEN = "com.atproto.admin.defs#reviewOpen";
      var REVIEWESCALATED = "com.atproto.admin.defs#reviewEscalated";
      var REVIEWCLOSED = "com.atproto.admin.defs#reviewClosed";
      function isModEventTakedown(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventTakedown";
      }
      function validateModEventTakedown(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventTakedown", v);
      }
      function isModEventReverseTakedown(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventReverseTakedown";
      }
      function validateModEventReverseTakedown(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventReverseTakedown", v);
      }
      function isModEventResolveAppeal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventResolveAppeal";
      }
      function validateModEventResolveAppeal(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventResolveAppeal", v);
      }
      function isModEventComment(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventComment";
      }
      function validateModEventComment(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventComment", v);
      }
      function isModEventReport(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventReport";
      }
      function validateModEventReport(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventReport", v);
      }
      function isModEventLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventLabel";
      }
      function validateModEventLabel(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventLabel", v);
      }
      function isModEventAcknowledge(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventAcknowledge";
      }
      function validateModEventAcknowledge(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventAcknowledge", v);
      }
      function isModEventEscalate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventEscalate";
      }
      function validateModEventEscalate(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventEscalate", v);
      }
      function isModEventMute(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventMute";
      }
      function validateModEventMute(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventMute", v);
      }
      function isModEventUnmute(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventUnmute";
      }
      function validateModEventUnmute(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventUnmute", v);
      }
      function isModEventEmail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventEmail";
      }
      function validateModEventEmail(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventEmail", v);
      }
      var defs_exports2 = {};
      __export(defs_exports2, {
        isLabel: () => isLabel,
        isSelfLabel: () => isSelfLabel,
        isSelfLabels: () => isSelfLabels,
        validateLabel: () => validateLabel,
        validateSelfLabel: () => validateSelfLabel,
        validateSelfLabels: () => validateSelfLabels
      });
      function isLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#label";
      }
      function validateLabel(v) {
        return lexicons.validate("com.atproto.label.defs#label", v);
      }
      function isSelfLabels(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#selfLabels";
      }
      function validateSelfLabels(v) {
        return lexicons.validate("com.atproto.label.defs#selfLabels", v);
      }
      function isSelfLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#selfLabel";
      }
      function validateSelfLabel(v) {
        return lexicons.validate("com.atproto.label.defs#selfLabel", v);
      }
      var subscribeLabels_exports = {};
      __export(subscribeLabels_exports, {
        isInfo: () => isInfo,
        isLabels: () => isLabels,
        validateInfo: () => validateInfo,
        validateLabels: () => validateLabels
      });
      function isLabels(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.subscribeLabels#labels";
      }
      function validateLabels(v) {
        return lexicons.validate("com.atproto.label.subscribeLabels#labels", v);
      }
      function isInfo(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.subscribeLabels#info";
      }
      function validateInfo(v) {
        return lexicons.validate("com.atproto.label.subscribeLabels#info", v);
      }
      var defs_exports3 = {};
      __export(defs_exports3, {
        REASONAPPEAL: () => REASONAPPEAL,
        REASONMISLEADING: () => REASONMISLEADING,
        REASONOTHER: () => REASONOTHER,
        REASONRUDE: () => REASONRUDE,
        REASONSEXUAL: () => REASONSEXUAL,
        REASONSPAM: () => REASONSPAM,
        REASONVIOLATION: () => REASONVIOLATION
      });
      var REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
      var REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
      var REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
      var REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
      var REASONRUDE = "com.atproto.moderation.defs#reasonRude";
      var REASONOTHER = "com.atproto.moderation.defs#reasonOther";
      var REASONAPPEAL = "com.atproto.moderation.defs#reasonAppeal";
      var strongRef_exports = {};
      __export(strongRef_exports, {
        isMain: () => isMain,
        validateMain: () => validateMain
      });
      function isMain(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "com.atproto.repo.strongRef#main" || v.$type === "com.atproto.repo.strongRef");
      }
      function validateMain(v) {
        return lexicons.validate("com.atproto.repo.strongRef#main", v);
      }
      var defs_exports4 = {};
      __export(defs_exports4, {
        isInviteCode: () => isInviteCode,
        isInviteCodeUse: () => isInviteCodeUse,
        validateInviteCode: () => validateInviteCode,
        validateInviteCodeUse: () => validateInviteCodeUse
      });
      function isInviteCode(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.defs#inviteCode";
      }
      function validateInviteCode(v) {
        return lexicons.validate("com.atproto.server.defs#inviteCode", v);
      }
      function isInviteCodeUse(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.defs#inviteCodeUse";
      }
      function validateInviteCodeUse(v) {
        return lexicons.validate("com.atproto.server.defs#inviteCodeUse", v);
      }
      var subscribeRepos_exports = {};
      __export(subscribeRepos_exports, {
        isCommit: () => isCommit,
        isHandle: () => isHandle,
        isInfo: () => isInfo2,
        isMigrate: () => isMigrate,
        isRepoOp: () => isRepoOp,
        isTombstone: () => isTombstone,
        validateCommit: () => validateCommit,
        validateHandle: () => validateHandle,
        validateInfo: () => validateInfo2,
        validateMigrate: () => validateMigrate,
        validateRepoOp: () => validateRepoOp,
        validateTombstone: () => validateTombstone
      });
      function isCommit(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#commit";
      }
      function validateCommit(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#commit", v);
      }
      function isHandle(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#handle";
      }
      function validateHandle(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#handle", v);
      }
      function isMigrate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#migrate";
      }
      function validateMigrate(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#migrate", v);
      }
      function isTombstone(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#tombstone";
      }
      function validateTombstone(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", v);
      }
      function isInfo2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#info";
      }
      function validateInfo2(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#info", v);
      }
      function isRepoOp(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#repoOp";
      }
      function validateRepoOp(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", v);
      }
      var defs_exports5 = {};
      __export(defs_exports5, {
        isAdultContentPref: () => isAdultContentPref,
        isContentLabelPref: () => isContentLabelPref,
        isFeedViewPref: () => isFeedViewPref,
        isPersonalDetailsPref: () => isPersonalDetailsPref,
        isProfileView: () => isProfileView,
        isProfileViewBasic: () => isProfileViewBasic,
        isProfileViewDetailed: () => isProfileViewDetailed,
        isSavedFeedsPref: () => isSavedFeedsPref,
        isThreadViewPref: () => isThreadViewPref,
        isViewerState: () => isViewerState,
        validateAdultContentPref: () => validateAdultContentPref,
        validateContentLabelPref: () => validateContentLabelPref,
        validateFeedViewPref: () => validateFeedViewPref,
        validatePersonalDetailsPref: () => validatePersonalDetailsPref,
        validateProfileView: () => validateProfileView,
        validateProfileViewBasic: () => validateProfileViewBasic,
        validateProfileViewDetailed: () => validateProfileViewDetailed,
        validateSavedFeedsPref: () => validateSavedFeedsPref,
        validateThreadViewPref: () => validateThreadViewPref,
        validateViewerState: () => validateViewerState
      });
      function isProfileViewBasic(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileViewBasic";
      }
      function validateProfileViewBasic(v) {
        return lexicons.validate("app.bsky.actor.defs#profileViewBasic", v);
      }
      function isProfileView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileView";
      }
      function validateProfileView(v) {
        return lexicons.validate("app.bsky.actor.defs#profileView", v);
      }
      function isProfileViewDetailed(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileViewDetailed";
      }
      function validateProfileViewDetailed(v) {
        return lexicons.validate("app.bsky.actor.defs#profileViewDetailed", v);
      }
      function isViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#viewerState";
      }
      function validateViewerState(v) {
        return lexicons.validate("app.bsky.actor.defs#viewerState", v);
      }
      function isAdultContentPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#adultContentPref";
      }
      function validateAdultContentPref(v) {
        return lexicons.validate("app.bsky.actor.defs#adultContentPref", v);
      }
      function isContentLabelPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#contentLabelPref";
      }
      function validateContentLabelPref(v) {
        return lexicons.validate("app.bsky.actor.defs#contentLabelPref", v);
      }
      function isSavedFeedsPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#savedFeedsPref";
      }
      function validateSavedFeedsPref(v) {
        return lexicons.validate("app.bsky.actor.defs#savedFeedsPref", v);
      }
      function isPersonalDetailsPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#personalDetailsPref";
      }
      function validatePersonalDetailsPref(v) {
        return lexicons.validate("app.bsky.actor.defs#personalDetailsPref", v);
      }
      function isFeedViewPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#feedViewPref";
      }
      function validateFeedViewPref(v) {
        return lexicons.validate("app.bsky.actor.defs#feedViewPref", v);
      }
      function isThreadViewPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#threadViewPref";
      }
      function validateThreadViewPref(v) {
        return lexicons.validate("app.bsky.actor.defs#threadViewPref", v);
      }
      var profile_exports = {};
      __export(profile_exports, {
        isRecord: () => isRecord2,
        validateRecord: () => validateRecord2
      });
      function isRecord2(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.actor.profile#main" || v.$type === "app.bsky.actor.profile");
      }
      function validateRecord2(v) {
        return lexicons.validate("app.bsky.actor.profile#main", v);
      }
      var external_exports = {};
      __export(external_exports, {
        isExternal: () => isExternal,
        isMain: () => isMain2,
        isView: () => isView,
        isViewExternal: () => isViewExternal,
        validateExternal: () => validateExternal,
        validateMain: () => validateMain2,
        validateView: () => validateView,
        validateViewExternal: () => validateViewExternal
      });
      function isMain2(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.external#main" || v.$type === "app.bsky.embed.external");
      }
      function validateMain2(v) {
        return lexicons.validate("app.bsky.embed.external#main", v);
      }
      function isExternal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#external";
      }
      function validateExternal(v) {
        return lexicons.validate("app.bsky.embed.external#external", v);
      }
      function isView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#view";
      }
      function validateView(v) {
        return lexicons.validate("app.bsky.embed.external#view", v);
      }
      function isViewExternal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#viewExternal";
      }
      function validateViewExternal(v) {
        return lexicons.validate("app.bsky.embed.external#viewExternal", v);
      }
      var images_exports = {};
      __export(images_exports, {
        isAspectRatio: () => isAspectRatio,
        isImage: () => isImage,
        isMain: () => isMain3,
        isView: () => isView2,
        isViewImage: () => isViewImage,
        validateAspectRatio: () => validateAspectRatio,
        validateImage: () => validateImage,
        validateMain: () => validateMain3,
        validateView: () => validateView2,
        validateViewImage: () => validateViewImage
      });
      function isMain3(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.images#main" || v.$type === "app.bsky.embed.images");
      }
      function validateMain3(v) {
        return lexicons.validate("app.bsky.embed.images#main", v);
      }
      function isImage(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#image";
      }
      function validateImage(v) {
        return lexicons.validate("app.bsky.embed.images#image", v);
      }
      function isAspectRatio(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#aspectRatio";
      }
      function validateAspectRatio(v) {
        return lexicons.validate("app.bsky.embed.images#aspectRatio", v);
      }
      function isView2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#view";
      }
      function validateView2(v) {
        return lexicons.validate("app.bsky.embed.images#view", v);
      }
      function isViewImage(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#viewImage";
      }
      function validateViewImage(v) {
        return lexicons.validate("app.bsky.embed.images#viewImage", v);
      }
      var record_exports = {};
      __export(record_exports, {
        isMain: () => isMain4,
        isView: () => isView3,
        isViewBlocked: () => isViewBlocked,
        isViewNotFound: () => isViewNotFound,
        isViewRecord: () => isViewRecord,
        validateMain: () => validateMain4,
        validateView: () => validateView3,
        validateViewBlocked: () => validateViewBlocked,
        validateViewNotFound: () => validateViewNotFound,
        validateViewRecord: () => validateViewRecord
      });
      function isMain4(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.record#main" || v.$type === "app.bsky.embed.record");
      }
      function validateMain4(v) {
        return lexicons.validate("app.bsky.embed.record#main", v);
      }
      function isView3(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#view";
      }
      function validateView3(v) {
        return lexicons.validate("app.bsky.embed.record#view", v);
      }
      function isViewRecord(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewRecord";
      }
      function validateViewRecord(v) {
        return lexicons.validate("app.bsky.embed.record#viewRecord", v);
      }
      function isViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewNotFound";
      }
      function validateViewNotFound(v) {
        return lexicons.validate("app.bsky.embed.record#viewNotFound", v);
      }
      function isViewBlocked(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewBlocked";
      }
      function validateViewBlocked(v) {
        return lexicons.validate("app.bsky.embed.record#viewBlocked", v);
      }
      var recordWithMedia_exports = {};
      __export(recordWithMedia_exports, {
        isMain: () => isMain5,
        isView: () => isView4,
        validateMain: () => validateMain5,
        validateView: () => validateView4
      });
      function isMain5(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.recordWithMedia#main" || v.$type === "app.bsky.embed.recordWithMedia");
      }
      function validateMain5(v) {
        return lexicons.validate("app.bsky.embed.recordWithMedia#main", v);
      }
      function isView4(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.recordWithMedia#view";
      }
      function validateView4(v) {
        return lexicons.validate("app.bsky.embed.recordWithMedia#view", v);
      }
      var defs_exports6 = {};
      __export(defs_exports6, {
        isBlockedAuthor: () => isBlockedAuthor,
        isBlockedPost: () => isBlockedPost,
        isFeedViewPost: () => isFeedViewPost,
        isGeneratorView: () => isGeneratorView,
        isGeneratorViewerState: () => isGeneratorViewerState,
        isNotFoundPost: () => isNotFoundPost,
        isPostView: () => isPostView,
        isReasonRepost: () => isReasonRepost,
        isReplyRef: () => isReplyRef,
        isSkeletonFeedPost: () => isSkeletonFeedPost,
        isSkeletonReasonRepost: () => isSkeletonReasonRepost,
        isThreadViewPost: () => isThreadViewPost,
        isThreadgateView: () => isThreadgateView,
        isViewerState: () => isViewerState2,
        validateBlockedAuthor: () => validateBlockedAuthor,
        validateBlockedPost: () => validateBlockedPost,
        validateFeedViewPost: () => validateFeedViewPost,
        validateGeneratorView: () => validateGeneratorView,
        validateGeneratorViewerState: () => validateGeneratorViewerState,
        validateNotFoundPost: () => validateNotFoundPost,
        validatePostView: () => validatePostView,
        validateReasonRepost: () => validateReasonRepost,
        validateReplyRef: () => validateReplyRef,
        validateSkeletonFeedPost: () => validateSkeletonFeedPost,
        validateSkeletonReasonRepost: () => validateSkeletonReasonRepost,
        validateThreadViewPost: () => validateThreadViewPost,
        validateThreadgateView: () => validateThreadgateView,
        validateViewerState: () => validateViewerState2
      });
      function isPostView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#postView";
      }
      function validatePostView(v) {
        return lexicons.validate("app.bsky.feed.defs#postView", v);
      }
      function isViewerState2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#viewerState";
      }
      function validateViewerState2(v) {
        return lexicons.validate("app.bsky.feed.defs#viewerState", v);
      }
      function isFeedViewPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#feedViewPost";
      }
      function validateFeedViewPost(v) {
        return lexicons.validate("app.bsky.feed.defs#feedViewPost", v);
      }
      function isReplyRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#replyRef";
      }
      function validateReplyRef(v) {
        return lexicons.validate("app.bsky.feed.defs#replyRef", v);
      }
      function isReasonRepost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#reasonRepost";
      }
      function validateReasonRepost(v) {
        return lexicons.validate("app.bsky.feed.defs#reasonRepost", v);
      }
      function isThreadViewPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#threadViewPost";
      }
      function validateThreadViewPost(v) {
        return lexicons.validate("app.bsky.feed.defs#threadViewPost", v);
      }
      function isNotFoundPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#notFoundPost";
      }
      function validateNotFoundPost(v) {
        return lexicons.validate("app.bsky.feed.defs#notFoundPost", v);
      }
      function isBlockedPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#blockedPost";
      }
      function validateBlockedPost(v) {
        return lexicons.validate("app.bsky.feed.defs#blockedPost", v);
      }
      function isBlockedAuthor(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#blockedAuthor";
      }
      function validateBlockedAuthor(v) {
        return lexicons.validate("app.bsky.feed.defs#blockedAuthor", v);
      }
      function isGeneratorView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#generatorView";
      }
      function validateGeneratorView(v) {
        return lexicons.validate("app.bsky.feed.defs#generatorView", v);
      }
      function isGeneratorViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#generatorViewerState";
      }
      function validateGeneratorViewerState(v) {
        return lexicons.validate("app.bsky.feed.defs#generatorViewerState", v);
      }
      function isSkeletonFeedPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#skeletonFeedPost";
      }
      function validateSkeletonFeedPost(v) {
        return lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", v);
      }
      function isSkeletonReasonRepost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#skeletonReasonRepost";
      }
      function validateSkeletonReasonRepost(v) {
        return lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", v);
      }
      function isThreadgateView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#threadgateView";
      }
      function validateThreadgateView(v) {
        return lexicons.validate("app.bsky.feed.defs#threadgateView", v);
      }
      var generator_exports = {};
      __export(generator_exports, {
        isRecord: () => isRecord3,
        validateRecord: () => validateRecord3
      });
      function isRecord3(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.generator#main" || v.$type === "app.bsky.feed.generator");
      }
      function validateRecord3(v) {
        return lexicons.validate("app.bsky.feed.generator#main", v);
      }
      var like_exports = {};
      __export(like_exports, {
        isRecord: () => isRecord4,
        validateRecord: () => validateRecord4
      });
      function isRecord4(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.like#main" || v.$type === "app.bsky.feed.like");
      }
      function validateRecord4(v) {
        return lexicons.validate("app.bsky.feed.like#main", v);
      }
      var post_exports = {};
      __export(post_exports, {
        isEntity: () => isEntity,
        isRecord: () => isRecord5,
        isReplyRef: () => isReplyRef2,
        isTextSlice: () => isTextSlice,
        validateEntity: () => validateEntity,
        validateRecord: () => validateRecord5,
        validateReplyRef: () => validateReplyRef2,
        validateTextSlice: () => validateTextSlice
      });
      function isRecord5(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.post#main" || v.$type === "app.bsky.feed.post");
      }
      function validateRecord5(v) {
        return lexicons.validate("app.bsky.feed.post#main", v);
      }
      function isReplyRef2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#replyRef";
      }
      function validateReplyRef2(v) {
        return lexicons.validate("app.bsky.feed.post#replyRef", v);
      }
      function isEntity(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#entity";
      }
      function validateEntity(v) {
        return lexicons.validate("app.bsky.feed.post#entity", v);
      }
      function isTextSlice(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#textSlice";
      }
      function validateTextSlice(v) {
        return lexicons.validate("app.bsky.feed.post#textSlice", v);
      }
      var repost_exports = {};
      __export(repost_exports, {
        isRecord: () => isRecord6,
        validateRecord: () => validateRecord6
      });
      function isRecord6(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.repost#main" || v.$type === "app.bsky.feed.repost");
      }
      function validateRecord6(v) {
        return lexicons.validate("app.bsky.feed.repost#main", v);
      }
      var threadgate_exports = {};
      __export(threadgate_exports, {
        isFollowingRule: () => isFollowingRule,
        isListRule: () => isListRule,
        isMentionRule: () => isMentionRule,
        isRecord: () => isRecord7,
        validateFollowingRule: () => validateFollowingRule,
        validateListRule: () => validateListRule,
        validateMentionRule: () => validateMentionRule,
        validateRecord: () => validateRecord7
      });
      function isRecord7(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.threadgate#main" || v.$type === "app.bsky.feed.threadgate");
      }
      function validateRecord7(v) {
        return lexicons.validate("app.bsky.feed.threadgate#main", v);
      }
      function isMentionRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#mentionRule";
      }
      function validateMentionRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#mentionRule", v);
      }
      function isFollowingRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#followingRule";
      }
      function validateFollowingRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#followingRule", v);
      }
      function isListRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#listRule";
      }
      function validateListRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#listRule", v);
      }
      var block_exports = {};
      __export(block_exports, {
        isRecord: () => isRecord8,
        validateRecord: () => validateRecord8
      });
      function isRecord8(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.block#main" || v.$type === "app.bsky.graph.block");
      }
      function validateRecord8(v) {
        return lexicons.validate("app.bsky.graph.block#main", v);
      }
      var defs_exports7 = {};
      __export(defs_exports7, {
        CURATELIST: () => CURATELIST,
        MODLIST: () => MODLIST,
        isListItemView: () => isListItemView,
        isListView: () => isListView,
        isListViewBasic: () => isListViewBasic,
        isListViewerState: () => isListViewerState,
        validateListItemView: () => validateListItemView,
        validateListView: () => validateListView,
        validateListViewBasic: () => validateListViewBasic,
        validateListViewerState: () => validateListViewerState
      });
      function isListViewBasic(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listViewBasic";
      }
      function validateListViewBasic(v) {
        return lexicons.validate("app.bsky.graph.defs#listViewBasic", v);
      }
      function isListView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listView";
      }
      function validateListView(v) {
        return lexicons.validate("app.bsky.graph.defs#listView", v);
      }
      function isListItemView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listItemView";
      }
      function validateListItemView(v) {
        return lexicons.validate("app.bsky.graph.defs#listItemView", v);
      }
      var MODLIST = "app.bsky.graph.defs#modlist";
      var CURATELIST = "app.bsky.graph.defs#curatelist";
      function isListViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listViewerState";
      }
      function validateListViewerState(v) {
        return lexicons.validate("app.bsky.graph.defs#listViewerState", v);
      }
      var follow_exports = {};
      __export(follow_exports, {
        isRecord: () => isRecord9,
        validateRecord: () => validateRecord9
      });
      function isRecord9(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.follow#main" || v.$type === "app.bsky.graph.follow");
      }
      function validateRecord9(v) {
        return lexicons.validate("app.bsky.graph.follow#main", v);
      }
      var list_exports = {};
      __export(list_exports, {
        isRecord: () => isRecord10,
        validateRecord: () => validateRecord10
      });
      function isRecord10(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.list#main" || v.$type === "app.bsky.graph.list");
      }
      function validateRecord10(v) {
        return lexicons.validate("app.bsky.graph.list#main", v);
      }
      var listblock_exports = {};
      __export(listblock_exports, {
        isRecord: () => isRecord11,
        validateRecord: () => validateRecord11
      });
      function isRecord11(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.listblock#main" || v.$type === "app.bsky.graph.listblock");
      }
      function validateRecord11(v) {
        return lexicons.validate("app.bsky.graph.listblock#main", v);
      }
      var listitem_exports = {};
      __export(listitem_exports, {
        isRecord: () => isRecord12,
        validateRecord: () => validateRecord12
      });
      function isRecord12(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.listitem#main" || v.$type === "app.bsky.graph.listitem");
      }
      function validateRecord12(v) {
        return lexicons.validate("app.bsky.graph.listitem#main", v);
      }
      var facet_exports = {};
      __export(facet_exports, {
        isByteSlice: () => isByteSlice,
        isLink: () => isLink,
        isMain: () => isMain6,
        isMention: () => isMention,
        isTag: () => isTag,
        validateByteSlice: () => validateByteSlice,
        validateLink: () => validateLink,
        validateMain: () => validateMain6,
        validateMention: () => validateMention,
        validateTag: () => validateTag
      });
      function isMain6(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.richtext.facet#main" || v.$type === "app.bsky.richtext.facet");
      }
      function validateMain6(v) {
        return lexicons.validate("app.bsky.richtext.facet#main", v);
      }
      function isMention(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#mention";
      }
      function validateMention(v) {
        return lexicons.validate("app.bsky.richtext.facet#mention", v);
      }
      function isLink(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#link";
      }
      function validateLink(v) {
        return lexicons.validate("app.bsky.richtext.facet#link", v);
      }
      function isTag(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#tag";
      }
      function validateTag(v) {
        return lexicons.validate("app.bsky.richtext.facet#tag", v);
      }
      function isByteSlice(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#byteSlice";
      }
      function validateByteSlice(v) {
        return lexicons.validate("app.bsky.richtext.facet#byteSlice", v);
      }
      var defs_exports8 = {};
      __export(defs_exports8, {
        isSkeletonSearchActor: () => isSkeletonSearchActor,
        isSkeletonSearchPost: () => isSkeletonSearchPost,
        validateSkeletonSearchActor: () => validateSkeletonSearchActor,
        validateSkeletonSearchPost: () => validateSkeletonSearchPost
      });
      function isSkeletonSearchPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
      }
      function validateSkeletonSearchPost(v) {
        return lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", v);
      }
      function isSkeletonSearchActor(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
      }
      function validateSkeletonSearchActor(v) {
        return lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", v);
      }
      var COM_ATPROTO_ADMIN = {
        DefsReviewOpen: "com.atproto.admin.defs#reviewOpen",
        DefsReviewEscalated: "com.atproto.admin.defs#reviewEscalated",
        DefsReviewClosed: "com.atproto.admin.defs#reviewClosed"
      };
      var COM_ATPROTO_MODERATION = {
        DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
        DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
        DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
        DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
        DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
        DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
        DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
      };
      var APP_BSKY_GRAPH = {
        DefsModlist: "app.bsky.graph.defs#modlist",
        DefsCuratelist: "app.bsky.graph.defs#curatelist"
      };
      var AtpBaseClient = class {
        constructor() {
          this.xrpc = new Client();
          this.xrpc.addLexicons(schemas);
        }
        service(serviceUri) {
          return new AtpServiceClient(this, this.xrpc.service(serviceUri));
        }
      };
      var AtpServiceClient = class {
        constructor(baseClient, xrpcService) {
          this._baseClient = baseClient;
          this.xrpc = xrpcService;
          this.com = new ComNS(this);
          this.app = new AppNS(this);
        }
        setHeader(key, value) {
          this.xrpc.setHeader(key, value);
        }
      };
      var ComNS = class {
        constructor(service2) {
          this._service = service2;
          this.atproto = new AtprotoNS(service2);
        }
      };
      var AtprotoNS = class {
        constructor(service2) {
          this._service = service2;
          this.admin = new AdminNS(service2);
          this.identity = new IdentityNS(service2);
          this.label = new LabelNS(service2);
          this.moderation = new ModerationNS(service2);
          this.repo = new RepoNS(service2);
          this.server = new ServerNS(service2);
          this.sync = new SyncNS(service2);
          this.temp = new TempNS(service2);
        }
      };
      var AdminNS = class {
        constructor(service2) {
          this._service = service2;
        }
        deleteAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.deleteAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr(e);
          });
        }
        disableAccountInvites(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr2(e);
          });
        }
        disableInviteCodes(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr3(e);
          });
        }
        emitModerationEvent(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.emitModerationEvent", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr4(e);
          });
        }
        enableAccountInvites(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr5(e);
          });
        }
        getAccountInfo(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getAccountInfo", params2, void 0, opts).catch((e) => {
            throw toKnownErr6(e);
          });
        }
        getInviteCodes(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getInviteCodes", params2, void 0, opts).catch((e) => {
            throw toKnownErr7(e);
          });
        }
        getModerationEvent(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getModerationEvent", params2, void 0, opts).catch((e) => {
            throw toKnownErr8(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr9(e);
          });
        }
        getRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr10(e);
          });
        }
        getSubjectStatus(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", params2, void 0, opts).catch((e) => {
            throw toKnownErr11(e);
          });
        }
        queryModerationEvents(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.queryModerationEvents", params2, void 0, opts).catch((e) => {
            throw toKnownErr12(e);
          });
        }
        queryModerationStatuses(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.queryModerationStatuses", params2, void 0, opts).catch((e) => {
            throw toKnownErr13(e);
          });
        }
        searchRepos(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.searchRepos", params2, void 0, opts).catch((e) => {
            throw toKnownErr14(e);
          });
        }
        sendEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.sendEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr15(e);
          });
        }
        updateAccountEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr16(e);
          });
        }
        updateAccountHandle(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr17(e);
          });
        }
        updateSubjectStatus(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr18(e);
          });
        }
      };
      var IdentityNS = class {
        constructor(service2) {
          this._service = service2;
        }
        resolveHandle(params2, opts) {
          return this._service.xrpc.call("com.atproto.identity.resolveHandle", params2, void 0, opts).catch((e) => {
            throw toKnownErr19(e);
          });
        }
        updateHandle(data, opts) {
          return this._service.xrpc.call("com.atproto.identity.updateHandle", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr20(e);
          });
        }
      };
      var LabelNS = class {
        constructor(service2) {
          this._service = service2;
        }
        queryLabels(params2, opts) {
          return this._service.xrpc.call("com.atproto.label.queryLabels", params2, void 0, opts).catch((e) => {
            throw toKnownErr21(e);
          });
        }
      };
      var ModerationNS = class {
        constructor(service2) {
          this._service = service2;
        }
        createReport(data, opts) {
          return this._service.xrpc.call("com.atproto.moderation.createReport", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr22(e);
          });
        }
      };
      var RepoNS = class {
        constructor(service2) {
          this._service = service2;
        }
        applyWrites(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.applyWrites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr23(e);
          });
        }
        createRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.createRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr24(e);
          });
        }
        deleteRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.deleteRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr25(e);
          });
        }
        describeRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.describeRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr26(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr27(e);
          });
        }
        listRecords(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.listRecords", params2, void 0, opts).catch((e) => {
            throw toKnownErr28(e);
          });
        }
        putRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.putRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr29(e);
          });
        }
        uploadBlob(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.uploadBlob", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr30(e);
          });
        }
      };
      var ServerNS = class {
        constructor(service2) {
          this._service = service2;
        }
        confirmEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.server.confirmEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr31(e);
          });
        }
        createAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr32(e);
          });
        }
        createAppPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createAppPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr33(e);
          });
        }
        createInviteCode(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createInviteCode", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr34(e);
          });
        }
        createInviteCodes(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createInviteCodes", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr35(e);
          });
        }
        createSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr36(e);
          });
        }
        deleteAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.server.deleteAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr37(e);
          });
        }
        deleteSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.deleteSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr38(e);
          });
        }
        describeServer(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.describeServer", params2, void 0, opts).catch((e) => {
            throw toKnownErr39(e);
          });
        }
        getAccountInviteCodes(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", params2, void 0, opts).catch((e) => {
            throw toKnownErr40(e);
          });
        }
        getSession(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.getSession", params2, void 0, opts).catch((e) => {
            throw toKnownErr41(e);
          });
        }
        listAppPasswords(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.listAppPasswords", params2, void 0, opts).catch((e) => {
            throw toKnownErr42(e);
          });
        }
        refreshSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.refreshSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr43(e);
          });
        }
        requestAccountDelete(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestAccountDelete", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr44(e);
          });
        }
        requestEmailConfirmation(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr45(e);
          });
        }
        requestEmailUpdate(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr46(e);
          });
        }
        requestPasswordReset(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestPasswordReset", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr47(e);
          });
        }
        reserveSigningKey(data, opts) {
          return this._service.xrpc.call("com.atproto.server.reserveSigningKey", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr48(e);
          });
        }
        resetPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.resetPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr49(e);
          });
        }
        revokeAppPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.revokeAppPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr50(e);
          });
        }
        updateEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.server.updateEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr51(e);
          });
        }
      };
      var SyncNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getBlob(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getBlob", params2, void 0, opts).catch((e) => {
            throw toKnownErr52(e);
          });
        }
        getBlocks(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr53(e);
          });
        }
        getCheckout(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getCheckout", params2, void 0, opts).catch((e) => {
            throw toKnownErr54(e);
          });
        }
        getHead(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getHead", params2, void 0, opts).catch((e) => {
            throw toKnownErr55(e);
          });
        }
        getLatestCommit(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getLatestCommit", params2, void 0, opts).catch((e) => {
            throw toKnownErr56(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr57(e);
          });
        }
        getRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr58(e);
          });
        }
        listBlobs(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.listBlobs", params2, void 0, opts).catch((e) => {
            throw toKnownErr59(e);
          });
        }
        listRepos(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.listRepos", params2, void 0, opts).catch((e) => {
            throw toKnownErr60(e);
          });
        }
        notifyOfUpdate(data, opts) {
          return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr61(e);
          });
        }
        requestCrawl(data, opts) {
          return this._service.xrpc.call("com.atproto.sync.requestCrawl", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr62(e);
          });
        }
      };
      var TempNS = class {
        constructor(service2) {
          this._service = service2;
        }
        fetchLabels(params2, opts) {
          return this._service.xrpc.call("com.atproto.temp.fetchLabels", params2, void 0, opts).catch((e) => {
            throw toKnownErr63(e);
          });
        }
        importRepo(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.importRepo", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr64(e);
          });
        }
        pushBlob(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.pushBlob", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr65(e);
          });
        }
        transferAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.transferAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr66(e);
          });
        }
      };
      var AppNS = class {
        constructor(service2) {
          this._service = service2;
          this.bsky = new BskyNS(service2);
        }
      };
      var BskyNS = class {
        constructor(service2) {
          this._service = service2;
          this.actor = new ActorNS(service2);
          this.embed = new EmbedNS(service2);
          this.feed = new FeedNS(service2);
          this.graph = new GraphNS(service2);
          this.notification = new NotificationNS(service2);
          this.richtext = new RichtextNS(service2);
          this.unspecced = new UnspeccedNS(service2);
        }
      };
      var ActorNS = class {
        constructor(service2) {
          this._service = service2;
          this.profile = new ProfileRecord(service2);
        }
        getPreferences(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getPreferences", params2, void 0, opts).catch((e) => {
            throw toKnownErr67(e);
          });
        }
        getProfile(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getProfile", params2, void 0, opts).catch((e) => {
            throw toKnownErr68(e);
          });
        }
        getProfiles(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getProfiles", params2, void 0, opts).catch((e) => {
            throw toKnownErr69(e);
          });
        }
        getSuggestions(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getSuggestions", params2, void 0, opts).catch((e) => {
            throw toKnownErr70(e);
          });
        }
        putPreferences(data, opts) {
          return this._service.xrpc.call("app.bsky.actor.putPreferences", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr71(e);
          });
        }
        searchActors(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.searchActors", params2, void 0, opts).catch((e) => {
            throw toKnownErr72(e);
          });
        }
        searchActorsTypeahead(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", params2, void 0, opts).catch((e) => {
            throw toKnownErr73(e);
          });
        }
      };
      var ProfileRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.actor.profile"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.actor.profile"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.actor.profile";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.actor.profile", rkey: "self" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.actor.profile" }, params2), { headers });
          });
        }
      };
      var EmbedNS = class {
        constructor(service2) {
          this._service = service2;
        }
      };
      var FeedNS = class {
        constructor(service2) {
          this._service = service2;
          this.generator = new GeneratorRecord(service2);
          this.like = new LikeRecord(service2);
          this.post = new PostRecord(service2);
          this.repost = new RepostRecord(service2);
          this.threadgate = new ThreadgateRecord(service2);
        }
        describeFeedGenerator(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", params2, void 0, opts).catch((e) => {
            throw toKnownErr74(e);
          });
        }
        getActorFeeds(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getActorFeeds", params2, void 0, opts).catch((e) => {
            throw toKnownErr75(e);
          });
        }
        getActorLikes(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getActorLikes", params2, void 0, opts).catch((e) => {
            throw toKnownErr76(e);
          });
        }
        getAuthorFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr77(e);
          });
        }
        getFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr78(e);
          });
        }
        getFeedGenerator(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", params2, void 0, opts).catch((e) => {
            throw toKnownErr79(e);
          });
        }
        getFeedGenerators(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", params2, void 0, opts).catch((e) => {
            throw toKnownErr80(e);
          });
        }
        getFeedSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr81(e);
          });
        }
        getLikes(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getLikes", params2, void 0, opts).catch((e) => {
            throw toKnownErr82(e);
          });
        }
        getListFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getListFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr83(e);
          });
        }
        getPostThread(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getPostThread", params2, void 0, opts).catch((e) => {
            throw toKnownErr84(e);
          });
        }
        getPosts(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getPosts", params2, void 0, opts).catch((e) => {
            throw toKnownErr85(e);
          });
        }
        getRepostedBy(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getRepostedBy", params2, void 0, opts).catch((e) => {
            throw toKnownErr86(e);
          });
        }
        getSuggestedFeeds(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", params2, void 0, opts).catch((e) => {
            throw toKnownErr87(e);
          });
        }
        getTimeline(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getTimeline", params2, void 0, opts).catch((e) => {
            throw toKnownErr88(e);
          });
        }
        searchPosts(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.searchPosts", params2, void 0, opts).catch((e) => {
            throw toKnownErr89(e);
          });
        }
      };
      var GeneratorRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.generator"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.generator"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.generator";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.generator" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.generator" }, params2), { headers });
          });
        }
      };
      var LikeRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.like"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.like"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.like";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.like" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.like" }, params2), { headers });
          });
        }
      };
      var PostRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.post"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.post"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.post";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.post" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.post" }, params2), { headers });
          });
        }
      };
      var RepostRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.repost"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.repost"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.repost";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.repost" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.repost" }, params2), { headers });
          });
        }
      };
      var ThreadgateRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.threadgate"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.threadgate"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.threadgate";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.threadgate" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.threadgate" }, params2), { headers });
          });
        }
      };
      var GraphNS = class {
        constructor(service2) {
          this._service = service2;
          this.block = new BlockRecord(service2);
          this.follow = new FollowRecord(service2);
          this.list = new ListRecord(service2);
          this.listblock = new ListblockRecord(service2);
          this.listitem = new ListitemRecord(service2);
        }
        getBlocks(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr90(e);
          });
        }
        getFollowers(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getFollowers", params2, void 0, opts).catch((e) => {
            throw toKnownErr91(e);
          });
        }
        getFollows(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getFollows", params2, void 0, opts).catch((e) => {
            throw toKnownErr92(e);
          });
        }
        getList(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getList", params2, void 0, opts).catch((e) => {
            throw toKnownErr93(e);
          });
        }
        getListBlocks(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getListBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr94(e);
          });
        }
        getListMutes(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getListMutes", params2, void 0, opts).catch((e) => {
            throw toKnownErr95(e);
          });
        }
        getLists(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getLists", params2, void 0, opts).catch((e) => {
            throw toKnownErr96(e);
          });
        }
        getMutes(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getMutes", params2, void 0, opts).catch((e) => {
            throw toKnownErr97(e);
          });
        }
        getSuggestedFollowsByActor(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", params2, void 0, opts).catch((e) => {
            throw toKnownErr98(e);
          });
        }
        muteActor(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.muteActor", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr99(e);
          });
        }
        muteActorList(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.muteActorList", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr100(e);
          });
        }
        unmuteActor(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.unmuteActor", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr101(e);
          });
        }
        unmuteActorList(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.unmuteActorList", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr102(e);
          });
        }
      };
      var BlockRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.block"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.block"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.block";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.block" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.block" }, params2), { headers });
          });
        }
      };
      var FollowRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.follow"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.follow"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.follow";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.follow" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.follow" }, params2), { headers });
          });
        }
      };
      var ListRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.list"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.list"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.list";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.list" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.list" }, params2), { headers });
          });
        }
      };
      var ListblockRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.listblock"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.listblock"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.listblock";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.listblock" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.listblock" }, params2), { headers });
          });
        }
      };
      var ListitemRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.listitem"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.listitem"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.listitem";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.listitem" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.listitem" }, params2), { headers });
          });
        }
      };
      var NotificationNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getUnreadCount(params2, opts) {
          return this._service.xrpc.call("app.bsky.notification.getUnreadCount", params2, void 0, opts).catch((e) => {
            throw toKnownErr103(e);
          });
        }
        listNotifications(params2, opts) {
          return this._service.xrpc.call("app.bsky.notification.listNotifications", params2, void 0, opts).catch((e) => {
            throw toKnownErr104(e);
          });
        }
        registerPush(data, opts) {
          return this._service.xrpc.call("app.bsky.notification.registerPush", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr105(e);
          });
        }
        updateSeen(data, opts) {
          return this._service.xrpc.call("app.bsky.notification.updateSeen", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr106(e);
          });
        }
      };
      var RichtextNS = class {
        constructor(service2) {
          this._service = service2;
        }
      };
      var UnspeccedNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getPopular(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getPopular", params2, void 0, opts).catch((e) => {
            throw toKnownErr107(e);
          });
        }
        getPopularFeedGenerators(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", params2, void 0, opts).catch((e) => {
            throw toKnownErr108(e);
          });
        }
        getTimelineSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getTimelineSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr109(e);
          });
        }
        searchActorsSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr110(e);
          });
        }
        searchPostsSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr111(e);
          });
        }
      };
      var REFRESH_SESSION = "com.atproto.server.refreshSession";
      var _AtpAgent = class {
        constructor(opts) {
          this.uploadBlob = (data, opts2) => this.api.com.atproto.repo.uploadBlob(data, opts2);
          this.resolveHandle = (params2, opts2) => this.api.com.atproto.identity.resolveHandle(params2, opts2);
          this.updateHandle = (data, opts2) => this.api.com.atproto.identity.updateHandle(data, opts2);
          this.createModerationReport = (data, opts2) => this.api.com.atproto.moderation.createReport(data, opts2);
          this.service = opts.service instanceof URL ? opts.service : new URL(opts.service);
          this._persistSession = opts.persistSession;
          this._baseClient = new AtpBaseClient();
          this._baseClient.xrpc.fetch = this._fetch.bind(this);
          this.api = this._baseClient.service(opts.service);
        }
        get com() {
          return this.api.com;
        }
        static configure(opts) {
          _AtpAgent.fetch = opts.fetch;
        }
        get hasSession() {
          return !!this.session;
        }
        setPersistSessionHandler(handler) {
          this._persistSession = handler;
        }
        createAccount(opts) {
          return __async(this, null, function* () {
            var _a, _b;
            try {
              const res = yield this.api.com.atproto.server.createAccount({
                handle: opts.handle,
                password: opts.password,
                email: opts.email,
                inviteCode: opts.inviteCode
              });
              this.session = {
                accessJwt: res.data.accessJwt,
                refreshJwt: res.data.refreshJwt,
                handle: res.data.handle,
                did: res.data.did,
                email: opts.email,
                emailConfirmed: false
              };
              this._updateApiEndpoint(res.data.didDoc);
              return res;
            } catch (e) {
              this.session = void 0;
              throw e;
            } finally {
              if (this.session) {
                (_a = this._persistSession) == null ? void 0 : _a.call(this, "create", this.session);
              } else {
                (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
              }
            }
          });
        }
        login(opts) {
          return __async(this, null, function* () {
            var _a, _b;
            try {
              const res = yield this.api.com.atproto.server.createSession({
                identifier: opts.identifier,
                password: opts.password
              });
              this.session = {
                accessJwt: res.data.accessJwt,
                refreshJwt: res.data.refreshJwt,
                handle: res.data.handle,
                did: res.data.did,
                email: res.data.email,
                emailConfirmed: res.data.emailConfirmed
              };
              this._updateApiEndpoint(res.data.didDoc);
              return res;
            } catch (e) {
              this.session = void 0;
              throw e;
            } finally {
              if (this.session) {
                (_a = this._persistSession) == null ? void 0 : _a.call(this, "create", this.session);
              } else {
                (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
              }
            }
          });
        }
        resumeSession(session) {
          return __async(this, null, function* () {
            var _a, _b, _c, _d;
            try {
              this.session = session;
              const res = yield this.api.com.atproto.server.getSession();
              if (res.data.did !== this.session.did) {
                throw new XRPCError(400, "Invalid session", "InvalidDID");
              }
              this.session.email = res.data.email;
              this.session.handle = res.data.handle;
              this.session.emailConfirmed = res.data.emailConfirmed;
              this._updateApiEndpoint(res.data.didDoc);
              (_a = this._persistSession) == null ? void 0 : _a.call(this, "update", this.session);
              return res;
            } catch (e) {
              this.session = void 0;
              if (e instanceof XRPCError) {
                if ([1, 408, 425, 429, 500, 502, 503, 504, 522, 524].includes(e.status)) {
                  (_b = this._persistSession) == null ? void 0 : _b.call(this, "network-error", void 0);
                } else {
                  (_c = this._persistSession) == null ? void 0 : _c.call(this, "expired", void 0);
                }
              } else {
                (_d = this._persistSession) == null ? void 0 : _d.call(this, "network-error", void 0);
              }
              throw e;
            }
          });
        }
        _addAuthHeader(reqHeaders) {
          var _a;
          if (!reqHeaders.authorization && ((_a = this.session) == null ? void 0 : _a.accessJwt)) {
            return __spreadProps(__spreadValues({}, reqHeaders), {
              authorization: `Bearer ${this.session.accessJwt}`
            });
          }
          return reqHeaders;
        }
        _fetch(reqUri, reqMethod, reqHeaders, reqBody) {
          return __async(this, null, function* () {
            var _a;
            if (!_AtpAgent.fetch) {
              throw new Error("AtpAgent fetch() method not configured");
            }
            yield this._refreshSessionPromise;
            let res = yield _AtpAgent.fetch(reqUri, reqMethod, this._addAuthHeader(reqHeaders), reqBody);
            if (isErrorResponse(res, ["ExpiredToken"]) && ((_a = this.session) == null ? void 0 : _a.refreshJwt)) {
              yield this._refreshSession();
              res = yield _AtpAgent.fetch(reqUri, reqMethod, this._addAuthHeader(reqHeaders), reqBody);
            }
            return res;
          });
        }
        _refreshSession() {
          return __async(this, null, function* () {
            if (this._refreshSessionPromise) {
              return this._refreshSessionPromise;
            }
            this._refreshSessionPromise = this._refreshSessionInner();
            try {
              yield this._refreshSessionPromise;
            } finally {
              this._refreshSessionPromise = void 0;
            }
          });
        }
        _refreshSessionInner() {
          return __async(this, null, function* () {
            var _a, _b, _c;
            if (!_AtpAgent.fetch) {
              throw new Error("AtpAgent fetch() method not configured");
            }
            if (!((_a = this.session) == null ? void 0 : _a.refreshJwt)) {
              return;
            }
            const url = new URL((this.pdsUrl || this.service).origin);
            url.pathname = `/xrpc/${REFRESH_SESSION}`;
            const res = yield _AtpAgent.fetch(url.toString(), "POST", {
              authorization: `Bearer ${this.session.refreshJwt}`
            }, void 0);
            if (isErrorResponse(res, ["ExpiredToken", "InvalidToken"])) {
              this.session = void 0;
              (_b = this._persistSession) == null ? void 0 : _b.call(this, "expired", void 0);
            } else if (isNewSessionObject(this._baseClient, res.body)) {
              this.session = __spreadProps(__spreadValues({}, this.session || {}), {
                accessJwt: res.body.accessJwt,
                refreshJwt: res.body.refreshJwt,
                handle: res.body.handle,
                did: res.body.did
              });
              this._updateApiEndpoint(res.body.didDoc);
              (_c = this._persistSession) == null ? void 0 : _c.call(this, "update", this.session);
            }
          });
        }
        _updateApiEndpoint(didDoc) {
          if (isValidDidDoc(didDoc)) {
            const endpoint = getPdsEndpoint(didDoc);
            this.pdsUrl = endpoint ? new URL(endpoint) : void 0;
          }
          this.api.xrpc.uri = this.pdsUrl || this.service;
        }
      };
      var AtpAgent = _AtpAgent;
      AtpAgent.fetch = defaultFetchHandler;
      function isErrorObject(v) {
        return errorResponseBody.safeParse(v).success;
      }
      function isErrorResponse(res, errorNames) {
        if (res.status !== 400) {
          return false;
        }
        if (!isErrorObject(res.body)) {
          return false;
        }
        return typeof res.body.error === "string" && errorNames.includes(res.body.error);
      }
      function isNewSessionObject(client, v) {
        try {
          client.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", v);
          return true;
        } catch (e) {
          return false;
        }
      }
      var encoder = new TextEncoder();
      var decoder = new TextDecoder();
      var UnicodeString = class {
        constructor(utf16) {
          this.utf16 = utf16;
          this.utf8 = encoder.encode(utf16);
        }
        get length() {
          return this.utf8.byteLength;
        }
        get graphemeLength() {
          if (!this._graphemeLen) {
            this._graphemeLen = graphemeLen(this.utf16);
          }
          return this._graphemeLen;
        }
        slice(start, end) {
          return decoder.decode(this.utf8.slice(start, end));
        }
        utf16IndexToUtf8Index(i) {
          return encoder.encode(this.utf16.slice(0, i)).byteLength;
        }
        toString() {
          return this.utf16;
        }
      };
      var EXCESS_SPACE_RE = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/;
      var REPLACEMENT_STR = "\n\n";
      function sanitizeRichText(richText, opts) {
        if (opts.cleanNewlines) {
          richText = clean(richText, EXCESS_SPACE_RE, REPLACEMENT_STR);
        }
        return richText;
      }
      function clean(richText, targetRegexp, replacementString) {
        richText = richText.clone();
        let match = richText.unicodeText.utf16.match(targetRegexp);
        while (match && typeof match.index !== "undefined") {
          const oldText = richText.unicodeText;
          const removeStartIndex = richText.unicodeText.utf16IndexToUtf8Index(match.index);
          const removeEndIndex = removeStartIndex + new UnicodeString(match[0]).length;
          richText.delete(removeStartIndex, removeEndIndex);
          if (richText.unicodeText.utf16 === oldText.utf16) {
            break;
          }
          richText.insert(removeStartIndex, replacementString);
          match = richText.unicodeText.utf16.match(targetRegexp);
        }
        return richText;
      }
      var tlds_default = [
        "aaa",
        "aarp",
        "abarth",
        "abb",
        "abbott",
        "abbvie",
        "abc",
        "able",
        "abogado",
        "abudhabi",
        "ac",
        "academy",
        "accenture",
        "accountant",
        "accountants",
        "aco",
        "actor",
        "ad",
        "ads",
        "adult",
        "ae",
        "aeg",
        "aero",
        "aetna",
        "af",
        "afl",
        "africa",
        "ag",
        "agakhan",
        "agency",
        "ai",
        "aig",
        "airbus",
        "airforce",
        "airtel",
        "akdn",
        "al",
        "alfaromeo",
        "alibaba",
        "alipay",
        "allfinanz",
        "allstate",
        "ally",
        "alsace",
        "alstom",
        "am",
        "amazon",
        "americanexpress",
        "americanfamily",
        "amex",
        "amfam",
        "amica",
        "amsterdam",
        "analytics",
        "android",
        "anquan",
        "anz",
        "ao",
        "aol",
        "apartments",
        "app",
        "apple",
        "aq",
        "aquarelle",
        "ar",
        "arab",
        "aramco",
        "archi",
        "army",
        "arpa",
        "art",
        "arte",
        "as",
        "asda",
        "asia",
        "associates",
        "at",
        "athleta",
        "attorney",
        "au",
        "auction",
        "audi",
        "audible",
        "audio",
        "auspost",
        "author",
        "auto",
        "autos",
        "avianca",
        "aw",
        "aws",
        "ax",
        "axa",
        "az",
        "azure",
        "ba",
        "baby",
        "baidu",
        "banamex",
        "bananarepublic",
        "band",
        "bank",
        "bar",
        "barcelona",
        "barclaycard",
        "barclays",
        "barefoot",
        "bargains",
        "baseball",
        "basketball",
        "bauhaus",
        "bayern",
        "bb",
        "bbc",
        "bbt",
        "bbva",
        "bcg",
        "bcn",
        "bd",
        "be",
        "beats",
        "beauty",
        "beer",
        "bentley",
        "berlin",
        "best",
        "bestbuy",
        "bet",
        "bf",
        "bg",
        "bh",
        "bharti",
        "bi",
        "bible",
        "bid",
        "bike",
        "bing",
        "bingo",
        "bio",
        "biz",
        "bj",
        "black",
        "blackfriday",
        "blockbuster",
        "blog",
        "bloomberg",
        "blue",
        "bm",
        "bms",
        "bmw",
        "bn",
        "bnpparibas",
        "bo",
        "boats",
        "boehringer",
        "bofa",
        "bom",
        "bond",
        "boo",
        "book",
        "booking",
        "bosch",
        "bostik",
        "boston",
        "bot",
        "boutique",
        "box",
        "br",
        "bradesco",
        "bridgestone",
        "broadway",
        "broker",
        "brother",
        "brussels",
        "bs",
        "bt",
        "build",
        "builders",
        "business",
        "buy",
        "buzz",
        "bv",
        "bw",
        "by",
        "bz",
        "bzh",
        "ca",
        "cab",
        "cafe",
        "cal",
        "call",
        "calvinklein",
        "cam",
        "camera",
        "camp",
        "canon",
        "capetown",
        "capital",
        "capitalone",
        "car",
        "caravan",
        "cards",
        "care",
        "career",
        "careers",
        "cars",
        "casa",
        "case",
        "cash",
        "casino",
        "cat",
        "catering",
        "catholic",
        "cba",
        "cbn",
        "cbre",
        "cbs",
        "cc",
        "cd",
        "center",
        "ceo",
        "cern",
        "cf",
        "cfa",
        "cfd",
        "cg",
        "ch",
        "chanel",
        "channel",
        "charity",
        "chase",
        "chat",
        "cheap",
        "chintai",
        "christmas",
        "chrome",
        "church",
        "ci",
        "cipriani",
        "circle",
        "cisco",
        "citadel",
        "citi",
        "citic",
        "city",
        "cityeats",
        "ck",
        "cl",
        "claims",
        "cleaning",
        "click",
        "clinic",
        "clinique",
        "clothing",
        "cloud",
        "club",
        "clubmed",
        "cm",
        "cn",
        "co",
        "coach",
        "codes",
        "coffee",
        "college",
        "cologne",
        "com",
        "comcast",
        "commbank",
        "community",
        "company",
        "compare",
        "computer",
        "comsec",
        "condos",
        "construction",
        "consulting",
        "contact",
        "contractors",
        "cooking",
        "cookingchannel",
        "cool",
        "coop",
        "corsica",
        "country",
        "coupon",
        "coupons",
        "courses",
        "cpa",
        "cr",
        "credit",
        "creditcard",
        "creditunion",
        "cricket",
        "crown",
        "crs",
        "cruise",
        "cruises",
        "cu",
        "cuisinella",
        "cv",
        "cw",
        "cx",
        "cy",
        "cymru",
        "cyou",
        "cz",
        "dabur",
        "dad",
        "dance",
        "data",
        "date",
        "dating",
        "datsun",
        "day",
        "dclk",
        "dds",
        "de",
        "deal",
        "dealer",
        "deals",
        "degree",
        "delivery",
        "dell",
        "deloitte",
        "delta",
        "democrat",
        "dental",
        "dentist",
        "desi",
        "design",
        "dev",
        "dhl",
        "diamonds",
        "diet",
        "digital",
        "direct",
        "directory",
        "discount",
        "discover",
        "dish",
        "diy",
        "dj",
        "dk",
        "dm",
        "dnp",
        "do",
        "docs",
        "doctor",
        "dog",
        "domains",
        "dot",
        "download",
        "drive",
        "dtv",
        "dubai",
        "dunlop",
        "dupont",
        "durban",
        "dvag",
        "dvr",
        "dz",
        "earth",
        "eat",
        "ec",
        "eco",
        "edeka",
        "edu",
        "education",
        "ee",
        "eg",
        "email",
        "emerck",
        "energy",
        "engineer",
        "engineering",
        "enterprises",
        "epson",
        "equipment",
        "er",
        "ericsson",
        "erni",
        "es",
        "esq",
        "estate",
        "et",
        "etisalat",
        "eu",
        "eurovision",
        "eus",
        "events",
        "exchange",
        "expert",
        "exposed",
        "express",
        "extraspace",
        "fage",
        "fail",
        "fairwinds",
        "faith",
        "family",
        "fan",
        "fans",
        "farm",
        "farmers",
        "fashion",
        "fast",
        "fedex",
        "feedback",
        "ferrari",
        "ferrero",
        "fi",
        "fiat",
        "fidelity",
        "fido",
        "film",
        "final",
        "finance",
        "financial",
        "fire",
        "firestone",
        "firmdale",
        "fish",
        "fishing",
        "fit",
        "fitness",
        "fj",
        "fk",
        "flickr",
        "flights",
        "flir",
        "florist",
        "flowers",
        "fly",
        "fm",
        "fo",
        "foo",
        "food",
        "foodnetwork",
        "football",
        "ford",
        "forex",
        "forsale",
        "forum",
        "foundation",
        "fox",
        "fr",
        "free",
        "fresenius",
        "frl",
        "frogans",
        "frontdoor",
        "frontier",
        "ftr",
        "fujitsu",
        "fun",
        "fund",
        "furniture",
        "futbol",
        "fyi",
        "ga",
        "gal",
        "gallery",
        "gallo",
        "gallup",
        "game",
        "games",
        "gap",
        "garden",
        "gay",
        "gb",
        "gbiz",
        "gd",
        "gdn",
        "ge",
        "gea",
        "gent",
        "genting",
        "george",
        "gf",
        "gg",
        "ggee",
        "gh",
        "gi",
        "gift",
        "gifts",
        "gives",
        "giving",
        "gl",
        "glass",
        "gle",
        "global",
        "globo",
        "gm",
        "gmail",
        "gmbh",
        "gmo",
        "gmx",
        "gn",
        "godaddy",
        "gold",
        "goldpoint",
        "golf",
        "goo",
        "goodyear",
        "goog",
        "google",
        "gop",
        "got",
        "gov",
        "gp",
        "gq",
        "gr",
        "grainger",
        "graphics",
        "gratis",
        "green",
        "gripe",
        "grocery",
        "group",
        "gs",
        "gt",
        "gu",
        "guardian",
        "gucci",
        "guge",
        "guide",
        "guitars",
        "guru",
        "gw",
        "gy",
        "hair",
        "hamburg",
        "hangout",
        "haus",
        "hbo",
        "hdfc",
        "hdfcbank",
        "health",
        "healthcare",
        "help",
        "helsinki",
        "here",
        "hermes",
        "hgtv",
        "hiphop",
        "hisamitsu",
        "hitachi",
        "hiv",
        "hk",
        "hkt",
        "hm",
        "hn",
        "hockey",
        "holdings",
        "holiday",
        "homedepot",
        "homegoods",
        "homes",
        "homesense",
        "honda",
        "horse",
        "hospital",
        "host",
        "hosting",
        "hot",
        "hoteles",
        "hotels",
        "hotmail",
        "house",
        "how",
        "hr",
        "hsbc",
        "ht",
        "hu",
        "hughes",
        "hyatt",
        "hyundai",
        "ibm",
        "icbc",
        "ice",
        "icu",
        "id",
        "ie",
        "ieee",
        "ifm",
        "ikano",
        "il",
        "im",
        "imamat",
        "imdb",
        "immo",
        "immobilien",
        "in",
        "inc",
        "industries",
        "infiniti",
        "info",
        "ing",
        "ink",
        "institute",
        "insurance",
        "insure",
        "int",
        "international",
        "intuit",
        "investments",
        "io",
        "ipiranga",
        "iq",
        "ir",
        "irish",
        "is",
        "ismaili",
        "ist",
        "istanbul",
        "it",
        "itau",
        "itv",
        "jaguar",
        "java",
        "jcb",
        "je",
        "jeep",
        "jetzt",
        "jewelry",
        "jio",
        "jll",
        "jm",
        "jmp",
        "jnj",
        "jo",
        "jobs",
        "joburg",
        "jot",
        "joy",
        "jp",
        "jpmorgan",
        "jprs",
        "juegos",
        "juniper",
        "kaufen",
        "kddi",
        "ke",
        "kerryhotels",
        "kerrylogistics",
        "kerryproperties",
        "kfh",
        "kg",
        "kh",
        "ki",
        "kia",
        "kids",
        "kim",
        "kinder",
        "kindle",
        "kitchen",
        "kiwi",
        "km",
        "kn",
        "koeln",
        "komatsu",
        "kosher",
        "kp",
        "kpmg",
        "kpn",
        "kr",
        "krd",
        "kred",
        "kuokgroup",
        "kw",
        "ky",
        "kyoto",
        "kz",
        "la",
        "lacaixa",
        "lamborghini",
        "lamer",
        "lancaster",
        "lancia",
        "land",
        "landrover",
        "lanxess",
        "lasalle",
        "lat",
        "latino",
        "latrobe",
        "law",
        "lawyer",
        "lb",
        "lc",
        "lds",
        "lease",
        "leclerc",
        "lefrak",
        "legal",
        "lego",
        "lexus",
        "lgbt",
        "li",
        "lidl",
        "life",
        "lifeinsurance",
        "lifestyle",
        "lighting",
        "like",
        "lilly",
        "limited",
        "limo",
        "lincoln",
        "linde",
        "link",
        "lipsy",
        "live",
        "living",
        "lk",
        "llc",
        "llp",
        "loan",
        "loans",
        "locker",
        "locus",
        "loft",
        "lol",
        "london",
        "lotte",
        "lotto",
        "love",
        "lpl",
        "lplfinancial",
        "lr",
        "ls",
        "lt",
        "ltd",
        "ltda",
        "lu",
        "lundbeck",
        "luxe",
        "luxury",
        "lv",
        "ly",
        "ma",
        "macys",
        "madrid",
        "maif",
        "maison",
        "makeup",
        "man",
        "management",
        "mango",
        "map",
        "market",
        "marketing",
        "markets",
        "marriott",
        "marshalls",
        "maserati",
        "mattel",
        "mba",
        "mc",
        "mckinsey",
        "md",
        "me",
        "med",
        "media",
        "meet",
        "melbourne",
        "meme",
        "memorial",
        "men",
        "menu",
        "merckmsd",
        "mg",
        "mh",
        "miami",
        "microsoft",
        "mil",
        "mini",
        "mint",
        "mit",
        "mitsubishi",
        "mk",
        "ml",
        "mlb",
        "mls",
        "mm",
        "mma",
        "mn",
        "mo",
        "mobi",
        "mobile",
        "moda",
        "moe",
        "moi",
        "mom",
        "monash",
        "money",
        "monster",
        "mormon",
        "mortgage",
        "moscow",
        "moto",
        "motorcycles",
        "mov",
        "movie",
        "mp",
        "mq",
        "mr",
        "ms",
        "msd",
        "mt",
        "mtn",
        "mtr",
        "mu",
        "museum",
        "music",
        "mutual",
        "mv",
        "mw",
        "mx",
        "my",
        "mz",
        "na",
        "nab",
        "nagoya",
        "name",
        "natura",
        "navy",
        "nba",
        "nc",
        "ne",
        "nec",
        "net",
        "netbank",
        "netflix",
        "network",
        "neustar",
        "new",
        "news",
        "next",
        "nextdirect",
        "nexus",
        "nf",
        "nfl",
        "ng",
        "ngo",
        "nhk",
        "ni",
        "nico",
        "nike",
        "nikon",
        "ninja",
        "nissan",
        "nissay",
        "nl",
        "no",
        "nokia",
        "northwesternmutual",
        "norton",
        "now",
        "nowruz",
        "nowtv",
        "np",
        "nr",
        "nra",
        "nrw",
        "ntt",
        "nu",
        "nyc",
        "nz",
        "obi",
        "observer",
        "office",
        "okinawa",
        "olayan",
        "olayangroup",
        "oldnavy",
        "ollo",
        "om",
        "omega",
        "one",
        "ong",
        "onl",
        "online",
        "ooo",
        "open",
        "oracle",
        "orange",
        "org",
        "organic",
        "origins",
        "osaka",
        "otsuka",
        "ott",
        "ovh",
        "pa",
        "page",
        "panasonic",
        "paris",
        "pars",
        "partners",
        "parts",
        "party",
        "passagens",
        "pay",
        "pccw",
        "pe",
        "pet",
        "pf",
        "pfizer",
        "pg",
        "ph",
        "pharmacy",
        "phd",
        "philips",
        "phone",
        "photo",
        "photography",
        "photos",
        "physio",
        "pics",
        "pictet",
        "pictures",
        "pid",
        "pin",
        "ping",
        "pink",
        "pioneer",
        "pizza",
        "pk",
        "pl",
        "place",
        "play",
        "playstation",
        "plumbing",
        "plus",
        "pm",
        "pn",
        "pnc",
        "pohl",
        "poker",
        "politie",
        "porn",
        "post",
        "pr",
        "pramerica",
        "praxi",
        "press",
        "prime",
        "pro",
        "prod",
        "productions",
        "prof",
        "progressive",
        "promo",
        "properties",
        "property",
        "protection",
        "pru",
        "prudential",
        "ps",
        "pt",
        "pub",
        "pw",
        "pwc",
        "py",
        "qa",
        "qpon",
        "quebec",
        "quest",
        "racing",
        "radio",
        "re",
        "read",
        "realestate",
        "realtor",
        "realty",
        "recipes",
        "red",
        "redstone",
        "redumbrella",
        "rehab",
        "reise",
        "reisen",
        "reit",
        "reliance",
        "ren",
        "rent",
        "rentals",
        "repair",
        "report",
        "republican",
        "rest",
        "restaurant",
        "review",
        "reviews",
        "rexroth",
        "rich",
        "richardli",
        "ricoh",
        "ril",
        "rio",
        "rip",
        "ro",
        "rocher",
        "rocks",
        "rodeo",
        "rogers",
        "room",
        "rs",
        "rsvp",
        "ru",
        "rugby",
        "ruhr",
        "run",
        "rw",
        "rwe",
        "ryukyu",
        "sa",
        "saarland",
        "safe",
        "safety",
        "sakura",
        "sale",
        "salon",
        "samsclub",
        "samsung",
        "sandvik",
        "sandvikcoromant",
        "sanofi",
        "sap",
        "sarl",
        "sas",
        "save",
        "saxo",
        "sb",
        "sbi",
        "sbs",
        "sc",
        "sca",
        "scb",
        "schaeffler",
        "schmidt",
        "scholarships",
        "school",
        "schule",
        "schwarz",
        "science",
        "scot",
        "sd",
        "se",
        "search",
        "seat",
        "secure",
        "security",
        "seek",
        "select",
        "sener",
        "services",
        "ses",
        "seven",
        "sew",
        "sex",
        "sexy",
        "sfr",
        "sg",
        "sh",
        "shangrila",
        "sharp",
        "shaw",
        "shell",
        "shia",
        "shiksha",
        "shoes",
        "shop",
        "shopping",
        "shouji",
        "show",
        "showtime",
        "si",
        "silk",
        "sina",
        "singles",
        "site",
        "sj",
        "sk",
        "ski",
        "skin",
        "sky",
        "skype",
        "sl",
        "sling",
        "sm",
        "smart",
        "smile",
        "sn",
        "sncf",
        "so",
        "soccer",
        "social",
        "softbank",
        "software",
        "sohu",
        "solar",
        "solutions",
        "song",
        "sony",
        "soy",
        "spa",
        "space",
        "sport",
        "spot",
        "sr",
        "srl",
        "ss",
        "st",
        "stada",
        "staples",
        "star",
        "statebank",
        "statefarm",
        "stc",
        "stcgroup",
        "stockholm",
        "storage",
        "store",
        "stream",
        "studio",
        "study",
        "style",
        "su",
        "sucks",
        "supplies",
        "supply",
        "support",
        "surf",
        "surgery",
        "suzuki",
        "sv",
        "swatch",
        "swiss",
        "sx",
        "sy",
        "sydney",
        "systems",
        "sz",
        "tab",
        "taipei",
        "talk",
        "taobao",
        "target",
        "tatamotors",
        "tatar",
        "tattoo",
        "tax",
        "taxi",
        "tc",
        "tci",
        "td",
        "tdk",
        "team",
        "tech",
        "technology",
        "tel",
        "temasek",
        "tennis",
        "teva",
        "tf",
        "tg",
        "th",
        "thd",
        "theater",
        "theatre",
        "tiaa",
        "tickets",
        "tienda",
        "tiffany",
        "tips",
        "tires",
        "tirol",
        "tj",
        "tjmaxx",
        "tjx",
        "tk",
        "tkmaxx",
        "tl",
        "tm",
        "tmall",
        "tn",
        "to",
        "today",
        "tokyo",
        "tools",
        "top",
        "toray",
        "toshiba",
        "total",
        "tours",
        "town",
        "toyota",
        "toys",
        "tr",
        "trade",
        "trading",
        "training",
        "travel",
        "travelchannel",
        "travelers",
        "travelersinsurance",
        "trust",
        "trv",
        "tt",
        "tube",
        "tui",
        "tunes",
        "tushu",
        "tv",
        "tvs",
        "tw",
        "tz",
        "ua",
        "ubank",
        "ubs",
        "ug",
        "uk",
        "unicom",
        "university",
        "uno",
        "uol",
        "ups",
        "us",
        "uy",
        "uz",
        "va",
        "vacations",
        "vana",
        "vanguard",
        "vc",
        "ve",
        "vegas",
        "ventures",
        "verisign",
        "verm\xF6gensberater",
        "verm\xF6gensberatung",
        "versicherung",
        "vet",
        "vg",
        "vi",
        "viajes",
        "video",
        "vig",
        "viking",
        "villas",
        "vin",
        "vip",
        "virgin",
        "visa",
        "vision",
        "viva",
        "vivo",
        "vlaanderen",
        "vn",
        "vodka",
        "volkswagen",
        "volvo",
        "vote",
        "voting",
        "voto",
        "voyage",
        "vu",
        "vuelos",
        "wales",
        "walmart",
        "walter",
        "wang",
        "wanggou",
        "watch",
        "watches",
        "weather",
        "weatherchannel",
        "webcam",
        "weber",
        "website",
        "wed",
        "wedding",
        "weibo",
        "weir",
        "wf",
        "whoswho",
        "wien",
        "wiki",
        "williamhill",
        "win",
        "windows",
        "wine",
        "winners",
        "wme",
        "wolterskluwer",
        "woodside",
        "work",
        "works",
        "world",
        "wow",
        "ws",
        "wtc",
        "wtf",
        "xbox",
        "xerox",
        "xfinity",
        "xihuan",
        "xin",
        "xxx",
        "xyz",
        "yachts",
        "yahoo",
        "yamaxun",
        "yandex",
        "ye",
        "yodobashi",
        "yoga",
        "yokohama",
        "you",
        "youtube",
        "yt",
        "yun",
        "za",
        "zappos",
        "zara",
        "zero",
        "zip",
        "zm",
        "zone",
        "zuerich",
        "zw",
        "\u03B5\u03BB",
        "\u03B5\u03C5",
        "\u0431\u0433",
        "\u0431\u0435\u043B",
        "\u0434\u0435\u0442\u0438",
        "\u0435\u044E",
        "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
        "\u043A\u043E\u043C",
        "\u043C\u043A\u0434",
        "\u043C\u043E\u043D",
        "\u043C\u043E\u0441\u043A\u0432\u0430",
        "\u043E\u043D\u043B\u0430\u0439\u043D",
        "\u043E\u0440\u0433",
        "\u0440\u0443\u0441",
        "\u0440\u0444",
        "\u0441\u0430\u0439\u0442",
        "\u0441\u0440\u0431",
        "\u0443\u043A\u0440",
        "\u049B\u0430\u0437",
        "\u0570\u0561\u0575",
        "\u05D9\u05E9\u05E8\u05D0\u05DC",
        "\u05E7\u05D5\u05DD",
        "\u0627\u0628\u0648\u0638\u0628\u064A",
        "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
        "\u0627\u0631\u0627\u0645\u0643\u0648",
        "\u0627\u0644\u0627\u0631\u062F\u0646",
        "\u0627\u0644\u0628\u062D\u0631\u064A\u0646",
        "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
        "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
        "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
        "\u0627\u0644\u0645\u063A\u0631\u0628",
        "\u0627\u0645\u0627\u0631\u0627\u062A",
        "\u0627\u06CC\u0631\u0627\u0646",
        "\u0628\u0627\u0631\u062A",
        "\u0628\u0627\u0632\u0627\u0631",
        "\u0628\u064A\u062A\u0643",
        "\u0628\u06BE\u0627\u0631\u062A",
        "\u062A\u0648\u0646\u0633",
        "\u0633\u0648\u062F\u0627\u0646",
        "\u0633\u0648\u0631\u064A\u0629",
        "\u0634\u0628\u0643\u0629",
        "\u0639\u0631\u0627\u0642",
        "\u0639\u0631\u0628",
        "\u0639\u0645\u0627\u0646",
        "\u0641\u0644\u0633\u0637\u064A\u0646",
        "\u0642\u0637\u0631",
        "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
        "\u0643\u0648\u0645",
        "\u0645\u0635\u0631",
        "\u0645\u0644\u064A\u0633\u064A\u0627",
        "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
        "\u0645\u0648\u0642\u0639",
        "\u0647\u0645\u0631\u0627\u0647",
        "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
        "\u0680\u0627\u0631\u062A",
        "\u0915\u0949\u092E",
        "\u0928\u0947\u091F",
        "\u092D\u093E\u0930\u0924",
        "\u092D\u093E\u0930\u0924\u092E\u094D",
        "\u092D\u093E\u0930\u094B\u0924",
        "\u0938\u0902\u0917\u0920\u0928",
        "\u09AC\u09BE\u0982\u09B2\u09BE",
        "\u09AD\u09BE\u09B0\u09A4",
        "\u09AD\u09BE\u09F0\u09A4",
        "\u0A2D\u0A3E\u0A30\u0A24",
        "\u0AAD\u0ABE\u0AB0\u0AA4",
        "\u0B2D\u0B3E\u0B30\u0B24",
        "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
        "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
        "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
        "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
        "\u0CAD\u0CBE\u0CB0\u0CA4",
        "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
        "\u0DBD\u0D82\u0D9A\u0DCF",
        "\u0E04\u0E2D\u0E21",
        "\u0E44\u0E17\u0E22",
        "\u0EA5\u0EB2\u0EA7",
        "\u10D2\u10D4",
        "\u307F\u3093\u306A",
        "\u30A2\u30DE\u30BE\u30F3",
        "\u30AF\u30E9\u30A6\u30C9",
        "\u30B0\u30FC\u30B0\u30EB",
        "\u30B3\u30E0",
        "\u30B9\u30C8\u30A2",
        "\u30BB\u30FC\u30EB",
        "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
        "\u30DD\u30A4\u30F3\u30C8",
        "\u4E16\u754C",
        "\u4E2D\u4FE1",
        "\u4E2D\u56FD",
        "\u4E2D\u570B",
        "\u4E2D\u6587\u7F51",
        "\u4E9A\u9A6C\u900A",
        "\u4F01\u4E1A",
        "\u4F5B\u5C71",
        "\u4FE1\u606F",
        "\u5065\u5EB7",
        "\u516B\u5366",
        "\u516C\u53F8",
        "\u516C\u76CA",
        "\u53F0\u6E7E",
        "\u53F0\u7063",
        "\u5546\u57CE",
        "\u5546\u5E97",
        "\u5546\u6807",
        "\u5609\u91CC",
        "\u5609\u91CC\u5927\u9152\u5E97",
        "\u5728\u7EBF",
        "\u5927\u62FF",
        "\u5929\u4E3B\u6559",
        "\u5A31\u4E50",
        "\u5BB6\u96FB",
        "\u5E7F\u4E1C",
        "\u5FAE\u535A",
        "\u6148\u5584",
        "\u6211\u7231\u4F60",
        "\u624B\u673A",
        "\u62DB\u8058",
        "\u653F\u52A1",
        "\u653F\u5E9C",
        "\u65B0\u52A0\u5761",
        "\u65B0\u95FB",
        "\u65F6\u5C1A",
        "\u66F8\u7C4D",
        "\u673A\u6784",
        "\u6DE1\u9A6C\u9521",
        "\u6E38\u620F",
        "\u6FB3\u9580",
        "\u70B9\u770B",
        "\u79FB\u52A8",
        "\u7EC4\u7EC7\u673A\u6784",
        "\u7F51\u5740",
        "\u7F51\u5E97",
        "\u7F51\u7AD9",
        "\u7F51\u7EDC",
        "\u8054\u901A",
        "\u8BFA\u57FA\u4E9A",
        "\u8C37\u6B4C",
        "\u8D2D\u7269",
        "\u901A\u8CA9",
        "\u96C6\u56E2",
        "\u96FB\u8A0A\u76C8\u79D1",
        "\u98DE\u5229\u6D66",
        "\u98DF\u54C1",
        "\u9910\u5385",
        "\u9999\u683C\u91CC\u62C9",
        "\u9999\u6E2F",
        "\uB2F7\uB137",
        "\uB2F7\uCEF4",
        "\uC0BC\uC131",
        "\uD55C\uAD6D"
      ];
      function detectFacets(text) {
        var _a;
        let match;
        const facets = [];
        {
          const re = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
          while (match = re.exec(text.utf16)) {
            if (!isValidDomain(match[3]) && !match[3].endsWith(".test")) {
              continue;
            }
            const start = text.utf16.indexOf(match[3], match.index) - 1;
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(start),
                byteEnd: text.utf16IndexToUtf8Index(start + match[3].length + 1)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#mention",
                  did: match[3]
                }
              ]
            });
          }
        }
        {
          const re = new RegExp("(^|\\s|\\()((https?:\\/\\/[\\S]+)|((?<domain>[a-z][a-z0-9]*(\\.[a-z0-9]+)+)[\\S]*))", "gim");
          while (match = re.exec(text.utf16)) {
            let uri2 = match[2];
            if (!uri2.startsWith("http")) {
              const domain = (_a = match.groups) == null ? void 0 : _a.domain;
              if (!domain || !isValidDomain(domain)) {
                continue;
              }
              uri2 = `https://${uri2}`;
            }
            const start = text.utf16.indexOf(match[2], match.index);
            const index = { start, end: start + match[2].length };
            if (/[.,;:!?]$/.test(uri2)) {
              uri2 = uri2.slice(0, -1);
              index.end--;
            }
            if (/[)]$/.test(uri2) && !uri2.includes("(")) {
              uri2 = uri2.slice(0, -1);
              index.end--;
            }
            facets.push({
              index: {
                byteStart: text.utf16IndexToUtf8Index(index.start),
                byteEnd: text.utf16IndexToUtf8Index(index.end)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#link",
                  uri: uri2
                }
              ]
            });
          }
        }
        {
          const re = /(?:^|\s)(#[^\d\s]\S*)(?=\s)?/g;
          while (match = re.exec(text.utf16)) {
            let [tag] = match;
            const hasLeadingSpace = /^\s/.test(tag);
            tag = tag.trim().replace(new RegExp("\\p{P}+$", "gu"), "");
            if (tag.length > 66)
              continue;
            const index = match.index + (hasLeadingSpace ? 1 : 0);
            facets.push({
              index: {
                byteStart: text.utf16IndexToUtf8Index(index),
                byteEnd: text.utf16IndexToUtf8Index(index + tag.length)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#tag",
                  tag: tag.replace(/^#/, "")
                }
              ]
            });
          }
        }
        return facets.length > 0 ? facets : void 0;
      }
      function isValidDomain(str) {
        return !!tlds_default.find((tld) => {
          const i = str.lastIndexOf(tld);
          if (i === -1) {
            return false;
          }
          return str.charAt(i - 1) === "." && i === str.length - tld.length;
        });
      }
      var RichTextSegment = class {
        constructor(text, facet) {
          this.text = text;
          this.facet = facet;
        }
        get link() {
          var _a;
          const link = (_a = this.facet) == null ? void 0 : _a.features.find(facet_exports.isLink);
          if (facet_exports.isLink(link)) {
            return link;
          }
          return void 0;
        }
        isLink() {
          return !!this.link;
        }
        get mention() {
          var _a;
          const mention = (_a = this.facet) == null ? void 0 : _a.features.find(facet_exports.isMention);
          if (facet_exports.isMention(mention)) {
            return mention;
          }
          return void 0;
        }
        isMention() {
          return !!this.mention;
        }
        get tag() {
          var _a;
          const tag = (_a = this.facet) == null ? void 0 : _a.features.find(facet_exports.isTag);
          if (facet_exports.isTag(tag)) {
            return tag;
          }
          return void 0;
        }
        isTag() {
          return !!this.tag;
        }
      };
      var RichText = class {
        constructor(props, opts) {
          var _a, _b;
          this.unicodeText = new UnicodeString(props.text);
          this.facets = props.facets;
          if (!((_a = this.facets) == null ? void 0 : _a.length) && ((_b = props.entities) == null ? void 0 : _b.length)) {
            this.facets = entitiesToFacets(this.unicodeText, props.entities);
          }
          if (this.facets) {
            this.facets.sort(facetSort);
          }
          if (opts == null ? void 0 : opts.cleanNewlines) {
            sanitizeRichText(this, { cleanNewlines: true }).copyInto(this);
          }
        }
        get text() {
          return this.unicodeText.toString();
        }
        get length() {
          return this.unicodeText.length;
        }
        get graphemeLength() {
          return this.unicodeText.graphemeLength;
        }
        clone() {
          return new RichText({
            text: this.unicodeText.utf16,
            facets: cloneDeep(this.facets)
          });
        }
        copyInto(target) {
          target.unicodeText = this.unicodeText;
          target.facets = cloneDeep(this.facets);
        }
        *segments() {
          const facets = this.facets || [];
          if (!facets.length) {
            yield new RichTextSegment(this.unicodeText.utf16);
            return;
          }
          let textCursor = 0;
          let facetCursor = 0;
          do {
            const currFacet = facets[facetCursor];
            if (textCursor < currFacet.index.byteStart) {
              yield new RichTextSegment(this.unicodeText.slice(textCursor, currFacet.index.byteStart));
            } else if (textCursor > currFacet.index.byteStart) {
              facetCursor++;
              continue;
            }
            if (currFacet.index.byteStart < currFacet.index.byteEnd) {
              const subtext = this.unicodeText.slice(currFacet.index.byteStart, currFacet.index.byteEnd);
              if (!subtext.trim()) {
                yield new RichTextSegment(subtext);
              } else {
                yield new RichTextSegment(subtext, currFacet);
              }
            }
            textCursor = currFacet.index.byteEnd;
            facetCursor++;
          } while (facetCursor < facets.length);
          if (textCursor < this.unicodeText.length) {
            yield new RichTextSegment(this.unicodeText.slice(textCursor, this.unicodeText.length));
          }
        }
        insert(insertIndex, insertText) {
          var _a;
          this.unicodeText = new UnicodeString(this.unicodeText.slice(0, insertIndex) + insertText + this.unicodeText.slice(insertIndex));
          if (!((_a = this.facets) == null ? void 0 : _a.length)) {
            return this;
          }
          const numCharsAdded = insertText.length;
          for (const ent of this.facets) {
            if (insertIndex <= ent.index.byteStart) {
              ent.index.byteStart += numCharsAdded;
              ent.index.byteEnd += numCharsAdded;
            } else if (insertIndex >= ent.index.byteStart && insertIndex < ent.index.byteEnd) {
              ent.index.byteEnd += numCharsAdded;
            }
          }
          return this;
        }
        delete(removeStartIndex, removeEndIndex) {
          var _a;
          this.unicodeText = new UnicodeString(this.unicodeText.slice(0, removeStartIndex) + this.unicodeText.slice(removeEndIndex));
          if (!((_a = this.facets) == null ? void 0 : _a.length)) {
            return this;
          }
          const numCharsRemoved = removeEndIndex - removeStartIndex;
          for (const ent of this.facets) {
            if (removeStartIndex <= ent.index.byteStart && removeEndIndex >= ent.index.byteEnd) {
              ent.index.byteStart = 0;
              ent.index.byteEnd = 0;
            } else if (removeStartIndex > ent.index.byteEnd) {
            } else if (removeStartIndex > ent.index.byteStart && removeStartIndex <= ent.index.byteEnd && removeEndIndex > ent.index.byteEnd) {
              ent.index.byteEnd = removeStartIndex;
            } else if (removeStartIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
              ent.index.byteEnd -= numCharsRemoved;
            } else if (removeStartIndex < ent.index.byteStart && removeEndIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
              ent.index.byteStart = removeStartIndex;
              ent.index.byteEnd -= numCharsRemoved;
            } else if (removeEndIndex < ent.index.byteStart) {
              ent.index.byteStart -= numCharsRemoved;
              ent.index.byteEnd -= numCharsRemoved;
            }
          }
          this.facets = this.facets.filter((ent) => ent.index.byteStart < ent.index.byteEnd);
          return this;
        }
        detectFacets(agent) {
          return __async(this, null, function* () {
            this.facets = detectFacets(this.unicodeText);
            if (this.facets) {
              for (const facet of this.facets) {
                for (const feature of facet.features) {
                  if (facet_exports.isMention(feature)) {
                    const did2 = yield agent.resolveHandle({ handle: feature.did }).catch((_) => void 0).then((res) => res == null ? void 0 : res.data.did);
                    feature.did = did2 || "";
                  }
                }
              }
              this.facets.sort(facetSort);
            }
          });
        }
        detectFacetsWithoutResolution() {
          this.facets = detectFacets(this.unicodeText);
          if (this.facets) {
            this.facets.sort(facetSort);
          }
        }
      };
      var facetSort = (a, b) => a.index.byteStart - b.index.byteStart;
      function entitiesToFacets(text, entities) {
        const facets = [];
        for (const ent of entities) {
          if (ent.type === "link") {
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(ent.index.start),
                byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
              },
              features: [{ $type: "app.bsky.richtext.facet#link", uri: ent.value }]
            });
          } else if (ent.type === "mention") {
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(ent.index.start),
                byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
              },
              features: [
                { $type: "app.bsky.richtext.facet#mention", did: ent.value }
              ]
            });
          }
        }
        return facets;
      }
      function cloneDeep(v) {
        if (typeof v === "undefined") {
          return v;
        }
        return JSON.parse(JSON.stringify(v));
      }
      var ModerationDecision = class {
        constructor(cause = void 0, alert = false, blur = false, blurMedia = false, filter = false, noOverride = false, additionalCauses = [], did2 = "") {
          this.cause = cause;
          this.alert = alert;
          this.blur = blur;
          this.blurMedia = blurMedia;
          this.filter = filter;
          this.noOverride = noOverride;
          this.additionalCauses = additionalCauses;
          this.did = did2;
        }
        static noop() {
          return new ModerationDecision();
        }
      };
      var LABELS = {
        "!hide": {
          id: "!hide",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Hide",
                description: "Moderator has chosen to hide the content."
              }
            },
            account: {
              en: {
                name: "Content Blocked",
                description: "This account has been hidden by the moderators."
              }
            },
            content: {
              en: {
                name: "Content Blocked",
                description: "This content has been hidden by the moderators."
              }
            }
          }
        },
        "!no-promote": {
          id: "!no-promote",
          preferences: ["hide"],
          flags: [],
          onwarn: null,
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Filter",
                description: "Moderator has chosen to filter the content from feeds."
              }
            },
            account: {
              en: {
                name: "N/A",
                description: "N/A"
              }
            },
            content: {
              en: {
                name: "N/A",
                description: "N/A"
              }
            }
          }
        },
        "!warn": {
          id: "!warn",
          preferences: ["warn"],
          flags: [],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Warn",
                description: "Moderator has chosen to set a general warning on the content."
              }
            },
            account: {
              en: {
                name: "Content Warning",
                description: "This account has received a general warning from moderators."
              }
            },
            content: {
              en: {
                name: "Content Warning",
                description: "This content has received a general warning from moderators."
              }
            }
          }
        },
        "!no-unauthenticated": {
          id: "!no-unauthenticated",
          preferences: ["hide"],
          flags: ["no-override", "unauthed"],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their account only be shown to signed-in users."
              }
            },
            account: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their account only be shown to signed-in users."
              }
            },
            content: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their content only be shown to signed-in users."
              }
            }
          }
        },
        "dmca-violation": {
          id: "dmca-violation",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "legal",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Copyright Violation",
                description: "The content has received a DMCA takedown request."
              }
            },
            account: {
              en: {
                name: "Copyright Violation",
                description: "This account has received a DMCA takedown request. It will be restored if the concerns can be resolved."
              }
            },
            content: {
              en: {
                name: "Copyright Violation",
                description: "This content has received a DMCA takedown request. It will be restored if the concerns can be resolved."
              }
            }
          }
        },
        doxxing: {
          id: "doxxing",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "legal",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Doxxing",
                description: "Information that reveals private information about someone which has been shared without the consent of the subject."
              }
            },
            account: {
              en: {
                name: "Doxxing",
                description: "This account has been reported to publish private information about someone without their consent. This report is currently under review."
              }
            },
            content: {
              en: {
                name: "Doxxing",
                description: "This content has been reported to include private information about someone without their consent."
              }
            }
          }
        },
        porn: {
          id: "porn",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Pornography",
                description: "Images of full-frontal nudity (genitalia) in any sexualized context, or explicit sexual activity (meaning contact with genitalia or breasts) even if partially covered. Includes graphic sexual cartoons (often jokes/memes)."
              }
            },
            account: {
              en: {
                name: "Adult Content",
                description: "This account contains imagery of full-frontal nudity or explicit sexual activity."
              }
            },
            content: {
              en: {
                name: "Adult Content",
                description: "This content contains imagery of full-frontal nudity or explicit sexual activity."
              }
            }
          }
        },
        sexual: {
          id: "sexual",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Sexually Suggestive",
                description: 'Content that does not meet the level of "pornography", but is still sexual. Some common examples have been selfies and "hornyposting" with underwear on, or partially naked (naked but covered, eg with hands or from side perspective). Sheer/see-through nipples may end up in this category.'
              }
            },
            account: {
              en: {
                name: "Suggestive Content",
                description: "This account contains imagery which is sexually suggestive. Common examples include selfies in underwear or in partial undress."
              }
            },
            content: {
              en: {
                name: "Suggestive Content",
                description: "This content contains imagery which is sexually suggestive. Common examples include selfies in underwear or in partial undress."
              }
            }
          }
        },
        nudity: {
          id: "nudity",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Nudity",
                description: 'Nudity which is not sexual, or that is primarily "artistic" in nature. For example: breastfeeding; classic art paintings and sculptures; newspaper images with some nudity; fashion modeling. "Erotic photography" is likely to end up in sexual or porn.'
              }
            },
            account: {
              en: {
                name: "Adult Content",
                description: "This account contains imagery which portrays nudity in a non-sexual or artistic setting."
              }
            },
            content: {
              en: {
                name: "Adult Content",
                description: "This content contains imagery which portrays nudity in a non-sexual or artistic setting."
              }
            }
          }
        },
        nsfl: {
          id: "nsfl",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "NSFL",
                description: `"Not Suitable For Life." This includes graphic images like the infamous "goatse" (don't look it up).`
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (NSFL)",
                description: 'This account contains graphic images which are often referred to as "Not Suitable For Life."'
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (NSFL)",
                description: 'This content contains graphic images which are often referred to as "Not Suitable For Life."'
              }
            }
          }
        },
        corpse: {
          id: "corpse",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Corpse",
                description: "Visual image of a dead human body in any context. Includes war images, hanging, funeral caskets. Does not include all figurative cases (cartoons), but can include realistic figurative images or renderings."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Corpse)",
                description: "This account contains images of a dead human body in any context. Includes war images, hanging, funeral caskets."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Corpse)",
                description: "This content contains images of a dead human body in any context. Includes war images, hanging, funeral caskets."
              }
            }
          }
        },
        gore: {
          id: "gore",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Gore",
                description: "Intended for shocking images, typically involving blood or visible wounds."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Gore)",
                description: "This account contains shocking images involving blood or visible wounds."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Gore)",
                description: "This content contains shocking images involving blood or visible wounds."
              }
            }
          }
        },
        torture: {
          id: "torture",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Torture",
                description: "Depictions of torture of a human or animal (animal cruelty)."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Torture)",
                description: "This account contains depictions of torture of a human or animal."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Torture)",
                description: "This content contains depictions of torture of a human or animal."
              }
            }
          }
        },
        "self-harm": {
          id: "self-harm",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Self-Harm",
                description: "A visual depiction (photo or figurative) of cutting, suicide, or similar."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Self-Harm)",
                description: "This account includes depictions of cutting, suicide, or other forms of self-harm."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Self-Harm)",
                description: "This content includes depictions of cutting, suicide, or other forms of self-harm."
              }
            }
          }
        },
        "intolerant-race": {
          id: "intolerant-race",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Racial Intolerance",
                description: "Hateful or intolerant content related to race."
              }
            },
            account: {
              en: {
                name: "Intolerance (Racial)",
                description: "This account includes hateful or intolerant content related to race."
              }
            },
            content: {
              en: {
                name: "Intolerance (Racial)",
                description: "This content includes hateful or intolerant views related to race."
              }
            }
          }
        },
        "intolerant-gender": {
          id: "intolerant-gender",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Gender Intolerance",
                description: "Hateful or intolerant content related to gender or gender identity."
              }
            },
            account: {
              en: {
                name: "Intolerance (Gender)",
                description: "This account includes hateful or intolerant content related to gender or gender identity."
              }
            },
            content: {
              en: {
                name: "Intolerance (Gender)",
                description: "This content includes hateful or intolerant views related to gender or gender identity."
              }
            }
          }
        },
        "intolerant-sexual-orientation": {
          id: "intolerant-sexual-orientation",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Sexual Orientation Intolerance",
                description: "Hateful or intolerant content related to sexual preferences."
              }
            },
            account: {
              en: {
                name: "Intolerance (Orientation)",
                description: "This account includes hateful or intolerant content related to sexual preferences."
              }
            },
            content: {
              en: {
                name: "Intolerance (Orientation)",
                description: "This content includes hateful or intolerant views related to sexual preferences."
              }
            }
          }
        },
        "intolerant-religion": {
          id: "intolerant-religion",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Religious Intolerance",
                description: "Hateful or intolerant content related to religious views or practices."
              }
            },
            account: {
              en: {
                name: "Intolerance (Religious)",
                description: "This account includes hateful or intolerant content related to religious views or practices."
              }
            },
            content: {
              en: {
                name: "Intolerance (Religious)",
                description: "This content includes hateful or intolerant views related to religious views or practices."
              }
            }
          }
        },
        intolerant: {
          id: "intolerant",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Intolerance",
                description: "A catchall for hateful or intolerant content which is not covered elsewhere."
              }
            },
            account: {
              en: {
                name: "Intolerance",
                description: "This account includes hateful or intolerant content."
              }
            },
            content: {
              en: {
                name: "Intolerance",
                description: "This content includes hateful or intolerant views."
              }
            }
          }
        },
        "icon-intolerant": {
          id: "icon-intolerant",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur-media",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Intolerant Iconography",
                description: "Visual imagery associated with a hate group, such as the KKK or Nazi, in any context (supportive, critical, documentary, etc)."
              }
            },
            account: {
              en: {
                name: "Intolerant Iconography",
                description: "This account includes imagery associated with a hate group such as the KKK or Nazis. This warning may apply to content any context, including critical or documentary purposes."
              }
            },
            content: {
              en: {
                name: "Intolerant Iconography",
                description: "This content includes imagery associated with a hate group such as the KKK or Nazis. This warning may apply to content any context, including critical or documentary purposes."
              }
            }
          }
        },
        threat: {
          id: "threat",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "rude",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Threats",
                description: "Statements or imagery published with the intent to threaten, intimidate, or harm."
              }
            },
            account: {
              en: {
                name: "Threats",
                description: "The moderators believe this account has published statements or imagery with the intent to threaten, intimidate, or harm others."
              }
            },
            content: {
              en: {
                name: "Threats",
                description: "The moderators believe this content was published with the intent to threaten, intimidate, or harm others."
              }
            }
          }
        },
        spoiler: {
          id: "spoiler",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "curation",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Spoiler",
                description: "Discussion about film, TV, etc which gives away plot points."
              }
            },
            account: {
              en: {
                name: "Spoiler Warning",
                description: "This account contains discussion about film, TV, etc which gives away plot points."
              }
            },
            content: {
              en: {
                name: "Spoiler Warning",
                description: "This content contains discussion about film, TV, etc which gives away plot points."
              }
            }
          }
        },
        spam: {
          id: "spam",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "spam",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Spam",
                description: "Repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            },
            account: {
              en: {
                name: "Spam",
                description: "This account publishes repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            },
            content: {
              en: {
                name: "Spam",
                description: "This content is a part of repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            }
          }
        },
        "account-security": {
          id: "account-security",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Security Concerns",
                description: "Content designed to hijack user accounts such as a phishing attack."
              }
            },
            account: {
              en: {
                name: "Security Warning",
                description: "This account has published content designed to hijack user accounts such as a phishing attack."
              }
            },
            content: {
              en: {
                name: "Security Warning",
                description: "This content is designed to hijack user accounts such as a phishing attack."
              }
            }
          }
        },
        "net-abuse": {
          id: "net-abuse",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Network Attacks",
                description: "Content designed to attack network systems such as denial-of-service attacks."
              }
            },
            account: {
              en: {
                name: "Network Attack Warning",
                description: "This account has published content designed to attack network systems such as denial-of-service attacks."
              }
            },
            content: {
              en: {
                name: "Network Attack Warning",
                description: "This content is designed to attack network systems such as denial-of-service attacks."
              }
            }
          }
        },
        impersonation: {
          id: "impersonation",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Impersonation",
                description: "Accounts which falsely assert some identity."
              }
            },
            account: {
              en: {
                name: "Impersonation Warning",
                description: "The moderators believe this account is lying about their identity."
              }
            },
            content: {
              en: {
                name: "Impersonation Warning",
                description: "The moderators believe this account is lying about their identity."
              }
            }
          }
        },
        scam: {
          id: "scam",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Scam",
                description: "Fraudulent content."
              }
            },
            account: {
              en: {
                name: "Scam Warning",
                description: "The moderators believe this account publishes fraudulent content."
              }
            },
            content: {
              en: {
                name: "Scam Warning",
                description: "The moderators believe this is fraudulent content."
              }
            }
          }
        },
        misleading: {
          id: "misleading",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Misleading",
                description: "Accounts which share misleading information."
              }
            },
            account: {
              en: {
                name: "Misleading",
                description: "The moderators believe this account is spreading misleading information."
              }
            },
            content: {
              en: {
                name: "Misleading",
                description: "The moderators believe this account is spreading misleading information."
              }
            }
          }
        }
      };
      var ModerationCauseAccumulator = class {
        constructor() {
          this.did = "";
          this.causes = [];
        }
        setDid(did2) {
          this.did = did2;
        }
        addBlocking(blocking) {
          if (blocking) {
            this.causes.push({
              type: "blocking",
              source: { type: "user" },
              priority: 3
            });
          }
        }
        addBlockingByList(blockingByList) {
          if (blockingByList) {
            this.causes.push({
              type: "blocking",
              source: { type: "list", list: blockingByList },
              priority: 3
            });
          }
        }
        addBlockedBy(blockedBy) {
          if (blockedBy) {
            this.causes.push({
              type: "blocked-by",
              source: { type: "user" },
              priority: 4
            });
          }
        }
        addBlockOther(blockOther) {
          if (blockOther) {
            this.causes.push({
              type: "block-other",
              source: { type: "user" },
              priority: 4
            });
          }
        }
        addLabel(label, opts) {
          const labelDef = LABELS[label.val];
          if (!labelDef) {
            return;
          }
          const isSelf = label.src === this.did;
          const labeler = isSelf ? void 0 : opts.labelers.find((s) => s.labeler.did === label.src);
          let labelPref = "ignore";
          if (!labelDef.configurable) {
            labelPref = labelDef.preferences[0];
          } else if (labelDef.flags.includes("adult") && !opts.adultContentEnabled) {
            labelPref = "hide";
          } else if (labeler == null ? void 0 : labeler.labels[label.val]) {
            labelPref = labeler.labels[label.val];
          } else if (opts.labels[label.val]) {
            labelPref = opts.labels[label.val];
          }
          if (labelPref === "ignore") {
            return;
          }
          if (labelDef.flags.includes("unauthed") && !!opts.userDid) {
            return;
          }
          let priority;
          if (labelDef.flags.includes("no-override")) {
            priority = 1;
          } else if (labelPref === "hide") {
            priority = 2;
          } else if (labelDef.onwarn === "blur") {
            priority = 5;
          } else if (labelDef.onwarn === "blur-media") {
            priority = 7;
          } else {
            priority = 8;
          }
          this.causes.push({
            type: "label",
            source: isSelf || !labeler ? { type: "user" } : { type: "labeler", labeler: labeler.labeler },
            label,
            labelDef,
            setting: labelPref,
            priority
          });
        }
        addMuted(muted) {
          if (muted) {
            this.causes.push({
              type: "muted",
              source: { type: "user" },
              priority: 6
            });
          }
        }
        addMutedByList(mutedByList) {
          if (mutedByList) {
            this.causes.push({
              type: "muted",
              source: { type: "list", list: mutedByList },
              priority: 6
            });
          }
        }
        finalizeDecision(opts) {
          const mod = new ModerationDecision();
          mod.did = this.did;
          if (!this.causes.length) {
            return mod;
          }
          this.causes.sort((a, b) => a.priority - b.priority);
          mod.cause = this.causes[0];
          mod.additionalCauses = this.causes.slice(1);
          if (mod.cause.type === "blocking" || mod.cause.type === "blocked-by" || mod.cause.type === "block-other") {
            mod.filter = true;
            mod.blur = true;
            mod.noOverride = true;
          } else if (mod.cause.type === "muted") {
            mod.filter = true;
            mod.blur = true;
          } else if (mod.cause.type === "label") {
            if (mod.cause.setting === "hide") {
              mod.filter = true;
            }
            switch (mod.cause.labelDef.onwarn) {
              case "alert":
                mod.alert = true;
                break;
              case "blur":
                mod.blur = true;
                break;
              case "blur-media":
                mod.blurMedia = true;
                break;
              case null:
                break;
            }
            if (mod.cause.labelDef.flags.includes("no-override")) {
              mod.noOverride = true;
            } else if (mod.cause.labelDef.flags.includes("adult") && !opts.adultContentEnabled) {
              mod.noOverride = true;
            }
          }
          return mod;
        }
      };
      function decideAccount(subject, opts) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.did);
        if ((_a = subject.viewer) == null ? void 0 : _a.muted) {
          if ((_b = subject.viewer) == null ? void 0 : _b.mutedByList) {
            acc.addMutedByList((_c = subject.viewer) == null ? void 0 : _c.mutedByList);
          } else {
            acc.addMuted((_d = subject.viewer) == null ? void 0 : _d.muted);
          }
        }
        if ((_e = subject.viewer) == null ? void 0 : _e.blocking) {
          if ((_f = subject.viewer) == null ? void 0 : _f.blockingByList) {
            acc.addBlockingByList((_g = subject.viewer) == null ? void 0 : _g.blockingByList);
          } else {
            acc.addBlocking((_h = subject.viewer) == null ? void 0 : _h.blocking);
          }
        }
        acc.addBlockedBy((_i = subject.viewer) == null ? void 0 : _i.blockedBy);
        for (const label of filterAccountLabels(subject.labels)) {
          acc.addLabel(label, opts);
        }
        return acc.finalizeDecision(opts);
      }
      function filterAccountLabels(labels) {
        if (!labels) {
          return [];
        }
        return labels.filter((label) => !label.uri.endsWith("/app.bsky.actor.profile/self") || label.val === "!no-unauthenticated");
      }
      function decideProfile(subject, opts) {
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.did);
        for (const label of filterProfileLabels(subject.labels)) {
          acc.addLabel(label, opts);
        }
        return acc.finalizeDecision(opts);
      }
      function filterProfileLabels(labels) {
        if (!labels) {
          return [];
        }
        return labels.filter((label) => label.uri.endsWith("/app.bsky.actor.profile/self"));
      }
      function decidePost(subject, opts) {
        var _a;
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.author.did);
        if ((_a = subject.labels) == null ? void 0 : _a.length) {
          for (const label of subject.labels) {
            acc.addLabel(label, opts);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPost(subject, opts) {
        var _a, _b, _c, _d, _e;
        const acc = new ModerationCauseAccumulator();
        if (record_exports.isViewRecord(subject.record)) {
          acc.setDid(subject.record.author.did);
          if ((_a = subject.record.labels) == null ? void 0 : _a.length) {
            for (const label of subject.record.labels) {
              acc.addLabel(label, opts);
            }
          }
        } else if (record_exports.isViewBlocked(subject.record)) {
          acc.setDid(subject.record.author.did);
          if ((_b = subject.record.author.viewer) == null ? void 0 : _b.blocking) {
            acc.addBlocking((_c = subject.record.author.viewer) == null ? void 0 : _c.blocking);
          } else if ((_d = subject.record.author.viewer) == null ? void 0 : _d.blockedBy) {
            acc.addBlockedBy((_e = subject.record.author.viewer) == null ? void 0 : _e.blockedBy);
          } else {
            acc.addBlockOther(true);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPostAccount(subject, opts) {
        if (record_exports.isViewRecord(subject.record)) {
          return decideAccount(subject.record.author, opts);
        }
        return ModerationDecision.noop();
      }
      function decideQuotedPostWithMedia(subject, opts) {
        var _a, _b, _c, _d, _e;
        const acc = new ModerationCauseAccumulator();
        if (record_exports.isViewRecord(subject.record.record)) {
          acc.setDid(subject.record.record.author.did);
          if ((_a = subject.record.record.labels) == null ? void 0 : _a.length) {
            for (const label of subject.record.record.labels) {
              acc.addLabel(label, opts);
            }
          }
        } else if (record_exports.isViewBlocked(subject.record.record)) {
          acc.setDid(subject.record.record.author.did);
          if ((_b = subject.record.record.author.viewer) == null ? void 0 : _b.blocking) {
            acc.addBlocking((_c = subject.record.record.author.viewer) == null ? void 0 : _c.blocking);
          } else if ((_d = subject.record.record.author.viewer) == null ? void 0 : _d.blockedBy) {
            acc.addBlockedBy((_e = subject.record.record.author.viewer) == null ? void 0 : _e.blockedBy);
          } else {
            acc.addBlockOther(true);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPostWithMediaAccount(subject, opts) {
        if (record_exports.isViewRecord(subject.record.record)) {
          return decideAccount(subject.record.record.author, opts);
        }
        return ModerationDecision.noop();
      }
      function decideFeedGenerator(_subject, _opts) {
        return ModerationDecision.noop();
      }
      function decideUserList(_subject, _opts) {
        return ModerationDecision.noop();
      }
      function takeHighestPriorityDecision(...decisions) {
        const filtered = decisions.filter((d) => !!d);
        if (filtered.length === 0) {
          return ModerationDecision.noop();
        }
        filtered.sort((a, b) => {
          if (a.cause && b.cause) {
            return a.cause.priority - b.cause.priority;
          }
          if (a.cause) {
            return -1;
          }
          if (b.cause) {
            return 1;
          }
          return 0;
        });
        return filtered[0];
      }
      function downgradeDecision(decision, to) {
        decision.filter = false;
        decision.noOverride = false;
        if (to === "noop") {
          decision.blur = false;
          decision.blurMedia = false;
          decision.alert = false;
          delete decision.cause;
        } else if (to === "alert") {
          decision.blur = false;
          decision.blurMedia = false;
          decision.alert = true;
        }
      }
      function isModerationDecisionNoop(decision, { ignoreFilter } = { ignoreFilter: false }) {
        if (!decision) {
          return true;
        }
        if (decision.alert) {
          return false;
        }
        if (decision.blur) {
          return false;
        }
        if (decision.filter && !ignoreFilter) {
          return false;
        }
        return true;
      }
      function isQuotedPost(embed) {
        return Boolean(embed && record_exports.isView(embed));
      }
      function isQuotedPostWithMedia(embed) {
        return Boolean(embed && recordWithMedia_exports.isView(embed));
      }
      function toModerationUI(decision) {
        return {
          cause: decision.cause,
          filter: decision.filter,
          blur: decision.blur,
          alert: decision.alert,
          noOverride: decision.noOverride
        };
      }
      function moderateProfile(subject, opts) {
        var _a, _b, _c, _d;
        const account = decideAccount(subject, opts);
        const profile = decideProfile(subject, opts);
        if (account.blurMedia) {
          account.blur = true;
        }
        profile.filter = false;
        if (!isModerationDecisionNoop(account) && account.did === opts.userDid) {
          downgradeDecision(account, "alert");
        }
        if (!isModerationDecisionNoop(profile) && profile.did === opts.userDid) {
          downgradeDecision(profile, "alert");
        }
        let avatarBlur = false;
        let avatarNoOverride = false;
        if ((account.blur || account.blurMedia) && ((_a = account.cause) == null ? void 0 : _a.type) !== "muted") {
          avatarBlur = true;
          avatarNoOverride = account.noOverride || profile.noOverride;
        } else if (profile.blur || profile.blurMedia) {
          avatarBlur = true;
          avatarNoOverride = account.noOverride || profile.noOverride;
        }
        if (((_b = account.cause) == null ? void 0 : _b.type) === "blocking" || ((_c = account.cause) == null ? void 0 : _c.type) === "blocked-by" || ((_d = account.cause) == null ? void 0 : _d.type) === "muted") {
          account.blur = false;
          account.noOverride = false;
        }
        return {
          decisions: { account, profile },
          account: account.filter || account.blur || account.alert ? toModerationUI(account) : {},
          profile: profile.filter || profile.blur || profile.alert ? toModerationUI(profile) : {},
          avatar: {
            blur: avatarBlur,
            alert: account.alert || profile.alert,
            noOverride: avatarNoOverride
          }
        };
      }
      function moderatePost(subject, opts) {
        var _a, _b;
        const post = decidePost(subject, opts);
        const account = decideAccount(subject.author, opts);
        const profile = decideProfile(subject.author, opts);
        let quote;
        let quotedAccount;
        if (isQuotedPost(subject.embed)) {
          quote = decideQuotedPost(subject.embed, opts);
          quotedAccount = decideQuotedPostAccount(subject.embed, opts);
        } else if (isQuotedPostWithMedia(subject.embed)) {
          quote = decideQuotedPostWithMedia(subject.embed, opts);
          quotedAccount = decideQuotedPostWithMediaAccount(subject.embed, opts);
        }
        if (quote == null ? void 0 : quote.blurMedia) {
          quote.blur = true;
        }
        if (!isModerationDecisionNoop(post) && post.did === opts.userDid) {
          downgradeDecision(post, "blur");
        }
        if (account.cause && account.did === opts.userDid) {
          downgradeDecision(account, "noop");
        }
        if (profile.cause && profile.did === opts.userDid) {
          downgradeDecision(profile, "noop");
        }
        if (quote && !isModerationDecisionNoop(quote) && quote.did === opts.userDid) {
          downgradeDecision(quote, "blur");
        }
        if (quotedAccount && !isModerationDecisionNoop(quotedAccount) && quotedAccount.did === opts.userDid) {
          downgradeDecision(quotedAccount, "noop");
        }
        const mergedForFeed = takeHighestPriorityDecision(post, account, quote, quotedAccount);
        const mergedForView = takeHighestPriorityDecision(post, account);
        const mergedQuote = takeHighestPriorityDecision(quote, quotedAccount);
        let blurAvatar = false;
        if ((account.blur || account.blurMedia) && ((_a = account.cause) == null ? void 0 : _a.type) !== "muted") {
          blurAvatar = true;
        } else if ((profile.blur || profile.blurMedia) && ((_b = profile.cause) == null ? void 0 : _b.type) !== "muted") {
          blurAvatar = true;
        }
        return {
          decisions: { post, account, profile, quote, quotedAccount },
          content: {
            cause: !isModerationDecisionNoop(mergedForView) ? mergedForView.cause : mergedForFeed.filter ? mergedForFeed.cause : void 0,
            filter: mergedForFeed.filter,
            blur: mergedForView.blur,
            alert: mergedForView.alert,
            noOverride: mergedForView.noOverride
          },
          avatar: {
            blur: blurAvatar,
            alert: account.alert || profile.alert,
            noOverride: account.noOverride || profile.noOverride
          },
          embed: !isModerationDecisionNoop(mergedQuote, { ignoreFilter: true }) ? {
            cause: mergedQuote.cause,
            blur: mergedQuote.blur,
            alert: mergedQuote.alert,
            noOverride: mergedQuote.noOverride
          } : account.blurMedia ? {
            cause: account.cause,
            blur: true,
            noOverride: account.noOverride
          } : post.blurMedia ? {
            cause: post.cause,
            blur: true,
            noOverride: post.noOverride
          } : {}
        };
      }
      function moderateFeedGenerator(subject, opts) {
        const feedGenerator = decideFeedGenerator(subject, opts);
        const account = decideAccount(subject.creator, opts);
        const profile = decideProfile(subject.creator, opts);
        const merged = takeHighestPriorityDecision(feedGenerator, account);
        return {
          decisions: { feedGenerator, account, profile },
          content: {
            cause: isModerationDecisionNoop(merged) ? void 0 : merged.cause,
            filter: merged.filter,
            blur: merged.blur,
            alert: merged.alert,
            noOverride: merged.noOverride
          },
          avatar: {
            blur: account.blurMedia || profile.blurMedia,
            alert: account.alert,
            noOverride: account.noOverride || profile.noOverride
          }
        };
      }
      function moderateUserList(subject, opts) {
        const userList = decideUserList(subject, opts);
        const account = defs_exports5.isProfileViewBasic(subject.creator) ? decideAccount(subject.creator, opts) : ModerationDecision.noop();
        const profile = defs_exports5.isProfileViewBasic(subject.creator) ? decideProfile(subject.creator, opts) : ModerationDecision.noop();
        const merged = takeHighestPriorityDecision(userList, account);
        return {
          decisions: { userList, account, profile },
          content: {
            cause: isModerationDecisionNoop(merged) ? void 0 : merged.cause,
            filter: merged.filter,
            blur: merged.blur,
            alert: merged.alert,
            noOverride: merged.noOverride
          },
          avatar: {
            blur: account.blurMedia || profile.blurMedia,
            alert: account.alert,
            noOverride: account.noOverride || profile.noOverride
          }
        };
      }
      var LABEL_GROUPS = {
        system: {
          id: "system",
          configurable: false,
          labels: [
            LABELS["!hide"],
            LABELS["!no-promote"],
            LABELS["!warn"],
            LABELS["!no-unauthenticated"]
          ],
          strings: {
            settings: {
              en: {
                name: "System",
                description: "Moderator overrides for special cases."
              }
            }
          }
        },
        legal: {
          id: "legal",
          configurable: false,
          labels: [LABELS["dmca-violation"], LABELS["doxxing"]],
          strings: {
            settings: {
              en: {
                name: "Legal",
                description: "Content removed for legal reasons."
              }
            }
          }
        },
        sexual: {
          id: "sexual",
          configurable: true,
          labels: [LABELS["porn"], LABELS["sexual"], LABELS["nudity"]],
          strings: {
            settings: {
              en: {
                name: "Adult Content",
                description: "Content which is sexual in nature."
              }
            }
          }
        },
        violence: {
          id: "violence",
          configurable: true,
          labels: [
            LABELS["nsfl"],
            LABELS["corpse"],
            LABELS["gore"],
            LABELS["torture"],
            LABELS["self-harm"]
          ],
          strings: {
            settings: {
              en: {
                name: "Violence",
                description: "Content which is violent or deeply disturbing."
              }
            }
          }
        },
        intolerance: {
          id: "intolerance",
          configurable: true,
          labels: [
            LABELS["intolerant-race"],
            LABELS["intolerant-gender"],
            LABELS["intolerant-sexual-orientation"],
            LABELS["intolerant-religion"],
            LABELS["intolerant"],
            LABELS["icon-intolerant"]
          ],
          strings: {
            settings: {
              en: {
                name: "Intolerance",
                description: "Content or behavior which is hateful or intolerant toward a group of people."
              }
            }
          }
        },
        rude: {
          id: "rude",
          configurable: true,
          labels: [LABELS["threat"]],
          strings: {
            settings: {
              en: {
                name: "Rude",
                description: "Behavior which is rude toward other users."
              }
            }
          }
        },
        curation: {
          id: "curation",
          configurable: true,
          labels: [LABELS["spoiler"]],
          strings: {
            settings: {
              en: {
                name: "Curational",
                description: "Subjective moderation geared towards curating a more positive environment."
              }
            }
          }
        },
        spam: {
          id: "spam",
          configurable: true,
          labels: [LABELS["spam"]],
          strings: {
            settings: {
              en: {
                name: "Spam",
                description: "Content which doesn't add to the conversation."
              }
            }
          }
        },
        misinfo: {
          id: "misinfo",
          configurable: true,
          labels: [
            LABELS["account-security"],
            LABELS["net-abuse"],
            LABELS["impersonation"],
            LABELS["scam"],
            LABELS["misleading"]
          ],
          strings: {
            settings: {
              en: {
                name: "Misinformation",
                description: "Content which misleads or defrauds users."
              }
            }
          }
        }
      };
      var FEED_VIEW_PREF_DEFAULTS = {
        hideReplies: false,
        hideRepliesByUnfollowed: false,
        hideRepliesByLikeCount: 0,
        hideReposts: false,
        hideQuotePosts: false
      };
      var THREAD_VIEW_PREF_DEFAULTS = {
        sort: "oldest",
        prioritizeFollowedUsers: true
      };
      var BskyAgent2 = class extends AtpAgent {
        constructor() {
          super(...arguments);
          this.getTimeline = (params2, opts) => this.api.app.bsky.feed.getTimeline(params2, opts);
          this.getAuthorFeed = (params2, opts) => this.api.app.bsky.feed.getAuthorFeed(params2, opts);
          this.getActorLikes = (params2, opts) => this.api.app.bsky.feed.getActorLikes(params2, opts);
          this.getPostThread = (params2, opts) => this.api.app.bsky.feed.getPostThread(params2, opts);
          this.getPost = (params2) => this.api.app.bsky.feed.post.get(params2);
          this.getPosts = (params2, opts) => this.api.app.bsky.feed.getPosts(params2, opts);
          this.getLikes = (params2, opts) => this.api.app.bsky.feed.getLikes(params2, opts);
          this.getRepostedBy = (params2, opts) => this.api.app.bsky.feed.getRepostedBy(params2, opts);
          this.getFollows = (params2, opts) => this.api.app.bsky.graph.getFollows(params2, opts);
          this.getFollowers = (params2, opts) => this.api.app.bsky.graph.getFollowers(params2, opts);
          this.getProfile = (params2, opts) => this.api.app.bsky.actor.getProfile(params2, opts);
          this.getProfiles = (params2, opts) => this.api.app.bsky.actor.getProfiles(params2, opts);
          this.getSuggestions = (params2, opts) => this.api.app.bsky.actor.getSuggestions(params2, opts);
          this.searchActors = (params2, opts) => this.api.app.bsky.actor.searchActors(params2, opts);
          this.searchActorsTypeahead = (params2, opts) => this.api.app.bsky.actor.searchActorsTypeahead(params2, opts);
          this.listNotifications = (params2, opts) => this.api.app.bsky.notification.listNotifications(params2, opts);
          this.countUnreadNotifications = (params2, opts) => this.api.app.bsky.notification.getUnreadCount(params2, opts);
        }
        get app() {
          return this.api.app;
        }
        post(record) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            record.createdAt = record.createdAt || (/* @__PURE__ */ new Date()).toISOString();
            return this.api.app.bsky.feed.post.create({ repo: this.session.did }, record);
          });
        }
        deletePost(postUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const postUrip = new AtUri(postUri);
            return yield this.api.app.bsky.feed.post.delete({
              repo: postUrip.hostname,
              rkey: postUrip.rkey
            });
          });
        }
        like(uri2, cid2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
              subject: { uri: uri2, cid: cid2 },
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteLike(likeUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const likeUrip = new AtUri(likeUri);
            return yield this.api.app.bsky.feed.like.delete({
              repo: likeUrip.hostname,
              rkey: likeUrip.rkey
            });
          });
        }
        repost(uri2, cid2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
              subject: { uri: uri2, cid: cid2 },
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteRepost(repostUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const repostUrip = new AtUri(repostUri);
            return yield this.api.app.bsky.feed.repost.delete({
              repo: repostUrip.hostname,
              rkey: repostUrip.rkey
            });
          });
        }
        follow(subjectDid) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
              subject: subjectDid,
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteFollow(followUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const followUrip = new AtUri(followUri);
            return yield this.api.app.bsky.graph.follow.delete({
              repo: followUrip.hostname,
              rkey: followUrip.rkey
            });
          });
        }
        upsertProfile(updateFn) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            let retriesRemaining = 5;
            while (retriesRemaining >= 0) {
              const existing = yield this.com.atproto.repo.getRecord({
                repo: this.session.did,
                collection: "app.bsky.actor.profile",
                rkey: "self"
              }).catch((_) => void 0);
              const updated = yield updateFn(existing == null ? void 0 : existing.data.value);
              if (updated) {
                updated.$type = "app.bsky.actor.profile";
              }
              const validation = profile_exports.validateRecord(updated);
              if (!validation.success) {
                throw validation.error;
              }
              try {
                yield this.com.atproto.repo.putRecord({
                  repo: this.session.did,
                  collection: "app.bsky.actor.profile",
                  rkey: "self",
                  record: updated,
                  swapRecord: (existing == null ? void 0 : existing.data.cid) || null
                });
              } catch (e) {
                if (retriesRemaining > 0 && e instanceof putRecord_exports.InvalidSwapError) {
                  retriesRemaining--;
                  continue;
                } else {
                  throw e;
                }
              }
              break;
            }
          });
        }
        mute(actor) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.muteActor({ actor });
          });
        }
        unmute(actor) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.unmuteActor({ actor });
          });
        }
        muteModList(uri2) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.muteActorList({
              list: uri2
            });
          });
        }
        unmuteModList(uri2) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.unmuteActorList({
              list: uri2
            });
          });
        }
        blockModList(uri2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
              subject: uri2,
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        unblockModList(uri2) {
          return __async(this, null, function* () {
            var _a;
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const listInfo = yield this.api.app.bsky.graph.getList({
              list: uri2,
              limit: 1
            });
            if (!((_a = listInfo.data.list.viewer) == null ? void 0 : _a.blocked)) {
              return;
            }
            const { rkey } = new AtUri(listInfo.data.list.viewer.blocked);
            return yield this.api.app.bsky.graph.listblock.delete({
              repo: this.session.did,
              rkey
            });
          });
        }
        updateSeenNotifications(seenAt) {
          return __async(this, null, function* () {
            seenAt = seenAt || (/* @__PURE__ */ new Date()).toISOString();
            return this.api.app.bsky.notification.updateSeen({
              seenAt
            });
          });
        }
        getPreferences() {
          return __async(this, null, function* () {
            const prefs = {
              feeds: {
                saved: void 0,
                pinned: void 0
              },
              feedViewPrefs: {
                home: __spreadValues({}, FEED_VIEW_PREF_DEFAULTS)
              },
              threadViewPrefs: __spreadValues({}, THREAD_VIEW_PREF_DEFAULTS),
              adultContentEnabled: false,
              contentLabels: {},
              birthDate: void 0
            };
            const res = yield this.app.bsky.actor.getPreferences({});
            for (const pref of res.data.preferences) {
              if (defs_exports5.isAdultContentPref(pref) && defs_exports5.validateAdultContentPref(pref).success) {
                prefs.adultContentEnabled = pref.enabled;
              } else if (defs_exports5.isContentLabelPref(pref) && defs_exports5.validateAdultContentPref(pref).success) {
                let value = pref.visibility;
                if (value === "show") {
                  value = "ignore";
                }
                if (value === "ignore" || value === "warn" || value === "hide") {
                  prefs.contentLabels[pref.label] = value;
                }
              } else if (defs_exports5.isSavedFeedsPref(pref) && defs_exports5.validateSavedFeedsPref(pref).success) {
                prefs.feeds.saved = pref.saved;
                prefs.feeds.pinned = pref.pinned;
              } else if (defs_exports5.isPersonalDetailsPref(pref) && defs_exports5.validatePersonalDetailsPref(pref).success) {
                if (pref.birthDate) {
                  prefs.birthDate = new Date(pref.birthDate);
                }
              } else if (defs_exports5.isFeedViewPref(pref) && defs_exports5.validateFeedViewPref(pref).success) {
                const _a = pref, { $type, feed } = _a, v = __objRest(_a, ["$type", "feed"]);
                prefs.feedViewPrefs[pref.feed] = __spreadValues(__spreadValues({}, FEED_VIEW_PREF_DEFAULTS), v);
              } else if (defs_exports5.isThreadViewPref(pref) && defs_exports5.validateThreadViewPref(pref).success) {
                const _b = pref, { $type } = _b, v = __objRest(_b, ["$type"]);
                prefs.threadViewPrefs = __spreadValues(__spreadValues({}, prefs.threadViewPrefs), v);
              }
            }
            return prefs;
          });
        }
        setSavedFeeds(saved, pinned) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, () => ({
              saved,
              pinned
            }));
          });
        }
        addSavedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: [...saved.filter((uri2) => uri2 !== v), v],
              pinned
            }));
          });
        }
        removeSavedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: saved.filter((uri2) => uri2 !== v),
              pinned: pinned.filter((uri2) => uri2 !== v)
            }));
          });
        }
        addPinnedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: [...saved.filter((uri2) => uri2 !== v), v],
              pinned: [...pinned.filter((uri2) => uri2 !== v), v]
            }));
          });
        }
        removePinnedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved,
              pinned: pinned.filter((uri2) => uri2 !== v)
            }));
          });
        }
        setAdultContentEnabled(v) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              let adultContentPref = prefs.findLast((pref) => defs_exports5.isAdultContentPref(pref) && defs_exports5.validateAdultContentPref(pref).success);
              if (adultContentPref) {
                adultContentPref.enabled = v;
              } else {
                adultContentPref = {
                  $type: "app.bsky.actor.defs#adultContentPref",
                  enabled: v
                };
              }
              return prefs.filter((pref) => !defs_exports5.isAdultContentPref(pref)).concat([adultContentPref]);
            });
          });
        }
        setContentLabelPref(key, value) {
          return __async(this, null, function* () {
            if (value === "show") {
              value = "ignore";
            }
            yield updatePreferences(this, (prefs) => {
              let labelPref = prefs.findLast((pref) => defs_exports5.isContentLabelPref(pref) && defs_exports5.validateAdultContentPref(pref).success && pref.label === key);
              if (labelPref) {
                labelPref.visibility = value;
              } else {
                labelPref = {
                  $type: "app.bsky.actor.defs#contentLabelPref",
                  label: key,
                  visibility: value
                };
              }
              return prefs.filter((pref) => !defs_exports5.isContentLabelPref(pref) || pref.label !== key).concat([labelPref]);
            });
          });
        }
        setPersonalDetails(_0) {
          return __async(this, arguments, function* ({
            birthDate
          }) {
            birthDate = birthDate instanceof Date ? birthDate.toISOString() : birthDate;
            yield updatePreferences(this, (prefs) => {
              let personalDetailsPref = prefs.findLast((pref) => defs_exports5.isPersonalDetailsPref(pref) && defs_exports5.validatePersonalDetailsPref(pref).success);
              if (personalDetailsPref) {
                personalDetailsPref.birthDate = birthDate;
              } else {
                personalDetailsPref = {
                  $type: "app.bsky.actor.defs#personalDetailsPref",
                  birthDate
                };
              }
              return prefs.filter((pref) => !defs_exports5.isPersonalDetailsPref(pref)).concat([personalDetailsPref]);
            });
          });
        }
        setFeedViewPrefs(feed, pref) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              const existing = prefs.findLast((pref2) => defs_exports5.isFeedViewPref(pref2) && defs_exports5.validateFeedViewPref(pref2).success && pref2.feed === feed);
              if (existing) {
                pref = __spreadValues(__spreadValues({}, existing), pref);
              }
              return prefs.filter((p) => !defs_exports5.isFeedViewPref(pref) || p.feed !== feed).concat([__spreadProps(__spreadValues({}, pref), { $type: "app.bsky.actor.defs#feedViewPref", feed })]);
            });
          });
        }
        setThreadViewPrefs(pref) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              const existing = prefs.findLast((pref2) => defs_exports5.isThreadViewPref(pref2) && defs_exports5.validateThreadViewPref(pref2).success);
              if (existing) {
                pref = __spreadValues(__spreadValues({}, existing), pref);
              }
              return prefs.filter((p) => !defs_exports5.isThreadViewPref(p)).concat([__spreadProps(__spreadValues({}, pref), { $type: "app.bsky.actor.defs#threadViewPref" })]);
            });
          });
        }
      };
      function updatePreferences(agent, cb) {
        return __async(this, null, function* () {
          const res = yield agent.app.bsky.actor.getPreferences({});
          const newPrefs = cb(res.data.preferences);
          if (newPrefs === false) {
            return;
          }
          yield agent.app.bsky.actor.putPreferences({
            preferences: newPrefs
          });
        });
      }
      function updateFeedPreferences(agent, cb) {
        return __async(this, null, function* () {
          let res;
          yield updatePreferences(agent, (prefs) => {
            let feedsPref = prefs.findLast((pref) => defs_exports5.isSavedFeedsPref(pref) && defs_exports5.validateSavedFeedsPref(pref).success);
            if (feedsPref) {
              res = cb(feedsPref.saved, feedsPref.pinned);
              feedsPref.saved = res.saved;
              feedsPref.pinned = res.pinned;
            } else {
              res = cb([], []);
              feedsPref = {
                $type: "app.bsky.actor.defs#savedFeedsPref",
                saved: res.saved,
                pinned: res.pinned
              };
            }
            return prefs.filter((pref) => !defs_exports5.isSavedFeedsPref(pref)).concat([feedsPref]);
          });
          return res;
        });
      }
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24);
        const hi = this[++offset] + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + last * __pow(2, 24);
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
        const lo = this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * __pow(2, 8) + this[offset + 6] * __pow(2, 16) + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24));
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > __pow(2, 32)) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > __pow(BigInt(2), BigInt(32)) || input < -__pow(BigInt(2), BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/@atproto/repo/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/@atproto/repo/dist/index.js"(exports, module) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod2) => function __require2() {
        return mod2 || (0, cb[__getOwnPropNames2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
      };
      var __export = (target2, all) => {
        for (var name3 in all)
          __defProp2(target2, name3, { get: all[name3], enumerable: true });
      };
      var __copyProps2 = (to, from3, except, desc) => {
        if (from3 && typeof from3 === "object" || typeof from3 === "function") {
          for (let key of __getOwnPropNames2(from3))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc2(from3, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod2, isNodeMode, target2) => (target2 = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target2, "default", { value: mod2, enumerable: true }) : target2, mod2));
      var __toCommonJS = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
      var require_boundaries = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/boundaries.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.EXTENDED_PICTOGRAPHIC = exports2.CLUSTER_BREAK = void 0;
          var CLUSTER_BREAK;
          (function(CLUSTER_BREAK2) {
            CLUSTER_BREAK2[CLUSTER_BREAK2["CR"] = 0] = "CR";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LF"] = 1] = "LF";
            CLUSTER_BREAK2[CLUSTER_BREAK2["CONTROL"] = 2] = "CONTROL";
            CLUSTER_BREAK2[CLUSTER_BREAK2["EXTEND"] = 3] = "EXTEND";
            CLUSTER_BREAK2[CLUSTER_BREAK2["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
            CLUSTER_BREAK2[CLUSTER_BREAK2["SPACINGMARK"] = 5] = "SPACINGMARK";
            CLUSTER_BREAK2[CLUSTER_BREAK2["L"] = 6] = "L";
            CLUSTER_BREAK2[CLUSTER_BREAK2["V"] = 7] = "V";
            CLUSTER_BREAK2[CLUSTER_BREAK2["T"] = 8] = "T";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LV"] = 9] = "LV";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LVT"] = 10] = "LVT";
            CLUSTER_BREAK2[CLUSTER_BREAK2["OTHER"] = 11] = "OTHER";
            CLUSTER_BREAK2[CLUSTER_BREAK2["PREPEND"] = 12] = "PREPEND";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE"] = 13] = "E_BASE";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_MODIFIER"] = 14] = "E_MODIFIER";
            CLUSTER_BREAK2[CLUSTER_BREAK2["ZWJ"] = 15] = "ZWJ";
            CLUSTER_BREAK2[CLUSTER_BREAK2["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
          })(CLUSTER_BREAK = exports2.CLUSTER_BREAK || (exports2.CLUSTER_BREAK = {}));
          exports2.EXTENDED_PICTOGRAPHIC = 101;
        }
      });
      var require_GraphemerHelper = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerHelper.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var boundaries_1 = require_boundaries();
          var NotBreak = 0;
          var BreakStart = 1;
          var Break = 2;
          var BreakLastRegional = 3;
          var BreakPenultimateRegional = 4;
          var GraphemerHelper = class {
            static isSurrogate(str, pos) {
              return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
            }
            static codePointAt(str, idx) {
              if (idx === void 0) {
                idx = 0;
              }
              const code4 = str.charCodeAt(idx);
              if (55296 <= code4 && code4 <= 56319 && idx < str.length - 1) {
                const hi = code4;
                const low = str.charCodeAt(idx + 1);
                if (56320 <= low && low <= 57343) {
                  return (hi - 55296) * 1024 + (low - 56320) + 65536;
                }
                return hi;
              }
              if (56320 <= code4 && code4 <= 57343 && idx >= 1) {
                const hi = str.charCodeAt(idx - 1);
                const low = code4;
                if (55296 <= hi && hi <= 56319) {
                  return (hi - 55296) * 1024 + (low - 56320) + 65536;
                }
                return low;
              }
              return code4;
            }
            static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
              const all = [start].concat(mid).concat([end]);
              const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
              const previous = all[all.length - 2];
              const next = end;
              const nextEmoji = endEmoji;
              const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
              if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
              }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
                if (all.filter(function(c) {
                  return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                }).length % 2 === 1) {
                  return BreakLastRegional;
                } else {
                  return BreakPenultimateRegional;
                }
              }
              if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
                return NotBreak;
              } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
                return BreakStart;
              } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
                return BreakStart;
              } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
                return NotBreak;
              } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
                return NotBreak;
              } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
                return NotBreak;
              } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
                return NotBreak;
              } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
                return NotBreak;
              } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
                return NotBreak;
              }
              const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
              if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.EXTEND;
              }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
                return NotBreak;
              }
              if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
                return Break;
              }
              if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
                return NotBreak;
              }
              return BreakStart;
            }
          };
          exports2.default = GraphemerHelper;
        }
      });
      var require_GraphemerIterator = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerIterator.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var GraphemerIterator = class {
            constructor(str, nextBreak) {
              this._index = 0;
              this._str = str;
              this._nextBreak = nextBreak;
            }
            [Symbol.iterator]() {
              return this;
            }
            next() {
              let brk;
              if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
                const value = this._str.slice(this._index, brk);
                this._index = brk;
                return { value, done: false };
              }
              if (this._index < this._str.length) {
                const value = this._str.slice(this._index);
                this._index = this._str.length;
                return { value, done: false };
              }
              return { value: void 0, done: true };
            }
          };
          exports2.default = GraphemerIterator;
        }
      });
      var require_Graphemer = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/Graphemer.js"(exports2) {
          "use strict";
          var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
            return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var boundaries_1 = require_boundaries();
          var GraphemerHelper_1 = __importDefault(require_GraphemerHelper());
          var GraphemerIterator_1 = __importDefault(require_GraphemerIterator());
          var Graphemer2 = class {
            static nextBreak(string3, index) {
              if (index === void 0) {
                index = 0;
              }
              if (index < 0) {
                return 0;
              }
              if (index >= string3.length - 1) {
                return string3.length;
              }
              const prevCP = GraphemerHelper_1.default.codePointAt(string3, index);
              const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
              const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
              const mid = [];
              const midEmoji = [];
              for (let i = index + 1; i < string3.length; i++) {
                if (GraphemerHelper_1.default.isSurrogate(string3, i - 1)) {
                  continue;
                }
                const nextCP = GraphemerHelper_1.default.codePointAt(string3, i);
                const next = Graphemer2.getGraphemeBreakProperty(nextCP);
                const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
                if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
                  return i;
                }
                mid.push(next);
                midEmoji.push(nextEmoji);
              }
              return string3.length;
            }
            splitGraphemes(str) {
              const res = [];
              let index = 0;
              let brk;
              while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
                res.push(str.slice(index, brk));
                index = brk;
              }
              if (index < str.length) {
                res.push(str.slice(index));
              }
              return res;
            }
            iterateGraphemes(str) {
              return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
            }
            countGraphemes(str) {
              let count = 0;
              let index = 0;
              let brk;
              while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
                index = brk;
                count++;
              }
              if (index < str.length) {
                count++;
              }
              return count;
            }
            static getGraphemeBreakProperty(code4) {
              if (code4 < 48905) {
                if (code4 < 44116) {
                  if (code4 < 4141) {
                    if (code4 < 2818) {
                      if (code4 < 2363) {
                        if (code4 < 1759) {
                          if (code4 < 1471) {
                            if (code4 < 127) {
                              if (code4 < 11) {
                                if (code4 < 10) {
                                  if (0 <= code4 && code4 <= 9) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code4 === 10) {
                                    return boundaries_1.CLUSTER_BREAK.LF;
                                  }
                                }
                              } else {
                                if (code4 < 13) {
                                  if (11 <= code4 && code4 <= 12) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code4 < 14) {
                                    if (code4 === 13) {
                                      return boundaries_1.CLUSTER_BREAK.CR;
                                    }
                                  } else {
                                    if (14 <= code4 && code4 <= 31) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 768) {
                                if (code4 < 173) {
                                  if (127 <= code4 && code4 <= 159) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code4 === 173) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              } else {
                                if (code4 < 1155) {
                                  if (768 <= code4 && code4 <= 879) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 1425) {
                                    if (1155 <= code4 && code4 <= 1161) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (1425 <= code4 && code4 <= 1469) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 1552) {
                              if (code4 < 1476) {
                                if (code4 < 1473) {
                                  if (code4 === 1471) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1473 <= code4 && code4 <= 1474) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 1479) {
                                  if (1476 <= code4 && code4 <= 1477) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 1536) {
                                    if (code4 === 1479) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (1536 <= code4 && code4 <= 1541) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 1648) {
                                if (code4 < 1564) {
                                  if (1552 <= code4 && code4 <= 1562) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 1611) {
                                    if (code4 === 1564) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (1611 <= code4 && code4 <= 1631) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 1750) {
                                  if (code4 === 1648) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 1757) {
                                    if (1750 <= code4 && code4 <= 1756) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 1757) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 2075) {
                            if (code4 < 1840) {
                              if (code4 < 1770) {
                                if (code4 < 1767) {
                                  if (1759 <= code4 && code4 <= 1764) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1767 <= code4 && code4 <= 1768) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 1807) {
                                  if (1770 <= code4 && code4 <= 1773) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 1807) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                  if (code4 === 1809) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2027) {
                                if (code4 < 1958) {
                                  if (1840 <= code4 && code4 <= 1866) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1958 <= code4 && code4 <= 1968) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 2045) {
                                  if (2027 <= code4 && code4 <= 2035) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2070) {
                                    if (code4 === 2045) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2070 <= code4 && code4 <= 2073) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2200) {
                              if (code4 < 2089) {
                                if (code4 < 2085) {
                                  if (2075 <= code4 && code4 <= 2083) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2085 <= code4 && code4 <= 2087) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 2137) {
                                  if (2089 <= code4 && code4 <= 2093) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2192) {
                                    if (2137 <= code4 && code4 <= 2139) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2192 <= code4 && code4 <= 2193) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2275) {
                                if (code4 < 2250) {
                                  if (2200 <= code4 && code4 <= 2207) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2274) {
                                    if (2250 <= code4 && code4 <= 2273) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 2274) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 2307) {
                                  if (2275 <= code4 && code4 <= 2306) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 2307) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code4 === 2362) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2561) {
                          if (code4 < 2434) {
                            if (code4 < 2381) {
                              if (code4 < 2366) {
                                if (code4 === 2363) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code4 === 2364) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2369) {
                                  if (2366 <= code4 && code4 <= 2368) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 2377) {
                                    if (2369 <= code4 && code4 <= 2376) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2377 <= code4 && code4 <= 2380) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2385) {
                                if (code4 < 2382) {
                                  if (code4 === 2381) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2382 <= code4 && code4 <= 2383) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 2402) {
                                  if (2385 <= code4 && code4 <= 2391) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2433) {
                                    if (2402 <= code4 && code4 <= 2403) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 2433) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2503) {
                              if (code4 < 2494) {
                                if (code4 < 2492) {
                                  if (2434 <= code4 && code4 <= 2435) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 2492) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 2495) {
                                  if (code4 === 2494) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2497) {
                                    if (2495 <= code4 && code4 <= 2496) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2497 <= code4 && code4 <= 2500) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2519) {
                                if (code4 < 2507) {
                                  if (2503 <= code4 && code4 <= 2504) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 2509) {
                                    if (2507 <= code4 && code4 <= 2508) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 2509) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 2530) {
                                  if (code4 === 2519) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2558) {
                                    if (2530 <= code4 && code4 <= 2531) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 2558) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 2691) {
                            if (code4 < 2631) {
                              if (code4 < 2620) {
                                if (code4 < 2563) {
                                  if (2561 <= code4 && code4 <= 2562) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 2563) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 2622) {
                                  if (code4 === 2620) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2625) {
                                    if (2622 <= code4 && code4 <= 2624) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2625 <= code4 && code4 <= 2626) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2672) {
                                if (code4 < 2635) {
                                  if (2631 <= code4 && code4 <= 2632) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2641) {
                                    if (2635 <= code4 && code4 <= 2637) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 2641) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 2677) {
                                  if (2672 <= code4 && code4 <= 2673) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2689) {
                                    if (code4 === 2677) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2689 <= code4 && code4 <= 2690) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2761) {
                              if (code4 < 2750) {
                                if (code4 === 2691) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code4 === 2748) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2753) {
                                  if (2750 <= code4 && code4 <= 2752) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 2759) {
                                    if (2753 <= code4 && code4 <= 2757) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2759 <= code4 && code4 <= 2760) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2786) {
                                if (code4 < 2763) {
                                  if (code4 === 2761) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 2765) {
                                    if (2763 <= code4 && code4 <= 2764) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 2765) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 2810) {
                                  if (2786 <= code4 && code4 <= 2787) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2817) {
                                    if (2810 <= code4 && code4 <= 2815) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 2817) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 3315) {
                        if (code4 < 3076) {
                          if (code4 < 2946) {
                            if (code4 < 2887) {
                              if (code4 < 2878) {
                                if (code4 < 2876) {
                                  if (2818 <= code4 && code4 <= 2819) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 2876) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 2880) {
                                  if (2878 <= code4 && code4 <= 2879) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2881) {
                                    if (code4 === 2880) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2881 <= code4 && code4 <= 2884) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2893) {
                                if (code4 < 2891) {
                                  if (2887 <= code4 && code4 <= 2888) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2891 <= code4 && code4 <= 2892) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 2901) {
                                  if (code4 === 2893) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 2914) {
                                    if (2901 <= code4 && code4 <= 2903) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2914 <= code4 && code4 <= 2915) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3014) {
                              if (code4 < 3007) {
                                if (code4 === 2946) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code4 === 3006) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3008) {
                                  if (code4 === 3007) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 3009) {
                                    if (code4 === 3008) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3009 <= code4 && code4 <= 3010) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3031) {
                                if (code4 < 3018) {
                                  if (3014 <= code4 && code4 <= 3016) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 3021) {
                                    if (3018 <= code4 && code4 <= 3020) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 3021) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 3072) {
                                  if (code4 === 3031) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3073) {
                                    if (code4 === 3072) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3073 <= code4 && code4 <= 3075) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 3262) {
                            if (code4 < 3146) {
                              if (code4 < 3134) {
                                if (code4 === 3076) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code4 === 3132) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3137) {
                                  if (3134 <= code4 && code4 <= 3136) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3142) {
                                    if (3137 <= code4 && code4 <= 3140) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3142 <= code4 && code4 <= 3144) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3201) {
                                if (code4 < 3157) {
                                  if (3146 <= code4 && code4 <= 3149) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3170) {
                                    if (3157 <= code4 && code4 <= 3158) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3170 <= code4 && code4 <= 3171) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 3202) {
                                  if (code4 === 3201) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3260) {
                                    if (3202 <= code4 && code4 <= 3203) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 3260) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3270) {
                              if (code4 < 3264) {
                                if (code4 === 3262) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code4 === 3263) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3266) {
                                  if (3264 <= code4 && code4 <= 3265) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 3267) {
                                    if (code4 === 3266) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3267 <= code4 && code4 <= 3268) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3276) {
                                if (code4 < 3271) {
                                  if (code4 === 3270) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3274) {
                                    if (3271 <= code4 && code4 <= 3272) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3274 <= code4 && code4 <= 3275) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 3285) {
                                  if (3276 <= code4 && code4 <= 3277) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3298) {
                                    if (3285 <= code4 && code4 <= 3286) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3298 <= code4 && code4 <= 3299) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3551) {
                          if (code4 < 3406) {
                            if (code4 < 3391) {
                              if (code4 < 3330) {
                                if (code4 < 3328) {
                                  if (code4 === 3315) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3328 <= code4 && code4 <= 3329) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 3387) {
                                  if (3330 <= code4 && code4 <= 3331) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 3390) {
                                    if (3387 <= code4 && code4 <= 3388) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 3390) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3398) {
                                if (code4 < 3393) {
                                  if (3391 <= code4 && code4 <= 3392) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3393 <= code4 && code4 <= 3396) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 3402) {
                                  if (3398 <= code4 && code4 <= 3400) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 3405) {
                                    if (3402 <= code4 && code4 <= 3404) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 3405) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3530) {
                              if (code4 < 3426) {
                                if (code4 === 3406) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code4 === 3415) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3457) {
                                  if (3426 <= code4 && code4 <= 3427) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3458) {
                                    if (code4 === 3457) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3458 <= code4 && code4 <= 3459) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3538) {
                                if (code4 < 3535) {
                                  if (code4 === 3530) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3536) {
                                    if (code4 === 3535) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3536 <= code4 && code4 <= 3537) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 3542) {
                                  if (3538 <= code4 && code4 <= 3540) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3544) {
                                    if (code4 === 3542) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3544 <= code4 && code4 <= 3550) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 3893) {
                            if (code4 < 3655) {
                              if (code4 < 3633) {
                                if (code4 < 3570) {
                                  if (code4 === 3551) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3570 <= code4 && code4 <= 3571) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 3635) {
                                  if (code4 === 3633) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3636) {
                                    if (code4 === 3635) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3636 <= code4 && code4 <= 3642) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3764) {
                                if (code4 < 3761) {
                                  if (3655 <= code4 && code4 <= 3662) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 3761) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 3763) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 3784) {
                                  if (3764 <= code4 && code4 <= 3772) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3864) {
                                    if (3784 <= code4 && code4 <= 3790) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3864 <= code4 && code4 <= 3865) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3967) {
                              if (code4 < 3897) {
                                if (code4 === 3893) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code4 === 3895) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3902) {
                                  if (code4 === 3897) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 3953) {
                                    if (3902 <= code4 && code4 <= 3903) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3953 <= code4 && code4 <= 3966) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3981) {
                                if (code4 < 3968) {
                                  if (code4 === 3967) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 3974) {
                                    if (3968 <= code4 && code4 <= 3972) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3974 <= code4 && code4 <= 3975) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 3993) {
                                  if (3981 <= code4 && code4 <= 3991) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 4038) {
                                    if (3993 <= code4 && code4 <= 4028) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 4038) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 7204) {
                      if (code4 < 6448) {
                        if (code4 < 5938) {
                          if (code4 < 4226) {
                            if (code4 < 4157) {
                              if (code4 < 4146) {
                                if (code4 < 4145) {
                                  if (4141 <= code4 && code4 <= 4144) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 4145) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 4153) {
                                  if (4146 <= code4 && code4 <= 4151) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 4155) {
                                    if (4153 <= code4 && code4 <= 4154) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (4155 <= code4 && code4 <= 4156) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 4184) {
                                if (code4 < 4182) {
                                  if (4157 <= code4 && code4 <= 4158) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4182 <= code4 && code4 <= 4183) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 4190) {
                                  if (4184 <= code4 && code4 <= 4185) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 4209) {
                                    if (4190 <= code4 && code4 <= 4192) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (4209 <= code4 && code4 <= 4212) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 4352) {
                              if (code4 < 4229) {
                                if (code4 === 4226) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code4 === 4228) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 4237) {
                                  if (4229 <= code4 && code4 <= 4230) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 4237) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 4253) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 4957) {
                                if (code4 < 4448) {
                                  if (4352 <= code4 && code4 <= 4447) {
                                    return boundaries_1.CLUSTER_BREAK.L;
                                  }
                                } else {
                                  if (code4 < 4520) {
                                    if (4448 <= code4 && code4 <= 4519) {
                                      return boundaries_1.CLUSTER_BREAK.V;
                                    }
                                  } else {
                                    if (4520 <= code4 && code4 <= 4607) {
                                      return boundaries_1.CLUSTER_BREAK.T;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 5906) {
                                  if (4957 <= code4 && code4 <= 4959) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 5909) {
                                    if (5906 <= code4 && code4 <= 5908) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 5909) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 6089) {
                            if (code4 < 6070) {
                              if (code4 < 5970) {
                                if (code4 < 5940) {
                                  if (5938 <= code4 && code4 <= 5939) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 5940) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 6002) {
                                  if (5970 <= code4 && code4 <= 5971) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 6068) {
                                    if (6002 <= code4 && code4 <= 6003) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6068 <= code4 && code4 <= 6069) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 6078) {
                                if (code4 < 6071) {
                                  if (code4 === 6070) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (6071 <= code4 && code4 <= 6077) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 6086) {
                                  if (6078 <= code4 && code4 <= 6085) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 6087) {
                                    if (code4 === 6086) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6087 <= code4 && code4 <= 6088) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 6277) {
                              if (code4 < 6155) {
                                if (code4 < 6109) {
                                  if (6089 <= code4 && code4 <= 6099) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 6109) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 6158) {
                                  if (6155 <= code4 && code4 <= 6157) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 6158) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                  if (code4 === 6159) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 6435) {
                                if (code4 < 6313) {
                                  if (6277 <= code4 && code4 <= 6278) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 6432) {
                                    if (code4 === 6313) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6432 <= code4 && code4 <= 6434) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 6439) {
                                  if (6435 <= code4 && code4 <= 6438) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 6441) {
                                    if (6439 <= code4 && code4 <= 6440) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6441 <= code4 && code4 <= 6443) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 6971) {
                          if (code4 < 6744) {
                            if (code4 < 6681) {
                              if (code4 < 6451) {
                                if (code4 < 6450) {
                                  if (6448 <= code4 && code4 <= 6449) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 6450) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 6457) {
                                  if (6451 <= code4 && code4 <= 6456) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 6679) {
                                    if (6457 <= code4 && code4 <= 6459) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6679 <= code4 && code4 <= 6680) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 6741) {
                                if (code4 < 6683) {
                                  if (6681 <= code4 && code4 <= 6682) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 6683) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 6742) {
                                  if (code4 === 6741) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 6742) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 6743) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 6771) {
                              if (code4 < 6754) {
                                if (code4 < 6752) {
                                  if (6744 <= code4 && code4 <= 6750) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 6752) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 6757) {
                                  if (code4 === 6754) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 6765) {
                                    if (6757 <= code4 && code4 <= 6764) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6765 <= code4 && code4 <= 6770) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 6912) {
                                if (code4 < 6783) {
                                  if (6771 <= code4 && code4 <= 6780) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 6832) {
                                    if (code4 === 6783) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6832 <= code4 && code4 <= 6862) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 6916) {
                                  if (6912 <= code4 && code4 <= 6915) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 6964) {
                                    if (code4 === 6916) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (6964 <= code4 && code4 <= 6970) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 7080) {
                            if (code4 < 7019) {
                              if (code4 < 6973) {
                                if (code4 === 6971) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code4 === 6972) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 6978) {
                                  if (6973 <= code4 && code4 <= 6977) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 6979) {
                                    if (code4 === 6978) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6979 <= code4 && code4 <= 6980) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 7073) {
                                if (code4 < 7040) {
                                  if (7019 <= code4 && code4 <= 7027) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 7042) {
                                    if (7040 <= code4 && code4 <= 7041) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 7042) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 7074) {
                                  if (code4 === 7073) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 7078) {
                                    if (7074 <= code4 && code4 <= 7077) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7078 <= code4 && code4 <= 7079) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 7144) {
                              if (code4 < 7083) {
                                if (code4 < 7082) {
                                  if (7080 <= code4 && code4 <= 7081) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 7082) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 7142) {
                                  if (7083 <= code4 && code4 <= 7085) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 7142) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 7143) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 7150) {
                                if (code4 < 7146) {
                                  if (7144 <= code4 && code4 <= 7145) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 7149) {
                                    if (7146 <= code4 && code4 <= 7148) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 7149) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 7151) {
                                  if (code4 === 7150) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 7154) {
                                    if (7151 <= code4 && code4 <= 7153) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7154 <= code4 && code4 <= 7155) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 43346) {
                        if (code4 < 11647) {
                          if (code4 < 7415) {
                            if (code4 < 7380) {
                              if (code4 < 7220) {
                                if (code4 < 7212) {
                                  if (7204 <= code4 && code4 <= 7211) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7212 <= code4 && code4 <= 7219) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 7222) {
                                  if (7220 <= code4 && code4 <= 7221) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 7376) {
                                    if (7222 <= code4 && code4 <= 7223) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7376 <= code4 && code4 <= 7378) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 7394) {
                                if (code4 < 7393) {
                                  if (7380 <= code4 && code4 <= 7392) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 7393) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 7405) {
                                  if (7394 <= code4 && code4 <= 7400) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 7405) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 7412) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 8205) {
                              if (code4 < 7616) {
                                if (code4 < 7416) {
                                  if (code4 === 7415) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7416 <= code4 && code4 <= 7417) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 8203) {
                                  if (7616 <= code4 && code4 <= 7679) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 8203) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                  if (code4 === 8204) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 8288) {
                                if (code4 < 8206) {
                                  if (code4 === 8205) {
                                    return boundaries_1.CLUSTER_BREAK.ZWJ;
                                  }
                                } else {
                                  if (code4 < 8232) {
                                    if (8206 <= code4 && code4 <= 8207) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (8232 <= code4 && code4 <= 8238) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 8400) {
                                  if (8288 <= code4 && code4 <= 8303) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code4 < 11503) {
                                    if (8400 <= code4 && code4 <= 8432) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (11503 <= code4 && code4 <= 11505) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 43043) {
                            if (code4 < 42612) {
                              if (code4 < 12330) {
                                if (code4 < 11744) {
                                  if (code4 === 11647) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (11744 <= code4 && code4 <= 11775) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 12441) {
                                  if (12330 <= code4 && code4 <= 12335) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 42607) {
                                    if (12441 <= code4 && code4 <= 12442) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (42607 <= code4 && code4 <= 42610) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 43010) {
                                if (code4 < 42654) {
                                  if (42612 <= code4 && code4 <= 42621) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 42736) {
                                    if (42654 <= code4 && code4 <= 42655) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (42736 <= code4 && code4 <= 42737) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 43014) {
                                  if (code4 === 43010) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 43014) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 43019) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 43188) {
                              if (code4 < 43047) {
                                if (code4 < 43045) {
                                  if (43043 <= code4 && code4 <= 43044) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43045 <= code4 && code4 <= 43046) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 43052) {
                                  if (code4 === 43047) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 43136) {
                                    if (code4 === 43052) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43136 <= code4 && code4 <= 43137) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 43263) {
                                if (code4 < 43204) {
                                  if (43188 <= code4 && code4 <= 43203) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 43232) {
                                    if (43204 <= code4 && code4 <= 43205) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43232 <= code4 && code4 <= 43249) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 43302) {
                                  if (code4 === 43263) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 43335) {
                                    if (43302 <= code4 && code4 <= 43309) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43335 <= code4 && code4 <= 43345) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 43698) {
                          if (code4 < 43493) {
                            if (code4 < 43444) {
                              if (code4 < 43392) {
                                if (code4 < 43360) {
                                  if (43346 <= code4 && code4 <= 43347) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43360 <= code4 && code4 <= 43388) {
                                    return boundaries_1.CLUSTER_BREAK.L;
                                  }
                                }
                              } else {
                                if (code4 < 43395) {
                                  if (43392 <= code4 && code4 <= 43394) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 43395) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code4 === 43443) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 43450) {
                                if (code4 < 43446) {
                                  if (43444 <= code4 && code4 <= 43445) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43446 <= code4 && code4 <= 43449) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 43452) {
                                  if (43450 <= code4 && code4 <= 43451) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 43454) {
                                    if (43452 <= code4 && code4 <= 43453) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43454 <= code4 && code4 <= 43456) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 43573) {
                              if (code4 < 43567) {
                                if (code4 < 43561) {
                                  if (code4 === 43493) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43561 <= code4 && code4 <= 43566) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 43569) {
                                  if (43567 <= code4 && code4 <= 43568) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 43571) {
                                    if (43569 <= code4 && code4 <= 43570) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43571 <= code4 && code4 <= 43572) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 43597) {
                                if (code4 < 43587) {
                                  if (43573 <= code4 && code4 <= 43574) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 43587) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 43596) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 43644) {
                                  if (code4 === 43597) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 43644) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 43696) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 44006) {
                            if (code4 < 43756) {
                              if (code4 < 43710) {
                                if (code4 < 43703) {
                                  if (43698 <= code4 && code4 <= 43700) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43703 <= code4 && code4 <= 43704) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 43713) {
                                  if (43710 <= code4 && code4 <= 43711) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 43713) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 43755) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 43766) {
                                if (code4 < 43758) {
                                  if (43756 <= code4 && code4 <= 43757) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 43765) {
                                    if (43758 <= code4 && code4 <= 43759) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 43765) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 44003) {
                                  if (code4 === 43766) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 44005) {
                                    if (44003 <= code4 && code4 <= 44004) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 44005) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44032) {
                              if (code4 < 44009) {
                                if (code4 < 44008) {
                                  if (44006 <= code4 && code4 <= 44007) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 44008) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 44012) {
                                  if (44009 <= code4 && code4 <= 44010) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 44012) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code4 === 44013) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44061) {
                                if (code4 < 44033) {
                                  if (code4 === 44032) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44060) {
                                    if (44033 <= code4 && code4 <= 44059) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44060) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 44088) {
                                  if (44061 <= code4 && code4 <= 44087) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 44089) {
                                    if (code4 === 44088) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44089 <= code4 && code4 <= 44115) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 46497) {
                    if (code4 < 45293) {
                      if (code4 < 44704) {
                        if (code4 < 44397) {
                          if (code4 < 44256) {
                            if (code4 < 44173) {
                              if (code4 < 44144) {
                                if (code4 < 44117) {
                                  if (code4 === 44116) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44117 <= code4 && code4 <= 44143) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 44145) {
                                  if (code4 === 44144) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44172) {
                                    if (44145 <= code4 && code4 <= 44171) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44172) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44201) {
                                if (code4 < 44200) {
                                  if (44173 <= code4 && code4 <= 44199) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 44200) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 44228) {
                                  if (44201 <= code4 && code4 <= 44227) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 44229) {
                                    if (code4 === 44228) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44229 <= code4 && code4 <= 44255) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44313) {
                              if (code4 < 44284) {
                                if (code4 < 44257) {
                                  if (code4 === 44256) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44257 <= code4 && code4 <= 44283) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 44285) {
                                  if (code4 === 44284) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44312) {
                                    if (44285 <= code4 && code4 <= 44311) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44312) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44368) {
                                if (code4 < 44340) {
                                  if (44313 <= code4 && code4 <= 44339) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 44341) {
                                    if (code4 === 44340) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44341 <= code4 && code4 <= 44367) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 44369) {
                                  if (code4 === 44368) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44396) {
                                    if (44369 <= code4 && code4 <= 44395) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44396) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 44537) {
                            if (code4 < 44480) {
                              if (code4 < 44425) {
                                if (code4 < 44424) {
                                  if (44397 <= code4 && code4 <= 44423) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 44424) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 44452) {
                                  if (44425 <= code4 && code4 <= 44451) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 44453) {
                                    if (code4 === 44452) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44453 <= code4 && code4 <= 44479) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44508) {
                                if (code4 < 44481) {
                                  if (code4 === 44480) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44481 <= code4 && code4 <= 44507) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 44509) {
                                  if (code4 === 44508) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44536) {
                                    if (44509 <= code4 && code4 <= 44535) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44536) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44620) {
                              if (code4 < 44565) {
                                if (code4 < 44564) {
                                  if (44537 <= code4 && code4 <= 44563) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 44564) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 44592) {
                                  if (44565 <= code4 && code4 <= 44591) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 44593) {
                                    if (code4 === 44592) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44593 <= code4 && code4 <= 44619) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44649) {
                                if (code4 < 44621) {
                                  if (code4 === 44620) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44648) {
                                    if (44621 <= code4 && code4 <= 44647) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44648) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 44676) {
                                  if (44649 <= code4 && code4 <= 44675) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 44677) {
                                    if (code4 === 44676) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44677 <= code4 && code4 <= 44703) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44985) {
                          if (code4 < 44844) {
                            if (code4 < 44761) {
                              if (code4 < 44732) {
                                if (code4 < 44705) {
                                  if (code4 === 44704) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44705 <= code4 && code4 <= 44731) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 44733) {
                                  if (code4 === 44732) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44760) {
                                    if (44733 <= code4 && code4 <= 44759) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44760) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44789) {
                                if (code4 < 44788) {
                                  if (44761 <= code4 && code4 <= 44787) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 44788) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 44816) {
                                  if (44789 <= code4 && code4 <= 44815) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 44817) {
                                    if (code4 === 44816) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44817 <= code4 && code4 <= 44843) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44901) {
                              if (code4 < 44872) {
                                if (code4 < 44845) {
                                  if (code4 === 44844) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44845 <= code4 && code4 <= 44871) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 44873) {
                                  if (code4 === 44872) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44900) {
                                    if (44873 <= code4 && code4 <= 44899) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44900) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44956) {
                                if (code4 < 44928) {
                                  if (44901 <= code4 && code4 <= 44927) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 44929) {
                                    if (code4 === 44928) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44929 <= code4 && code4 <= 44955) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 44957) {
                                  if (code4 === 44956) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 44984) {
                                    if (44957 <= code4 && code4 <= 44983) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 44984) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 45152) {
                            if (code4 < 45068) {
                              if (code4 < 45013) {
                                if (code4 < 45012) {
                                  if (44985 <= code4 && code4 <= 45011) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 45012) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 45040) {
                                  if (45013 <= code4 && code4 <= 45039) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45041) {
                                    if (code4 === 45040) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45041 <= code4 && code4 <= 45067) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45097) {
                                if (code4 < 45069) {
                                  if (code4 === 45068) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45096) {
                                    if (45069 <= code4 && code4 <= 45095) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45096) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 45124) {
                                  if (45097 <= code4 && code4 <= 45123) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45125) {
                                    if (code4 === 45124) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45125 <= code4 && code4 <= 45151) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45209) {
                              if (code4 < 45180) {
                                if (code4 < 45153) {
                                  if (code4 === 45152) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45153 <= code4 && code4 <= 45179) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 45181) {
                                  if (code4 === 45180) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45208) {
                                    if (45181 <= code4 && code4 <= 45207) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45208) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45264) {
                                if (code4 < 45236) {
                                  if (45209 <= code4 && code4 <= 45235) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45237) {
                                    if (code4 === 45236) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45237 <= code4 && code4 <= 45263) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 45265) {
                                  if (code4 === 45264) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45292) {
                                    if (45265 <= code4 && code4 <= 45291) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45292) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 45908) {
                        if (code4 < 45600) {
                          if (code4 < 45433) {
                            if (code4 < 45376) {
                              if (code4 < 45321) {
                                if (code4 < 45320) {
                                  if (45293 <= code4 && code4 <= 45319) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 45320) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 45348) {
                                  if (45321 <= code4 && code4 <= 45347) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45349) {
                                    if (code4 === 45348) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45349 <= code4 && code4 <= 45375) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45404) {
                                if (code4 < 45377) {
                                  if (code4 === 45376) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45377 <= code4 && code4 <= 45403) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 45405) {
                                  if (code4 === 45404) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45432) {
                                    if (45405 <= code4 && code4 <= 45431) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45432) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45516) {
                              if (code4 < 45461) {
                                if (code4 < 45460) {
                                  if (45433 <= code4 && code4 <= 45459) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 45460) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 45488) {
                                  if (45461 <= code4 && code4 <= 45487) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45489) {
                                    if (code4 === 45488) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45489 <= code4 && code4 <= 45515) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45545) {
                                if (code4 < 45517) {
                                  if (code4 === 45516) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45544) {
                                    if (45517 <= code4 && code4 <= 45543) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45544) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 45572) {
                                  if (45545 <= code4 && code4 <= 45571) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45573) {
                                    if (code4 === 45572) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45573 <= code4 && code4 <= 45599) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 45741) {
                            if (code4 < 45657) {
                              if (code4 < 45628) {
                                if (code4 < 45601) {
                                  if (code4 === 45600) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45601 <= code4 && code4 <= 45627) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 45629) {
                                  if (code4 === 45628) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45656) {
                                    if (45629 <= code4 && code4 <= 45655) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45656) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45712) {
                                if (code4 < 45684) {
                                  if (45657 <= code4 && code4 <= 45683) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45685) {
                                    if (code4 === 45684) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45685 <= code4 && code4 <= 45711) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 45713) {
                                  if (code4 === 45712) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45740) {
                                    if (45713 <= code4 && code4 <= 45739) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45740) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45824) {
                              if (code4 < 45769) {
                                if (code4 < 45768) {
                                  if (45741 <= code4 && code4 <= 45767) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 45768) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 45796) {
                                  if (45769 <= code4 && code4 <= 45795) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45797) {
                                    if (code4 === 45796) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45797 <= code4 && code4 <= 45823) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45853) {
                                if (code4 < 45825) {
                                  if (code4 === 45824) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45852) {
                                    if (45825 <= code4 && code4 <= 45851) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45852) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 45880) {
                                  if (45853 <= code4 && code4 <= 45879) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 45881) {
                                    if (code4 === 45880) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45881 <= code4 && code4 <= 45907) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46189) {
                          if (code4 < 46048) {
                            if (code4 < 45965) {
                              if (code4 < 45936) {
                                if (code4 < 45909) {
                                  if (code4 === 45908) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45909 <= code4 && code4 <= 45935) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 45937) {
                                  if (code4 === 45936) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 45964) {
                                    if (45937 <= code4 && code4 <= 45963) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 45964) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45993) {
                                if (code4 < 45992) {
                                  if (45965 <= code4 && code4 <= 45991) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 45992) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 46020) {
                                  if (45993 <= code4 && code4 <= 46019) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46021) {
                                    if (code4 === 46020) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46021 <= code4 && code4 <= 46047) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46105) {
                              if (code4 < 46076) {
                                if (code4 < 46049) {
                                  if (code4 === 46048) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46049 <= code4 && code4 <= 46075) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 46077) {
                                  if (code4 === 46076) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46104) {
                                    if (46077 <= code4 && code4 <= 46103) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46104) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46160) {
                                if (code4 < 46132) {
                                  if (46105 <= code4 && code4 <= 46131) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46133) {
                                    if (code4 === 46132) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46133 <= code4 && code4 <= 46159) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 46161) {
                                  if (code4 === 46160) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46188) {
                                    if (46161 <= code4 && code4 <= 46187) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46188) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 46356) {
                            if (code4 < 46272) {
                              if (code4 < 46217) {
                                if (code4 < 46216) {
                                  if (46189 <= code4 && code4 <= 46215) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 46216) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 46244) {
                                  if (46217 <= code4 && code4 <= 46243) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46245) {
                                    if (code4 === 46244) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46245 <= code4 && code4 <= 46271) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46301) {
                                if (code4 < 46273) {
                                  if (code4 === 46272) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46300) {
                                    if (46273 <= code4 && code4 <= 46299) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46300) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 46328) {
                                  if (46301 <= code4 && code4 <= 46327) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46329) {
                                    if (code4 === 46328) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46329 <= code4 && code4 <= 46355) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46413) {
                              if (code4 < 46384) {
                                if (code4 < 46357) {
                                  if (code4 === 46356) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46357 <= code4 && code4 <= 46383) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 46385) {
                                  if (code4 === 46384) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46412) {
                                    if (46385 <= code4 && code4 <= 46411) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46412) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46468) {
                                if (code4 < 46440) {
                                  if (46413 <= code4 && code4 <= 46439) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46441) {
                                    if (code4 === 46440) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46441 <= code4 && code4 <= 46467) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 46469) {
                                  if (code4 === 46468) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46496) {
                                    if (46469 <= code4 && code4 <= 46495) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46496) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 47701) {
                      if (code4 < 47112) {
                        if (code4 < 46804) {
                          if (code4 < 46637) {
                            if (code4 < 46580) {
                              if (code4 < 46525) {
                                if (code4 < 46524) {
                                  if (46497 <= code4 && code4 <= 46523) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 46524) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 46552) {
                                  if (46525 <= code4 && code4 <= 46551) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46553) {
                                    if (code4 === 46552) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46553 <= code4 && code4 <= 46579) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46608) {
                                if (code4 < 46581) {
                                  if (code4 === 46580) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46581 <= code4 && code4 <= 46607) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 46609) {
                                  if (code4 === 46608) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46636) {
                                    if (46609 <= code4 && code4 <= 46635) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46636) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46720) {
                              if (code4 < 46665) {
                                if (code4 < 46664) {
                                  if (46637 <= code4 && code4 <= 46663) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 46664) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 46692) {
                                  if (46665 <= code4 && code4 <= 46691) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46693) {
                                    if (code4 === 46692) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46693 <= code4 && code4 <= 46719) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46749) {
                                if (code4 < 46721) {
                                  if (code4 === 46720) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46748) {
                                    if (46721 <= code4 && code4 <= 46747) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46748) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 46776) {
                                  if (46749 <= code4 && code4 <= 46775) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46777) {
                                    if (code4 === 46776) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46777 <= code4 && code4 <= 46803) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 46945) {
                            if (code4 < 46861) {
                              if (code4 < 46832) {
                                if (code4 < 46805) {
                                  if (code4 === 46804) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46805 <= code4 && code4 <= 46831) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 46833) {
                                  if (code4 === 46832) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46860) {
                                    if (46833 <= code4 && code4 <= 46859) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46860) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46916) {
                                if (code4 < 46888) {
                                  if (46861 <= code4 && code4 <= 46887) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 46889) {
                                    if (code4 === 46888) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46889 <= code4 && code4 <= 46915) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 46917) {
                                  if (code4 === 46916) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 46944) {
                                    if (46917 <= code4 && code4 <= 46943) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 46944) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47028) {
                              if (code4 < 46973) {
                                if (code4 < 46972) {
                                  if (46945 <= code4 && code4 <= 46971) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 46972) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 47e3) {
                                  if (46973 <= code4 && code4 <= 46999) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47001) {
                                    if (code4 === 47e3) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47001 <= code4 && code4 <= 47027) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47057) {
                                if (code4 < 47029) {
                                  if (code4 === 47028) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47056) {
                                    if (47029 <= code4 && code4 <= 47055) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47056) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 47084) {
                                  if (47057 <= code4 && code4 <= 47083) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47085) {
                                    if (code4 === 47084) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47085 <= code4 && code4 <= 47111) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47393) {
                          if (code4 < 47252) {
                            if (code4 < 47169) {
                              if (code4 < 47140) {
                                if (code4 < 47113) {
                                  if (code4 === 47112) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47113 <= code4 && code4 <= 47139) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 47141) {
                                  if (code4 === 47140) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47168) {
                                    if (47141 <= code4 && code4 <= 47167) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47168) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47197) {
                                if (code4 < 47196) {
                                  if (47169 <= code4 && code4 <= 47195) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 47196) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 47224) {
                                  if (47197 <= code4 && code4 <= 47223) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47225) {
                                    if (code4 === 47224) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47225 <= code4 && code4 <= 47251) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47309) {
                              if (code4 < 47280) {
                                if (code4 < 47253) {
                                  if (code4 === 47252) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47253 <= code4 && code4 <= 47279) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 47281) {
                                  if (code4 === 47280) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47308) {
                                    if (47281 <= code4 && code4 <= 47307) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47308) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47364) {
                                if (code4 < 47336) {
                                  if (47309 <= code4 && code4 <= 47335) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47337) {
                                    if (code4 === 47336) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47337 <= code4 && code4 <= 47363) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 47365) {
                                  if (code4 === 47364) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47392) {
                                    if (47365 <= code4 && code4 <= 47391) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47392) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 47560) {
                            if (code4 < 47476) {
                              if (code4 < 47421) {
                                if (code4 < 47420) {
                                  if (47393 <= code4 && code4 <= 47419) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 47420) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 47448) {
                                  if (47421 <= code4 && code4 <= 47447) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47449) {
                                    if (code4 === 47448) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47449 <= code4 && code4 <= 47475) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47505) {
                                if (code4 < 47477) {
                                  if (code4 === 47476) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47504) {
                                    if (47477 <= code4 && code4 <= 47503) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47504) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 47532) {
                                  if (47505 <= code4 && code4 <= 47531) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47533) {
                                    if (code4 === 47532) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47533 <= code4 && code4 <= 47559) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47617) {
                              if (code4 < 47588) {
                                if (code4 < 47561) {
                                  if (code4 === 47560) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47561 <= code4 && code4 <= 47587) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 47589) {
                                  if (code4 === 47588) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47616) {
                                    if (47589 <= code4 && code4 <= 47615) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47616) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47672) {
                                if (code4 < 47644) {
                                  if (47617 <= code4 && code4 <= 47643) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47645) {
                                    if (code4 === 47644) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47645 <= code4 && code4 <= 47671) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 47673) {
                                  if (code4 === 47672) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47700) {
                                    if (47673 <= code4 && code4 <= 47699) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47700) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 48316) {
                        if (code4 < 48008) {
                          if (code4 < 47841) {
                            if (code4 < 47784) {
                              if (code4 < 47729) {
                                if (code4 < 47728) {
                                  if (47701 <= code4 && code4 <= 47727) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 47728) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 47756) {
                                  if (47729 <= code4 && code4 <= 47755) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47757) {
                                    if (code4 === 47756) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47757 <= code4 && code4 <= 47783) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47812) {
                                if (code4 < 47785) {
                                  if (code4 === 47784) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47785 <= code4 && code4 <= 47811) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 47813) {
                                  if (code4 === 47812) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47840) {
                                    if (47813 <= code4 && code4 <= 47839) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47840) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47924) {
                              if (code4 < 47869) {
                                if (code4 < 47868) {
                                  if (47841 <= code4 && code4 <= 47867) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 47868) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 47896) {
                                  if (47869 <= code4 && code4 <= 47895) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47897) {
                                    if (code4 === 47896) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47897 <= code4 && code4 <= 47923) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47953) {
                                if (code4 < 47925) {
                                  if (code4 === 47924) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 47952) {
                                    if (47925 <= code4 && code4 <= 47951) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 47952) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 47980) {
                                  if (47953 <= code4 && code4 <= 47979) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 47981) {
                                    if (code4 === 47980) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47981 <= code4 && code4 <= 48007) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 48149) {
                            if (code4 < 48065) {
                              if (code4 < 48036) {
                                if (code4 < 48009) {
                                  if (code4 === 48008) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48009 <= code4 && code4 <= 48035) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 48037) {
                                  if (code4 === 48036) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48064) {
                                    if (48037 <= code4 && code4 <= 48063) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48064) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48120) {
                                if (code4 < 48092) {
                                  if (48065 <= code4 && code4 <= 48091) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48093) {
                                    if (code4 === 48092) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48093 <= code4 && code4 <= 48119) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 48121) {
                                  if (code4 === 48120) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48148) {
                                    if (48121 <= code4 && code4 <= 48147) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48148) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48232) {
                              if (code4 < 48177) {
                                if (code4 < 48176) {
                                  if (48149 <= code4 && code4 <= 48175) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 48176) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 48204) {
                                  if (48177 <= code4 && code4 <= 48203) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48205) {
                                    if (code4 === 48204) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48205 <= code4 && code4 <= 48231) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48261) {
                                if (code4 < 48233) {
                                  if (code4 === 48232) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48260) {
                                    if (48233 <= code4 && code4 <= 48259) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48260) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 48288) {
                                  if (48261 <= code4 && code4 <= 48287) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48289) {
                                    if (code4 === 48288) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48289 <= code4 && code4 <= 48315) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48597) {
                          if (code4 < 48456) {
                            if (code4 < 48373) {
                              if (code4 < 48344) {
                                if (code4 < 48317) {
                                  if (code4 === 48316) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48317 <= code4 && code4 <= 48343) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 48345) {
                                  if (code4 === 48344) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48372) {
                                    if (48345 <= code4 && code4 <= 48371) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48372) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48401) {
                                if (code4 < 48400) {
                                  if (48373 <= code4 && code4 <= 48399) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 48400) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 48428) {
                                  if (48401 <= code4 && code4 <= 48427) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48429) {
                                    if (code4 === 48428) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48429 <= code4 && code4 <= 48455) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48513) {
                              if (code4 < 48484) {
                                if (code4 < 48457) {
                                  if (code4 === 48456) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48457 <= code4 && code4 <= 48483) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 48485) {
                                  if (code4 === 48484) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48512) {
                                    if (48485 <= code4 && code4 <= 48511) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48512) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48568) {
                                if (code4 < 48540) {
                                  if (48513 <= code4 && code4 <= 48539) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48541) {
                                    if (code4 === 48540) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48541 <= code4 && code4 <= 48567) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 48569) {
                                  if (code4 === 48568) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48596) {
                                    if (48569 <= code4 && code4 <= 48595) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48596) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 48764) {
                            if (code4 < 48680) {
                              if (code4 < 48625) {
                                if (code4 < 48624) {
                                  if (48597 <= code4 && code4 <= 48623) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 48624) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 48652) {
                                  if (48625 <= code4 && code4 <= 48651) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48653) {
                                    if (code4 === 48652) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48653 <= code4 && code4 <= 48679) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48709) {
                                if (code4 < 48681) {
                                  if (code4 === 48680) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48708) {
                                    if (48681 <= code4 && code4 <= 48707) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48708) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 48736) {
                                  if (48709 <= code4 && code4 <= 48735) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48737) {
                                    if (code4 === 48736) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48737 <= code4 && code4 <= 48763) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48821) {
                              if (code4 < 48792) {
                                if (code4 < 48765) {
                                  if (code4 === 48764) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48765 <= code4 && code4 <= 48791) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 48793) {
                                  if (code4 === 48792) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48820) {
                                    if (48793 <= code4 && code4 <= 48819) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48820) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48876) {
                                if (code4 < 48848) {
                                  if (48821 <= code4 && code4 <= 48847) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48849) {
                                    if (code4 === 48848) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48849 <= code4 && code4 <= 48875) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 48877) {
                                  if (code4 === 48876) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 48904) {
                                    if (48877 <= code4 && code4 <= 48903) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 48904) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 53720) {
                  if (code4 < 51312) {
                    if (code4 < 50108) {
                      if (code4 < 49493) {
                        if (code4 < 49212) {
                          if (code4 < 49045) {
                            if (code4 < 48988) {
                              if (code4 < 48933) {
                                if (code4 < 48932) {
                                  if (48905 <= code4 && code4 <= 48931) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 48932) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 48960) {
                                  if (48933 <= code4 && code4 <= 48959) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 48961) {
                                    if (code4 === 48960) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48961 <= code4 && code4 <= 48987) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49016) {
                                if (code4 < 48989) {
                                  if (code4 === 48988) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48989 <= code4 && code4 <= 49015) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 49017) {
                                  if (code4 === 49016) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49044) {
                                    if (49017 <= code4 && code4 <= 49043) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49044) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49128) {
                              if (code4 < 49073) {
                                if (code4 < 49072) {
                                  if (49045 <= code4 && code4 <= 49071) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 49072) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 49100) {
                                  if (49073 <= code4 && code4 <= 49099) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49101) {
                                    if (code4 === 49100) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49101 <= code4 && code4 <= 49127) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49157) {
                                if (code4 < 49129) {
                                  if (code4 === 49128) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49156) {
                                    if (49129 <= code4 && code4 <= 49155) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49156) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 49184) {
                                  if (49157 <= code4 && code4 <= 49183) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49185) {
                                    if (code4 === 49184) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49185 <= code4 && code4 <= 49211) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 49352) {
                            if (code4 < 49269) {
                              if (code4 < 49240) {
                                if (code4 < 49213) {
                                  if (code4 === 49212) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49213 <= code4 && code4 <= 49239) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 49241) {
                                  if (code4 === 49240) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49268) {
                                    if (49241 <= code4 && code4 <= 49267) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49268) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49297) {
                                if (code4 < 49296) {
                                  if (49269 <= code4 && code4 <= 49295) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 49296) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 49324) {
                                  if (49297 <= code4 && code4 <= 49323) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49325) {
                                    if (code4 === 49324) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49325 <= code4 && code4 <= 49351) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49409) {
                              if (code4 < 49380) {
                                if (code4 < 49353) {
                                  if (code4 === 49352) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49353 <= code4 && code4 <= 49379) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 49381) {
                                  if (code4 === 49380) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49408) {
                                    if (49381 <= code4 && code4 <= 49407) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49408) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49464) {
                                if (code4 < 49436) {
                                  if (49409 <= code4 && code4 <= 49435) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49437) {
                                    if (code4 === 49436) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49437 <= code4 && code4 <= 49463) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 49465) {
                                  if (code4 === 49464) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49492) {
                                    if (49465 <= code4 && code4 <= 49491) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49492) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49800) {
                          if (code4 < 49633) {
                            if (code4 < 49576) {
                              if (code4 < 49521) {
                                if (code4 < 49520) {
                                  if (49493 <= code4 && code4 <= 49519) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 49520) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 49548) {
                                  if (49521 <= code4 && code4 <= 49547) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49549) {
                                    if (code4 === 49548) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49549 <= code4 && code4 <= 49575) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49604) {
                                if (code4 < 49577) {
                                  if (code4 === 49576) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49577 <= code4 && code4 <= 49603) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 49605) {
                                  if (code4 === 49604) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49632) {
                                    if (49605 <= code4 && code4 <= 49631) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49632) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49716) {
                              if (code4 < 49661) {
                                if (code4 < 49660) {
                                  if (49633 <= code4 && code4 <= 49659) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 49660) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 49688) {
                                  if (49661 <= code4 && code4 <= 49687) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49689) {
                                    if (code4 === 49688) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49689 <= code4 && code4 <= 49715) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49745) {
                                if (code4 < 49717) {
                                  if (code4 === 49716) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49744) {
                                    if (49717 <= code4 && code4 <= 49743) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49744) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 49772) {
                                  if (49745 <= code4 && code4 <= 49771) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49773) {
                                    if (code4 === 49772) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49773 <= code4 && code4 <= 49799) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 49941) {
                            if (code4 < 49857) {
                              if (code4 < 49828) {
                                if (code4 < 49801) {
                                  if (code4 === 49800) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49801 <= code4 && code4 <= 49827) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 49829) {
                                  if (code4 === 49828) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49856) {
                                    if (49829 <= code4 && code4 <= 49855) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49856) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49912) {
                                if (code4 < 49884) {
                                  if (49857 <= code4 && code4 <= 49883) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49885) {
                                    if (code4 === 49884) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49885 <= code4 && code4 <= 49911) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 49913) {
                                  if (code4 === 49912) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 49940) {
                                    if (49913 <= code4 && code4 <= 49939) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 49940) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50024) {
                              if (code4 < 49969) {
                                if (code4 < 49968) {
                                  if (49941 <= code4 && code4 <= 49967) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 49968) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 49996) {
                                  if (49969 <= code4 && code4 <= 49995) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 49997) {
                                    if (code4 === 49996) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49997 <= code4 && code4 <= 50023) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50053) {
                                if (code4 < 50025) {
                                  if (code4 === 50024) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50052) {
                                    if (50025 <= code4 && code4 <= 50051) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50052) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 50080) {
                                  if (50053 <= code4 && code4 <= 50079) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50081) {
                                    if (code4 === 50080) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50081 <= code4 && code4 <= 50107) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 50697) {
                        if (code4 < 50389) {
                          if (code4 < 50248) {
                            if (code4 < 50165) {
                              if (code4 < 50136) {
                                if (code4 < 50109) {
                                  if (code4 === 50108) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50109 <= code4 && code4 <= 50135) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 50137) {
                                  if (code4 === 50136) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50164) {
                                    if (50137 <= code4 && code4 <= 50163) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50164) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50193) {
                                if (code4 < 50192) {
                                  if (50165 <= code4 && code4 <= 50191) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 50192) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 50220) {
                                  if (50193 <= code4 && code4 <= 50219) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50221) {
                                    if (code4 === 50220) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50221 <= code4 && code4 <= 50247) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50305) {
                              if (code4 < 50276) {
                                if (code4 < 50249) {
                                  if (code4 === 50248) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50249 <= code4 && code4 <= 50275) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 50277) {
                                  if (code4 === 50276) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50304) {
                                    if (50277 <= code4 && code4 <= 50303) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50304) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50360) {
                                if (code4 < 50332) {
                                  if (50305 <= code4 && code4 <= 50331) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50333) {
                                    if (code4 === 50332) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50333 <= code4 && code4 <= 50359) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 50361) {
                                  if (code4 === 50360) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50388) {
                                    if (50361 <= code4 && code4 <= 50387) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50388) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 50556) {
                            if (code4 < 50472) {
                              if (code4 < 50417) {
                                if (code4 < 50416) {
                                  if (50389 <= code4 && code4 <= 50415) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 50416) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 50444) {
                                  if (50417 <= code4 && code4 <= 50443) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50445) {
                                    if (code4 === 50444) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50445 <= code4 && code4 <= 50471) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50501) {
                                if (code4 < 50473) {
                                  if (code4 === 50472) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50500) {
                                    if (50473 <= code4 && code4 <= 50499) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50500) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 50528) {
                                  if (50501 <= code4 && code4 <= 50527) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50529) {
                                    if (code4 === 50528) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50529 <= code4 && code4 <= 50555) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50613) {
                              if (code4 < 50584) {
                                if (code4 < 50557) {
                                  if (code4 === 50556) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50557 <= code4 && code4 <= 50583) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 50585) {
                                  if (code4 === 50584) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50612) {
                                    if (50585 <= code4 && code4 <= 50611) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50612) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50668) {
                                if (code4 < 50640) {
                                  if (50613 <= code4 && code4 <= 50639) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50641) {
                                    if (code4 === 50640) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50641 <= code4 && code4 <= 50667) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 50669) {
                                  if (code4 === 50668) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50696) {
                                    if (50669 <= code4 && code4 <= 50695) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50696) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51004) {
                          if (code4 < 50837) {
                            if (code4 < 50780) {
                              if (code4 < 50725) {
                                if (code4 < 50724) {
                                  if (50697 <= code4 && code4 <= 50723) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 50724) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 50752) {
                                  if (50725 <= code4 && code4 <= 50751) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50753) {
                                    if (code4 === 50752) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50753 <= code4 && code4 <= 50779) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50808) {
                                if (code4 < 50781) {
                                  if (code4 === 50780) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50781 <= code4 && code4 <= 50807) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 50809) {
                                  if (code4 === 50808) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50836) {
                                    if (50809 <= code4 && code4 <= 50835) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50836) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50920) {
                              if (code4 < 50865) {
                                if (code4 < 50864) {
                                  if (50837 <= code4 && code4 <= 50863) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 50864) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 50892) {
                                  if (50865 <= code4 && code4 <= 50891) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50893) {
                                    if (code4 === 50892) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50893 <= code4 && code4 <= 50919) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50949) {
                                if (code4 < 50921) {
                                  if (code4 === 50920) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 50948) {
                                    if (50921 <= code4 && code4 <= 50947) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 50948) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 50976) {
                                  if (50949 <= code4 && code4 <= 50975) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 50977) {
                                    if (code4 === 50976) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50977 <= code4 && code4 <= 51003) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 51145) {
                            if (code4 < 51061) {
                              if (code4 < 51032) {
                                if (code4 < 51005) {
                                  if (code4 === 51004) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51005 <= code4 && code4 <= 51031) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 51033) {
                                  if (code4 === 51032) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51060) {
                                    if (51033 <= code4 && code4 <= 51059) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51060) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51116) {
                                if (code4 < 51088) {
                                  if (51061 <= code4 && code4 <= 51087) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51089) {
                                    if (code4 === 51088) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51089 <= code4 && code4 <= 51115) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 51117) {
                                  if (code4 === 51116) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51144) {
                                    if (51117 <= code4 && code4 <= 51143) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51144) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51228) {
                              if (code4 < 51173) {
                                if (code4 < 51172) {
                                  if (51145 <= code4 && code4 <= 51171) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 51172) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 51200) {
                                  if (51173 <= code4 && code4 <= 51199) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51201) {
                                    if (code4 === 51200) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51201 <= code4 && code4 <= 51227) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51257) {
                                if (code4 < 51229) {
                                  if (code4 === 51228) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51256) {
                                    if (51229 <= code4 && code4 <= 51255) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51256) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 51284) {
                                  if (51257 <= code4 && code4 <= 51283) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51285) {
                                    if (code4 === 51284) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51285 <= code4 && code4 <= 51311) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 52516) {
                      if (code4 < 51901) {
                        if (code4 < 51593) {
                          if (code4 < 51452) {
                            if (code4 < 51369) {
                              if (code4 < 51340) {
                                if (code4 < 51313) {
                                  if (code4 === 51312) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51313 <= code4 && code4 <= 51339) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 51341) {
                                  if (code4 === 51340) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51368) {
                                    if (51341 <= code4 && code4 <= 51367) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51368) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51397) {
                                if (code4 < 51396) {
                                  if (51369 <= code4 && code4 <= 51395) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 51396) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 51424) {
                                  if (51397 <= code4 && code4 <= 51423) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51425) {
                                    if (code4 === 51424) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51425 <= code4 && code4 <= 51451) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51509) {
                              if (code4 < 51480) {
                                if (code4 < 51453) {
                                  if (code4 === 51452) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51453 <= code4 && code4 <= 51479) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 51481) {
                                  if (code4 === 51480) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51508) {
                                    if (51481 <= code4 && code4 <= 51507) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51508) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51564) {
                                if (code4 < 51536) {
                                  if (51509 <= code4 && code4 <= 51535) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51537) {
                                    if (code4 === 51536) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51537 <= code4 && code4 <= 51563) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 51565) {
                                  if (code4 === 51564) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51592) {
                                    if (51565 <= code4 && code4 <= 51591) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51592) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 51760) {
                            if (code4 < 51676) {
                              if (code4 < 51621) {
                                if (code4 < 51620) {
                                  if (51593 <= code4 && code4 <= 51619) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 51620) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 51648) {
                                  if (51621 <= code4 && code4 <= 51647) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51649) {
                                    if (code4 === 51648) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51649 <= code4 && code4 <= 51675) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51705) {
                                if (code4 < 51677) {
                                  if (code4 === 51676) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51704) {
                                    if (51677 <= code4 && code4 <= 51703) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51704) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 51732) {
                                  if (51705 <= code4 && code4 <= 51731) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51733) {
                                    if (code4 === 51732) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51733 <= code4 && code4 <= 51759) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51817) {
                              if (code4 < 51788) {
                                if (code4 < 51761) {
                                  if (code4 === 51760) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51761 <= code4 && code4 <= 51787) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 51789) {
                                  if (code4 === 51788) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51816) {
                                    if (51789 <= code4 && code4 <= 51815) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51816) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51872) {
                                if (code4 < 51844) {
                                  if (51817 <= code4 && code4 <= 51843) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51845) {
                                    if (code4 === 51844) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51845 <= code4 && code4 <= 51871) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 51873) {
                                  if (code4 === 51872) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 51900) {
                                    if (51873 <= code4 && code4 <= 51899) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 51900) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52208) {
                          if (code4 < 52041) {
                            if (code4 < 51984) {
                              if (code4 < 51929) {
                                if (code4 < 51928) {
                                  if (51901 <= code4 && code4 <= 51927) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 51928) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 51956) {
                                  if (51929 <= code4 && code4 <= 51955) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 51957) {
                                    if (code4 === 51956) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51957 <= code4 && code4 <= 51983) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52012) {
                                if (code4 < 51985) {
                                  if (code4 === 51984) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51985 <= code4 && code4 <= 52011) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 52013) {
                                  if (code4 === 52012) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52040) {
                                    if (52013 <= code4 && code4 <= 52039) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52040) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52124) {
                              if (code4 < 52069) {
                                if (code4 < 52068) {
                                  if (52041 <= code4 && code4 <= 52067) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 52068) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 52096) {
                                  if (52069 <= code4 && code4 <= 52095) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52097) {
                                    if (code4 === 52096) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52097 <= code4 && code4 <= 52123) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52153) {
                                if (code4 < 52125) {
                                  if (code4 === 52124) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52152) {
                                    if (52125 <= code4 && code4 <= 52151) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52152) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 52180) {
                                  if (52153 <= code4 && code4 <= 52179) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52181) {
                                    if (code4 === 52180) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52181 <= code4 && code4 <= 52207) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 52349) {
                            if (code4 < 52265) {
                              if (code4 < 52236) {
                                if (code4 < 52209) {
                                  if (code4 === 52208) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52209 <= code4 && code4 <= 52235) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 52237) {
                                  if (code4 === 52236) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52264) {
                                    if (52237 <= code4 && code4 <= 52263) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52264) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52320) {
                                if (code4 < 52292) {
                                  if (52265 <= code4 && code4 <= 52291) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52293) {
                                    if (code4 === 52292) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52293 <= code4 && code4 <= 52319) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 52321) {
                                  if (code4 === 52320) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52348) {
                                    if (52321 <= code4 && code4 <= 52347) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52348) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52432) {
                              if (code4 < 52377) {
                                if (code4 < 52376) {
                                  if (52349 <= code4 && code4 <= 52375) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 52376) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 52404) {
                                  if (52377 <= code4 && code4 <= 52403) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52405) {
                                    if (code4 === 52404) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52405 <= code4 && code4 <= 52431) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52461) {
                                if (code4 < 52433) {
                                  if (code4 === 52432) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52460) {
                                    if (52433 <= code4 && code4 <= 52459) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52460) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 52488) {
                                  if (52461 <= code4 && code4 <= 52487) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52489) {
                                    if (code4 === 52488) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52489 <= code4 && code4 <= 52515) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 53105) {
                        if (code4 < 52797) {
                          if (code4 < 52656) {
                            if (code4 < 52573) {
                              if (code4 < 52544) {
                                if (code4 < 52517) {
                                  if (code4 === 52516) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52517 <= code4 && code4 <= 52543) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 52545) {
                                  if (code4 === 52544) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52572) {
                                    if (52545 <= code4 && code4 <= 52571) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52572) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52601) {
                                if (code4 < 52600) {
                                  if (52573 <= code4 && code4 <= 52599) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 52600) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 52628) {
                                  if (52601 <= code4 && code4 <= 52627) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52629) {
                                    if (code4 === 52628) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52629 <= code4 && code4 <= 52655) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52713) {
                              if (code4 < 52684) {
                                if (code4 < 52657) {
                                  if (code4 === 52656) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52657 <= code4 && code4 <= 52683) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 52685) {
                                  if (code4 === 52684) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52712) {
                                    if (52685 <= code4 && code4 <= 52711) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52712) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52768) {
                                if (code4 < 52740) {
                                  if (52713 <= code4 && code4 <= 52739) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52741) {
                                    if (code4 === 52740) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52741 <= code4 && code4 <= 52767) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 52769) {
                                  if (code4 === 52768) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52796) {
                                    if (52769 <= code4 && code4 <= 52795) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52796) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 52964) {
                            if (code4 < 52880) {
                              if (code4 < 52825) {
                                if (code4 < 52824) {
                                  if (52797 <= code4 && code4 <= 52823) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 52824) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 52852) {
                                  if (52825 <= code4 && code4 <= 52851) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52853) {
                                    if (code4 === 52852) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52853 <= code4 && code4 <= 52879) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52909) {
                                if (code4 < 52881) {
                                  if (code4 === 52880) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 52908) {
                                    if (52881 <= code4 && code4 <= 52907) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 52908) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 52936) {
                                  if (52909 <= code4 && code4 <= 52935) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 52937) {
                                    if (code4 === 52936) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52937 <= code4 && code4 <= 52963) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53021) {
                              if (code4 < 52992) {
                                if (code4 < 52965) {
                                  if (code4 === 52964) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52965 <= code4 && code4 <= 52991) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 52993) {
                                  if (code4 === 52992) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53020) {
                                    if (52993 <= code4 && code4 <= 53019) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53020) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53076) {
                                if (code4 < 53048) {
                                  if (53021 <= code4 && code4 <= 53047) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53049) {
                                    if (code4 === 53048) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53049 <= code4 && code4 <= 53075) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 53077) {
                                  if (code4 === 53076) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53104) {
                                    if (53077 <= code4 && code4 <= 53103) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53104) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53412) {
                          if (code4 < 53245) {
                            if (code4 < 53188) {
                              if (code4 < 53133) {
                                if (code4 < 53132) {
                                  if (53105 <= code4 && code4 <= 53131) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 53132) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 53160) {
                                  if (53133 <= code4 && code4 <= 53159) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53161) {
                                    if (code4 === 53160) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53161 <= code4 && code4 <= 53187) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53216) {
                                if (code4 < 53189) {
                                  if (code4 === 53188) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53189 <= code4 && code4 <= 53215) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 53217) {
                                  if (code4 === 53216) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53244) {
                                    if (53217 <= code4 && code4 <= 53243) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53244) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53328) {
                              if (code4 < 53273) {
                                if (code4 < 53272) {
                                  if (53245 <= code4 && code4 <= 53271) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 53272) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 53300) {
                                  if (53273 <= code4 && code4 <= 53299) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53301) {
                                    if (code4 === 53300) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53301 <= code4 && code4 <= 53327) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53357) {
                                if (code4 < 53329) {
                                  if (code4 === 53328) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53356) {
                                    if (53329 <= code4 && code4 <= 53355) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53356) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 53384) {
                                  if (53357 <= code4 && code4 <= 53383) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53385) {
                                    if (code4 === 53384) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53385 <= code4 && code4 <= 53411) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 53553) {
                            if (code4 < 53469) {
                              if (code4 < 53440) {
                                if (code4 < 53413) {
                                  if (code4 === 53412) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53413 <= code4 && code4 <= 53439) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 53441) {
                                  if (code4 === 53440) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53468) {
                                    if (53441 <= code4 && code4 <= 53467) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53468) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53524) {
                                if (code4 < 53496) {
                                  if (53469 <= code4 && code4 <= 53495) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53497) {
                                    if (code4 === 53496) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53497 <= code4 && code4 <= 53523) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 53525) {
                                  if (code4 === 53524) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53552) {
                                    if (53525 <= code4 && code4 <= 53551) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53552) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53636) {
                              if (code4 < 53581) {
                                if (code4 < 53580) {
                                  if (53553 <= code4 && code4 <= 53579) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 53580) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 53608) {
                                  if (53581 <= code4 && code4 <= 53607) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53609) {
                                    if (code4 === 53608) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53609 <= code4 && code4 <= 53635) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53665) {
                                if (code4 < 53637) {
                                  if (code4 === 53636) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53664) {
                                    if (53637 <= code4 && code4 <= 53663) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53664) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 53692) {
                                  if (53665 <= code4 && code4 <= 53691) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53693) {
                                    if (code4 === 53692) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53693 <= code4 && code4 <= 53719) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 70459) {
                    if (code4 < 54897) {
                      if (code4 < 54308) {
                        if (code4 < 54001) {
                          if (code4 < 53860) {
                            if (code4 < 53777) {
                              if (code4 < 53748) {
                                if (code4 < 53721) {
                                  if (code4 === 53720) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53721 <= code4 && code4 <= 53747) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 53749) {
                                  if (code4 === 53748) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53776) {
                                    if (53749 <= code4 && code4 <= 53775) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53776) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53805) {
                                if (code4 < 53804) {
                                  if (53777 <= code4 && code4 <= 53803) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 53804) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 53832) {
                                  if (53805 <= code4 && code4 <= 53831) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53833) {
                                    if (code4 === 53832) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53833 <= code4 && code4 <= 53859) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53917) {
                              if (code4 < 53888) {
                                if (code4 < 53861) {
                                  if (code4 === 53860) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53861 <= code4 && code4 <= 53887) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 53889) {
                                  if (code4 === 53888) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 53916) {
                                    if (53889 <= code4 && code4 <= 53915) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 53916) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53972) {
                                if (code4 < 53944) {
                                  if (53917 <= code4 && code4 <= 53943) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 53945) {
                                    if (code4 === 53944) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53945 <= code4 && code4 <= 53971) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 53973) {
                                  if (code4 === 53972) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54e3) {
                                    if (53973 <= code4 && code4 <= 53999) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54e3) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 54141) {
                            if (code4 < 54084) {
                              if (code4 < 54029) {
                                if (code4 < 54028) {
                                  if (54001 <= code4 && code4 <= 54027) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 54028) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 54056) {
                                  if (54029 <= code4 && code4 <= 54055) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54057) {
                                    if (code4 === 54056) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54057 <= code4 && code4 <= 54083) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54112) {
                                if (code4 < 54085) {
                                  if (code4 === 54084) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54085 <= code4 && code4 <= 54111) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 54113) {
                                  if (code4 === 54112) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54140) {
                                    if (54113 <= code4 && code4 <= 54139) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54140) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54224) {
                              if (code4 < 54169) {
                                if (code4 < 54168) {
                                  if (54141 <= code4 && code4 <= 54167) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 54168) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 54196) {
                                  if (54169 <= code4 && code4 <= 54195) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54197) {
                                    if (code4 === 54196) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54197 <= code4 && code4 <= 54223) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54253) {
                                if (code4 < 54225) {
                                  if (code4 === 54224) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54252) {
                                    if (54225 <= code4 && code4 <= 54251) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54252) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 54280) {
                                  if (54253 <= code4 && code4 <= 54279) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54281) {
                                    if (code4 === 54280) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54281 <= code4 && code4 <= 54307) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54589) {
                          if (code4 < 54448) {
                            if (code4 < 54365) {
                              if (code4 < 54336) {
                                if (code4 < 54309) {
                                  if (code4 === 54308) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54309 <= code4 && code4 <= 54335) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 54337) {
                                  if (code4 === 54336) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54364) {
                                    if (54337 <= code4 && code4 <= 54363) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54364) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54393) {
                                if (code4 < 54392) {
                                  if (54365 <= code4 && code4 <= 54391) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 54392) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 54420) {
                                  if (54393 <= code4 && code4 <= 54419) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54421) {
                                    if (code4 === 54420) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54421 <= code4 && code4 <= 54447) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54505) {
                              if (code4 < 54476) {
                                if (code4 < 54449) {
                                  if (code4 === 54448) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54449 <= code4 && code4 <= 54475) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 54477) {
                                  if (code4 === 54476) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54504) {
                                    if (54477 <= code4 && code4 <= 54503) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54504) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54560) {
                                if (code4 < 54532) {
                                  if (54505 <= code4 && code4 <= 54531) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54533) {
                                    if (code4 === 54532) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54533 <= code4 && code4 <= 54559) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 54561) {
                                  if (code4 === 54560) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54588) {
                                    if (54561 <= code4 && code4 <= 54587) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54588) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 54756) {
                            if (code4 < 54672) {
                              if (code4 < 54617) {
                                if (code4 < 54616) {
                                  if (54589 <= code4 && code4 <= 54615) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 54616) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 54644) {
                                  if (54617 <= code4 && code4 <= 54643) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54645) {
                                    if (code4 === 54644) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54645 <= code4 && code4 <= 54671) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54701) {
                                if (code4 < 54673) {
                                  if (code4 === 54672) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54700) {
                                    if (54673 <= code4 && code4 <= 54699) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54700) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 54728) {
                                  if (54701 <= code4 && code4 <= 54727) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54729) {
                                    if (code4 === 54728) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54729 <= code4 && code4 <= 54755) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54813) {
                              if (code4 < 54784) {
                                if (code4 < 54757) {
                                  if (code4 === 54756) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54757 <= code4 && code4 <= 54783) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 54785) {
                                  if (code4 === 54784) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54812) {
                                    if (54785 <= code4 && code4 <= 54811) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54812) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54868) {
                                if (code4 < 54840) {
                                  if (54813 <= code4 && code4 <= 54839) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54841) {
                                    if (code4 === 54840) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54841 <= code4 && code4 <= 54867) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 54869) {
                                  if (code4 === 54868) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 54896) {
                                    if (54869 <= code4 && code4 <= 54895) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 54896) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 69632) {
                        if (code4 < 55216) {
                          if (code4 < 55037) {
                            if (code4 < 54980) {
                              if (code4 < 54925) {
                                if (code4 < 54924) {
                                  if (54897 <= code4 && code4 <= 54923) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 54924) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 54952) {
                                  if (54925 <= code4 && code4 <= 54951) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 54953) {
                                    if (code4 === 54952) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54953 <= code4 && code4 <= 54979) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 55008) {
                                if (code4 < 54981) {
                                  if (code4 === 54980) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54981 <= code4 && code4 <= 55007) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code4 < 55009) {
                                  if (code4 === 55008) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 55036) {
                                    if (55009 <= code4 && code4 <= 55035) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 55036) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 55120) {
                              if (code4 < 55065) {
                                if (code4 < 55064) {
                                  if (55037 <= code4 && code4 <= 55063) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 === 55064) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code4 < 55092) {
                                  if (55065 <= code4 && code4 <= 55091) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 55093) {
                                    if (code4 === 55092) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (55093 <= code4 && code4 <= 55119) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 55149) {
                                if (code4 < 55121) {
                                  if (code4 === 55120) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code4 < 55148) {
                                    if (55121 <= code4 && code4 <= 55147) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code4 === 55148) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 55176) {
                                  if (55149 <= code4 && code4 <= 55175) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code4 < 55177) {
                                    if (code4 === 55176) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (55177 <= code4 && code4 <= 55203) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 68097) {
                            if (code4 < 65279) {
                              if (code4 < 64286) {
                                if (code4 < 55243) {
                                  if (55216 <= code4 && code4 <= 55238) {
                                    return boundaries_1.CLUSTER_BREAK.V;
                                  }
                                } else {
                                  if (55243 <= code4 && code4 <= 55291) {
                                    return boundaries_1.CLUSTER_BREAK.T;
                                  }
                                }
                              } else {
                                if (code4 < 65024) {
                                  if (code4 === 64286) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 65056) {
                                    if (65024 <= code4 && code4 <= 65039) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (65056 <= code4 && code4 <= 65071) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 66045) {
                                if (code4 < 65438) {
                                  if (code4 === 65279) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code4 < 65520) {
                                    if (65438 <= code4 && code4 <= 65439) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (65520 <= code4 && code4 <= 65531) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 66272) {
                                  if (code4 === 66045) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 66422) {
                                    if (code4 === 66272) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (66422 <= code4 && code4 <= 66426) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 68325) {
                              if (code4 < 68108) {
                                if (code4 < 68101) {
                                  if (68097 <= code4 && code4 <= 68099) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (68101 <= code4 && code4 <= 68102) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 68152) {
                                  if (68108 <= code4 && code4 <= 68111) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 68159) {
                                    if (68152 <= code4 && code4 <= 68154) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 68159) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 69373) {
                                if (code4 < 68900) {
                                  if (68325 <= code4 && code4 <= 68326) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 69291) {
                                    if (68900 <= code4 && code4 <= 68903) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (69291 <= code4 && code4 <= 69292) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 69446) {
                                  if (69373 <= code4 && code4 <= 69375) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 69506) {
                                    if (69446 <= code4 && code4 <= 69456) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (69506 <= code4 && code4 <= 69509) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 70016) {
                          if (code4 < 69815) {
                            if (code4 < 69747) {
                              if (code4 < 69634) {
                                if (code4 === 69632) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code4 === 69633) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 69688) {
                                  if (code4 === 69634) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 69744) {
                                    if (69688 <= code4 && code4 <= 69702) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 69744) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 69762) {
                                if (code4 < 69759) {
                                  if (69747 <= code4 && code4 <= 69748) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69759 <= code4 && code4 <= 69761) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 69808) {
                                  if (code4 === 69762) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 69811) {
                                    if (69808 <= code4 && code4 <= 69810) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (69811 <= code4 && code4 <= 69814) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 69888) {
                              if (code4 < 69821) {
                                if (code4 < 69817) {
                                  if (69815 <= code4 && code4 <= 69816) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (69817 <= code4 && code4 <= 69818) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 69826) {
                                  if (code4 === 69821) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code4 === 69826) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 69837) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 69933) {
                                if (code4 < 69927) {
                                  if (69888 <= code4 && code4 <= 69890) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 69932) {
                                    if (69927 <= code4 && code4 <= 69931) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 69932) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 69957) {
                                  if (69933 <= code4 && code4 <= 69940) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 70003) {
                                    if (69957 <= code4 && code4 <= 69958) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code4 === 70003) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 70194) {
                            if (code4 < 70082) {
                              if (code4 < 70067) {
                                if (code4 < 70018) {
                                  if (70016 <= code4 && code4 <= 70017) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 70018) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 70070) {
                                  if (70067 <= code4 && code4 <= 70069) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 70079) {
                                    if (70070 <= code4 && code4 <= 70078) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70079 <= code4 && code4 <= 70080) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 70095) {
                                if (code4 < 70089) {
                                  if (70082 <= code4 && code4 <= 70083) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code4 < 70094) {
                                    if (70089 <= code4 && code4 <= 70092) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 70094) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 70188) {
                                  if (code4 === 70095) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 70191) {
                                    if (70188 <= code4 && code4 <= 70190) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70191 <= code4 && code4 <= 70193) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 70209) {
                              if (code4 < 70197) {
                                if (code4 < 70196) {
                                  if (70194 <= code4 && code4 <= 70195) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 70196) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 70198) {
                                  if (code4 === 70197) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 70206) {
                                    if (70198 <= code4 && code4 <= 70199) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 70206) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 70371) {
                                if (code4 < 70367) {
                                  if (code4 === 70209) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 70368) {
                                    if (code4 === 70367) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70368 <= code4 && code4 <= 70370) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 70400) {
                                  if (70371 <= code4 && code4 <= 70378) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 70402) {
                                    if (70400 <= code4 && code4 <= 70401) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70402 <= code4 && code4 <= 70403) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 72343) {
                      if (code4 < 71339) {
                        if (code4 < 70841) {
                          if (code4 < 70512) {
                            if (code4 < 70471) {
                              if (code4 < 70463) {
                                if (code4 < 70462) {
                                  if (70459 <= code4 && code4 <= 70460) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 70462) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 70464) {
                                  if (code4 === 70463) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 70465) {
                                    if (code4 === 70464) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70465 <= code4 && code4 <= 70468) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 70487) {
                                if (code4 < 70475) {
                                  if (70471 <= code4 && code4 <= 70472) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70475 <= code4 && code4 <= 70477) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 70498) {
                                  if (code4 === 70487) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 70502) {
                                    if (70498 <= code4 && code4 <= 70499) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70502 <= code4 && code4 <= 70508) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 70725) {
                              if (code4 < 70712) {
                                if (code4 < 70709) {
                                  if (70512 <= code4 && code4 <= 70516) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70709 <= code4 && code4 <= 70711) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 70720) {
                                  if (70712 <= code4 && code4 <= 70719) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 70722) {
                                    if (70720 <= code4 && code4 <= 70721) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70722 <= code4 && code4 <= 70724) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 70832) {
                                if (code4 < 70726) {
                                  if (code4 === 70725) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 70726) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 70750) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 70833) {
                                  if (code4 === 70832) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 70835) {
                                    if (70833 <= code4 && code4 <= 70834) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70835 <= code4 && code4 <= 70840) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 71096) {
                            if (code4 < 70847) {
                              if (code4 < 70843) {
                                if (code4 === 70841) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code4 === 70842) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70845) {
                                  if (70843 <= code4 && code4 <= 70844) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 70845) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 70846) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 71087) {
                                if (code4 < 70849) {
                                  if (70847 <= code4 && code4 <= 70848) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 70850) {
                                    if (code4 === 70849) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70850 <= code4 && code4 <= 70851) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 71088) {
                                  if (code4 === 71087) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 71090) {
                                    if (71088 <= code4 && code4 <= 71089) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71090 <= code4 && code4 <= 71093) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 71216) {
                              if (code4 < 71102) {
                                if (code4 < 71100) {
                                  if (71096 <= code4 && code4 <= 71099) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71100 <= code4 && code4 <= 71101) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 71103) {
                                  if (code4 === 71102) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 71132) {
                                    if (71103 <= code4 && code4 <= 71104) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (71132 <= code4 && code4 <= 71133) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 71229) {
                                if (code4 < 71219) {
                                  if (71216 <= code4 && code4 <= 71218) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 71227) {
                                    if (71219 <= code4 && code4 <= 71226) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (71227 <= code4 && code4 <= 71228) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 71230) {
                                  if (code4 === 71229) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 71231) {
                                    if (code4 === 71230) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71231 <= code4 && code4 <= 71232) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 71999) {
                          if (code4 < 71463) {
                            if (code4 < 71350) {
                              if (code4 < 71341) {
                                if (code4 === 71339) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code4 === 71340) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 71342) {
                                  if (code4 === 71341) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 71344) {
                                    if (71342 <= code4 && code4 <= 71343) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71344 <= code4 && code4 <= 71349) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 71453) {
                                if (code4 === 71350) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code4 === 71351) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 71458) {
                                  if (71453 <= code4 && code4 <= 71455) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 71462) {
                                    if (71458 <= code4 && code4 <= 71461) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 71462) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 71984) {
                              if (code4 < 71727) {
                                if (code4 < 71724) {
                                  if (71463 <= code4 && code4 <= 71467) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71724 <= code4 && code4 <= 71726) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 71736) {
                                  if (71727 <= code4 && code4 <= 71735) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 71737) {
                                    if (code4 === 71736) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71737 <= code4 && code4 <= 71738) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 71995) {
                                if (code4 < 71985) {
                                  if (code4 === 71984) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 71991) {
                                    if (71985 <= code4 && code4 <= 71989) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71991 <= code4 && code4 <= 71992) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 71997) {
                                  if (71995 <= code4 && code4 <= 71996) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 71997) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code4 === 71998) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 72193) {
                            if (code4 < 72145) {
                              if (code4 < 72001) {
                                if (code4 === 71999) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code4 === 72e3) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 72002) {
                                  if (code4 === 72001) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code4 === 72002) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code4 === 72003) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 72156) {
                                if (code4 < 72148) {
                                  if (72145 <= code4 && code4 <= 72147) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 72154) {
                                    if (72148 <= code4 && code4 <= 72151) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72154 <= code4 && code4 <= 72155) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 72160) {
                                  if (72156 <= code4 && code4 <= 72159) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 === 72160) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 72164) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 72263) {
                              if (code4 < 72249) {
                                if (code4 < 72243) {
                                  if (72193 <= code4 && code4 <= 72202) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72243 <= code4 && code4 <= 72248) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 72250) {
                                  if (code4 === 72249) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 72251) {
                                    if (code4 === 72250) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  } else {
                                    if (72251 <= code4 && code4 <= 72254) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 72281) {
                                if (code4 < 72273) {
                                  if (code4 === 72263) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 72279) {
                                    if (72273 <= code4 && code4 <= 72278) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72279 <= code4 && code4 <= 72280) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 72324) {
                                  if (72281 <= code4 && code4 <= 72283) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 72330) {
                                    if (72324 <= code4 && code4 <= 72329) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  } else {
                                    if (72330 <= code4 && code4 <= 72342) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 94033) {
                        if (code4 < 73104) {
                          if (code4 < 72881) {
                            if (code4 < 72766) {
                              if (code4 < 72751) {
                                if (code4 < 72344) {
                                  if (code4 === 72343) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72344 <= code4 && code4 <= 72345) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 72752) {
                                  if (code4 === 72751) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 72760) {
                                    if (72752 <= code4 && code4 <= 72758) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72760 <= code4 && code4 <= 72765) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 72850) {
                                if (code4 === 72766) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code4 === 72767) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 72873) {
                                  if (72850 <= code4 && code4 <= 72871) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 72874) {
                                    if (code4 === 72873) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (72874 <= code4 && code4 <= 72880) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 73018) {
                              if (code4 < 72884) {
                                if (code4 < 72882) {
                                  if (code4 === 72881) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72882 <= code4 && code4 <= 72883) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 72885) {
                                  if (code4 === 72884) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code4 < 73009) {
                                    if (72885 <= code4 && code4 <= 72886) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73009 <= code4 && code4 <= 73014) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 73030) {
                                if (code4 < 73020) {
                                  if (code4 === 73018) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 73023) {
                                    if (73020 <= code4 && code4 <= 73021) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73023 <= code4 && code4 <= 73029) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 73031) {
                                  if (code4 === 73030) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code4 < 73098) {
                                    if (code4 === 73031) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73098 <= code4 && code4 <= 73102) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 73526) {
                            if (code4 < 73459) {
                              if (code4 < 73109) {
                                if (code4 < 73107) {
                                  if (73104 <= code4 && code4 <= 73105) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73107 <= code4 && code4 <= 73108) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 73110) {
                                  if (code4 === 73109) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 73110) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code4 === 73111) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 73474) {
                                if (code4 < 73461) {
                                  if (73459 <= code4 && code4 <= 73460) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 73472) {
                                    if (73461 <= code4 && code4 <= 73462) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (73472 <= code4 && code4 <= 73473) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 73475) {
                                  if (code4 === 73474) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code4 < 73524) {
                                    if (code4 === 73475) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (73524 <= code4 && code4 <= 73525) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 78896) {
                              if (code4 < 73536) {
                                if (code4 < 73534) {
                                  if (73526 <= code4 && code4 <= 73530) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73534 <= code4 && code4 <= 73535) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 73537) {
                                  if (code4 === 73536) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 73537) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code4 === 73538) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 92912) {
                                if (code4 < 78912) {
                                  if (78896 <= code4 && code4 <= 78911) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code4 < 78919) {
                                    if (code4 === 78912) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (78919 <= code4 && code4 <= 78933) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 92976) {
                                  if (92912 <= code4 && code4 <= 92916) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 94031) {
                                    if (92976 <= code4 && code4 <= 92982) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 94031) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 121476) {
                          if (code4 < 119143) {
                            if (code4 < 113824) {
                              if (code4 < 94180) {
                                if (code4 < 94095) {
                                  if (94033 <= code4 && code4 <= 94087) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (94095 <= code4 && code4 <= 94098) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 94192) {
                                  if (code4 === 94180) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 113821) {
                                    if (94192 <= code4 && code4 <= 94193) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (113821 <= code4 && code4 <= 113822) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 118576) {
                                if (code4 < 118528) {
                                  if (113824 <= code4 && code4 <= 113827) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (118528 <= code4 && code4 <= 118573) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 119141) {
                                  if (118576 <= code4 && code4 <= 118598) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 119141) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code4 === 119142) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 119173) {
                              if (code4 < 119150) {
                                if (code4 < 119149) {
                                  if (119143 <= code4 && code4 <= 119145) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 === 119149) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code4 < 119155) {
                                  if (119150 <= code4 && code4 <= 119154) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 119163) {
                                    if (119155 <= code4 && code4 <= 119162) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (119163 <= code4 && code4 <= 119170) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 121344) {
                                if (code4 < 119210) {
                                  if (119173 <= code4 && code4 <= 119179) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 119362) {
                                    if (119210 <= code4 && code4 <= 119213) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (119362 <= code4 && code4 <= 119364) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 121403) {
                                  if (121344 <= code4 && code4 <= 121398) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 121461) {
                                    if (121403 <= code4 && code4 <= 121452) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 121461) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 123628) {
                            if (code4 < 122907) {
                              if (code4 < 121505) {
                                if (code4 < 121499) {
                                  if (code4 === 121476) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (121499 <= code4 && code4 <= 121503) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 122880) {
                                  if (121505 <= code4 && code4 <= 121519) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 122888) {
                                    if (122880 <= code4 && code4 <= 122886) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (122888 <= code4 && code4 <= 122904) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 123023) {
                                if (code4 < 122915) {
                                  if (122907 <= code4 && code4 <= 122913) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 122918) {
                                    if (122915 <= code4 && code4 <= 122916) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (122918 <= code4 && code4 <= 122922) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 123184) {
                                  if (code4 === 123023) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 123566) {
                                    if (123184 <= code4 && code4 <= 123190) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code4 === 123566) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 127995) {
                              if (code4 < 125136) {
                                if (code4 < 124140) {
                                  if (123628 <= code4 && code4 <= 123631) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (124140 <= code4 && code4 <= 124143) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code4 < 125252) {
                                  if (125136 <= code4 && code4 <= 125142) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 127462) {
                                    if (125252 <= code4 && code4 <= 125258) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (127462 <= code4 && code4 <= 127487) {
                                      return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code4 < 917632) {
                                if (code4 < 917504) {
                                  if (127995 <= code4 && code4 <= 127999) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code4 < 917536) {
                                    if (917504 <= code4 && code4 <= 917535) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (917536 <= code4 && code4 <= 917631) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code4 < 917760) {
                                  if (917632 <= code4 && code4 <= 917759) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code4 < 918e3) {
                                    if (917760 <= code4 && code4 <= 917999) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (918e3 <= code4 && code4 <= 921599) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return boundaries_1.CLUSTER_BREAK.OTHER;
            }
            static getEmojiProperty(code4) {
              if (code4 < 10160) {
                if (code4 < 9728) {
                  if (code4 < 9e3) {
                    if (code4 < 8482) {
                      if (code4 < 8252) {
                        if (code4 === 169) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code4 === 174) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 === 8252) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code4 === 8265) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 8596) {
                        if (code4 === 8482) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code4 === 8505) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 8617) {
                          if (8596 <= code4 && code4 <= 8601) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 8986) {
                            if (8617 <= code4 && code4 <= 8618) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (8986 <= code4 && code4 <= 8987) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 9410) {
                      if (code4 < 9167) {
                        if (code4 === 9e3) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code4 === 9096) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 9193) {
                          if (code4 === 9167) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 9208) {
                            if (9193 <= code4 && code4 <= 9203) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9208 <= code4 && code4 <= 9210) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 9654) {
                        if (code4 < 9642) {
                          if (code4 === 9410) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9642 <= code4 && code4 <= 9643) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 9664) {
                          if (code4 === 9654) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 9723) {
                            if (code4 === 9664) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9723 <= code4 && code4 <= 9726) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 10035) {
                    if (code4 < 10004) {
                      if (code4 < 9748) {
                        if (code4 < 9735) {
                          if (9728 <= code4 && code4 <= 9733) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9735 <= code4 && code4 <= 9746) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 9872) {
                          if (9748 <= code4 && code4 <= 9861) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 9992) {
                            if (9872 <= code4 && code4 <= 9989) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9992 <= code4 && code4 <= 10002) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 10013) {
                        if (code4 === 10004) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code4 === 10006) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 10017) {
                          if (code4 === 10013) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 === 10017) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code4 === 10024) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 10067) {
                      if (code4 < 10055) {
                        if (code4 < 10052) {
                          if (10035 <= code4 && code4 <= 10036) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 === 10052) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 10060) {
                          if (code4 === 10055) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 === 10060) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code4 === 10062) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    } else {
                      if (code4 < 10083) {
                        if (code4 < 10071) {
                          if (10067 <= code4 && code4 <= 10069) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 === 10071) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 10133) {
                          if (10083 <= code4 && code4 <= 10087) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 10145) {
                            if (10133 <= code4 && code4 <= 10135) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (code4 === 10145) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 127489) {
                  if (code4 < 12951) {
                    if (code4 < 11035) {
                      if (code4 < 10548) {
                        if (code4 === 10160) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code4 === 10175) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 11013) {
                          if (10548 <= code4 && code4 <= 10549) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (11013 <= code4 && code4 <= 11015) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    } else {
                      if (code4 < 11093) {
                        if (code4 < 11088) {
                          if (11035 <= code4 && code4 <= 11036) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 === 11088) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 12336) {
                          if (code4 === 11093) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 === 12336) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code4 === 12349) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 127340) {
                      if (code4 < 126976) {
                        if (code4 === 12951) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code4 === 12953) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 127245) {
                          if (126976 <= code4 && code4 <= 127231) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 127279) {
                            if (127245 <= code4 && code4 <= 127247) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (code4 === 127279) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 127374) {
                        if (code4 < 127358) {
                          if (127340 <= code4 && code4 <= 127345) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127358 <= code4 && code4 <= 127359) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 127377) {
                          if (code4 === 127374) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 127405) {
                            if (127377 <= code4 && code4 <= 127386) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (127405 <= code4 && code4 <= 127461) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 128981) {
                    if (code4 < 127561) {
                      if (code4 < 127535) {
                        if (code4 < 127514) {
                          if (127489 <= code4 && code4 <= 127503) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 === 127514) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 127538) {
                          if (code4 === 127535) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 127548) {
                            if (127538 <= code4 && code4 <= 127546) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (127548 <= code4 && code4 <= 127551) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 128326) {
                        if (code4 < 128e3) {
                          if (127561 <= code4 && code4 <= 127994) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (128e3 <= code4 && code4 <= 128317) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 128640) {
                          if (128326 <= code4 && code4 <= 128591) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 128884) {
                            if (128640 <= code4 && code4 <= 128767) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (128884 <= code4 && code4 <= 128895) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 129198) {
                      if (code4 < 129096) {
                        if (code4 < 129036) {
                          if (128981 <= code4 && code4 <= 129023) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129036 <= code4 && code4 <= 129039) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 129114) {
                          if (129096 <= code4 && code4 <= 129103) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 129160) {
                            if (129114 <= code4 && code4 <= 129119) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (129160 <= code4 && code4 <= 129167) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 129340) {
                        if (code4 < 129292) {
                          if (129198 <= code4 && code4 <= 129279) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129292 <= code4 && code4 <= 129338) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code4 < 129351) {
                          if (129340 <= code4 && code4 <= 129349) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code4 < 130048) {
                            if (129351 <= code4 && code4 <= 129791) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (130048 <= code4 && code4 <= 131069) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return boundaries_1.CLUSTER_BREAK.OTHER;
            }
          };
          exports2.default = Graphemer2;
        }
      });
      var require_lib = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/index.js"(exports2) {
          "use strict";
          var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
            return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var Graphemer_1 = __importDefault(require_Graphemer());
          exports2.default = Graphemer_1.default;
        }
      });
      var require_dist3 = __commonJS2({
        "../../node_modules/.pnpm/iso-datestring-validator@2.2.2/node_modules/iso-datestring-validator/dist/index.js"(exports2) {
          (() => {
            "use strict";
            var e = { d: (t2, r2) => {
              for (var n2 in r2)
                e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
            }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
              typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
            } }, t = {};
            function r(e2, t2) {
              return t2 === void 0 && (t2 = "-"), new RegExp("^(?!0{4}" + t2 + "0{2}" + t2 + "0{2})((?=[0-9]{4}" + t2 + "(((0[^2])|1[0-2])|02(?=" + t2 + "(([0-1][0-9])|2[0-8])))" + t2 + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t2 + "02" + t2 + "29))([0-9]{4})" + t2 + "(?!((0[469])|11)" + t2 + "31)((0[1,3-9]|1[0-2])|(02(?!" + t2 + "3)))" + t2 + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e2);
            }
            function n(e2) {
              var t2 = /\D/.exec(e2);
              return t2 ? t2[0] : "";
            }
            function i(e2, t2, r2) {
              t2 === void 0 && (t2 = ":"), r2 === void 0 && (r2 = false);
              var i2 = new RegExp("^([0-1]|2(?=([0-3])|4" + t2 + "00))[0-9]" + t2 + "[0-5][0-9](" + t2 + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
              if (!r2 || !/[Z+\-]/.test(e2))
                return i2.test(e2);
              if (/Z$/.test(e2))
                return i2.test(e2.replace("Z", ""));
              var o2 = e2.includes("+"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];
              return i2.test(u2) && function(e3, t3, r3) {
                return r3 === void 0 && (r3 = ":"), new RegExp(t3 ? "^(0(?!(2" + r3 + "4)|0" + r3 + "3)|1(?=([0-1]|2(?=" + r3 + "[04])|[34](?=" + r3 + "0))))([03469](?=" + r3 + "[03])|[17](?=" + r3 + "0)|2(?=" + r3 + "[04])|5(?=" + r3 + "[034])|8(?=" + r3 + "[04]))" + r3 + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r3 + "[03])|[0-24-8](?=" + r3 + "00))" + r3 + "[03]0$").test(e3);
              }(d2, o2, n(d2));
            }
            function o(e2) {
              var t2 = e2.split("T"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));
              if (!a2)
                return false;
              var d2, s = (d2 = a2.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d2) ? d2[0] : "");
              return u2 && i(a2, s, true);
            }
            function a(e2, t2) {
              return t2 === void 0 && (t2 = "-"), new RegExp("^[0-9]{4}" + t2 + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e2);
            }
            e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });
            var u = exports2;
            for (var d in t)
              u[d] = t[d];
            t.__esModule && Object.defineProperty(u, "__esModule", { value: true });
          })();
        }
      });
      var require_node_gyp_build_optional_packages = __commonJS2({
        "../../node_modules/.pnpm/node-gyp-build-optional-packages@5.0.3/node_modules/node-gyp-build-optional-packages/index.js"(exports2, module2) {
          var fs3 = __require("fs");
          var path = __require("path");
          var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
          var vars = process.config && process.config.variables || {};
          var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
          var abi = process.versions.modules;
          var runtime = isElectron() ? "electron" : "node";
          var arch = process.arch;
          var platform = process.platform;
          var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
          var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
          var uv = (process.versions.uv || "").split(".")[0];
          module2.exports = load;
          function load(dir) {
            return runtimeRequire(load.path(dir));
          }
          load.path = function(dir) {
            dir = path.resolve(dir || ".");
            var packageName;
            try {
              packageName = runtimeRequire(path.join(dir, "package.json")).name;
              var varName = packageName.toUpperCase().replace(/-/g, "_") + "_PREBUILD";
              if (process.env[varName])
                dir = process.env[varName];
            } catch (err) {
            }
            if (!prebuildsOnly) {
              var release = getFirst(path.join(dir, "build/Release"), matchBuild);
              if (release)
                return release;
              var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
              if (debug)
                return debug;
            }
            var prebuild = resolve(dir);
            if (prebuild)
              return prebuild;
            var nearby = resolve(path.dirname(process.execPath));
            if (nearby)
              return nearby;
            var platformPackage = (packageName[0] == "@" ? "" : "@" + packageName + "/") + packageName + "-" + platform + "-" + arch;
            try {
              var prebuildPackage = path.dirname(__require("module").createRequire(path.join(dir, "package.json")).resolve(platformPackage));
              return resolveFile(prebuildPackage);
            } catch (error) {
            }
            var target2 = [
              "platform=" + platform,
              "arch=" + arch,
              "runtime=" + runtime,
              "abi=" + abi,
              "uv=" + uv,
              armv ? "armv=" + armv : "",
              "libc=" + libc,
              "node=" + process.versions.node,
              process.versions.electron ? "electron=" + process.versions.electron : "",
              typeof __webpack_require__ === "function" ? "webpack=true" : ""
            ].filter(Boolean).join(" ");
            throw new Error("No native build was found for " + target2 + "\n    loaded from: " + dir + " and package: " + platformPackage + "\n");
            function resolve(dir2) {
              var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
              var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
              if (!tuple)
                return;
              return resolveFile(path.join(dir2, "prebuilds", tuple.name));
            }
            function resolveFile(prebuilds) {
              var parsed = readdirSync(prebuilds).map(parseTags);
              var candidates = parsed.filter(matchTags(runtime, abi));
              var winner = candidates.sort(compareTags(runtime))[0];
              if (winner)
                return path.join(prebuilds, winner.file);
            }
          };
          function readdirSync(dir) {
            try {
              return fs3.readdirSync(dir);
            } catch (err) {
              return [];
            }
          }
          function getFirst(dir, filter) {
            var files = readdirSync(dir).filter(filter);
            return files[0] && path.join(dir, files[0]);
          }
          function matchBuild(name3) {
            return /\.node$/.test(name3);
          }
          function parseTuple(name3) {
            var arr = name3.split("-");
            if (arr.length !== 2)
              return;
            var platform2 = arr[0];
            var architectures = arr[1].split("+");
            if (!platform2)
              return;
            if (!architectures.length)
              return;
            if (!architectures.every(Boolean))
              return;
            return { name: name3, platform: platform2, architectures };
          }
          function matchTuple(platform2, arch2) {
            return function(tuple) {
              if (tuple == null)
                return false;
              if (tuple.platform !== platform2)
                return false;
              return tuple.architectures.includes(arch2);
            };
          }
          function compareTuples(a, b) {
            return a.architectures.length - b.architectures.length;
          }
          function parseTags(file) {
            var arr = file.split(".");
            var extension = arr.pop();
            var tags = { file, specificity: 0 };
            if (extension !== "node")
              return;
            for (var i = 0; i < arr.length; i++) {
              var tag = arr[i];
              if (tag === "node" || tag === "electron" || tag === "node-webkit") {
                tags.runtime = tag;
              } else if (tag === "napi") {
                tags.napi = true;
              } else if (tag.slice(0, 3) === "abi") {
                tags.abi = tag.slice(3);
              } else if (tag.slice(0, 2) === "uv") {
                tags.uv = tag.slice(2);
              } else if (tag.slice(0, 4) === "armv") {
                tags.armv = tag.slice(4);
              } else if (tag === "glibc" || tag === "musl") {
                tags.libc = tag;
              } else {
                continue;
              }
              tags.specificity++;
            }
            return tags;
          }
          function matchTags(runtime2, abi2) {
            return function(tags) {
              if (tags == null)
                return false;
              if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
                return false;
              if (tags.abi !== abi2 && !tags.napi)
                return false;
              if (tags.uv && tags.uv !== uv)
                return false;
              if (tags.armv && tags.armv !== armv)
                return false;
              if (tags.libc && tags.libc !== libc)
                return false;
              return true;
            };
          }
          function runtimeAgnostic(tags) {
            return tags.runtime === "node" && tags.napi;
          }
          function compareTags(runtime2) {
            return function(a, b) {
              if (a.runtime !== b.runtime) {
                return a.runtime === runtime2 ? -1 : 1;
              } else if (a.abi !== b.abi) {
                return a.abi ? -1 : 1;
              } else if (a.specificity !== b.specificity) {
                return a.specificity > b.specificity ? -1 : 1;
              } else {
                return 0;
              }
            };
          }
          function isElectron() {
            if (process.versions && process.versions.electron)
              return true;
            if (process.env.ELECTRON_RUN_AS_NODE)
              return true;
            return typeof window !== "undefined" && window.process && window.process.type === "renderer";
          }
          function isAlpine(platform2) {
            return platform2 === "linux" && fs3.existsSync("/etc/alpine-release");
          }
          load.parseTags = parseTags;
          load.matchTags = matchTags;
          load.compareTags = compareTags;
          load.parseTuple = parseTuple;
          load.matchTuple = matchTuple;
          load.compareTuples = compareTuples;
        }
      });
      var require_cbor_extract = __commonJS2({
        "../../node_modules/.pnpm/cbor-extract@2.1.1/node_modules/cbor-extract/index.js"(exports2, module2) {
          module2.exports = require_node_gyp_build_optional_packages()(__dirname);
        }
      });
      var require_err_helpers = __commonJS2({
        "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-helpers.js"(exports2, module2) {
          "use strict";
          var isErrorLike = (err) => {
            return err && typeof err.message === "string";
          };
          var getErrorCause = (err) => {
            if (!err)
              return;
            const cause = err.cause;
            if (typeof cause === "function") {
              const causeResult = err.cause();
              return isErrorLike(causeResult) ? causeResult : void 0;
            } else {
              return isErrorLike(cause) ? cause : void 0;
            }
          };
          var _stackWithCauses = (err, seen) => {
            if (!isErrorLike(err))
              return "";
            const stack = err.stack || "";
            if (seen.has(err)) {
              return stack + "\ncauses have become circular...";
            }
            const cause = getErrorCause(err);
            if (cause) {
              seen.add(err);
              return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
            } else {
              return stack;
            }
          };
          var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
          var _messageWithCauses = (err, seen, skip) => {
            if (!isErrorLike(err))
              return "";
            const message = skip ? "" : err.message || "";
            if (seen.has(err)) {
              return message + ": ...";
            }
            const cause = getErrorCause(err);
            if (cause) {
              seen.add(err);
              const skipIfVErrorStyleCause = typeof err.cause === "function";
              return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
            } else {
              return message;
            }
          };
          var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
          module2.exports = {
            isErrorLike,
            getErrorCause,
            stackWithCauses,
            messageWithCauses
          };
        }
      });
      var require_err_proto = __commonJS2({
        "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-proto.js"(exports2, module2) {
          "use strict";
          var seen = Symbol("circular-ref-tag");
          var rawSymbol = Symbol("pino-raw-err-ref");
          var pinoErrProto = Object.create({}, {
            type: {
              enumerable: true,
              writable: true,
              value: void 0
            },
            message: {
              enumerable: true,
              writable: true,
              value: void 0
            },
            stack: {
              enumerable: true,
              writable: true,
              value: void 0
            },
            aggregateErrors: {
              enumerable: true,
              writable: true,
              value: void 0
            },
            raw: {
              enumerable: false,
              get: function() {
                return this[rawSymbol];
              },
              set: function(val) {
                this[rawSymbol] = val;
              }
            }
          });
          Object.defineProperty(pinoErrProto, rawSymbol, {
            writable: true,
            value: {}
          });
          module2.exports = {
            pinoErrProto,
            pinoErrorSymbols: {
              seen,
              rawSymbol
            }
          };
        }
      });
      var require_err = __commonJS2({
        "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err.js"(exports2, module2) {
          "use strict";
          module2.exports = errSerializer;
          var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
          var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
          var { seen } = pinoErrorSymbols;
          var { toString: toString4 } = Object.prototype;
          function errSerializer(err) {
            if (!isErrorLike(err)) {
              return err;
            }
            err[seen] = void 0;
            const _err = Object.create(pinoErrProto);
            _err.type = toString4.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
            _err.message = messageWithCauses(err);
            _err.stack = stackWithCauses(err);
            if (Array.isArray(err.errors)) {
              _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
            }
            for (const key in err) {
              if (_err[key] === void 0) {
                const val = err[key];
                if (isErrorLike(val)) {
                  if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
                    _err[key] = errSerializer(val);
                  }
                } else {
                  _err[key] = val;
                }
              }
            }
            delete err[seen];
            _err.raw = err;
            return _err;
          }
        }
      });
      var require_err_with_cause = __commonJS2({
        "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-with-cause.js"(exports2, module2) {
          "use strict";
          module2.exports = errWithCauseSerializer;
          var { isErrorLike } = require_err_helpers();
          var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
          var { seen } = pinoErrorSymbols;
          var { toString: toString4 } = Object.prototype;
          function errWithCauseSerializer(err) {
            if (!isErrorLike(err)) {
              return err;
            }
            err[seen] = void 0;
            const _err = Object.create(pinoErrProto);
            _err.type = toString4.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
            _err.message = err.message;
            _err.stack = err.stack;
            if (Array.isArray(err.errors)) {
              _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
            }
            if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
              _err.cause = errWithCauseSerializer(err.cause);
            }
            for (const key in err) {
              if (_err[key] === void 0) {
                const val = err[key];
                if (isErrorLike(val)) {
                  if (!Object.prototype.hasOwnProperty.call(val, seen)) {
                    _err[key] = errWithCauseSerializer(val);
                  }
                } else {
                  _err[key] = val;
                }
              }
            }
            delete err[seen];
            _err.raw = err;
            return _err;
          }
        }
      });
      var require_req = __commonJS2({
        "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/req.js"(exports2, module2) {
          "use strict";
          module2.exports = {
            mapHttpRequest,
            reqSerializer
          };
          var rawSymbol = Symbol("pino-raw-req-ref");
          var pinoReqProto = Object.create({}, {
            id: {
              enumerable: true,
              writable: true,
              value: ""
            },
            method: {
              enumerable: true,
              writable: true,
              value: ""
            },
            url: {
              enumerable: true,
              writable: true,
              value: ""
            },
            query: {
              enumerable: true,
              writable: true,
              value: ""
            },
            params: {
              enumerable: true,
              writable: true,
              value: ""
            },
            headers: {
              enumerable: true,
              writable: true,
              value: {}
            },
            remoteAddress: {
              enumerable: true,
              writable: true,
              value: ""
            },
            remotePort: {
              enumerable: true,
              writable: true,
              value: ""
            },
            raw: {
              enumerable: false,
              get: function() {
                return this[rawSymbol];
              },
              set: function(val) {
                this[rawSymbol] = val;
              }
            }
          });
          Object.defineProperty(pinoReqProto, rawSymbol, {
            writable: true,
            value: {}
          });
          function reqSerializer(req) {
            const connection = req.info || req.socket;
            const _req = Object.create(pinoReqProto);
            _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
            _req.method = req.method;
            if (req.originalUrl) {
              _req.url = req.originalUrl;
            } else {
              const path = req.path;
              _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : void 0;
            }
            if (req.query) {
              _req.query = req.query;
            }
            if (req.params) {
              _req.params = req.params;
            }
            _req.headers = req.headers;
            _req.remoteAddress = connection && connection.remoteAddress;
            _req.remotePort = connection && connection.remotePort;
            _req.raw = req.raw || req;
            return _req;
          }
          function mapHttpRequest(req) {
            return {
              req: reqSerializer(req)
            };
          }
        }
      });
      var require_res = __commonJS2({
        "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/res.js"(exports2, module2) {
          "use strict";
          module2.exports = {
            mapHttpResponse,
            resSerializer
          };
          var rawSymbol = Symbol("pino-raw-res-ref");
          var pinoResProto = Object.create({}, {
            statusCode: {
              enumerable: true,
              writable: true,
              value: 0
            },
            headers: {
              enumerable: true,
              writable: true,
              value: ""
            },
            raw: {
              enumerable: false,
              get: function() {
                return this[rawSymbol];
              },
              set: function(val) {
                this[rawSymbol] = val;
              }
            }
          });
          Object.defineProperty(pinoResProto, rawSymbol, {
            writable: true,
            value: {}
          });
          function resSerializer(res) {
            const _res = Object.create(pinoResProto);
            _res.statusCode = res.headersSent ? res.statusCode : null;
            _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
            _res.raw = res;
            return _res;
          }
          function mapHttpResponse(res) {
            return {
              res: resSerializer(res)
            };
          }
        }
      });
      var require_pino_std_serializers = __commonJS2({
        "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/index.js"(exports2, module2) {
          "use strict";
          var errSerializer = require_err();
          var errWithCauseSerializer = require_err_with_cause();
          var reqSerializers = require_req();
          var resSerializers = require_res();
          module2.exports = {
            err: errSerializer,
            errWithCause: errWithCauseSerializer,
            mapHttpRequest: reqSerializers.mapHttpRequest,
            mapHttpResponse: resSerializers.mapHttpResponse,
            req: reqSerializers.reqSerializer,
            res: resSerializers.resSerializer,
            wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
              if (customSerializer === errSerializer)
                return customSerializer;
              return function wrapErrSerializer(err) {
                return customSerializer(errSerializer(err));
              };
            },
            wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
              if (customSerializer === reqSerializers.reqSerializer)
                return customSerializer;
              return function wrappedReqSerializer(req) {
                return customSerializer(reqSerializers.reqSerializer(req));
              };
            },
            wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
              if (customSerializer === resSerializers.resSerializer)
                return customSerializer;
              return function wrappedResSerializer(res) {
                return customSerializer(resSerializers.resSerializer(res));
              };
            }
          };
        }
      });
      var require_caller = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/caller.js"(exports2, module2) {
          "use strict";
          function noOpPrepareStackTrace(_, stack) {
            return stack;
          }
          module2.exports = function getCallers() {
            const originalPrepare = Error.prepareStackTrace;
            Error.prepareStackTrace = noOpPrepareStackTrace;
            const stack = new Error().stack;
            Error.prepareStackTrace = originalPrepare;
            if (!Array.isArray(stack)) {
              return void 0;
            }
            const entries = stack.slice(2);
            const fileNames = [];
            for (const entry of entries) {
              if (!entry) {
                continue;
              }
              fileNames.push(entry.getFileName());
            }
            return fileNames;
          };
        }
      });
      var require_validator = __commonJS2({
        "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/validator.js"(exports2, module2) {
          "use strict";
          module2.exports = validator;
          function validator(opts = {}) {
            const {
              ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
              ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
            } = opts;
            return function validate3({ paths }) {
              paths.forEach((s) => {
                if (typeof s !== "string") {
                  throw Error(ERR_PATHS_MUST_BE_STRINGS());
                }
                try {
                  if (/〇/.test(s))
                    throw Error();
                  const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
                  if (/\n|\r|;/.test(expr))
                    throw Error();
                  if (/\/\*/.test(expr))
                    throw Error();
                  Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
                } catch (e) {
                  throw Error(ERR_INVALID_PATH(s));
                }
              });
            };
          }
        }
      });
      var require_rx = __commonJS2({
        "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/rx.js"(exports2, module2) {
          "use strict";
          module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
        }
      });
      var require_parse = __commonJS2({
        "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/parse.js"(exports2, module2) {
          "use strict";
          var rx = require_rx();
          module2.exports = parse;
          function parse({ paths }) {
            const wildcards = [];
            var wcLen = 0;
            const secret = paths.reduce(function(o, strPath, ix) {
              var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
              const leadingBracket = strPath[0] === "[";
              path = path.map((p) => {
                if (p[0] === "[")
                  return p.substr(1, p.length - 2);
                else
                  return p;
              });
              const star = path.indexOf("*");
              if (star > -1) {
                const before = path.slice(0, star);
                const beforeStr = before.join(".");
                const after = path.slice(star + 1, path.length);
                const nested = after.length > 0;
                wcLen++;
                wildcards.push({
                  before,
                  beforeStr,
                  after,
                  nested
                });
              } else {
                o[strPath] = {
                  path,
                  val: void 0,
                  precensored: false,
                  circle: "",
                  escPath: JSON.stringify(strPath),
                  leadingBracket
                };
              }
              return o;
            }, {});
            return { wildcards, wcLen, secret };
          }
        }
      });
      var require_redactor = __commonJS2({
        "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/redactor.js"(exports2, module2) {
          "use strict";
          var rx = require_rx();
          module2.exports = redactor;
          function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
            const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    ${resultTmpl(serialize)}
  `).bind(state);
            if (serialize === false) {
              redact.restore = (o) => state.restore(o);
            }
            return redact;
          }
          function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
            return Object.keys(secret).map((path) => {
              const { escPath, leadingBracket, path: arrPath } = secret[path];
              const skip = leadingBracket ? 1 : 0;
              const delim = leadingBracket ? "" : ".";
              const hops = [];
              var match;
              while ((match = rx.exec(path)) !== null) {
                const [, ix] = match;
                const { index, input } = match;
                if (index > skip)
                  hops.push(input.substring(0, index - (ix ? 0 : 1)));
              }
              var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
              if (existence.length === 0)
                existence += `o${delim}${path} != null`;
              else
                existence += ` && o${delim}${path} != null`;
              const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
              const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
              return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
            }).join("\n");
          }
          function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
            return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
          }
          function resultTmpl(serialize) {
            return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
          }
          function strictImpl(strict, serialize) {
            return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
          }
        }
      });
      var require_modifiers = __commonJS2({
        "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/modifiers.js"(exports2, module2) {
          "use strict";
          module2.exports = {
            groupRedact,
            groupRestore,
            nestedRedact,
            nestedRestore
          };
          function groupRestore({ keys, values, target: target2 }) {
            if (target2 == null)
              return;
            const length2 = keys.length;
            for (var i = 0; i < length2; i++) {
              const k = keys[i];
              target2[k] = values[i];
            }
          }
          function groupRedact(o, path, censor, isCensorFct, censorFctTakesPath) {
            const target2 = get2(o, path);
            if (target2 == null)
              return { keys: null, values: null, target: null, flat: true };
            const keys = Object.keys(target2);
            const keysLength = keys.length;
            const pathLength = path.length;
            const pathWithKey = censorFctTakesPath ? [...path] : void 0;
            const values = new Array(keysLength);
            for (var i = 0; i < keysLength; i++) {
              const key = keys[i];
              values[i] = target2[key];
              if (censorFctTakesPath) {
                pathWithKey[pathLength] = key;
                target2[key] = censor(target2[key], pathWithKey);
              } else if (isCensorFct) {
                target2[key] = censor(target2[key]);
              } else {
                target2[key] = censor;
              }
            }
            return { keys, values, target: target2, flat: true };
          }
          function nestedRestore(instructions) {
            for (let i = 0; i < instructions.length; i++) {
              const { target: target2, path, value } = instructions[i];
              let current = target2;
              for (let i2 = path.length - 1; i2 > 0; i2--) {
                current = current[path[i2]];
              }
              current[path[0]] = value;
            }
          }
          function nestedRedact(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
            const target2 = get2(o, path);
            if (target2 == null)
              return;
            const keys = Object.keys(target2);
            const keysLength = keys.length;
            for (var i = 0; i < keysLength; i++) {
              const key = keys[i];
              specialSet(store, target2, key, path, ns, censor, isCensorFct, censorFctTakesPath);
            }
            return store;
          }
          function has(obj, prop) {
            return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
          }
          function specialSet(store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
            const afterPathLen = afterPath.length;
            const lastPathIndex = afterPathLen - 1;
            const originalKey = k;
            var i = -1;
            var n;
            var nv;
            var ov;
            var oov = null;
            var wc = null;
            var kIsWc;
            var wcov;
            var consecutive = false;
            var level2 = 0;
            var depth = 0;
            var redactPathCurrent = tree2();
            ov = n = o[k];
            if (typeof n !== "object")
              return;
            while (n != null && ++i < afterPathLen) {
              depth += 1;
              k = afterPath[i];
              oov = ov;
              if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
                break;
              }
              if (k === "*") {
                if (wc === "*") {
                  consecutive = true;
                }
                wc = k;
                if (i !== lastPathIndex) {
                  continue;
                }
              }
              if (wc) {
                const wcKeys = Object.keys(n);
                for (var j = 0; j < wcKeys.length; j++) {
                  const wck = wcKeys[j];
                  wcov = n[wck];
                  kIsWc = k === "*";
                  if (consecutive) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    level2 = i;
                    ov = iterateNthLevel(wcov, level2 - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
                  } else {
                    if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                      if (kIsWc) {
                        ov = wcov;
                      } else {
                        ov = wcov[k];
                      }
                      nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                      if (kIsWc) {
                        const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
                        store.push(rv);
                        n[wck] = nv;
                      } else {
                        if (wcov[k] === nv) {
                        } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
                          redactPathCurrent = node(redactPathCurrent, wck, depth);
                        } else {
                          redactPathCurrent = node(redactPathCurrent, wck, depth);
                          const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                          store.push(rv);
                          wcov[k] = nv;
                        }
                      }
                    }
                  }
                }
                wc = null;
              } else {
                ov = n[k];
                redactPathCurrent = node(redactPathCurrent, k, depth);
                nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                if (has(n, k) && nv === ov || nv === void 0 && censor !== void 0) {
                } else {
                  const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
                  store.push(rv);
                  n[k] = nv;
                }
                n = n[k];
              }
              if (typeof n !== "object")
                break;
              if (ov === oov || typeof ov === "undefined") {
              }
            }
          }
          function get2(o, p) {
            var i = -1;
            var l = p.length;
            var n = o;
            while (n != null && ++i < l) {
              n = n[p[i]];
            }
            return n;
          }
          function iterateNthLevel(wcov, level2, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
            if (level2 === 0) {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(redactPathCurrent, ov, parent);
                  store.push(rv);
                  n[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
                  } else {
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
            for (const key in wcov) {
              if (typeof wcov[key] === "object") {
                redactPathCurrent = node(redactPathCurrent, key, depth);
                iterateNthLevel(wcov[key], level2 - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
              }
            }
          }
          function tree2() {
            return { parent: null, key: null, children: [], depth: 0 };
          }
          function node(parent, key, depth) {
            if (parent.depth === depth) {
              return node(parent.parent, key, depth);
            }
            var child = {
              parent,
              key,
              depth,
              children: []
            };
            parent.children.push(child);
            return child;
          }
          function restoreInstr(node2, value, target2) {
            let current = node2;
            const path = [];
            do {
              path.push(current.key);
              current = current.parent;
            } while (current.parent != null);
            return { path, value, target: target2 };
          }
        }
      });
      var require_restorer = __commonJS2({
        "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/restorer.js"(exports2, module2) {
          "use strict";
          var { groupRestore, nestedRestore } = require_modifiers();
          module2.exports = restorer;
          function restorer({ secret, wcLen }) {
            return function compileRestore() {
              if (this.restore)
                return;
              const paths = Object.keys(secret);
              const resetters = resetTmpl(secret, paths);
              const hasWildcards = wcLen > 0;
              const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
              this.restore = Function("o", restoreTmpl(resetters, paths, hasWildcards)).bind(state);
            };
          }
          function resetTmpl(secret, paths) {
            return paths.map((path) => {
              const { circle, escPath, leadingBracket } = secret[path];
              const delim = leadingBracket ? "" : ".";
              const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
              const clear = `secret[${escPath}].val = undefined`;
              return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
            }).join("");
          }
          function restoreTmpl(resetters, paths, hasWildcards) {
            const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : "";
            return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
          }
        }
      });
      var require_state = __commonJS2({
        "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/state.js"(exports2, module2) {
          "use strict";
          module2.exports = state;
          function state(o) {
            const {
              secret,
              censor,
              compileRestore,
              serialize,
              groupRedact,
              nestedRedact,
              wildcards,
              wcLen
            } = o;
            const builder = [{ secret, censor, compileRestore }];
            if (serialize !== false)
              builder.push({ serialize });
            if (wcLen > 0)
              builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
            return Object.assign(...builder);
          }
        }
      });
      var require_fast_redact = __commonJS2({
        "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/index.js"(exports2, module2) {
          "use strict";
          var validator = require_validator();
          var parse = require_parse();
          var redactor = require_redactor();
          var restorer = require_restorer();
          var { groupRedact, nestedRedact } = require_modifiers();
          var state = require_state();
          var rx = require_rx();
          var validate3 = validator();
          var noop2 = (o) => o;
          noop2.restore = noop2;
          var DEFAULT_CENSOR = "[REDACTED]";
          fastRedact.rx = rx;
          fastRedact.validator = validator;
          module2.exports = fastRedact;
          function fastRedact(opts = {}) {
            const paths = Array.from(new Set(opts.paths || []));
            const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
            const remove = opts.remove;
            if (remove === true && serialize !== JSON.stringify) {
              throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
            }
            const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
            const isCensorFct = typeof censor === "function";
            const censorFctTakesPath = isCensorFct && censor.length > 1;
            if (paths.length === 0)
              return serialize || noop2;
            validate3({ paths, serialize, censor });
            const { wildcards, wcLen, secret } = parse({ paths, censor });
            const compileRestore = restorer({ secret, wcLen });
            const strict = "strict" in opts ? opts.strict : true;
            return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
              secret,
              censor,
              compileRestore,
              serialize,
              groupRedact,
              nestedRedact,
              wildcards,
              wcLen
            }));
          }
        }
      });
      var require_symbols = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/symbols.js"(exports2, module2) {
          "use strict";
          var setLevelSym = Symbol("pino.setLevel");
          var getLevelSym = Symbol("pino.getLevel");
          var levelValSym = Symbol("pino.levelVal");
          var useLevelLabelsSym = Symbol("pino.useLevelLabels");
          var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
          var mixinSym = Symbol("pino.mixin");
          var lsCacheSym = Symbol("pino.lsCache");
          var chindingsSym = Symbol("pino.chindings");
          var asJsonSym = Symbol("pino.asJson");
          var writeSym = Symbol("pino.write");
          var redactFmtSym = Symbol("pino.redactFmt");
          var timeSym = Symbol("pino.time");
          var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
          var streamSym = Symbol("pino.stream");
          var stringifySym = Symbol("pino.stringify");
          var stringifySafeSym = Symbol("pino.stringifySafe");
          var stringifiersSym = Symbol("pino.stringifiers");
          var endSym = Symbol("pino.end");
          var formatOptsSym = Symbol("pino.formatOpts");
          var messageKeySym = Symbol("pino.messageKey");
          var errorKeySym = Symbol("pino.errorKey");
          var nestedKeySym = Symbol("pino.nestedKey");
          var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
          var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
          var msgPrefixSym = Symbol("pino.msgPrefix");
          var wildcardFirstSym = Symbol("pino.wildcardFirst");
          var serializersSym = Symbol.for("pino.serializers");
          var formattersSym = Symbol.for("pino.formatters");
          var hooksSym = Symbol.for("pino.hooks");
          var needsMetadataGsym = Symbol.for("pino.metadata");
          module2.exports = {
            setLevelSym,
            getLevelSym,
            levelValSym,
            useLevelLabelsSym,
            mixinSym,
            lsCacheSym,
            chindingsSym,
            asJsonSym,
            writeSym,
            serializersSym,
            redactFmtSym,
            timeSym,
            timeSliceIndexSym,
            streamSym,
            stringifySym,
            stringifySafeSym,
            stringifiersSym,
            endSym,
            formatOptsSym,
            messageKeySym,
            errorKeySym,
            nestedKeySym,
            wildcardFirstSym,
            needsMetadataGsym,
            useOnlyCustomLevelsSym,
            formattersSym,
            hooksSym,
            nestedKeyStrSym,
            mixinMergeStrategySym,
            msgPrefixSym
          };
        }
      });
      var require_redaction = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/redaction.js"(exports2, module2) {
          "use strict";
          var fastRedact = require_fast_redact();
          var { redactFmtSym, wildcardFirstSym } = require_symbols();
          var { rx, validator } = fastRedact;
          var validate3 = validator({
            ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
            ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
          });
          var CENSOR = "[Redacted]";
          var strict = false;
          function redaction(opts, serialize) {
            const { paths, censor } = handle2(opts);
            const shape = paths.reduce((o, str) => {
              rx.lastIndex = 0;
              const first = rx.exec(str);
              const next = rx.exec(str);
              let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
              if (ns === "*") {
                ns = wildcardFirstSym;
              }
              if (next === null) {
                o[ns] = null;
                return o;
              }
              if (o[ns] === null) {
                return o;
              }
              const { index } = next;
              const nextPath = `${str.substr(index, str.length - 1)}`;
              o[ns] = o[ns] || [];
              if (ns !== wildcardFirstSym && o[ns].length === 0) {
                o[ns].push(...o[wildcardFirstSym] || []);
              }
              if (ns === wildcardFirstSym) {
                Object.keys(o).forEach(function(k) {
                  if (o[k]) {
                    o[k].push(nextPath);
                  }
                });
              }
              o[ns].push(nextPath);
              return o;
            }, {});
            const result = {
              [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
            };
            const topCensor = (...args) => {
              return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
            };
            return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
              if (shape[k] === null) {
                o[k] = (value) => topCensor(value, [k]);
              } else {
                const wrappedCensor = typeof censor === "function" ? (value, path) => {
                  return censor(value, [k, ...path]);
                } : censor;
                o[k] = fastRedact({
                  paths: shape[k],
                  censor: wrappedCensor,
                  serialize,
                  strict
                });
              }
              return o;
            }, result);
          }
          function handle2(opts) {
            if (Array.isArray(opts)) {
              opts = { paths: opts, censor: CENSOR };
              validate3(opts);
              return opts;
            }
            let { paths, censor = CENSOR, remove } = opts;
            if (Array.isArray(paths) === false) {
              throw Error("pino \u2013 redact must contain an array of strings");
            }
            if (remove === true)
              censor = void 0;
            validate3({ paths, censor });
            return { paths, censor };
          }
          module2.exports = redaction;
        }
      });
      var require_time = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/time.js"(exports2, module2) {
          "use strict";
          var nullTime = () => "";
          var epochTime = () => `,"time":${Date.now()}`;
          var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
          var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
          module2.exports = { nullTime, epochTime, unixTime, isoTime };
        }
      });
      var require_quick_format_unescaped = __commonJS2({
        "../../node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports2, module2) {
          "use strict";
          function tryStringify(o) {
            try {
              return JSON.stringify(o);
            } catch (e) {
              return '"[Circular]"';
            }
          }
          module2.exports = format;
          function format(f, args, opts) {
            var ss = opts && opts.stringify || tryStringify;
            var offset = 1;
            if (typeof f === "object" && f !== null) {
              var len = args.length + offset;
              if (len === 1)
                return f;
              var objects = new Array(len);
              objects[0] = ss(f);
              for (var index = 1; index < len; index++) {
                objects[index] = ss(args[index]);
              }
              return objects.join(" ");
            }
            if (typeof f !== "string") {
              return f;
            }
            var argLen = args.length;
            if (argLen === 0)
              return f;
            var str = "";
            var a = 1 - offset;
            var lastPos = -1;
            var flen = f && f.length || 0;
            for (var i = 0; i < flen; ) {
              if (f.charCodeAt(i) === 37 && i + 1 < flen) {
                lastPos = lastPos > -1 ? lastPos : 0;
                switch (f.charCodeAt(i + 1)) {
                  case 100:
                  case 102:
                    if (a >= argLen)
                      break;
                    if (args[a] == null)
                      break;
                    if (lastPos < i)
                      str += f.slice(lastPos, i);
                    str += Number(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                  case 105:
                    if (a >= argLen)
                      break;
                    if (args[a] == null)
                      break;
                    if (lastPos < i)
                      str += f.slice(lastPos, i);
                    str += Math.floor(Number(args[a]));
                    lastPos = i + 2;
                    i++;
                    break;
                  case 79:
                  case 111:
                  case 106:
                    if (a >= argLen)
                      break;
                    if (args[a] === void 0)
                      break;
                    if (lastPos < i)
                      str += f.slice(lastPos, i);
                    var type = typeof args[a];
                    if (type === "string") {
                      str += "'" + args[a] + "'";
                      lastPos = i + 2;
                      i++;
                      break;
                    }
                    if (type === "function") {
                      str += args[a].name || "<anonymous>";
                      lastPos = i + 2;
                      i++;
                      break;
                    }
                    str += ss(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                  case 115:
                    if (a >= argLen)
                      break;
                    if (lastPos < i)
                      str += f.slice(lastPos, i);
                    str += String(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                  case 37:
                    if (lastPos < i)
                      str += f.slice(lastPos, i);
                    str += "%";
                    lastPos = i + 2;
                    i++;
                    a--;
                    break;
                }
                ++a;
              }
              ++i;
            }
            if (lastPos === -1)
              return f;
            else if (lastPos < flen) {
              str += f.slice(lastPos);
            }
            return str;
          }
        }
      });
      var require_atomic_sleep = __commonJS2({
        "../../node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js"(exports2, module2) {
          "use strict";
          if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
            let sleep = function(ms) {
              const valid = ms > 0 && ms < Infinity;
              if (valid === false) {
                if (typeof ms !== "number" && typeof ms !== "bigint") {
                  throw TypeError("sleep: ms must be a number");
                }
                throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
              }
              Atomics.wait(nil, 0, 0, Number(ms));
            };
            const nil = new Int32Array(new SharedArrayBuffer(4));
            module2.exports = sleep;
          } else {
            let sleep = function(ms) {
              const valid = ms > 0 && ms < Infinity;
              if (valid === false) {
                if (typeof ms !== "number" && typeof ms !== "bigint") {
                  throw TypeError("sleep: ms must be a number");
                }
                throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
              }
              const target2 = Date.now() + Number(ms);
              while (target2 > Date.now()) {
              }
            };
            module2.exports = sleep;
          }
        }
      });
      var require_sonic_boom = __commonJS2({
        "../../node_modules/.pnpm/sonic-boom@3.3.0/node_modules/sonic-boom/index.js"(exports2, module2) {
          "use strict";
          var fs3 = __require("fs");
          var EventEmitter = __require("events");
          var inherits = __require("util").inherits;
          var path = __require("path");
          var sleep = require_atomic_sleep();
          var BUSY_WRITE_TIMEOUT = 100;
          var MAX_WRITE = 16 * 1024;
          function openFile(file, sonic) {
            sonic._opening = true;
            sonic._writing = true;
            sonic._asyncDrainScheduled = false;
            function fileOpened(err, fd) {
              if (err) {
                sonic._reopening = false;
                sonic._writing = false;
                sonic._opening = false;
                if (sonic.sync) {
                  process.nextTick(() => {
                    if (sonic.listenerCount("error") > 0) {
                      sonic.emit("error", err);
                    }
                  });
                } else {
                  sonic.emit("error", err);
                }
                return;
              }
              sonic.fd = fd;
              sonic.file = file;
              sonic._reopening = false;
              sonic._opening = false;
              sonic._writing = false;
              if (sonic.sync) {
                process.nextTick(() => sonic.emit("ready"));
              } else {
                sonic.emit("ready");
              }
              if (sonic._reopening) {
                return;
              }
              if (!sonic._writing && sonic._len > sonic.minLength && !sonic.destroyed) {
                actualWrite(sonic);
              }
            }
            const flags = sonic.append ? "a" : "w";
            const mode = sonic.mode;
            if (sonic.sync) {
              try {
                if (sonic.mkdir)
                  fs3.mkdirSync(path.dirname(file), { recursive: true });
                const fd = fs3.openSync(file, flags, mode);
                fileOpened(null, fd);
              } catch (err) {
                fileOpened(err);
                throw err;
              }
            } else if (sonic.mkdir) {
              fs3.mkdir(path.dirname(file), { recursive: true }, (err) => {
                if (err)
                  return fileOpened(err);
                fs3.open(file, flags, mode, fileOpened);
              });
            } else {
              fs3.open(file, flags, mode, fileOpened);
            }
          }
          function SonicBoom(opts) {
            if (!(this instanceof SonicBoom)) {
              return new SonicBoom(opts);
            }
            let { fd, dest, minLength, maxLength, maxWrite, sync, append = true, mode, mkdir, retryEAGAIN, fsync } = opts || {};
            fd = fd || dest;
            this._bufs = [];
            this._len = 0;
            this.fd = -1;
            this._writing = false;
            this._writingBuf = "";
            this._ending = false;
            this._reopening = false;
            this._asyncDrainScheduled = false;
            this._hwm = Math.max(minLength || 0, 16387);
            this.file = null;
            this.destroyed = false;
            this.minLength = minLength || 0;
            this.maxLength = maxLength || 0;
            this.maxWrite = maxWrite || MAX_WRITE;
            this.sync = sync || false;
            this._fsync = fsync || false;
            this.append = append || false;
            this.mode = mode;
            this.retryEAGAIN = retryEAGAIN || (() => true);
            this.mkdir = mkdir || false;
            if (typeof fd === "number") {
              this.fd = fd;
              process.nextTick(() => this.emit("ready"));
            } else if (typeof fd === "string") {
              openFile(fd, this);
            } else {
              throw new Error("SonicBoom supports only file descriptors and files");
            }
            if (this.minLength >= this.maxWrite) {
              throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
            }
            this.release = (err, n) => {
              if (err) {
                if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
                  if (this.sync) {
                    try {
                      sleep(BUSY_WRITE_TIMEOUT);
                      this.release(void 0, 0);
                    } catch (err2) {
                      this.release(err2);
                    }
                  } else {
                    setTimeout(() => {
                      fs3.write(this.fd, this._writingBuf, "utf8", this.release);
                    }, BUSY_WRITE_TIMEOUT);
                  }
                } else {
                  this._writing = false;
                  this.emit("error", err);
                }
                return;
              }
              this.emit("write", n);
              this._len -= n;
              if (this._len < 0) {
                this._len = 0;
              }
              this._writingBuf = this._writingBuf.slice(n);
              if (this._writingBuf.length) {
                if (!this.sync) {
                  fs3.write(this.fd, this._writingBuf, "utf8", this.release);
                  return;
                }
                try {
                  do {
                    const n2 = fs3.writeSync(this.fd, this._writingBuf, "utf8");
                    this._len -= n2;
                    this._writingBuf = this._writingBuf.slice(n2);
                  } while (this._writingBuf);
                } catch (err2) {
                  this.release(err2);
                  return;
                }
              }
              if (this._fsync) {
                fs3.fsyncSync(this.fd);
              }
              const len = this._len;
              if (this._reopening) {
                this._writing = false;
                this._reopening = false;
                this.reopen();
              } else if (len > this.minLength) {
                actualWrite(this);
              } else if (this._ending) {
                if (len > 0) {
                  actualWrite(this);
                } else {
                  this._writing = false;
                  actualClose(this);
                }
              } else {
                this._writing = false;
                if (this.sync) {
                  if (!this._asyncDrainScheduled) {
                    this._asyncDrainScheduled = true;
                    process.nextTick(emitDrain, this);
                  }
                } else {
                  this.emit("drain");
                }
              }
            };
            this.on("newListener", function(name3) {
              if (name3 === "drain") {
                this._asyncDrainScheduled = false;
              }
            });
          }
          function emitDrain(sonic) {
            const hasListeners = sonic.listenerCount("drain") > 0;
            if (!hasListeners)
              return;
            sonic._asyncDrainScheduled = false;
            sonic.emit("drain");
          }
          inherits(SonicBoom, EventEmitter);
          SonicBoom.prototype.write = function(data) {
            if (this.destroyed) {
              throw new Error("SonicBoom destroyed");
            }
            const len = this._len + data.length;
            const bufs = this._bufs;
            if (this.maxLength && len > this.maxLength) {
              this.emit("drop", data);
              return this._len < this._hwm;
            }
            if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
              bufs.push("" + data);
            } else {
              bufs[bufs.length - 1] += data;
            }
            this._len = len;
            if (!this._writing && this._len >= this.minLength) {
              actualWrite(this);
            }
            return this._len < this._hwm;
          };
          SonicBoom.prototype.flush = function() {
            if (this.destroyed) {
              throw new Error("SonicBoom destroyed");
            }
            if (this._writing || this.minLength <= 0) {
              return;
            }
            if (this._bufs.length === 0) {
              this._bufs.push("");
            }
            actualWrite(this);
          };
          SonicBoom.prototype.reopen = function(file) {
            if (this.destroyed) {
              throw new Error("SonicBoom destroyed");
            }
            if (this._opening) {
              this.once("ready", () => {
                this.reopen(file);
              });
              return;
            }
            if (this._ending) {
              return;
            }
            if (!this.file) {
              throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
            }
            this._reopening = true;
            if (this._writing) {
              return;
            }
            const fd = this.fd;
            this.once("ready", () => {
              if (fd !== this.fd) {
                fs3.close(fd, (err) => {
                  if (err) {
                    return this.emit("error", err);
                  }
                });
              }
            });
            openFile(file || this.file, this);
          };
          SonicBoom.prototype.end = function() {
            if (this.destroyed) {
              throw new Error("SonicBoom destroyed");
            }
            if (this._opening) {
              this.once("ready", () => {
                this.end();
              });
              return;
            }
            if (this._ending) {
              return;
            }
            this._ending = true;
            if (this._writing) {
              return;
            }
            if (this._len > 0 && this.fd >= 0) {
              actualWrite(this);
            } else {
              actualClose(this);
            }
          };
          SonicBoom.prototype.flushSync = function() {
            if (this.destroyed) {
              throw new Error("SonicBoom destroyed");
            }
            if (this.fd < 0) {
              throw new Error("sonic boom is not ready yet");
            }
            if (!this._writing && this._writingBuf.length > 0) {
              this._bufs.unshift(this._writingBuf);
              this._writingBuf = "";
            }
            let buf2 = "";
            while (this._bufs.length || buf2.length) {
              if (buf2.length <= 0) {
                buf2 = this._bufs[0];
              }
              try {
                const n = fs3.writeSync(this.fd, buf2, "utf8");
                buf2 = buf2.slice(n);
                this._len = Math.max(this._len - n, 0);
                if (buf2.length <= 0) {
                  this._bufs.shift();
                }
              } catch (err) {
                const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
                if (shouldRetry && !this.retryEAGAIN(err, buf2.length, this._len - buf2.length)) {
                  throw err;
                }
                sleep(BUSY_WRITE_TIMEOUT);
              }
            }
          };
          SonicBoom.prototype.destroy = function() {
            if (this.destroyed) {
              return;
            }
            actualClose(this);
          };
          function actualWrite(sonic) {
            const release = sonic.release;
            sonic._writing = true;
            sonic._writingBuf = sonic._writingBuf || sonic._bufs.shift() || "";
            if (sonic.sync) {
              try {
                const written = fs3.writeSync(sonic.fd, sonic._writingBuf, "utf8");
                release(null, written);
              } catch (err) {
                release(err);
              }
            } else {
              fs3.write(sonic.fd, sonic._writingBuf, "utf8", release);
            }
          }
          function actualClose(sonic) {
            if (sonic.fd === -1) {
              sonic.once("ready", actualClose.bind(null, sonic));
              return;
            }
            sonic.destroyed = true;
            sonic._bufs = [];
            if (sonic.fd !== 1 && sonic.fd !== 2) {
              fs3.close(sonic.fd, done);
            } else {
              setImmediate(done);
            }
            function done(err) {
              if (err) {
                sonic.emit("error", err);
                return;
              }
              if (sonic._ending && !sonic._writing) {
                sonic.emit("finish");
              }
              sonic.emit("close");
            }
          }
          SonicBoom.SonicBoom = SonicBoom;
          SonicBoom.default = SonicBoom;
          module2.exports = SonicBoom;
        }
      });
      var require_on_exit_leak_free = __commonJS2({
        "../../node_modules/.pnpm/on-exit-leak-free@2.1.0/node_modules/on-exit-leak-free/index.js"(exports2, module2) {
          "use strict";
          var refs = {
            exit: [],
            beforeExit: []
          };
          var functions = {
            exit: onExit,
            beforeExit: onBeforeExit
          };
          var registry = new FinalizationRegistry(clear);
          function install(event) {
            if (refs[event].length > 0) {
              return;
            }
            process.on(event, functions[event]);
          }
          function uninstall(event) {
            if (refs[event].length > 0) {
              return;
            }
            process.removeListener(event, functions[event]);
          }
          function onExit() {
            callRefs("exit");
          }
          function onBeforeExit() {
            callRefs("beforeExit");
          }
          function callRefs(event) {
            for (const ref of refs[event]) {
              const obj = ref.deref();
              const fn = ref.fn;
              if (obj !== void 0) {
                fn(obj, event);
              }
            }
          }
          function clear(ref) {
            for (const event of ["exit", "beforeExit"]) {
              const index = refs[event].indexOf(ref);
              refs[event].splice(index, index + 1);
              uninstall(event);
            }
          }
          function _register(event, obj, fn) {
            if (obj === void 0) {
              throw new Error("the object can't be undefined");
            }
            install(event);
            const ref = new WeakRef(obj);
            ref.fn = fn;
            registry.register(obj, ref);
            refs[event].push(ref);
          }
          function register(obj, fn) {
            _register("exit", obj, fn);
          }
          function registerBeforeExit(obj, fn) {
            _register("beforeExit", obj, fn);
          }
          function unregister(obj) {
            registry.unregister(obj);
            for (const event of ["exit", "beforeExit"]) {
              refs[event] = refs[event].filter((ref) => {
                const _obj = ref.deref();
                return _obj && _obj !== obj;
              });
              uninstall(event);
            }
          }
          module2.exports = {
            register,
            registerBeforeExit,
            unregister
          };
        }
      });
      var require_package = __commonJS2({
        "../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/package.json"(exports2, module2) {
          module2.exports = {
            name: "thread-stream",
            version: "2.4.0",
            description: "A streaming way to send data to a Node.js Worker Thread",
            main: "index.js",
            types: "index.d.ts",
            dependencies: {
              "real-require": "^0.2.0"
            },
            devDependencies: {
              "@types/node": "^20.1.0",
              "@types/tap": "^15.0.0",
              desm: "^1.3.0",
              fastbench: "^1.0.1",
              husky: "^8.0.1",
              "pino-elasticsearch": "^6.0.0",
              "sonic-boom": "^3.0.0",
              standard: "^17.0.0",
              tap: "^16.2.0",
              "ts-node": "^10.8.0",
              typescript: "^4.7.2",
              "why-is-node-running": "^2.2.2"
            },
            scripts: {
              test: "standard && npm run transpile && tap test/*.test.*js && tap --ts test/*.test.*ts",
              "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
              "test:ci:js": 'tap --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*js"',
              "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
              "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
              transpile: "sh ./test/ts/transpile.sh",
              prepare: "husky install"
            },
            standard: {
              ignore: [
                "test/ts/**/*"
              ]
            },
            repository: {
              type: "git",
              url: "git+https://github.com/mcollina/thread-stream.git"
            },
            keywords: [
              "worker",
              "thread",
              "threads",
              "stream"
            ],
            author: "Matteo Collina <hello@matteocollina.com>",
            license: "MIT",
            bugs: {
              url: "https://github.com/mcollina/thread-stream/issues"
            },
            homepage: "https://github.com/mcollina/thread-stream#readme"
          };
        }
      });
      var require_wait = __commonJS2({
        "../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/lib/wait.js"(exports2, module2) {
          "use strict";
          var MAX_TIMEOUT = 1e3;
          function wait(state, index, expected, timeout, done) {
            const max = Date.now() + timeout;
            let current = Atomics.load(state, index);
            if (current === expected) {
              done(null, "ok");
              return;
            }
            let prior = current;
            const check2 = (backoff) => {
              if (Date.now() > max) {
                done(null, "timed-out");
              } else {
                setTimeout(() => {
                  prior = current;
                  current = Atomics.load(state, index);
                  if (current === prior) {
                    check2(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
                  } else {
                    if (current === expected)
                      done(null, "ok");
                    else
                      done(null, "not-equal");
                  }
                }, backoff);
              }
            };
            check2(1);
          }
          function waitDiff(state, index, expected, timeout, done) {
            const max = Date.now() + timeout;
            let current = Atomics.load(state, index);
            if (current !== expected) {
              done(null, "ok");
              return;
            }
            const check2 = (backoff) => {
              if (Date.now() > max) {
                done(null, "timed-out");
              } else {
                setTimeout(() => {
                  current = Atomics.load(state, index);
                  if (current !== expected) {
                    done(null, "ok");
                  } else {
                    check2(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
                  }
                }, backoff);
              }
            };
            check2(1);
          }
          module2.exports = { wait, waitDiff };
        }
      });
      var require_indexes = __commonJS2({
        "../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/lib/indexes.js"(exports2, module2) {
          "use strict";
          var WRITE_INDEX = 4;
          var READ_INDEX = 8;
          module2.exports = {
            WRITE_INDEX,
            READ_INDEX
          };
        }
      });
      var require_thread_stream = __commonJS2({
        "../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/index.js"(exports2, module2) {
          "use strict";
          var { version: version2 } = require_package();
          var { EventEmitter } = __require("events");
          var { Worker } = __require("worker_threads");
          var { join } = __require("path");
          var { pathToFileURL } = __require("url");
          var { wait } = require_wait();
          var {
            WRITE_INDEX,
            READ_INDEX
          } = require_indexes();
          var buffer2 = require_buffer();
          var assert2 = __require("assert");
          var kImpl = Symbol("kImpl");
          var MAX_STRING = buffer2.constants.MAX_STRING_LENGTH;
          var FakeWeakRef = class {
            constructor(value) {
              this._value = value;
            }
            deref() {
              return this._value;
            }
          };
          var FinalizationRegistry2 = global.FinalizationRegistry || class FakeFinalizationRegistry {
            register() {
            }
            unregister() {
            }
          };
          var WeakRef2 = global.WeakRef || FakeWeakRef;
          var registry = new FinalizationRegistry2((worker) => {
            if (worker.exited) {
              return;
            }
            worker.terminate();
          });
          function createWorker(stream, opts) {
            const { filename, workerData } = opts;
            const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
            const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
            const worker = new Worker(toExecute, __spreadProps(__spreadValues({}, opts.workerOpts), {
              trackUnmanagedFds: false,
              workerData: {
                filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
                dataBuf: stream[kImpl].dataBuf,
                stateBuf: stream[kImpl].stateBuf,
                workerData: __spreadValues({
                  $context: {
                    threadStreamVersion: version2
                  }
                }, workerData)
              }
            }));
            worker.stream = new FakeWeakRef(stream);
            worker.on("message", onWorkerMessage);
            worker.on("exit", onWorkerExit);
            registry.register(stream, worker);
            return worker;
          }
          function drain(stream) {
            assert2(!stream[kImpl].sync);
            if (stream[kImpl].needDrain) {
              stream[kImpl].needDrain = false;
              stream.emit("drain");
            }
          }
          function nextFlush(stream) {
            const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
            let leftover = stream[kImpl].data.length - writeIndex;
            if (leftover > 0) {
              if (stream[kImpl].buf.length === 0) {
                stream[kImpl].flushing = false;
                if (stream[kImpl].ending) {
                  end(stream);
                } else if (stream[kImpl].needDrain) {
                  process.nextTick(drain, stream);
                }
                return;
              }
              let toWrite = stream[kImpl].buf.slice(0, leftover);
              let toWriteBytes = Buffer.byteLength(toWrite);
              if (toWriteBytes <= leftover) {
                stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
                write(stream, toWrite, nextFlush.bind(null, stream));
              } else {
                stream.flush(() => {
                  if (stream.destroyed) {
                    return;
                  }
                  Atomics.store(stream[kImpl].state, READ_INDEX, 0);
                  Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
                  while (toWriteBytes > stream[kImpl].data.length) {
                    leftover = leftover / 2;
                    toWrite = stream[kImpl].buf.slice(0, leftover);
                    toWriteBytes = Buffer.byteLength(toWrite);
                  }
                  stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
                  write(stream, toWrite, nextFlush.bind(null, stream));
                });
              }
            } else if (leftover === 0) {
              if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
                return;
              }
              stream.flush(() => {
                Atomics.store(stream[kImpl].state, READ_INDEX, 0);
                Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
                nextFlush(stream);
              });
            } else {
              destroy(stream, new Error("overwritten"));
            }
          }
          function onWorkerMessage(msg) {
            const stream = this.stream.deref();
            if (stream === void 0) {
              this.exited = true;
              this.terminate();
              return;
            }
            switch (msg.code) {
              case "READY":
                this.stream = new WeakRef2(stream);
                stream.flush(() => {
                  stream[kImpl].ready = true;
                  stream.emit("ready");
                });
                break;
              case "ERROR":
                destroy(stream, msg.err);
                break;
              case "EVENT":
                if (Array.isArray(msg.args)) {
                  stream.emit(msg.name, ...msg.args);
                } else {
                  stream.emit(msg.name, msg.args);
                }
                break;
              case "WARNING":
                process.emitWarning(msg.err);
                break;
              default:
                destroy(stream, new Error("this should not happen: " + msg.code));
            }
          }
          function onWorkerExit(code4) {
            const stream = this.stream.deref();
            if (stream === void 0) {
              return;
            }
            registry.unregister(stream);
            stream.worker.exited = true;
            stream.worker.off("exit", onWorkerExit);
            destroy(stream, code4 !== 0 ? new Error("the worker thread exited") : null);
          }
          var ThreadStream = class extends EventEmitter {
            constructor(opts = {}) {
              super();
              if (opts.bufferSize < 4) {
                throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
              }
              this[kImpl] = {};
              this[kImpl].stateBuf = new SharedArrayBuffer(128);
              this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
              this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
              this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
              this[kImpl].sync = opts.sync || false;
              this[kImpl].ending = false;
              this[kImpl].ended = false;
              this[kImpl].needDrain = false;
              this[kImpl].destroyed = false;
              this[kImpl].flushing = false;
              this[kImpl].ready = false;
              this[kImpl].finished = false;
              this[kImpl].errored = null;
              this[kImpl].closed = false;
              this[kImpl].buf = "";
              this.worker = createWorker(this, opts);
            }
            write(data) {
              if (this[kImpl].destroyed) {
                error(this, new Error("the worker has exited"));
                return false;
              }
              if (this[kImpl].ending) {
                error(this, new Error("the worker is ending"));
                return false;
              }
              if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
                try {
                  writeSync(this);
                  this[kImpl].flushing = true;
                } catch (err) {
                  destroy(this, err);
                  return false;
                }
              }
              this[kImpl].buf += data;
              if (this[kImpl].sync) {
                try {
                  writeSync(this);
                  return true;
                } catch (err) {
                  destroy(this, err);
                  return false;
                }
              }
              if (!this[kImpl].flushing) {
                this[kImpl].flushing = true;
                setImmediate(nextFlush, this);
              }
              this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
              return !this[kImpl].needDrain;
            }
            end() {
              if (this[kImpl].destroyed) {
                return;
              }
              this[kImpl].ending = true;
              end(this);
            }
            flush(cb) {
              if (this[kImpl].destroyed) {
                if (typeof cb === "function") {
                  process.nextTick(cb, new Error("the worker has exited"));
                }
                return;
              }
              const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
              wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
                if (err) {
                  destroy(this, err);
                  process.nextTick(cb, err);
                  return;
                }
                if (res === "not-equal") {
                  this.flush(cb);
                  return;
                }
                process.nextTick(cb);
              });
            }
            flushSync() {
              if (this[kImpl].destroyed) {
                return;
              }
              writeSync(this);
              flushSync(this);
            }
            unref() {
              this.worker.unref();
            }
            ref() {
              this.worker.ref();
            }
            get ready() {
              return this[kImpl].ready;
            }
            get destroyed() {
              return this[kImpl].destroyed;
            }
            get closed() {
              return this[kImpl].closed;
            }
            get writable() {
              return !this[kImpl].destroyed && !this[kImpl].ending;
            }
            get writableEnded() {
              return this[kImpl].ending;
            }
            get writableFinished() {
              return this[kImpl].finished;
            }
            get writableNeedDrain() {
              return this[kImpl].needDrain;
            }
            get writableObjectMode() {
              return false;
            }
            get writableErrored() {
              return this[kImpl].errored;
            }
          };
          function error(stream, err) {
            setImmediate(() => {
              stream.emit("error", err);
            });
          }
          function destroy(stream, err) {
            if (stream[kImpl].destroyed) {
              return;
            }
            stream[kImpl].destroyed = true;
            if (err) {
              stream[kImpl].errored = err;
              error(stream, err);
            }
            if (!stream.worker.exited) {
              stream.worker.terminate().catch(() => {
              }).then(() => {
                stream[kImpl].closed = true;
                stream.emit("close");
              });
            } else {
              setImmediate(() => {
                stream[kImpl].closed = true;
                stream.emit("close");
              });
            }
          }
          function write(stream, data, cb) {
            const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
            const length2 = Buffer.byteLength(data);
            stream[kImpl].data.write(data, current);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length2);
            Atomics.notify(stream[kImpl].state, WRITE_INDEX);
            cb();
            return true;
          }
          function end(stream) {
            if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
              return;
            }
            stream[kImpl].ended = true;
            try {
              stream.flushSync();
              let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
              Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
              Atomics.notify(stream[kImpl].state, WRITE_INDEX);
              let spins = 0;
              while (readIndex !== -1) {
                Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
                readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
                if (readIndex === -2) {
                  destroy(stream, new Error("end() failed"));
                  return;
                }
                if (++spins === 10) {
                  destroy(stream, new Error("end() took too long (10s)"));
                  return;
                }
              }
              process.nextTick(() => {
                stream[kImpl].finished = true;
                stream.emit("finish");
              });
            } catch (err) {
              destroy(stream, err);
            }
          }
          function writeSync(stream) {
            const cb = () => {
              if (stream[kImpl].ending) {
                end(stream);
              } else if (stream[kImpl].needDrain) {
                process.nextTick(drain, stream);
              }
            };
            stream[kImpl].flushing = false;
            while (stream[kImpl].buf.length !== 0) {
              const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
              let leftover = stream[kImpl].data.length - writeIndex;
              if (leftover === 0) {
                flushSync(stream);
                Atomics.store(stream[kImpl].state, READ_INDEX, 0);
                Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
                continue;
              } else if (leftover < 0) {
                throw new Error("overwritten");
              }
              let toWrite = stream[kImpl].buf.slice(0, leftover);
              let toWriteBytes = Buffer.byteLength(toWrite);
              if (toWriteBytes <= leftover) {
                stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
                write(stream, toWrite, cb);
              } else {
                flushSync(stream);
                Atomics.store(stream[kImpl].state, READ_INDEX, 0);
                Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
                while (toWriteBytes > stream[kImpl].buf.length) {
                  leftover = leftover / 2;
                  toWrite = stream[kImpl].buf.slice(0, leftover);
                  toWriteBytes = Buffer.byteLength(toWrite);
                }
                stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
                write(stream, toWrite, cb);
              }
            }
          }
          function flushSync(stream) {
            if (stream[kImpl].flushing) {
              throw new Error("unable to flush while flushing");
            }
            const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
            let spins = 0;
            while (true) {
              const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
              if (readIndex === -2) {
                throw Error("_flushSync failed");
              }
              if (readIndex !== writeIndex) {
                Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
              } else {
                break;
              }
              if (++spins === 10) {
                throw new Error("_flushSync took too long (10s)");
              }
            }
          }
          module2.exports = ThreadStream;
        }
      });
      var require_transport = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/transport.js"(exports2, module2) {
          "use strict";
          var { createRequire: createRequire2 } = __require("module");
          var getCallers = require_caller();
          var { join, isAbsolute, sep } = __require("path");
          var sleep = require_atomic_sleep();
          var onExit = require_on_exit_leak_free();
          var ThreadStream = require_thread_stream();
          function setupOnExit(stream) {
            onExit.register(stream, autoEnd);
            onExit.registerBeforeExit(stream, flush);
            stream.on("close", function() {
              onExit.unregister(stream);
            });
          }
          function buildStream(filename, workerData, workerOpts) {
            const stream = new ThreadStream({
              filename,
              workerData,
              workerOpts
            });
            stream.on("ready", onReady);
            stream.on("close", function() {
              process.removeListener("exit", onExit2);
            });
            process.on("exit", onExit2);
            function onReady() {
              process.removeListener("exit", onExit2);
              stream.unref();
              if (workerOpts.autoEnd !== false) {
                setupOnExit(stream);
              }
            }
            function onExit2() {
              if (stream.closed) {
                return;
              }
              stream.flushSync();
              sleep(100);
              stream.end();
            }
            return stream;
          }
          function autoEnd(stream) {
            stream.ref();
            stream.flushSync();
            stream.end();
            stream.once("close", function() {
              stream.unref();
            });
          }
          function flush(stream) {
            stream.flushSync();
          }
          function transport(fullOptions) {
            const { pipeline, targets, levels, dedupe, options = {}, worker = {}, caller = getCallers() } = fullOptions;
            const callers = typeof caller === "string" ? [caller] : caller;
            const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
            let target2 = fullOptions.target;
            if (target2 && targets) {
              throw new Error("only one of target or targets can be specified");
            }
            if (targets) {
              target2 = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
              options.targets = targets.map((dest) => {
                return __spreadProps(__spreadValues({}, dest), {
                  target: fixTarget(dest.target)
                });
              });
            } else if (pipeline) {
              target2 = bundlerOverrides["pino-pipeline-worker"] || join(__dirname, "worker-pipeline.js");
              options.targets = pipeline.map((dest) => {
                return __spreadProps(__spreadValues({}, dest), {
                  target: fixTarget(dest.target)
                });
              });
            }
            if (levels) {
              options.levels = levels;
            }
            if (dedupe) {
              options.dedupe = dedupe;
            }
            return buildStream(fixTarget(target2), options, worker);
            function fixTarget(origin) {
              origin = bundlerOverrides[origin] || origin;
              if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
                return origin;
              }
              if (origin === "pino/file") {
                return join(__dirname, "..", "file.js");
              }
              let fixTarget2;
              for (const filePath of callers) {
                try {
                  const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
                  fixTarget2 = createRequire2(context).resolve(origin);
                  break;
                } catch (err) {
                  continue;
                }
              }
              if (!fixTarget2) {
                throw new Error(`unable to determine transport target for "${origin}"`);
              }
              return fixTarget2;
            }
          }
          module2.exports = transport;
        }
      });
      var require_tools = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/tools.js"(exports2, module2) {
          "use strict";
          var format = require_quick_format_unescaped();
          var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
          var SonicBoom = require_sonic_boom();
          var onExit = require_on_exit_leak_free();
          var {
            lsCacheSym,
            chindingsSym,
            writeSym,
            serializersSym,
            formatOptsSym,
            endSym,
            stringifiersSym,
            stringifySym,
            stringifySafeSym,
            wildcardFirstSym,
            nestedKeySym,
            formattersSym,
            messageKeySym,
            errorKeySym,
            nestedKeyStrSym,
            msgPrefixSym
          } = require_symbols();
          var { isMainThread } = __require("worker_threads");
          var transport = require_transport();
          function noop2() {
          }
          function genLog(level2, hook) {
            if (!hook)
              return LOG;
            return function hookWrappedLog(...args) {
              hook.call(this, args, LOG, level2);
            };
            function LOG(o, ...n) {
              if (typeof o === "object") {
                let msg = o;
                if (o !== null) {
                  if (o.method && o.headers && o.socket) {
                    o = mapHttpRequest(o);
                  } else if (typeof o.setHeader === "function") {
                    o = mapHttpResponse(o);
                  }
                }
                let formatParams;
                if (msg === null && n.length === 0) {
                  formatParams = [null];
                } else {
                  msg = n.shift();
                  formatParams = n;
                }
                if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
                  msg = this[msgPrefixSym] + msg;
                }
                this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level2);
              } else {
                let msg = o === void 0 ? n.shift() : o;
                if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
                  msg = this[msgPrefixSym] + msg;
                }
                this[writeSym](null, format(msg, n, this[formatOptsSym]), level2);
              }
            }
          }
          function asString(str) {
            let result = "";
            let last = 0;
            let found = false;
            let point = 255;
            const l = str.length;
            if (l > 100) {
              return JSON.stringify(str);
            }
            for (var i = 0; i < l && point >= 32; i++) {
              point = str.charCodeAt(i);
              if (point === 34 || point === 92) {
                result += str.slice(last, i) + "\\";
                last = i;
                found = true;
              }
            }
            if (!found) {
              result = str;
            } else {
              result += str.slice(last);
            }
            return point < 32 ? JSON.stringify(str) : '"' + result + '"';
          }
          function asJson(obj, msg, num, time) {
            const stringify2 = this[stringifySym];
            const stringifySafe = this[stringifySafeSym];
            const stringifiers = this[stringifiersSym];
            const end = this[endSym];
            const chindings = this[chindingsSym];
            const serializers = this[serializersSym];
            const formatters = this[formattersSym];
            const messageKey = this[messageKeySym];
            const errorKey = this[errorKeySym];
            let data = this[lsCacheSym][num] + time;
            data = data + chindings;
            let value;
            if (formatters.log) {
              obj = formatters.log(obj);
            }
            const wildcardStringifier = stringifiers[wildcardFirstSym];
            let propStr = "";
            for (const key in obj) {
              value = obj[key];
              if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
                if (serializers[key]) {
                  value = serializers[key](value);
                } else if (key === errorKey && serializers.err) {
                  value = serializers.err(value);
                }
                const stringifier = stringifiers[key] || wildcardStringifier;
                switch (typeof value) {
                  case "undefined":
                  case "function":
                    continue;
                  case "number":
                    if (Number.isFinite(value) === false) {
                      value = null;
                    }
                  case "boolean":
                    if (stringifier)
                      value = stringifier(value);
                    break;
                  case "string":
                    value = (stringifier || asString)(value);
                    break;
                  default:
                    value = (stringifier || stringify2)(value, stringifySafe);
                }
                if (value === void 0)
                  continue;
                propStr += ',"' + key + '":' + value;
              }
            }
            let msgStr = "";
            if (msg !== void 0) {
              value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
              const stringifier = stringifiers[messageKey] || wildcardStringifier;
              switch (typeof value) {
                case "function":
                  break;
                case "number":
                  if (Number.isFinite(value) === false) {
                    value = null;
                  }
                case "boolean":
                  if (stringifier)
                    value = stringifier(value);
                  msgStr = ',"' + messageKey + '":' + value;
                  break;
                case "string":
                  value = (stringifier || asString)(value);
                  msgStr = ',"' + messageKey + '":' + value;
                  break;
                default:
                  value = (stringifier || stringify2)(value, stringifySafe);
                  msgStr = ',"' + messageKey + '":' + value;
              }
            }
            if (this[nestedKeySym] && propStr) {
              return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
            } else {
              return data + propStr + msgStr + end;
            }
          }
          function asChindings(instance, bindings) {
            let value;
            let data = instance[chindingsSym];
            const stringify2 = instance[stringifySym];
            const stringifySafe = instance[stringifySafeSym];
            const stringifiers = instance[stringifiersSym];
            const wildcardStringifier = stringifiers[wildcardFirstSym];
            const serializers = instance[serializersSym];
            const formatter = instance[formattersSym].bindings;
            bindings = formatter(bindings);
            for (const key in bindings) {
              value = bindings[key];
              const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
              if (valid === true) {
                value = serializers[key] ? serializers[key](value) : value;
                value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
                if (value === void 0)
                  continue;
                data += ',"' + key + '":' + value;
              }
            }
            return data;
          }
          function hasBeenTampered(stream) {
            return stream.write !== stream.constructor.prototype.write;
          }
          function buildSafeSonicBoom(opts) {
            const stream = new SonicBoom(opts);
            stream.on("error", filterBrokenPipe);
            if (!opts.sync && isMainThread) {
              onExit.register(stream, autoEnd);
              stream.on("close", function() {
                onExit.unregister(stream);
              });
            }
            return stream;
            function filterBrokenPipe(err) {
              if (err.code === "EPIPE") {
                stream.write = noop2;
                stream.end = noop2;
                stream.flushSync = noop2;
                stream.destroy = noop2;
                return;
              }
              stream.removeListener("error", filterBrokenPipe);
              stream.emit("error", err);
            }
          }
          function autoEnd(stream, eventName) {
            if (stream.destroyed) {
              return;
            }
            if (eventName === "beforeExit") {
              stream.flush();
              stream.on("drain", function() {
                stream.end();
              });
            } else {
              stream.flushSync();
            }
          }
          function createArgsNormalizer(defaultOptions2) {
            return function normalizeArgs(instance, caller, opts = {}, stream) {
              if (typeof opts === "string") {
                stream = buildSafeSonicBoom({ dest: opts });
                opts = {};
              } else if (typeof stream === "string") {
                if (opts && opts.transport) {
                  throw Error("only one of option.transport or stream can be specified");
                }
                stream = buildSafeSonicBoom({ dest: stream });
              } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
                stream = opts;
                opts = {};
              } else if (opts.transport) {
                if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
                  throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
                }
                if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
                  throw Error("option.transport.targets do not allow custom level formatters");
                }
                let customLevels;
                if (opts.customLevels) {
                  customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
                }
                stream = transport(__spreadProps(__spreadValues({ caller }, opts.transport), { levels: customLevels }));
              }
              opts = Object.assign({}, defaultOptions2, opts);
              opts.serializers = Object.assign({}, defaultOptions2.serializers, opts.serializers);
              opts.formatters = Object.assign({}, defaultOptions2.formatters, opts.formatters);
              if (opts.prettyPrint) {
                throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
              }
              const { enabled: enabled2, onChild } = opts;
              if (enabled2 === false)
                opts.level = "silent";
              if (!onChild)
                opts.onChild = noop2;
              if (!stream) {
                if (!hasBeenTampered(process.stdout)) {
                  stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
                } else {
                  stream = process.stdout;
                }
              }
              return { opts, stream };
            };
          }
          function stringify(obj, stringifySafeFn) {
            try {
              return JSON.stringify(obj);
            } catch (_) {
              try {
                const stringify2 = stringifySafeFn || this[stringifySafeSym];
                return stringify2(obj);
              } catch (_2) {
                return '"[unable to serialize, circular reference is too complex to analyze]"';
              }
            }
          }
          function buildFormatters(level2, bindings, log) {
            return {
              level: level2,
              bindings,
              log
            };
          }
          function normalizeDestFileDescriptor(destination) {
            const fd = Number(destination);
            if (typeof destination === "string" && Number.isFinite(fd)) {
              return fd;
            }
            if (destination === void 0) {
              return 1;
            }
            return destination;
          }
          module2.exports = {
            noop: noop2,
            buildSafeSonicBoom,
            asChindings,
            asJson,
            genLog,
            createArgsNormalizer,
            stringify,
            buildFormatters,
            normalizeDestFileDescriptor
          };
        }
      });
      var require_levels = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/levels.js"(exports2, module2) {
          "use strict";
          var {
            lsCacheSym,
            levelValSym,
            useOnlyCustomLevelsSym,
            streamSym,
            formattersSym,
            hooksSym
          } = require_symbols();
          var { noop: noop2, genLog } = require_tools();
          var levels = {
            trace: 10,
            debug: 20,
            info: 30,
            warn: 40,
            error: 50,
            fatal: 60
          };
          var levelMethods = {
            fatal: (hook) => {
              const logFatal = genLog(levels.fatal, hook);
              return function(...args) {
                const stream = this[streamSym];
                logFatal.call(this, ...args);
                if (typeof stream.flushSync === "function") {
                  try {
                    stream.flushSync();
                  } catch (e) {
                  }
                }
              };
            },
            error: (hook) => genLog(levels.error, hook),
            warn: (hook) => genLog(levels.warn, hook),
            info: (hook) => genLog(levels.info, hook),
            debug: (hook) => genLog(levels.debug, hook),
            trace: (hook) => genLog(levels.trace, hook)
          };
          var nums = Object.keys(levels).reduce((o, k) => {
            o[levels[k]] = k;
            return o;
          }, {});
          var initialLsCache = Object.keys(nums).reduce((o, k) => {
            o[k] = '{"level":' + Number(k);
            return o;
          }, {});
          function genLsCache(instance) {
            const formatter = instance[formattersSym].level;
            const { labels } = instance.levels;
            const cache = {};
            for (const label in labels) {
              const level2 = formatter(labels[label], Number(label));
              cache[label] = JSON.stringify(level2).slice(0, -1);
            }
            instance[lsCacheSym] = cache;
            return instance;
          }
          function isStandardLevel(level2, useOnlyCustomLevels) {
            if (useOnlyCustomLevels) {
              return false;
            }
            switch (level2) {
              case "fatal":
              case "error":
              case "warn":
              case "info":
              case "debug":
              case "trace":
                return true;
              default:
                return false;
            }
          }
          function setLevel(level2) {
            const { labels, values } = this.levels;
            if (typeof level2 === "number") {
              if (labels[level2] === void 0)
                throw Error("unknown level value" + level2);
              level2 = labels[level2];
            }
            if (values[level2] === void 0)
              throw Error("unknown level " + level2);
            const preLevelVal = this[levelValSym];
            const levelVal = this[levelValSym] = values[level2];
            const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
            const hook = this[hooksSym].logMethod;
            for (const key in values) {
              if (levelVal > values[key]) {
                this[key] = noop2;
                continue;
              }
              this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
            }
            this.emit("level-change", level2, levelVal, labels[preLevelVal], preLevelVal, this);
          }
          function getLevel(level2) {
            const { levels: levels2, levelVal } = this;
            return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
          }
          function isLevelEnabled(logLevel) {
            const { values } = this.levels;
            const logLevelVal = values[logLevel];
            return logLevelVal !== void 0 && logLevelVal >= this[levelValSym];
          }
          function mappings(customLevels = null, useOnlyCustomLevels = false) {
            const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
              o[customLevels[k]] = k;
              return o;
            }, {}) : null;
            const labels = Object.assign(Object.create(Object.prototype, { Infinity: { value: "silent" } }), useOnlyCustomLevels ? null : nums, customNums);
            const values = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : levels, customLevels);
            return { labels, values };
          }
          function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
            if (typeof defaultLevel === "number") {
              const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level2) => +level2), Infinity);
              if (!values.includes(defaultLevel)) {
                throw Error(`default level:${defaultLevel} must be included in custom levels`);
              }
              return;
            }
            const labels = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : levels, customLevels);
            if (!(defaultLevel in labels)) {
              throw Error(`default level:${defaultLevel} must be included in custom levels`);
            }
          }
          function assertNoLevelCollisions(levels2, customLevels) {
            const { labels, values } = levels2;
            for (const k in customLevels) {
              if (k in values) {
                throw Error("levels cannot be overridden");
              }
              if (customLevels[k] in labels) {
                throw Error("pre-existing level values cannot be used for new levels");
              }
            }
          }
          module2.exports = {
            initialLsCache,
            genLsCache,
            levelMethods,
            getLevel,
            setLevel,
            isLevelEnabled,
            mappings,
            levels,
            assertNoLevelCollisions,
            assertDefaultLevelFound
          };
        }
      });
      var require_meta = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/meta.js"(exports2, module2) {
          "use strict";
          module2.exports = { version: "8.15.0" };
        }
      });
      var require_proto = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/proto.js"(exports2, module2) {
          "use strict";
          var { EventEmitter } = __require("events");
          var {
            lsCacheSym,
            levelValSym,
            setLevelSym,
            getLevelSym,
            chindingsSym,
            parsedChindingsSym,
            mixinSym,
            asJsonSym,
            writeSym,
            mixinMergeStrategySym,
            timeSym,
            timeSliceIndexSym,
            streamSym,
            serializersSym,
            formattersSym,
            errorKeySym,
            messageKeySym,
            useOnlyCustomLevelsSym,
            needsMetadataGsym,
            redactFmtSym,
            stringifySym,
            formatOptsSym,
            stringifiersSym,
            msgPrefixSym
          } = require_symbols();
          var {
            getLevel,
            setLevel,
            isLevelEnabled,
            mappings,
            initialLsCache,
            genLsCache,
            assertNoLevelCollisions
          } = require_levels();
          var {
            asChindings,
            asJson,
            buildFormatters,
            stringify
          } = require_tools();
          var {
            version: version2
          } = require_meta();
          var redaction = require_redaction();
          var constructor = class Pino {
          };
          var prototype = {
            constructor,
            child,
            bindings,
            setBindings,
            flush,
            isLevelEnabled,
            version: version2,
            get level() {
              return this[getLevelSym]();
            },
            set level(lvl) {
              this[setLevelSym](lvl);
            },
            get levelVal() {
              return this[levelValSym];
            },
            set levelVal(n) {
              throw Error("levelVal is read-only");
            },
            [lsCacheSym]: initialLsCache,
            [writeSym]: write,
            [asJsonSym]: asJson,
            [getLevelSym]: getLevel,
            [setLevelSym]: setLevel
          };
          Object.setPrototypeOf(prototype, EventEmitter.prototype);
          module2.exports = function() {
            return Object.create(prototype);
          };
          var resetChildingsFormatter = (bindings2) => bindings2;
          function child(bindings2, options) {
            if (!bindings2) {
              throw Error("missing bindings for child Pino");
            }
            options = options || {};
            const serializers = this[serializersSym];
            const formatters = this[formattersSym];
            const instance = Object.create(this);
            if (options.hasOwnProperty("serializers") === true) {
              instance[serializersSym] = /* @__PURE__ */ Object.create(null);
              for (const k in serializers) {
                instance[serializersSym][k] = serializers[k];
              }
              const parentSymbols = Object.getOwnPropertySymbols(serializers);
              for (var i = 0; i < parentSymbols.length; i++) {
                const ks = parentSymbols[i];
                instance[serializersSym][ks] = serializers[ks];
              }
              for (const bk in options.serializers) {
                instance[serializersSym][bk] = options.serializers[bk];
              }
              const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
              for (var bi = 0; bi < bindingsSymbols.length; bi++) {
                const bks = bindingsSymbols[bi];
                instance[serializersSym][bks] = options.serializers[bks];
              }
            } else
              instance[serializersSym] = serializers;
            if (options.hasOwnProperty("formatters")) {
              const { level: level2, bindings: chindings, log } = options.formatters;
              instance[formattersSym] = buildFormatters(level2 || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);
            } else {
              instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
            }
            if (options.hasOwnProperty("customLevels") === true) {
              assertNoLevelCollisions(this.levels, options.customLevels);
              instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
              genLsCache(instance);
            }
            if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
              instance.redact = options.redact;
              const stringifiers = redaction(instance.redact, stringify);
              const formatOpts = { stringify: stringifiers[redactFmtSym] };
              instance[stringifySym] = stringify;
              instance[stringifiersSym] = stringifiers;
              instance[formatOptsSym] = formatOpts;
            }
            if (typeof options.msgPrefix === "string") {
              instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
            }
            instance[chindingsSym] = asChindings(instance, bindings2);
            const childLevel = options.level || this.level;
            instance[setLevelSym](childLevel);
            this.onChild(instance);
            return instance;
          }
          function bindings() {
            const chindings = this[chindingsSym];
            const chindingsJson = `{${chindings.substr(1)}}`;
            const bindingsFromJson = JSON.parse(chindingsJson);
            delete bindingsFromJson.pid;
            delete bindingsFromJson.hostname;
            return bindingsFromJson;
          }
          function setBindings(newBindings) {
            const chindings = asChindings(this, newBindings);
            this[chindingsSym] = chindings;
            delete this[parsedChindingsSym];
          }
          function defaultMixinMergeStrategy(mergeObject, mixinObject) {
            return Object.assign(mixinObject, mergeObject);
          }
          function write(_obj, msg, num) {
            const t = this[timeSym]();
            const mixin = this[mixinSym];
            const errorKey = this[errorKeySym];
            const messageKey = this[messageKeySym];
            const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
            let obj;
            if (_obj === void 0 || _obj === null) {
              obj = {};
            } else if (_obj instanceof Error) {
              obj = { [errorKey]: _obj };
              if (msg === void 0) {
                msg = _obj.message;
              }
            } else {
              obj = _obj;
              if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
                msg = _obj[errorKey].message;
              }
            }
            if (mixin) {
              obj = mixinMergeStrategy(obj, mixin(obj, num, this));
            }
            const s = this[asJsonSym](obj, msg, num, t);
            const stream = this[streamSym];
            if (stream[needsMetadataGsym] === true) {
              stream.lastLevel = num;
              stream.lastObj = obj;
              stream.lastMsg = msg;
              stream.lastTime = t.slice(this[timeSliceIndexSym]);
              stream.lastLogger = this;
            }
            stream.write(s);
          }
          function noop2() {
          }
          function flush() {
            const stream = this[streamSym];
            if ("flush" in stream)
              stream.flush(noop2);
          }
        }
      });
      var require_safe_stable_stringify = __commonJS2({
        "../../node_modules/.pnpm/safe-stable-stringify@2.4.3/node_modules/safe-stable-stringify/index.js"(exports2, module2) {
          "use strict";
          var { hasOwnProperty } = Object.prototype;
          var stringify = configure();
          stringify.configure = configure;
          stringify.stringify = stringify;
          stringify.default = stringify;
          exports2.stringify = stringify;
          exports2.configure = configure;
          module2.exports = stringify;
          var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
          function strEscape(str) {
            if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
              return `"${str}"`;
            }
            return JSON.stringify(str);
          }
          function insertSort(array2) {
            if (array2.length > 200) {
              return array2.sort();
            }
            for (let i = 1; i < array2.length; i++) {
              const currentValue = array2[i];
              let position3 = i;
              while (position3 !== 0 && array2[position3 - 1] > currentValue) {
                array2[position3] = array2[position3 - 1];
                position3--;
              }
              array2[position3] = currentValue;
            }
            return array2;
          }
          var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
          function isTypedArrayWithEntries(value) {
            return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
          }
          function stringifyTypedArray(array2, separator, maximumBreadth) {
            if (array2.length < maximumBreadth) {
              maximumBreadth = array2.length;
            }
            const whitespace = separator === "," ? "" : " ";
            let res = `"0":${whitespace}${array2[0]}`;
            for (let i = 1; i < maximumBreadth; i++) {
              res += `${separator}"${i}":${whitespace}${array2[i]}`;
            }
            return res;
          }
          function getCircularValueOption(options) {
            if (hasOwnProperty.call(options, "circularValue")) {
              const circularValue = options.circularValue;
              if (typeof circularValue === "string") {
                return `"${circularValue}"`;
              }
              if (circularValue == null) {
                return circularValue;
              }
              if (circularValue === Error || circularValue === TypeError) {
                return {
                  toString() {
                    throw new TypeError("Converting circular structure to JSON");
                  }
                };
              }
              throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
            }
            return '"[Circular]"';
          }
          function getBooleanOption(options, key) {
            let value;
            if (hasOwnProperty.call(options, key)) {
              value = options[key];
              if (typeof value !== "boolean") {
                throw new TypeError(`The "${key}" argument must be of type boolean`);
              }
            }
            return value === void 0 ? true : value;
          }
          function getPositiveIntegerOption(options, key) {
            let value;
            if (hasOwnProperty.call(options, key)) {
              value = options[key];
              if (typeof value !== "number") {
                throw new TypeError(`The "${key}" argument must be of type number`);
              }
              if (!Number.isInteger(value)) {
                throw new TypeError(`The "${key}" argument must be an integer`);
              }
              if (value < 1) {
                throw new RangeError(`The "${key}" argument must be >= 1`);
              }
            }
            return value === void 0 ? Infinity : value;
          }
          function getItemCount(number2) {
            if (number2 === 1) {
              return "1 item";
            }
            return `${number2} items`;
          }
          function getUniqueReplacerSet(replacerArray) {
            const replacerSet = /* @__PURE__ */ new Set();
            for (const value of replacerArray) {
              if (typeof value === "string" || typeof value === "number") {
                replacerSet.add(String(value));
              }
            }
            return replacerSet;
          }
          function getStrictOption(options) {
            if (hasOwnProperty.call(options, "strict")) {
              const value = options.strict;
              if (typeof value !== "boolean") {
                throw new TypeError('The "strict" argument must be of type boolean');
              }
              if (value) {
                return (value2) => {
                  let message = `Object can not safely be stringified. Received type ${typeof value2}`;
                  if (typeof value2 !== "function")
                    message += ` (${value2.toString()})`;
                  throw new Error(message);
                };
              }
            }
          }
          function configure(options) {
            options = __spreadValues({}, options);
            const fail = getStrictOption(options);
            if (fail) {
              if (options.bigint === void 0) {
                options.bigint = false;
              }
              if (!("circularValue" in options)) {
                options.circularValue = Error;
              }
            }
            const circularValue = getCircularValueOption(options);
            const bigint = getBooleanOption(options, "bigint");
            const deterministic = getBooleanOption(options, "deterministic");
            const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
            const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
            function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
              let value = parent[key];
              if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
                value = value.toJSON(key);
              }
              value = replacer.call(parent, key, value);
              switch (typeof value) {
                case "string":
                  return strEscape(value);
                case "object": {
                  if (value === null) {
                    return "null";
                  }
                  if (stack.indexOf(value) !== -1) {
                    return circularValue;
                  }
                  let res = "";
                  let join = ",";
                  const originalIndentation = indentation;
                  if (Array.isArray(value)) {
                    if (value.length === 0) {
                      return "[]";
                    }
                    if (maximumDepth < stack.length + 1) {
                      return '"[Array]"';
                    }
                    stack.push(value);
                    if (spacer !== "") {
                      indentation += spacer;
                      res += `
${indentation}`;
                      join = `,
${indentation}`;
                    }
                    const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                    let i = 0;
                    for (; i < maximumValuesToStringify - 1; i++) {
                      const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                      res += tmp2 !== void 0 ? tmp2 : "null";
                      res += join;
                    }
                    const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                    res += tmp !== void 0 ? tmp : "null";
                    if (value.length - 1 > maximumBreadth) {
                      const removedKeys = value.length - maximumBreadth - 1;
                      res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                    }
                    if (spacer !== "") {
                      res += `
${originalIndentation}`;
                    }
                    stack.pop();
                    return `[${res}]`;
                  }
                  let keys = Object.keys(value);
                  const keyLength = keys.length;
                  if (keyLength === 0) {
                    return "{}";
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Object]"';
                  }
                  let whitespace = "";
                  let separator = "";
                  if (spacer !== "") {
                    indentation += spacer;
                    join = `,
${indentation}`;
                    whitespace = " ";
                  }
                  const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                  if (deterministic && !isTypedArrayWithEntries(value)) {
                    keys = insertSort(keys);
                  }
                  stack.push(value);
                  for (let i = 0; i < maximumPropertiesToStringify; i++) {
                    const key2 = keys[i];
                    const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
                    if (tmp !== void 0) {
                      res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                      separator = join;
                    }
                  }
                  if (keyLength > maximumBreadth) {
                    const removedKeys = keyLength - maximumBreadth;
                    res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
                    separator = join;
                  }
                  if (spacer !== "" && separator.length > 1) {
                    res = `
${indentation}${res}
${originalIndentation}`;
                  }
                  stack.pop();
                  return `{${res}}`;
                }
                case "number":
                  return isFinite(value) ? String(value) : fail ? fail(value) : "null";
                case "boolean":
                  return value === true ? "true" : "false";
                case "undefined":
                  return void 0;
                case "bigint":
                  if (bigint) {
                    return String(value);
                  }
                default:
                  return fail ? fail(value) : void 0;
              }
            }
            function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
              if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
                value = value.toJSON(key);
              }
              switch (typeof value) {
                case "string":
                  return strEscape(value);
                case "object": {
                  if (value === null) {
                    return "null";
                  }
                  if (stack.indexOf(value) !== -1) {
                    return circularValue;
                  }
                  const originalIndentation = indentation;
                  let res = "";
                  let join = ",";
                  if (Array.isArray(value)) {
                    if (value.length === 0) {
                      return "[]";
                    }
                    if (maximumDepth < stack.length + 1) {
                      return '"[Array]"';
                    }
                    stack.push(value);
                    if (spacer !== "") {
                      indentation += spacer;
                      res += `
${indentation}`;
                      join = `,
${indentation}`;
                    }
                    const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                    let i = 0;
                    for (; i < maximumValuesToStringify - 1; i++) {
                      const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                      res += tmp2 !== void 0 ? tmp2 : "null";
                      res += join;
                    }
                    const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                    res += tmp !== void 0 ? tmp : "null";
                    if (value.length - 1 > maximumBreadth) {
                      const removedKeys = value.length - maximumBreadth - 1;
                      res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                    }
                    if (spacer !== "") {
                      res += `
${originalIndentation}`;
                    }
                    stack.pop();
                    return `[${res}]`;
                  }
                  stack.push(value);
                  let whitespace = "";
                  if (spacer !== "") {
                    indentation += spacer;
                    join = `,
${indentation}`;
                    whitespace = " ";
                  }
                  let separator = "";
                  for (const key2 of replacer) {
                    const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
                    if (tmp !== void 0) {
                      res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                      separator = join;
                    }
                  }
                  if (spacer !== "" && separator.length > 1) {
                    res = `
${indentation}${res}
${originalIndentation}`;
                  }
                  stack.pop();
                  return `{${res}}`;
                }
                case "number":
                  return isFinite(value) ? String(value) : fail ? fail(value) : "null";
                case "boolean":
                  return value === true ? "true" : "false";
                case "undefined":
                  return void 0;
                case "bigint":
                  if (bigint) {
                    return String(value);
                  }
                default:
                  return fail ? fail(value) : void 0;
              }
            }
            function stringifyIndent(key, value, stack, spacer, indentation) {
              switch (typeof value) {
                case "string":
                  return strEscape(value);
                case "object": {
                  if (value === null) {
                    return "null";
                  }
                  if (typeof value.toJSON === "function") {
                    value = value.toJSON(key);
                    if (typeof value !== "object") {
                      return stringifyIndent(key, value, stack, spacer, indentation);
                    }
                    if (value === null) {
                      return "null";
                    }
                  }
                  if (stack.indexOf(value) !== -1) {
                    return circularValue;
                  }
                  const originalIndentation = indentation;
                  if (Array.isArray(value)) {
                    if (value.length === 0) {
                      return "[]";
                    }
                    if (maximumDepth < stack.length + 1) {
                      return '"[Array]"';
                    }
                    stack.push(value);
                    indentation += spacer;
                    let res2 = `
${indentation}`;
                    const join2 = `,
${indentation}`;
                    const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                    let i = 0;
                    for (; i < maximumValuesToStringify - 1; i++) {
                      const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                      res2 += tmp2 !== void 0 ? tmp2 : "null";
                      res2 += join2;
                    }
                    const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                    res2 += tmp !== void 0 ? tmp : "null";
                    if (value.length - 1 > maximumBreadth) {
                      const removedKeys = value.length - maximumBreadth - 1;
                      res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
                    }
                    res2 += `
${originalIndentation}`;
                    stack.pop();
                    return `[${res2}]`;
                  }
                  let keys = Object.keys(value);
                  const keyLength = keys.length;
                  if (keyLength === 0) {
                    return "{}";
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Object]"';
                  }
                  indentation += spacer;
                  const join = `,
${indentation}`;
                  let res = "";
                  let separator = "";
                  let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                  if (isTypedArrayWithEntries(value)) {
                    res += stringifyTypedArray(value, join, maximumBreadth);
                    keys = keys.slice(value.length);
                    maximumPropertiesToStringify -= value.length;
                    separator = join;
                  }
                  if (deterministic) {
                    keys = insertSort(keys);
                  }
                  stack.push(value);
                  for (let i = 0; i < maximumPropertiesToStringify; i++) {
                    const key2 = keys[i];
                    const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
                    if (tmp !== void 0) {
                      res += `${separator}${strEscape(key2)}: ${tmp}`;
                      separator = join;
                    }
                  }
                  if (keyLength > maximumBreadth) {
                    const removedKeys = keyLength - maximumBreadth;
                    res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
                    separator = join;
                  }
                  if (separator !== "") {
                    res = `
${indentation}${res}
${originalIndentation}`;
                  }
                  stack.pop();
                  return `{${res}}`;
                }
                case "number":
                  return isFinite(value) ? String(value) : fail ? fail(value) : "null";
                case "boolean":
                  return value === true ? "true" : "false";
                case "undefined":
                  return void 0;
                case "bigint":
                  if (bigint) {
                    return String(value);
                  }
                default:
                  return fail ? fail(value) : void 0;
              }
            }
            function stringifySimple(key, value, stack) {
              switch (typeof value) {
                case "string":
                  return strEscape(value);
                case "object": {
                  if (value === null) {
                    return "null";
                  }
                  if (typeof value.toJSON === "function") {
                    value = value.toJSON(key);
                    if (typeof value !== "object") {
                      return stringifySimple(key, value, stack);
                    }
                    if (value === null) {
                      return "null";
                    }
                  }
                  if (stack.indexOf(value) !== -1) {
                    return circularValue;
                  }
                  let res = "";
                  if (Array.isArray(value)) {
                    if (value.length === 0) {
                      return "[]";
                    }
                    if (maximumDepth < stack.length + 1) {
                      return '"[Array]"';
                    }
                    stack.push(value);
                    const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                    let i = 0;
                    for (; i < maximumValuesToStringify - 1; i++) {
                      const tmp2 = stringifySimple(String(i), value[i], stack);
                      res += tmp2 !== void 0 ? tmp2 : "null";
                      res += ",";
                    }
                    const tmp = stringifySimple(String(i), value[i], stack);
                    res += tmp !== void 0 ? tmp : "null";
                    if (value.length - 1 > maximumBreadth) {
                      const removedKeys = value.length - maximumBreadth - 1;
                      res += `,"... ${getItemCount(removedKeys)} not stringified"`;
                    }
                    stack.pop();
                    return `[${res}]`;
                  }
                  let keys = Object.keys(value);
                  const keyLength = keys.length;
                  if (keyLength === 0) {
                    return "{}";
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Object]"';
                  }
                  let separator = "";
                  let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                  if (isTypedArrayWithEntries(value)) {
                    res += stringifyTypedArray(value, ",", maximumBreadth);
                    keys = keys.slice(value.length);
                    maximumPropertiesToStringify -= value.length;
                    separator = ",";
                  }
                  if (deterministic) {
                    keys = insertSort(keys);
                  }
                  stack.push(value);
                  for (let i = 0; i < maximumPropertiesToStringify; i++) {
                    const key2 = keys[i];
                    const tmp = stringifySimple(key2, value[key2], stack);
                    if (tmp !== void 0) {
                      res += `${separator}${strEscape(key2)}:${tmp}`;
                      separator = ",";
                    }
                  }
                  if (keyLength > maximumBreadth) {
                    const removedKeys = keyLength - maximumBreadth;
                    res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
                  }
                  stack.pop();
                  return `{${res}}`;
                }
                case "number":
                  return isFinite(value) ? String(value) : fail ? fail(value) : "null";
                case "boolean":
                  return value === true ? "true" : "false";
                case "undefined":
                  return void 0;
                case "bigint":
                  if (bigint) {
                    return String(value);
                  }
                default:
                  return fail ? fail(value) : void 0;
              }
            }
            function stringify2(value, replacer, space) {
              if (arguments.length > 1) {
                let spacer = "";
                if (typeof space === "number") {
                  spacer = " ".repeat(Math.min(space, 10));
                } else if (typeof space === "string") {
                  spacer = space.slice(0, 10);
                }
                if (replacer != null) {
                  if (typeof replacer === "function") {
                    return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
                  }
                  if (Array.isArray(replacer)) {
                    return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
                  }
                }
                if (spacer.length !== 0) {
                  return stringifyIndent("", value, [], spacer, "");
                }
              }
              return stringifySimple("", value, []);
            }
            return stringify2;
          }
        }
      });
      var require_multistream = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/multistream.js"(exports2, module2) {
          "use strict";
          var metadata = Symbol.for("pino.metadata");
          var { levels } = require_levels();
          var DEFAULT_INFO_LEVEL = levels.info;
          function multistream(streamsArray, opts) {
            let counter = 0;
            streamsArray = streamsArray || [];
            opts = opts || { dedupe: false };
            const streamLevels = Object.create(levels);
            streamLevels.silent = Infinity;
            if (opts.levels && typeof opts.levels === "object") {
              Object.keys(opts.levels).forEach((i) => {
                streamLevels[i] = opts.levels[i];
              });
            }
            const res = {
              write,
              add,
              flushSync,
              end,
              minLevel: 0,
              streams: [],
              clone,
              [metadata]: true,
              streamLevels
            };
            if (Array.isArray(streamsArray)) {
              streamsArray.forEach(add, res);
            } else {
              add.call(res, streamsArray);
            }
            streamsArray = null;
            return res;
            function write(data) {
              let dest;
              const level2 = this.lastLevel;
              const { streams } = this;
              let recordedLevel = 0;
              let stream;
              for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
                dest = streams[i];
                if (dest.level <= level2) {
                  if (recordedLevel !== 0 && recordedLevel !== dest.level) {
                    break;
                  }
                  stream = dest.stream;
                  if (stream[metadata]) {
                    const { lastTime, lastMsg, lastObj, lastLogger } = this;
                    stream.lastLevel = level2;
                    stream.lastTime = lastTime;
                    stream.lastMsg = lastMsg;
                    stream.lastObj = lastObj;
                    stream.lastLogger = lastLogger;
                  }
                  stream.write(data);
                  if (opts.dedupe) {
                    recordedLevel = dest.level;
                  }
                } else if (!opts.dedupe) {
                  break;
                }
              }
            }
            function flushSync() {
              for (const { stream } of this.streams) {
                if (typeof stream.flushSync === "function") {
                  stream.flushSync();
                }
              }
            }
            function add(dest) {
              if (!dest) {
                return res;
              }
              const isStream = typeof dest.write === "function" || dest.stream;
              const stream_ = dest.write ? dest : dest.stream;
              if (!isStream) {
                throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
              }
              const { streams, streamLevels: streamLevels2 } = this;
              let level2;
              if (typeof dest.levelVal === "number") {
                level2 = dest.levelVal;
              } else if (typeof dest.level === "string") {
                level2 = streamLevels2[dest.level];
              } else if (typeof dest.level === "number") {
                level2 = dest.level;
              } else {
                level2 = DEFAULT_INFO_LEVEL;
              }
              const dest_ = {
                stream: stream_,
                level: level2,
                levelVal: void 0,
                id: counter++
              };
              streams.unshift(dest_);
              streams.sort(compareByLevel);
              this.minLevel = streams[0].level;
              return res;
            }
            function end() {
              for (const { stream } of this.streams) {
                if (typeof stream.flushSync === "function") {
                  stream.flushSync();
                }
                stream.end();
              }
            }
            function clone(level2) {
              const streams = new Array(this.streams.length);
              for (let i = 0; i < streams.length; i++) {
                streams[i] = {
                  level: level2,
                  stream: this.streams[i].stream
                };
              }
              return {
                write,
                add,
                minLevel: level2,
                streams,
                clone,
                flushSync,
                [metadata]: true
              };
            }
          }
          function compareByLevel(a, b) {
            return a.level - b.level;
          }
          function initLoopVar(length2, dedupe) {
            return dedupe ? length2 - 1 : 0;
          }
          function adjustLoopVar(i, dedupe) {
            return dedupe ? i - 1 : i + 1;
          }
          function checkLoopVar(i, length2, dedupe) {
            return dedupe ? i >= 0 : i < length2;
          }
          module2.exports = multistream;
        }
      });
      var require_pino = __commonJS2({
        "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/pino.js"(exports2, module2) {
          "use strict";
          var os = __require("os");
          var stdSerializers = require_pino_std_serializers();
          var caller = require_caller();
          var redaction = require_redaction();
          var time = require_time();
          var proto = require_proto();
          var symbols = require_symbols();
          var { configure } = require_safe_stable_stringify();
          var { assertDefaultLevelFound, mappings, genLsCache, levels } = require_levels();
          var {
            createArgsNormalizer,
            asChindings,
            buildSafeSonicBoom,
            buildFormatters,
            stringify,
            normalizeDestFileDescriptor,
            noop: noop2
          } = require_tools();
          var { version: version2 } = require_meta();
          var {
            chindingsSym,
            redactFmtSym,
            serializersSym,
            timeSym,
            timeSliceIndexSym,
            streamSym,
            stringifySym,
            stringifySafeSym,
            stringifiersSym,
            setLevelSym,
            endSym,
            formatOptsSym,
            messageKeySym,
            errorKeySym,
            nestedKeySym,
            mixinSym,
            useOnlyCustomLevelsSym,
            formattersSym,
            hooksSym,
            nestedKeyStrSym,
            mixinMergeStrategySym,
            msgPrefixSym
          } = symbols;
          var { epochTime, nullTime } = time;
          var { pid } = process;
          var hostname = os.hostname();
          var defaultErrorSerializer = stdSerializers.err;
          var defaultOptions2 = {
            level: "info",
            levels,
            messageKey: "msg",
            errorKey: "err",
            nestedKey: null,
            enabled: true,
            base: { pid, hostname },
            serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
              err: defaultErrorSerializer
            }),
            formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
              bindings(bindings) {
                return bindings;
              },
              level(label, number2) {
                return { level: number2 };
              }
            }),
            hooks: {
              logMethod: void 0
            },
            timestamp: epochTime,
            name: void 0,
            redact: null,
            customLevels: null,
            useOnlyCustomLevels: false,
            depthLimit: 5,
            edgeLimit: 100
          };
          var normalize = createArgsNormalizer(defaultOptions2);
          var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
          function pino2(...args) {
            const instance = {};
            const { opts, stream } = normalize(instance, caller(), ...args);
            const {
              redact,
              crlf,
              serializers: serializers2,
              timestamp,
              messageKey,
              errorKey,
              nestedKey,
              base: base3,
              name: name3,
              level: level2,
              customLevels,
              mixin,
              mixinMergeStrategy,
              useOnlyCustomLevels,
              formatters,
              hooks,
              depthLimit,
              edgeLimit,
              onChild,
              msgPrefix
            } = opts;
            const stringifySafe = configure({
              maximumDepth: depthLimit,
              maximumBreadth: edgeLimit
            });
            const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
            const stringifyFn = stringify.bind({
              [stringifySafeSym]: stringifySafe
            });
            const stringifiers = redact ? redaction(redact, stringifyFn) : {};
            const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
            const end = "}" + (crlf ? "\r\n" : "\n");
            const coreChindings = asChindings.bind(null, {
              [chindingsSym]: "",
              [serializersSym]: serializers2,
              [stringifiersSym]: stringifiers,
              [stringifySym]: stringify,
              [stringifySafeSym]: stringifySafe,
              [formattersSym]: allFormatters
            });
            let chindings = "";
            if (base3 !== null) {
              if (name3 === void 0) {
                chindings = coreChindings(base3);
              } else {
                chindings = coreChindings(Object.assign({}, base3, { name: name3 }));
              }
            }
            const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
            const timeSliceIndex = time2().indexOf(":") + 1;
            if (useOnlyCustomLevels && !customLevels)
              throw Error("customLevels is required if useOnlyCustomLevels is set true");
            if (mixin && typeof mixin !== "function")
              throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
            if (msgPrefix && typeof msgPrefix !== "string")
              throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
            assertDefaultLevelFound(level2, customLevels, useOnlyCustomLevels);
            const levels2 = mappings(customLevels, useOnlyCustomLevels);
            Object.assign(instance, {
              levels: levels2,
              [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
              [streamSym]: stream,
              [timeSym]: time2,
              [timeSliceIndexSym]: timeSliceIndex,
              [stringifySym]: stringify,
              [stringifySafeSym]: stringifySafe,
              [stringifiersSym]: stringifiers,
              [endSym]: end,
              [formatOptsSym]: formatOpts,
              [messageKeySym]: messageKey,
              [errorKeySym]: errorKey,
              [nestedKeySym]: nestedKey,
              [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
              [serializersSym]: serializers2,
              [mixinSym]: mixin,
              [mixinMergeStrategySym]: mixinMergeStrategy,
              [chindingsSym]: chindings,
              [formattersSym]: allFormatters,
              [hooksSym]: hooks,
              silent: noop2,
              onChild,
              [msgPrefixSym]: msgPrefix
            });
            Object.setPrototypeOf(instance, proto());
            genLsCache(instance);
            instance[setLevelSym](level2);
            return instance;
          }
          module2.exports = pino2;
          module2.exports.destination = (dest = process.stdout.fd) => {
            if (typeof dest === "object") {
              dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
              return buildSafeSonicBoom(dest);
            } else {
              return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
            }
          };
          module2.exports.transport = require_transport();
          module2.exports.multistream = require_multistream();
          module2.exports.levels = mappings();
          module2.exports.stdSerializers = serializers;
          module2.exports.stdTimeFunctions = Object.assign({}, time);
          module2.exports.symbols = symbols;
          module2.exports.version = version2;
          module2.exports.default = pino2;
          module2.exports.pino = pino2;
        }
      });
      var require_encode = __commonJS2({
        "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports2, module2) {
          module2.exports = encode9;
          var MSB2 = 128;
          var REST2 = 127;
          var MSBALL2 = ~REST2;
          var INT2 = Math.pow(2, 31);
          function encode9(num, out, offset) {
            if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
              encode9.bytes = 0;
              throw new RangeError("Could not encode varint");
            }
            out = out || [];
            offset = offset || 0;
            var oldOffset = offset;
            while (num >= INT2) {
              out[offset++] = num & 255 | MSB2;
              num /= 128;
            }
            while (num & MSBALL2) {
              out[offset++] = num & 255 | MSB2;
              num >>>= 7;
            }
            out[offset] = num | 0;
            encode9.bytes = offset - oldOffset + 1;
            return out;
          }
        }
      });
      var require_decode = __commonJS2({
        "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports2, module2) {
          module2.exports = read3;
          var MSB2 = 128;
          var REST2 = 127;
          function read3(buf2, offset) {
            var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
            do {
              if (counter >= l || shift > 49) {
                read3.bytes = 0;
                throw new RangeError("Could not decode varint");
              }
              b = buf2[counter++];
              res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
              shift += 7;
            } while (b >= MSB2);
            read3.bytes = counter - offset;
            return res;
          }
        }
      });
      var require_length = __commonJS2({
        "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports2, module2) {
          var N12 = Math.pow(2, 7);
          var N22 = Math.pow(2, 14);
          var N32 = Math.pow(2, 21);
          var N42 = Math.pow(2, 28);
          var N52 = Math.pow(2, 35);
          var N62 = Math.pow(2, 42);
          var N72 = Math.pow(2, 49);
          var N82 = Math.pow(2, 56);
          var N92 = Math.pow(2, 63);
          module2.exports = function(value) {
            return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
          };
        }
      });
      var require_varint = __commonJS2({
        "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports2, module2) {
          module2.exports = {
            encode: require_encode(),
            decode: require_decode(),
            encodingLength: require_length()
          };
        }
      });
      var src_exports4 = {};
      __export(src_exports4, {
        BlobNotFoundError: () => BlobNotFoundError,
        BlockMap: () => BlockMap,
        CidSet: () => CidSet,
        DataDiff: () => DataDiff,
        Leaf: () => Leaf,
        MST: () => MST,
        MemoryBlockstore: () => MemoryBlockstore,
        MstWalker: () => MstWalker,
        ReadableBlockstore: () => ReadableBlockstore,
        Repo: () => Repo,
        RepoVerificationError: () => RepoVerificationError,
        SyncStorage: () => SyncStorage,
        WriteOpAction: () => WriteOpAction,
        blocksToCarFile: () => blocksToCarFile,
        blocksToCarStream: () => blocksToCarStream,
        cborToLex: () => cborToLex,
        cborToLexRecord: () => cborToLexRecord,
        cidForRecord: () => cidForRecord,
        def: () => def2,
        diffToWriteDescripts: () => diffToWriteDescripts,
        ensureCreates: () => ensureCreates,
        ensureV3Commit: () => ensureV3Commit,
        formatDataKey: () => formatDataKey,
        getFullRepo: () => getFullRepo,
        getRecords: () => getRecords,
        metaEqual: () => metaEqual,
        mstDiff: () => mstDiff,
        mstUtil: () => util_exports2,
        nodeDataDef: () => nodeDataDef,
        nullDiff: () => nullDiff,
        parseDataKey: () => parseDataKey,
        readCar: () => readCar,
        readCarWithRoot: () => readCarWithRoot,
        schema: () => schema2,
        signCommit: () => signCommit,
        verifyCommitSig: () => verifyCommitSig,
        verifyDiff: () => verifyDiff,
        verifyDiffCar: () => verifyDiffCar,
        verifyIncomingCarBlocks: () => verifyIncomingCarBlocks,
        verifyProofs: () => verifyProofs,
        verifyRecords: () => verifyRecords,
        verifyRepo: () => verifyRepo,
        verifyRepoCar: () => verifyRepoCar,
        writeCar: () => writeCar,
        writeCarStream: () => writeCarStream
      });
      module.exports = __toCommonJS(src_exports4);
      var util;
      (function(util2) {
        util2.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util2.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util2.assertNever = assertNever;
        util2.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util2.getValidEnumValues = (obj) => {
          const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
          const filtered = {};
          for (const k of validKeys) {
            filtered[k] = obj[k];
          }
          return util2.objectValues(filtered);
        };
        util2.objectValues = (obj) => {
          return util2.objectKeys(obj).map(function(e) {
            return obj[e];
          });
        };
        util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
          const keys = [];
          for (const key in object2) {
            if (Object.prototype.hasOwnProperty.call(object2, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        util2.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array2, separator = " | ") {
          return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util2.joinValues = joinValues;
        util2.jsonStringifyReplacer = (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util || (util = {}));
      var objectUtil;
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return __spreadValues(__spreadValues({}, first), second);
        };
      })(objectUtil || (objectUtil = {}));
      var ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      var getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "undefined":
            return ZodParsedType.undefined;
          case "string":
            return ZodParsedType.string;
          case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
          case "boolean":
            return ZodParsedType.boolean;
          case "function":
            return ZodParsedType.function;
          case "bigint":
            return ZodParsedType.bigint;
          case "symbol":
            return ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return ZodParsedType.array;
            }
            if (data === null) {
              return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return ZodParsedType.date;
            }
            return ZodParsedType.object;
          default:
            return ZodParsedType.unknown;
        }
      };
      var ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
      ]);
      var quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
      };
      var ZodError = class extends Error {
        constructor(issues) {
          super();
          this.issues = [];
          this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
          };
          this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
          };
          const actualProto = new.target.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
          } else {
            this.__proto__ = actualProto;
          }
          this.name = "ZodError";
          this.issues = issues;
        }
        get errors() {
          return this.issues;
        }
        format(_mapper) {
          const mapper = _mapper || function(issue) {
            return issue.message;
          };
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union") {
                issue.unionErrors.map(processError);
              } else if (issue.code === "invalid_return_type") {
                processError(issue.returnTypeError);
              } else if (issue.code === "invalid_arguments") {
                processError(issue.argumentsError);
              } else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              } else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                  const el = issue.path[i];
                  const terminal = i === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  } else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i++;
                }
              }
            }
          };
          processError(this);
          return fieldErrors;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub of this.issues) {
            if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
              formErrors.push(mapper(sub));
            }
          }
          return { formErrors, fieldErrors };
        }
        get formErrors() {
          return this.flatten();
        }
      };
      ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
      };
      var errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
          case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
              message = "Required";
            } else {
              message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
          case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
          case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
          case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
          case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
          case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
          case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
          case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
          case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
              if ("includes" in issue.validation) {
                message = `Invalid input: must include "${issue.validation.includes}"`;
                if (typeof issue.validation.position === "number") {
                  message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                }
              } else if ("startsWith" in issue.validation) {
                message = `Invalid input: must start with "${issue.validation.startsWith}"`;
              } else if ("endsWith" in issue.validation) {
                message = `Invalid input: must end with "${issue.validation.endsWith}"`;
              } else {
                util.assertNever(issue.validation);
              }
            } else if (issue.validation !== "regex") {
              message = `Invalid ${issue.validation}`;
            } else {
              message = "Invalid";
            }
            break;
          case ZodIssueCode.too_small:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.too_big:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
              message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
          case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
          case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
          default:
            message = _ctx.defaultError;
            util.assertNever(issue);
        }
        return { message };
      };
      var overrideErrorMap = errorMap;
      function setErrorMap(map) {
        overrideErrorMap = map;
      }
      function getErrorMap() {
        return overrideErrorMap;
      }
      var makeIssue = (params2) => {
        const { data, path, errorMaps, issueData } = params2;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = __spreadProps(__spreadValues({}, issueData), {
          path: fullPath
        });
        let errorMessage = "";
        const maps = errorMaps.filter((m) => !!m).slice().reverse();
        for (const map of maps) {
          errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return __spreadProps(__spreadValues({}, issueData), {
          path: fullPath,
          message: issueData.message || errorMessage
        });
      };
      var EMPTY_PATH = [];
      function addIssueToContext(ctx, issueData) {
        const issue = makeIssue({
          issueData,
          data: ctx.data,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x)
        });
        ctx.common.issues.push(issue);
      }
      var ParseStatus = class {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s of results) {
            if (s.status === "aborted")
              return INVALID;
            if (s.status === "dirty")
              status.dirty();
            arrayValue.push(s.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static mergeObjectAsync(status, pairs) {
          return __async(this, null, function* () {
            const syncPairs = [];
            for (const pair of pairs) {
              syncPairs.push({
                key: yield pair.key,
                value: yield pair.value
              });
            }
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return INVALID;
            if (value.status === "aborted")
              return INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      };
      var INVALID = Object.freeze({
        status: "aborted"
      });
      var DIRTY = (value) => ({ status: "dirty", value });
      var OK = (value) => ({ status: "valid", value });
      var isAborted = (x) => x.status === "aborted";
      var isDirty = (x) => x.status === "dirty";
      var isValid = (x) => x.status === "valid";
      var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
      var errorUtil;
      (function(errorUtil2) {
        errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
      })(errorUtil || (errorUtil = {}));
      var ParseInputLazyPath = class {
        constructor(parent, value, path, key) {
          this._cachedPath = [];
          this.parent = parent;
          this.data = value;
          this._path = path;
          this._key = key;
        }
        get path() {
          if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
              this._cachedPath.push(...this._path, ...this._key);
            } else {
              this._cachedPath.push(...this._path, this._key);
            }
          }
          return this._cachedPath;
        }
      };
      var handleResult = (ctx, result) => {
        if (isValid(result)) {
          return { success: true, data: result.value };
        } else {
          if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
          }
          return {
            success: false,
            get error() {
              if (this._error)
                return this._error;
              const error = new ZodError(ctx.common.issues);
              this._error = error;
              return this._error;
            }
          };
        }
      };
      function processCreateParams(params2) {
        if (!params2)
          return {};
        const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
        if (errorMap2 && (invalid_type_error || required_error)) {
          throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        }
        if (errorMap2)
          return { errorMap: errorMap2, description };
        const customMap = (iss, ctx) => {
          if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
          if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
          }
          return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
        };
        return { errorMap: customMap, description };
      }
      var ZodType = class {
        constructor(def3) {
          this.spa = this.safeParseAsync;
          this._def = def3;
          this.parse = this.parse.bind(this);
          this.safeParse = this.safeParse.bind(this);
          this.parseAsync = this.parseAsync.bind(this);
          this.safeParseAsync = this.safeParseAsync.bind(this);
          this.spa = this.spa.bind(this);
          this.refine = this.refine.bind(this);
          this.refinement = this.refinement.bind(this);
          this.superRefine = this.superRefine.bind(this);
          this.optional = this.optional.bind(this);
          this.nullable = this.nullable.bind(this);
          this.nullish = this.nullish.bind(this);
          this.array = this.array.bind(this);
          this.promise = this.promise.bind(this);
          this.or = this.or.bind(this);
          this.and = this.and.bind(this);
          this.transform = this.transform.bind(this);
          this.brand = this.brand.bind(this);
          this.default = this.default.bind(this);
          this.catch = this.catch.bind(this);
          this.describe = this.describe.bind(this);
          this.pipe = this.pipe.bind(this);
          this.isNullable = this.isNullable.bind(this);
          this.isOptional = this.isOptional.bind(this);
        }
        get description() {
          return this._def.description;
        }
        _getType(input) {
          return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
          return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          };
        }
        _processInputParams(input) {
          return {
            status: new ParseStatus(),
            ctx: {
              common: input.parent.common,
              data: input.data,
              parsedType: getParsedType(input.data),
              schemaErrorMap: this._def.errorMap,
              path: input.path,
              parent: input.parent
            }
          };
        }
        _parseSync(input) {
          const result = this._parse(input);
          if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
          }
          return result;
        }
        _parseAsync(input) {
          const result = this._parse(input);
          return Promise.resolve(result);
        }
        parse(data, params2) {
          const result = this.safeParse(data, params2);
          if (result.success)
            return result.data;
          throw result.error;
        }
        safeParse(data, params2) {
          var _a;
          const ctx = {
            common: {
              issues: [],
              async: (_a = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a !== void 0 ? _a : false,
              contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
            },
            path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const result = this._parseSync({ data, path: ctx.path, parent: ctx });
          return handleResult(ctx, result);
        }
        parseAsync(data, params2) {
          return __async(this, null, function* () {
            const result = yield this.safeParseAsync(data, params2);
            if (result.success)
              return result.data;
            throw result.error;
          });
        }
        safeParseAsync(data, params2) {
          return __async(this, null, function* () {
            const ctx = {
              common: {
                issues: [],
                contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
                async: true
              },
              path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data,
              parsedType: getParsedType(data)
            };
            const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
            const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
            return handleResult(ctx, result);
          });
        }
        refine(check2, message) {
          const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
              return { message };
            } else if (typeof message === "function") {
              return message(val);
            } else {
              return message;
            }
          };
          return this._refinement((val, ctx) => {
            const result = check2(val);
            const setError = () => ctx.addIssue(__spreadValues({
              code: ZodIssueCode.custom
            }, getIssueProperties(val)));
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then((data) => {
                if (!data) {
                  setError();
                  return false;
                } else {
                  return true;
                }
              });
            }
            if (!result) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        refinement(check2, refinementData) {
          return this._refinement((val, ctx) => {
            if (!check2(val)) {
              ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
              return false;
            } else {
              return true;
            }
          });
        }
        _refinement(refinement) {
          return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement }
          });
        }
        superRefine(refinement) {
          return this._refinement(refinement);
        }
        optional() {
          return ZodOptional.create(this, this._def);
        }
        nullable() {
          return ZodNullable.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return ZodArray.create(this, this._def);
        }
        promise() {
          return ZodPromise.create(this, this._def);
        }
        or(option) {
          return ZodUnion.create([this, option], this._def);
        }
        and(incoming) {
          return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
          return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform }
          }));
        }
        default(def3) {
          const defaultValueFunc = typeof def3 === "function" ? def3 : () => def3;
          return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
          }));
        }
        brand() {
          return new ZodBranded(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this
          }, processCreateParams(this._def)));
        }
        catch(def3) {
          const catchValueFunc = typeof def3 === "function" ? def3 : () => def3;
          return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
          }));
        }
        describe(description) {
          const This = this.constructor;
          return new This(__spreadProps(__spreadValues({}, this._def), {
            description
          }));
        }
        pipe(target2) {
          return ZodPipeline.create(this, target2);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      };
      var cuidRegex = /^c[^\s-]{8,}$/i;
      var cuid2Regex = /^[a-z][a-z0-9]*$/;
      var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
      var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
      var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
      var emojiRegex = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
      var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
      var datetimeRegex = (args) => {
        if (args.precision) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
          }
        } else if (args.precision === 0) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
          }
        } else {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
          }
        }
      };
      function isValidIP(ip, version2) {
        if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
          return true;
        }
        if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
          return true;
        }
        return false;
      }
      var ZodString = class extends ZodType {
        constructor() {
          super(...arguments);
          this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), __spreadValues({
            validation,
            code: ZodIssueCode.invalid_string
          }, errorUtil.errToObj(message)));
          this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
          this.trim = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "trim" }]
          }));
          this.toLowerCase = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toLowerCase" }]
          }));
          this.toUpperCase = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toUpperCase" }]
          }));
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = String(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check2 of this._def.checks) {
            if (check2.kind === "min") {
              if (input.data.length < check2.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "max") {
              if (input.data.length > check2.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "length") {
              const tooBig = input.data.length > check2.value;
              const tooSmall = input.data.length < check2.value;
              if (tooBig || tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                if (tooBig) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: check2.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check2.message
                  });
                } else if (tooSmall) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: check2.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check2.message
                  });
                }
                status.dirty();
              }
            } else if (check2.kind === "email") {
              if (!emailRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "email",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "emoji") {
              if (!emojiRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "emoji",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "uuid") {
              if (!uuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "uuid",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "cuid") {
              if (!cuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "cuid2") {
              if (!cuid2Regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid2",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "ulid") {
              if (!ulidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ulid",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "url") {
              try {
                new URL(input.data);
              } catch (_a) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "url",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "regex") {
              check2.regex.lastIndex = 0;
              const testResult = check2.regex.test(input.data);
              if (!testResult) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "regex",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "trim") {
              input.data = input.data.trim();
            } else if (check2.kind === "includes") {
              if (!input.data.includes(check2.value, check2.position)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { includes: check2.value, position: check2.position },
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "toLowerCase") {
              input.data = input.data.toLowerCase();
            } else if (check2.kind === "toUpperCase") {
              input.data = input.data.toUpperCase();
            } else if (check2.kind === "startsWith") {
              if (!input.data.startsWith(check2.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { startsWith: check2.value },
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "endsWith") {
              if (!input.data.endsWith(check2.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { endsWith: check2.value },
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "datetime") {
              const regex = datetimeRegex(check2);
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: "datetime",
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "ip") {
              if (!isValidIP(input.data, check2.version)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ip",
                  code: ZodIssueCode.invalid_string,
                  message: check2.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check2);
            }
          }
          return { status: status.value, value: input.data };
        }
        _addCheck(check2) {
          return new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check2]
          }));
        }
        email(message) {
          return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
        }
        url(message) {
          return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
        }
        emoji(message) {
          return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
        }
        uuid(message) {
          return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
        }
        cuid(message) {
          return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
        }
        cuid2(message) {
          return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
        }
        ulid(message) {
          return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
        }
        ip(options) {
          return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
        }
        datetime(options) {
          var _a;
          if (typeof options === "string") {
            return this._addCheck({
              kind: "datetime",
              precision: null,
              offset: false,
              message: options
            });
          }
          return this._addCheck(__spreadValues({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        regex(regex, message) {
          return this._addCheck(__spreadValues({
            kind: "regex",
            regex
          }, errorUtil.errToObj(message)));
        }
        includes(value, options) {
          return this._addCheck(__spreadValues({
            kind: "includes",
            value,
            position: options === null || options === void 0 ? void 0 : options.position
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        startsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "startsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        endsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "endsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        min(minLength, message) {
          return this._addCheck(__spreadValues({
            kind: "min",
            value: minLength
          }, errorUtil.errToObj(message)));
        }
        max(maxLength, message) {
          return this._addCheck(__spreadValues({
            kind: "max",
            value: maxLength
          }, errorUtil.errToObj(message)));
        }
        length(len, message) {
          return this._addCheck(__spreadValues({
            kind: "length",
            value: len
          }, errorUtil.errToObj(message)));
        }
        get isDatetime() {
          return !!this._def.checks.find((ch) => ch.kind === "datetime");
        }
        get isEmail() {
          return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
          return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isEmoji() {
          return !!this._def.checks.find((ch) => ch.kind === "emoji");
        }
        get isUUID() {
          return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get isCUID2() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid2");
        }
        get isULID() {
          return !!this._def.checks.find((ch) => ch.kind === "ulid");
        }
        get isIP() {
          return !!this._def.checks.find((ch) => ch.kind === "ip");
        }
        get minLength() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxLength() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodString.create = (params2) => {
        var _a;
        return new ZodString(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodString,
          coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false
        }, processCreateParams(params2)));
      };
      function floatSafeRemainder(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
        return valInt % stepInt / Math.pow(10, decCount);
      }
      var ZodNumber = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
          this.step = this.multipleOf;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = Number(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.number,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check2 of this._def.checks) {
            if (check2.kind === "int") {
              if (!util.isInteger(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "min") {
              const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check2.value,
                  type: "number",
                  inclusive: check2.inclusive,
                  exact: false,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "max") {
              const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check2.value,
                  type: "number",
                  inclusive: check2.inclusive,
                  exact: false,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "multipleOf") {
              if (floatSafeRemainder(input.data, check2.value) !== 0) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check2.value,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "finite") {
              if (!Number.isFinite(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_finite,
                  message: check2.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check2);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check2) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check2]
          }));
        }
        int(message) {
          return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        finite(message) {
          return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message)
          });
        }
        safe(message) {
          return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message)
          })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
        get isInt() {
          return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
        }
        get isFinite() {
          let max = null, min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
              return true;
            } else if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            } else if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return Number.isFinite(min) && Number.isFinite(max);
        }
      };
      ZodNumber.create = (params2) => {
        return new ZodNumber(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodNumber,
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false
        }, processCreateParams(params2)));
      };
      var ZodBigInt = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = BigInt(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.bigint) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.bigint,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check2 of this._def.checks) {
            if (check2.kind === "min") {
              const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  type: "bigint",
                  minimum: check2.value,
                  inclusive: check2.inclusive,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "max") {
              const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  type: "bigint",
                  maximum: check2.value,
                  inclusive: check2.inclusive,
                  message: check2.message
                });
                status.dirty();
              }
            } else if (check2.kind === "multipleOf") {
              if (input.data % check2.value !== BigInt(0)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check2.value,
                  message: check2.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check2);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check2) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check2]
          }));
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodBigInt.create = (params2) => {
        var _a;
        return new ZodBigInt(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodBigInt,
          coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false
        }, processCreateParams(params2)));
      };
      var ZodBoolean = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = Boolean(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.boolean,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodBoolean.create = (params2) => {
        return new ZodBoolean(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodBoolean,
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false
        }, processCreateParams(params2)));
      };
      var ZodDate = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = new Date(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.date,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          if (isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_date
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check2 of this._def.checks) {
            if (check2.kind === "min") {
              if (input.data.getTime() < check2.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  message: check2.message,
                  inclusive: true,
                  exact: false,
                  minimum: check2.value,
                  type: "date"
                });
                status.dirty();
              }
            } else if (check2.kind === "max") {
              if (input.data.getTime() > check2.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  message: check2.message,
                  inclusive: true,
                  exact: false,
                  maximum: check2.value,
                  type: "date"
                });
                status.dirty();
              }
            } else {
              util.assertNever(check2);
            }
          }
          return {
            status: status.value,
            value: new Date(input.data.getTime())
          };
        }
        _addCheck(check2) {
          return new ZodDate(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check2]
          }));
        }
        min(minDate, message) {
          return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        max(maxDate, message) {
          return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        get minDate() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min != null ? new Date(min) : null;
        }
        get maxDate() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max != null ? new Date(max) : null;
        }
      };
      ZodDate.create = (params2) => {
        return new ZodDate(__spreadValues({
          checks: [],
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
          typeName: ZodFirstPartyTypeKind.ZodDate
        }, processCreateParams(params2)));
      };
      var ZodSymbol = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.symbol,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodSymbol.create = (params2) => {
        return new ZodSymbol(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodSymbol
        }, processCreateParams(params2)));
      };
      var ZodUndefined = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.undefined,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodUndefined.create = (params2) => {
        return new ZodUndefined(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUndefined
        }, processCreateParams(params2)));
      };
      var ZodNull = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.null,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodNull.create = (params2) => {
        return new ZodNull(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNull
        }, processCreateParams(params2)));
      };
      var ZodAny = class extends ZodType {
        constructor() {
          super(...arguments);
          this._any = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodAny.create = (params2) => {
        return new ZodAny(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodAny
        }, processCreateParams(params2)));
      };
      var ZodUnknown = class extends ZodType {
        constructor() {
          super(...arguments);
          this._unknown = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodUnknown.create = (params2) => {
        return new ZodUnknown(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUnknown
        }, processCreateParams(params2)));
      };
      var ZodNever = class extends ZodType {
        _parse(input) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
          });
          return INVALID;
        }
      };
      ZodNever.create = (params2) => {
        return new ZodNever(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNever
        }, processCreateParams(params2)));
      };
      var ZodVoid = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.void,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodVoid.create = (params2) => {
        return new ZodVoid(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodVoid
        }, processCreateParams(params2)));
      };
      var ZodArray = class extends ZodType {
        _parse(input) {
          const { ctx, status } = this._processInputParams(input);
          const def3 = this._def;
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (def3.exactLength !== null) {
            const tooBig = ctx.data.length > def3.exactLength.value;
            const tooSmall = ctx.data.length < def3.exactLength.value;
            if (tooBig || tooSmall) {
              addIssueToContext(ctx, {
                code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                minimum: tooSmall ? def3.exactLength.value : void 0,
                maximum: tooBig ? def3.exactLength.value : void 0,
                type: "array",
                inclusive: true,
                exact: true,
                message: def3.exactLength.message
              });
              status.dirty();
            }
          }
          if (def3.minLength !== null) {
            if (ctx.data.length < def3.minLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def3.minLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def3.minLength.message
              });
              status.dirty();
            }
          }
          if (def3.maxLength !== null) {
            if (ctx.data.length > def3.maxLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def3.maxLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def3.maxLength.message
              });
              status.dirty();
            }
          }
          if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
              return def3.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result2) => {
              return ParseStatus.mergeArray(status, result2);
            });
          }
          const result = [...ctx.data].map((item, i) => {
            return def3.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          });
          return ParseStatus.mergeArray(status, result);
        }
        get element() {
          return this._def.type;
        }
        min(minLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            minLength: { value: minLength, message: errorUtil.toString(message) }
          }));
        }
        max(maxLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            maxLength: { value: maxLength, message: errorUtil.toString(message) }
          }));
        }
        length(len, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            exactLength: { value: len, message: errorUtil.toString(message) }
          }));
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodArray.create = (schema3, params2) => {
        return new ZodArray(__spreadValues({
          type: schema3,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: ZodFirstPartyTypeKind.ZodArray
        }, processCreateParams(params2)));
      };
      function deepPartialify(schema3) {
        if (schema3 instanceof ZodObject) {
          const newShape = {};
          for (const key in schema3.shape) {
            const fieldSchema = schema3.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
          }
          return new ZodObject(__spreadProps(__spreadValues({}, schema3._def), {
            shape: () => newShape
          }));
        } else if (schema3 instanceof ZodArray) {
          return new ZodArray(__spreadProps(__spreadValues({}, schema3._def), {
            type: deepPartialify(schema3.element)
          }));
        } else if (schema3 instanceof ZodOptional) {
          return ZodOptional.create(deepPartialify(schema3.unwrap()));
        } else if (schema3 instanceof ZodNullable) {
          return ZodNullable.create(deepPartialify(schema3.unwrap()));
        } else if (schema3 instanceof ZodTuple) {
          return ZodTuple.create(schema3.items.map((item) => deepPartialify(item)));
        } else {
          return schema3;
        }
      }
      var ZodObject = class extends ZodType {
        constructor() {
          super(...arguments);
          this._cached = null;
          this.nonstrict = this.passthrough;
          this.augment = this.extend;
        }
        _getCached() {
          if (this._cached !== null)
            return this._cached;
          const shape = this._def.shape();
          const keys = util.objectKeys(shape);
          return this._cached = { shape, keys };
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const { status, ctx } = this._processInputParams(input);
          const { shape, keys: shapeKeys } = this._getCached();
          const extraKeys = [];
          if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
              if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
              }
            }
          }
          const pairs = [];
          for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
              for (const key of extraKeys) {
                pairs.push({
                  key: { status: "valid", value: key },
                  value: { status: "valid", value: ctx.data[key] }
                });
              }
            } else if (unknownKeys === "strict") {
              if (extraKeys.length > 0) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.unrecognized_keys,
                  keys: extraKeys
                });
                status.dirty();
              }
            } else if (unknownKeys === "strip")
              ;
            else {
              throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
          } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
              const value = ctx.data[key];
              pairs.push({
                key: { status: "valid", value: key },
                value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
              });
            }
          }
          if (ctx.common.async) {
            return Promise.resolve().then(() => __async(this, null, function* () {
              const syncPairs = [];
              for (const pair of pairs) {
                const key = yield pair.key;
                syncPairs.push({
                  key,
                  value: yield pair.value,
                  alwaysSet: pair.alwaysSet
                });
              }
              return syncPairs;
            })).then((syncPairs) => {
              return ParseStatus.mergeObjectSync(status, syncPairs);
            });
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get shape() {
          return this._def.shape();
        }
        strict(message) {
          errorUtil.errToObj;
          return new ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strict"
          }), message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}));
        }
        strip() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strip"
          }));
        }
        passthrough() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "passthrough"
          }));
        }
        extend(augmentation) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
          }));
        }
        merge(merging) {
          const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject
          });
          return merged;
        }
        setKey(key, schema3) {
          return this.augment({ [key]: schema3 });
        }
        catchall(index) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            catchall: index
          }));
        }
        pick(mask) {
          const shape = {};
          util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        omit(mask) {
          const shape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        deepPartial() {
          return deepPartialify(this);
        }
        partial(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
              newShape[key] = fieldSchema;
            } else {
              newShape[key] = fieldSchema.optional();
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        required(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        keyof() {
          return createZodEnum(util.objectKeys(this.shape));
        }
      };
      ZodObject.create = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      ZodObject.strictCreate = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strict",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      ZodObject.lazycreate = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      var ZodUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const options = this._def.options;
          function handleResults(results) {
            for (const result of results) {
              if (result.result.status === "valid") {
                return result.result;
              }
            }
            for (const result of results) {
              if (result.result.status === "dirty") {
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
              }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return Promise.all(options.map((option) => __async(this, null, function* () {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              return {
                result: yield option._parseAsync({
                  data: ctx.data,
                  path: ctx.path,
                  parent: childCtx
                }),
                ctx: childCtx
              };
            }))).then(handleResults);
          } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              const result = option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              });
              if (result.status === "valid") {
                return result;
              } else if (result.status === "dirty" && !dirty) {
                dirty = { result, ctx: childCtx };
              }
              if (childCtx.common.issues.length) {
                issues.push(childCtx.common.issues);
              }
            }
            if (dirty) {
              ctx.common.issues.push(...dirty.ctx.common.issues);
              return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError(issues2));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      ZodUnion.create = (types, params2) => {
        return new ZodUnion(__spreadValues({
          options: types,
          typeName: ZodFirstPartyTypeKind.ZodUnion
        }, processCreateParams(params2)));
      };
      var getDiscriminator = (type) => {
        if (type instanceof ZodLazy) {
          return getDiscriminator(type.schema);
        } else if (type instanceof ZodEffects) {
          return getDiscriminator(type.innerType());
        } else if (type instanceof ZodLiteral) {
          return [type.value];
        } else if (type instanceof ZodEnum) {
          return type.options;
        } else if (type instanceof ZodNativeEnum) {
          return Object.keys(type.enum);
        } else if (type instanceof ZodDefault) {
          return getDiscriminator(type._def.innerType);
        } else if (type instanceof ZodUndefined) {
          return [void 0];
        } else if (type instanceof ZodNull) {
          return [null];
        } else {
          return null;
        }
      };
      var ZodDiscriminatedUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const discriminator = this.discriminator;
          const discriminatorValue = ctx.data[discriminator];
          const option = this.optionsMap.get(discriminatorValue);
          if (!option) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [discriminator]
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          } else {
            return option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(discriminator, options, params2) {
          const optionsMap = /* @__PURE__ */ new Map();
          for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
              throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
              if (optionsMap.has(value)) {
                throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
              }
              optionsMap.set(value, type);
            }
          }
          return new ZodDiscriminatedUnion(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap
          }, processCreateParams(params2)));
        }
      };
      function mergeValues(a, b) {
        const aType = getParsedType(a);
        const bType = getParsedType(b);
        if (a === b) {
          return { valid: true, data: a };
        } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
          const bKeys = util.objectKeys(b);
          const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
          const newObj = __spreadValues(__spreadValues({}, a), b);
          for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newObj[key] = sharedValue.data;
          }
          return { valid: true, data: newObj };
        } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
          if (a.length !== b.length) {
            return { valid: false };
          }
          const newArray = [];
          for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newArray.push(sharedValue.data);
          }
          return { valid: true, data: newArray };
        } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
          return { valid: true, data: a };
        } else {
          return { valid: false };
        }
      }
      var ZodIntersection = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
              return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_intersection_types
              });
              return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
              status.dirty();
            }
            return { status: status.value, value: merged.data };
          };
          if (ctx.common.async) {
            return Promise.all([
              this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              }),
              this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              })
            ]).then(([left, right]) => handleParsed(left, right));
          } else {
            return handleParsed(this._def.left._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }), this._def.right._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }));
          }
        }
      };
      ZodIntersection.create = (left, right, params2) => {
        return new ZodIntersection(__spreadValues({
          left,
          right,
          typeName: ZodFirstPartyTypeKind.ZodIntersection
        }, processCreateParams(params2)));
      };
      var ZodTuple = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            return INVALID;
          }
          const rest = this._def.rest;
          if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            status.dirty();
          }
          const items = [...ctx.data].map((item, itemIndex) => {
            const schema3 = this._def.items[itemIndex] || this._def.rest;
            if (!schema3)
              return null;
            return schema3._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
          }).filter((x) => !!x);
          if (ctx.common.async) {
            return Promise.all(items).then((results) => {
              return ParseStatus.mergeArray(status, results);
            });
          } else {
            return ParseStatus.mergeArray(status, items);
          }
        }
        get items() {
          return this._def.items;
        }
        rest(rest) {
          return new ZodTuple(__spreadProps(__spreadValues({}, this._def), {
            rest
          }));
        }
      };
      ZodTuple.create = (schemas, params2) => {
        if (!Array.isArray(schemas)) {
          throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple(__spreadValues({
          items: schemas,
          typeName: ZodFirstPartyTypeKind.ZodTuple,
          rest: null
        }, processCreateParams(params2)));
      };
      var ZodRecord = class extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const pairs = [];
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          for (const key in ctx.data) {
            pairs.push({
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
              value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
            });
          }
          if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get element() {
          return this._def.valueType;
        }
        static create(first, second, third) {
          if (second instanceof ZodType) {
            return new ZodRecord(__spreadValues({
              keyType: first,
              valueType: second,
              typeName: ZodFirstPartyTypeKind.ZodRecord
            }, processCreateParams(third)));
          }
          return new ZodRecord(__spreadValues({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord
          }, processCreateParams(second)));
        }
      };
      var ZodMap = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.map,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
              value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
            };
          });
          if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(() => __async(this, null, function* () {
              for (const pair of pairs) {
                const key = yield pair.key;
                const value = yield pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                  return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                  status.dirty();
                }
                finalMap.set(key.value, value.value);
              }
              return { status: status.value, value: finalMap };
            }));
          } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
              const key = pair.key;
              const value = pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          }
        }
      };
      ZodMap.create = (keyType, valueType, params2) => {
        return new ZodMap(__spreadValues({
          valueType,
          keyType,
          typeName: ZodFirstPartyTypeKind.ZodMap
        }, processCreateParams(params2)));
      };
      var ZodSet = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.set,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const def3 = this._def;
          if (def3.minSize !== null) {
            if (ctx.data.size < def3.minSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def3.minSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def3.minSize.message
              });
              status.dirty();
            }
          }
          if (def3.maxSize !== null) {
            if (ctx.data.size > def3.maxSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def3.maxSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def3.maxSize.message
              });
              status.dirty();
            }
          }
          const valueType = this._def.valueType;
          function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
              if (element.status === "aborted")
                return INVALID;
              if (element.status === "dirty")
                status.dirty();
              parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
          }
          const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
          if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
          } else {
            return finalizeSet(elements);
          }
        }
        min(minSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            minSize: { value: minSize, message: errorUtil.toString(message) }
          }));
        }
        max(maxSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            maxSize: { value: maxSize, message: errorUtil.toString(message) }
          }));
        }
        size(size, message) {
          return this.min(size, message).max(size, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodSet.create = (valueType, params2) => {
        return new ZodSet(__spreadValues({
          valueType,
          minSize: null,
          maxSize: null,
          typeName: ZodFirstPartyTypeKind.ZodSet
        }, processCreateParams(params2)));
      };
      var ZodFunction = class extends ZodType {
        constructor() {
          super(...arguments);
          this.validate = this.implement;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.function,
              received: ctx.parsedType
            });
            return INVALID;
          }
          function makeArgsIssue(args, error) {
            return makeIssue({
              data: args,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_arguments,
                argumentsError: error
              }
            });
          }
          function makeReturnsIssue(returns, error) {
            return makeIssue({
              data: returns,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_return_type,
                returnTypeError: error
              }
            });
          }
          const params2 = { errorMap: ctx.common.contextualErrorMap };
          const fn = ctx.data;
          if (this._def.returns instanceof ZodPromise) {
            return OK((...args) => __async(this, null, function* () {
              const error = new ZodError([]);
              const parsedArgs = yield this._def.args.parseAsync(args, params2).catch((e) => {
                error.addIssue(makeArgsIssue(args, e));
                throw error;
              });
              const result = yield fn(...parsedArgs);
              const parsedReturns = yield this._def.returns._def.type.parseAsync(result, params2).catch((e) => {
                error.addIssue(makeReturnsIssue(result, e));
                throw error;
              });
              return parsedReturns;
            }));
          } else {
            return OK((...args) => {
              const parsedArgs = this._def.args.safeParse(args, params2);
              if (!parsedArgs.success) {
                throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
              }
              const result = fn(...parsedArgs.data);
              const parsedReturns = this._def.returns.safeParse(result, params2);
              if (!parsedReturns.success) {
                throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
              }
              return parsedReturns.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...items) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            args: ZodTuple.create(items).rest(ZodUnknown.create())
          }));
        }
        returns(returnType) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            returns: returnType
          }));
        }
        implement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        strictImplement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        static create(args, returns, params2) {
          return new ZodFunction(__spreadValues({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction
          }, processCreateParams(params2)));
        }
      };
      var ZodLazy = class extends ZodType {
        get schema() {
          return this._def.getter();
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const lazySchema = this._def.getter();
          return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
      };
      ZodLazy.create = (getter, params2) => {
        return new ZodLazy(__spreadValues({
          getter,
          typeName: ZodFirstPartyTypeKind.ZodLazy
        }, processCreateParams(params2)));
      };
      var ZodLiteral = class extends ZodType {
        _parse(input) {
          if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_literal,
              expected: this._def.value
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
        get value() {
          return this._def.value;
        }
      };
      ZodLiteral.create = (value, params2) => {
        return new ZodLiteral(__spreadValues({
          value,
          typeName: ZodFirstPartyTypeKind.ZodLiteral
        }, processCreateParams(params2)));
      };
      function createZodEnum(values, params2) {
        return new ZodEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodEnum
        }, processCreateParams(params2)));
      }
      var ZodEnum = class extends ZodType {
        _parse(input) {
          if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Values() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        extract(values) {
          return ZodEnum.create(values);
        }
        exclude(values) {
          return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
        }
      };
      ZodEnum.create = createZodEnum;
      var ZodNativeEnum = class extends ZodType {
        _parse(input) {
          const nativeEnumValues = util.getValidEnumValues(this._def.values);
          const ctx = this._getOrReturnCtx(input);
          if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      ZodNativeEnum.create = (values, params2) => {
        return new ZodNativeEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodNativeEnum
        }, processCreateParams(params2)));
      };
      var ZodPromise = class extends ZodType {
        unwrap() {
          return this._def.type;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.promise,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
          return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
              path: ctx.path,
              errorMap: ctx.common.contextualErrorMap
            });
          }));
        }
      };
      ZodPromise.create = (schema3, params2) => {
        return new ZodPromise(__spreadValues({
          type: schema3,
          typeName: ZodFirstPartyTypeKind.ZodPromise
        }, processCreateParams(params2)));
      };
      var ZodEffects = class extends ZodType {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const effect = this._def.effect || null;
          if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
              return Promise.resolve(processed).then((processed2) => {
                return this._def.schema._parseAsync({
                  data: processed2,
                  path: ctx.path,
                  parent: ctx
                });
              });
            } else {
              return this._def.schema._parseSync({
                data: processed,
                path: ctx.path,
                parent: ctx
              });
            }
          }
          const checkCtx = {
            addIssue: (arg) => {
              addIssueToContext(ctx, arg);
              if (arg.fatal) {
                status.abort();
              } else {
                status.dirty();
              }
            },
            get path() {
              return ctx.path;
            }
          };
          checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
          if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
              const result = effect.refinement(acc, checkCtx);
              if (ctx.common.async) {
                return Promise.resolve(result);
              }
              if (result instanceof Promise) {
                throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
              }
              return acc;
            };
            if (ctx.common.async === false) {
              const inner = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              executeRefinement(inner.value);
              return { status: status.value, value: inner.value };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                if (inner.status === "aborted")
                  return INVALID;
                if (inner.status === "dirty")
                  status.dirty();
                return executeRefinement(inner.value).then(() => {
                  return { status: status.value, value: inner.value };
                });
              });
            }
          }
          if (effect.type === "transform") {
            if (ctx.common.async === false) {
              const base3 = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (!isValid(base3))
                return base3;
              const result = effect.transform(base3.value, checkCtx);
              if (result instanceof Promise) {
                throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
              }
              return { status: status.value, value: result };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
                if (!isValid(base3))
                  return base3;
                return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
              });
            }
          }
          util.assertNever(effect);
        }
      };
      ZodEffects.create = (schema3, effect, params2) => {
        return new ZodEffects(__spreadValues({
          schema: schema3,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect
        }, processCreateParams(params2)));
      };
      ZodEffects.createWithPreprocess = (preprocess, schema3, params2) => {
        return new ZodEffects(__spreadValues({
          schema: schema3,
          effect: { type: "preprocess", transform: preprocess },
          typeName: ZodFirstPartyTypeKind.ZodEffects
        }, processCreateParams(params2)));
      };
      var ZodOptional = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.undefined) {
            return OK(void 0);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodOptional.create = (type, params2) => {
        return new ZodOptional(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodOptional
        }, processCreateParams(params2)));
      };
      var ZodNullable = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.null) {
            return OK(null);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodNullable.create = (type, params2) => {
        return new ZodNullable(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodNullable
        }, processCreateParams(params2)));
      };
      var ZodDefault = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          let data = ctx.data;
          if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
          }
          return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      ZodDefault.create = (type, params2) => {
        return new ZodDefault(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodDefault,
          defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default
        }, processCreateParams(params2)));
      };
      var ZodCatch = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const newCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            })
          });
          const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: __spreadValues({}, newCtx)
          });
          if (isAsync(result)) {
            return result.then((result2) => {
              return {
                status: "valid",
                value: result2.status === "valid" ? result2.value : this._def.catchValue({
                  get error() {
                    return new ZodError(newCtx.common.issues);
                  },
                  input: newCtx.data
                })
              };
            });
          } else {
            return {
              status: "valid",
              value: result.status === "valid" ? result.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          }
        }
        removeCatch() {
          return this._def.innerType;
        }
      };
      ZodCatch.create = (type, params2) => {
        return new ZodCatch(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodCatch,
          catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch
        }, processCreateParams(params2)));
      };
      var ZodNaN = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.nan,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
      };
      ZodNaN.create = (params2) => {
        return new ZodNaN(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNaN
        }, processCreateParams(params2)));
      };
      var BRAND = Symbol("zod_brand");
      var ZodBranded = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const data = ctx.data;
          return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        unwrap() {
          return this._def.type;
        }
      };
      var ZodPipeline = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.common.async) {
            const handleAsync = () => __async(this, null, function* () {
              const inResult = yield this._def.in._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inResult.status === "aborted")
                return INVALID;
              if (inResult.status === "dirty") {
                status.dirty();
                return DIRTY(inResult.value);
              } else {
                return this._def.out._parseAsync({
                  data: inResult.value,
                  path: ctx.path,
                  parent: ctx
                });
              }
            });
            return handleAsync();
          } else {
            const inResult = this._def.in._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return {
                status: "dirty",
                value: inResult.value
              };
            } else {
              return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }
        }
        static create(a, b) {
          return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
          });
        }
      };
      var custom = (check2, params2 = {}, fatal) => {
        if (check2)
          return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check2(data)) {
              const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
              const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
              const p2 = typeof p === "string" ? { message: p } : p;
              ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal: _fatal }));
            }
          });
        return ZodAny.create();
      };
      var late = {
        object: ZodObject.lazycreate
      };
      var ZodFirstPartyTypeKind;
      (function(ZodFirstPartyTypeKind2) {
        ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
      var instanceOfType = (cls, params2 = {
        message: `Input not instance of ${cls.name}`
      }) => custom((data) => data instanceof cls, params2);
      var stringType = ZodString.create;
      var numberType = ZodNumber.create;
      var nanType = ZodNaN.create;
      var bigIntType = ZodBigInt.create;
      var booleanType = ZodBoolean.create;
      var dateType = ZodDate.create;
      var symbolType = ZodSymbol.create;
      var undefinedType = ZodUndefined.create;
      var nullType = ZodNull.create;
      var anyType = ZodAny.create;
      var unknownType = ZodUnknown.create;
      var neverType = ZodNever.create;
      var voidType = ZodVoid.create;
      var arrayType = ZodArray.create;
      var objectType = ZodObject.create;
      var strictObjectType = ZodObject.strictCreate;
      var unionType = ZodUnion.create;
      var discriminatedUnionType = ZodDiscriminatedUnion.create;
      var intersectionType = ZodIntersection.create;
      var tupleType = ZodTuple.create;
      var recordType = ZodRecord.create;
      var mapType = ZodMap.create;
      var setType = ZodSet.create;
      var functionType = ZodFunction.create;
      var lazyType = ZodLazy.create;
      var literalType = ZodLiteral.create;
      var enumType = ZodEnum.create;
      var nativeEnumType = ZodNativeEnum.create;
      var promiseType = ZodPromise.create;
      var effectsType = ZodEffects.create;
      var optionalType = ZodOptional.create;
      var nullableType = ZodNullable.create;
      var preprocessType = ZodEffects.createWithPreprocess;
      var pipelineType = ZodPipeline.create;
      var ostring = () => stringType().optional();
      var onumber = () => numberType().optional();
      var oboolean = () => booleanType().optional();
      var coerce = {
        string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
          coerce: true
        })),
        bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true }))
      };
      var NEVER = INVALID;
      var z = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        defaultErrorMap: errorMap,
        setErrorMap,
        getErrorMap,
        makeIssue,
        EMPTY_PATH,
        addIssueToContext,
        ParseStatus,
        INVALID,
        DIRTY,
        OK,
        isAborted,
        isDirty,
        isValid,
        isAsync,
        get util() {
          return util;
        },
        get objectUtil() {
          return objectUtil;
        },
        ZodParsedType,
        getParsedType,
        ZodType,
        ZodString,
        ZodNumber,
        ZodBigInt,
        ZodBoolean,
        ZodDate,
        ZodSymbol,
        ZodUndefined,
        ZodNull,
        ZodAny,
        ZodUnknown,
        ZodNever,
        ZodVoid,
        ZodArray,
        ZodObject,
        ZodUnion,
        ZodDiscriminatedUnion,
        ZodIntersection,
        ZodTuple,
        ZodRecord,
        ZodMap,
        ZodSet,
        ZodFunction,
        ZodLazy,
        ZodLiteral,
        ZodEnum,
        ZodNativeEnum,
        ZodPromise,
        ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional,
        ZodNullable,
        ZodDefault,
        ZodCatch,
        ZodNaN,
        BRAND,
        ZodBranded,
        ZodPipeline,
        custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late,
        get ZodFirstPartyTypeKind() {
          return ZodFirstPartyTypeKind;
        },
        coerce,
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        "enum": enumType,
        "function": functionType,
        "instanceof": instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        "null": nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean,
        onumber,
        optional: optionalType,
        ostring,
        pipeline: pipelineType,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        symbol: symbolType,
        transformer: effectsType,
        tuple: tupleType,
        "undefined": undefinedType,
        union: unionType,
        unknown: unknownType,
        "void": voidType,
        NEVER,
        ZodIssueCode,
        quotelessJson,
        ZodError
      });
      var NSID = class {
        constructor(nsid2) {
          this.segments = [];
          ensureValidNsid(nsid2);
          this.segments = nsid2.split(".");
        }
        static parse(nsid2) {
          return new NSID(nsid2);
        }
        static create(authority, name3) {
          const segments = [...authority.split(".").reverse(), name3].join(".");
          return new NSID(segments);
        }
        static isValid(nsid2) {
          try {
            NSID.parse(nsid2);
            return true;
          } catch (e) {
            return false;
          }
        }
        get authority() {
          return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
        }
        get name() {
          return this.segments.at(this.segments.length - 1);
        }
        toString() {
          return this.segments.join(".");
        }
      };
      var ensureValidNsid = (nsid2) => {
        const toCheck = nsid2;
        if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
          throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
        }
        if (toCheck.length > 253 + 1 + 63) {
          throw new InvalidNsidError("NSID is too long (317 chars max)");
        }
        const labels = toCheck.split(".");
        if (labels.length < 3) {
          throw new InvalidNsidError("NSID needs at least three parts");
        }
        for (let i = 0; i < labels.length; i++) {
          const l = labels[i];
          if (l.length < 1) {
            throw new InvalidNsidError("NSID parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidNsidError("NSID part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidNsidError("NSID parts can not start or end with hyphen");
          }
          if (/^[0-9]/.test(l) && i == 0) {
            throw new InvalidNsidError("NSID first part may not start with a digit");
          }
          if (!/^[a-zA-Z]+$/.test(l) && i + 1 == labels.length) {
            throw new InvalidNsidError("NSID name part must be only letters");
          }
        }
      };
      var InvalidNsidError = class extends Error {
      };
      var check_exports = {};
      __export(check_exports, {
        assure: () => assure,
        is: () => is,
        isObject: () => isObject
      });
      var is = (obj, def3) => {
        return def3.safeParse(obj).success;
      };
      var assure = (def3, obj) => {
        return def3.parse(obj);
      };
      var isObject = (obj) => {
        return typeof obj === "object" && obj !== null;
      };
      var flattenUint8Arrays = (arrs) => {
        const length2 = arrs.reduce((acc, cur) => {
          return acc + cur.length;
        }, 0);
        const flattened = new Uint8Array(length2);
        let offset = 0;
        arrs.forEach((arr) => {
          flattened.set(arr, offset);
          offset += arr.length;
        });
        return flattened;
      };
      var streamToBuffer = (stream) => __async(exports, null, function* () {
        const arrays = [];
        try {
          for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const chunk = temp.value;
            arrays.push(chunk);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        return flattenUint8Arrays(arrays);
      });
      var S32_CHAR = "234567abcdefghijklmnopqrstuvwxyz";
      var s32encode = (i) => {
        let s = "";
        while (i) {
          const c = i % 32;
          i = Math.floor(i / 32);
          s = S32_CHAR.charAt(c) + s;
        }
        return s;
      };
      var s32decode = (s) => {
        let i = 0;
        for (const c of s) {
          i = i * 32 + S32_CHAR.indexOf(c);
        }
        return i;
      };
      var TID_LEN = 13;
      var lastTimestamp = 0;
      var timestampCount = 0;
      var clockid = null;
      function dedash(str) {
        return str.replaceAll("-", "");
      }
      var TID = class {
        constructor(str) {
          const noDashes = dedash(str);
          if (noDashes.length !== TID_LEN) {
            throw new Error(`Poorly formatted TID: ${noDashes.length} length`);
          }
          this.str = noDashes;
        }
        static next(prev) {
          const time = Math.max(Date.now(), lastTimestamp);
          if (time === lastTimestamp) {
            timestampCount++;
          }
          lastTimestamp = time;
          const timestamp = time * 1e3 + timestampCount;
          if (clockid === null) {
            clockid = Math.floor(Math.random() * 32);
          }
          const tid = TID.fromTime(timestamp, clockid);
          if (!prev || tid.newerThan(prev)) {
            return tid;
          }
          return TID.fromTime(prev.timestamp() + 1, clockid);
        }
        static nextStr(prev) {
          return TID.next(prev ? new TID(prev) : void 0).toString();
        }
        static fromTime(timestamp, clockid2) {
          const str = `${s32encode(timestamp)}${s32encode(clockid2).padStart(2, "2")}`;
          return new TID(str);
        }
        static fromStr(str) {
          return new TID(str);
        }
        static oldestFirst(a, b) {
          return a.compareTo(b);
        }
        static newestFirst(a, b) {
          return b.compareTo(a);
        }
        static is(str) {
          return dedash(str).length === TID_LEN;
        }
        timestamp() {
          return s32decode(this.str.slice(0, 11));
        }
        clockid() {
          return s32decode(this.str.slice(11, 13));
        }
        formatted() {
          const str = this.toString();
          return `${str.slice(0, 4)}-${str.slice(4, 7)}-${str.slice(7, 11)}-${str.slice(11, 13)}`;
        }
        toString() {
          return this.str;
        }
        compareTo(other) {
          if (this.str > other.str)
            return 1;
          if (this.str < other.str)
            return -1;
          return 0;
        }
        equals(other) {
          return this.str === other.str;
        }
        newerThan(other) {
          return this.compareTo(other) > 0;
        }
        olderThan(other) {
          return this.compareTo(other) < 0;
        }
      };
      var encode_1 = encode;
      var MSB = 128;
      var REST = 127;
      var MSBALL = ~REST;
      var INT = Math.pow(2, 31);
      function encode(num, out, offset) {
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT) {
          out[offset++] = num & 255 | MSB;
          num /= 128;
        }
        while (num & MSBALL) {
          out[offset++] = num & 255 | MSB;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode.bytes = offset - oldOffset + 1;
        return out;
      }
      var decode = read;
      var MSB$1 = 128;
      var REST$1 = 127;
      function read(buf2, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
        do {
          if (counter >= l) {
            read.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf2[counter++];
          res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB$1);
        read.bytes = counter - offset;
        return res;
      }
      var N1 = Math.pow(2, 7);
      var N2 = Math.pow(2, 14);
      var N3 = Math.pow(2, 21);
      var N4 = Math.pow(2, 28);
      var N5 = Math.pow(2, 35);
      var N6 = Math.pow(2, 42);
      var N7 = Math.pow(2, 49);
      var N8 = Math.pow(2, 56);
      var N9 = Math.pow(2, 63);
      var length = function(value) {
        return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
      };
      var varint = {
        encode: encode_1,
        decode,
        encodingLength: length
      };
      var _brrp_varint = varint;
      var varint_default = _brrp_varint;
      var decode2 = (data, offset = 0) => {
        const code4 = varint_default.decode(data, offset);
        return [
          code4,
          varint_default.decode.bytes
        ];
      };
      var encodeTo = (int, target2, offset = 0) => {
        varint_default.encode(int, target2, offset);
        return target2;
      };
      var encodingLength = (int) => {
        return varint_default.encodingLength(int);
      };
      var empty = new Uint8Array(0);
      var equals = (aa, bb) => {
        if (aa === bb)
          return true;
        if (aa.byteLength !== bb.byteLength) {
          return false;
        }
        for (let ii = 0; ii < aa.byteLength; ii++) {
          if (aa[ii] !== bb[ii]) {
            return false;
          }
        }
        return true;
      };
      var coerce2 = (o) => {
        if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
          return o;
        if (o instanceof ArrayBuffer)
          return new Uint8Array(o);
        if (ArrayBuffer.isView(o)) {
          return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
        }
        throw new Error("Unknown type, must be binary type");
      };
      var fromString = (str) => new TextEncoder().encode(str);
      var toString = (b) => new TextDecoder().decode(b);
      var create = (code4, digest2) => {
        const size = digest2.byteLength;
        const sizeOffset = encodingLength(code4);
        const digestOffset = sizeOffset + encodingLength(size);
        const bytes3 = new Uint8Array(digestOffset + size);
        encodeTo(code4, bytes3, 0);
        encodeTo(size, bytes3, sizeOffset);
        bytes3.set(digest2, digestOffset);
        return new Digest(code4, size, digest2, bytes3);
      };
      var decode3 = (multihash) => {
        const bytes3 = coerce2(multihash);
        const [code4, sizeOffset] = decode2(bytes3);
        const [size, digestOffset] = decode2(bytes3.subarray(sizeOffset));
        const digest2 = bytes3.subarray(sizeOffset + digestOffset);
        if (digest2.byteLength !== size) {
          throw new Error("Incorrect length");
        }
        return new Digest(code4, size, digest2, bytes3);
      };
      var equals2 = (a, b) => {
        if (a === b) {
          return true;
        } else {
          return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
        }
      };
      var Digest = class {
        constructor(code4, size, digest2, bytes3) {
          this.code = code4;
          this.size = size;
          this.digest = digest2;
          this.bytes = bytes3;
        }
      };
      var base58_exports = {};
      __export(base58_exports, {
        base58btc: () => base58btc,
        base58flickr: () => base58flickr
      });
      function base(ALPHABET, name3) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode9(source) {
          if (source instanceof Uint8Array)
            ;
          else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length2 = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length2 = i2;
            pbegin++;
          }
          var it2 = size - length2;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          var psz = 0;
          if (source[psz] === " ") {
            return;
          }
          var zeroes = 0;
          var length2 = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length2 = i2;
            psz++;
          }
          if (source[psz] === " ") {
            return;
          }
          var it4 = size - length2;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = new Uint8Array(zeroes + (size - it4));
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode9(string3) {
          var buffer2 = decodeUnsafe(string3);
          if (buffer2) {
            return buffer2;
          }
          throw new Error(`Non-${name3} character`);
        }
        return {
          encode: encode9,
          decodeUnsafe,
          decode: decode9
        };
      }
      var src = base;
      var _brrp__multiformats_scope_baseX = src;
      var base_x_default = _brrp__multiformats_scope_baseX;
      var Encoder = class {
        constructor(name3, prefix, baseEncode) {
          this.name = name3;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes3) {
          if (bytes3 instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes3)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      var Decoder = class {
        constructor(name3, prefix, baseDecode) {
          this.name = name3;
          this.prefix = prefix;
          if (prefix.codePointAt(0) === void 0) {
            throw new Error("Invalid prefix character");
          }
          this.prefixCodePoint = prefix.codePointAt(0);
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder2) {
          return or(this, decoder2);
        }
      };
      var ComposedDecoder = class {
        constructor(decoders) {
          this.decoders = decoders;
        }
        or(decoder2) {
          return or(this, decoder2);
        }
        decode(input) {
          const prefix = input[0];
          const decoder2 = this.decoders[prefix];
          if (decoder2) {
            return decoder2.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      var or = (left, right) => new ComposedDecoder(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
      var Codec = class {
        constructor(name3, prefix, baseEncode, baseDecode) {
          this.name = name3;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder(name3, prefix, baseEncode);
          this.decoder = new Decoder(name3, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
      var from = ({ name: name3, prefix, encode: encode9, decode: decode9 }) => new Codec(name3, prefix, encode9, decode9);
      var baseX = ({ prefix, name: name3, alphabet: alphabet2 }) => {
        const { encode: encode9, decode: decode9 } = base_x_default(alphabet2, name3);
        return from({
          prefix,
          name: name3,
          encode: encode9,
          decode: (text) => coerce2(decode9(text))
        });
      };
      var decode4 = (string3, alphabet2, bitsPerChar, name3) => {
        const codes = {};
        for (let i = 0; i < alphabet2.length; ++i) {
          codes[alphabet2[i]] = i;
        }
        let end = string3.length;
        while (string3[end - 1] === "=") {
          --end;
        }
        const out = new Uint8Array(end * bitsPerChar / 8 | 0);
        let bits = 0;
        let buffer2 = 0;
        let written = 0;
        for (let i = 0; i < end; ++i) {
          const value = codes[string3[i]];
          if (value === void 0) {
            throw new SyntaxError(`Non-${name3} character`);
          }
          buffer2 = buffer2 << bitsPerChar | value;
          bits += bitsPerChar;
          if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer2 >> bits;
          }
        }
        if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
          throw new SyntaxError("Unexpected end of data");
        }
        return out;
      };
      var encode2 = (data, alphabet2, bitsPerChar) => {
        const pad = alphabet2[alphabet2.length - 1] === "=";
        const mask = (1 << bitsPerChar) - 1;
        let out = "";
        let bits = 0;
        let buffer2 = 0;
        for (let i = 0; i < data.length; ++i) {
          buffer2 = buffer2 << 8 | data[i];
          bits += 8;
          while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet2[mask & buffer2 >> bits];
          }
        }
        if (bits) {
          out += alphabet2[mask & buffer2 << bitsPerChar - bits];
        }
        if (pad) {
          while (out.length * bitsPerChar & 7) {
            out += "=";
          }
        }
        return out;
      };
      var rfc4648 = ({ name: name3, prefix, bitsPerChar, alphabet: alphabet2 }) => {
        return from({
          prefix,
          name: name3,
          encode(input) {
            return encode2(input, alphabet2, bitsPerChar);
          },
          decode(input) {
            return decode4(input, alphabet2, bitsPerChar, name3);
          }
        });
      };
      var base58btc = baseX({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      var base58flickr = baseX({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
      var base32_exports = {};
      __export(base32_exports, {
        base32: () => base32,
        base32hex: () => base32hex,
        base32hexpad: () => base32hexpad,
        base32hexpadupper: () => base32hexpadupper,
        base32hexupper: () => base32hexupper,
        base32pad: () => base32pad,
        base32padupper: () => base32padupper,
        base32upper: () => base32upper,
        base32z: () => base32z
      });
      var base32 = rfc4648({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      });
      var base32upper = rfc4648({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      });
      var base32pad = rfc4648({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      });
      var base32padupper = rfc4648({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      });
      var base32hex = rfc4648({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      });
      var base32hexupper = rfc4648({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      });
      var base32hexpad = rfc4648({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      });
      var base32hexpadupper = rfc4648({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      });
      var base32z = rfc4648({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
      var CID = class {
        constructor(version2, code4, multihash, bytes3) {
          this.code = code4;
          this.version = version2;
          this.multihash = multihash;
          this.bytes = bytes3;
          this.byteOffset = bytes3.byteOffset;
          this.byteLength = bytes3.byteLength;
          this.asCID = this;
          this._baseCache = /* @__PURE__ */ new Map();
          Object.defineProperties(this, {
            byteOffset: hidden,
            byteLength: hidden,
            code: readonly,
            version: readonly,
            multihash: readonly,
            bytes: readonly,
            _baseCache: hidden,
            asCID: hidden
          });
        }
        toV0() {
          switch (this.version) {
            case 0: {
              return this;
            }
            default: {
              const { code: code4, multihash } = this;
              if (code4 !== DAG_PB_CODE) {
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              }
              if (multihash.code !== SHA_256_CODE) {
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              }
              return CID.createV0(multihash);
            }
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              const { code: code4, digest: digest2 } = this.multihash;
              const multihash = create(code4, digest2);
              return CID.createV1(this.code, multihash);
            }
            case 1: {
              return this;
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
          }
        }
        equals(other) {
          return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
        }
        toString(base3) {
          const { bytes: bytes3, version: version2, _baseCache } = this;
          switch (version2) {
            case 0:
              return toStringV0(bytes3, _baseCache, base3 || base58btc.encoder);
            default:
              return toStringV1(bytes3, _baseCache, base3 || base32.encoder);
          }
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(value) {
          deprecate(/^0\.0/, IS_CID_DEPRECATION);
          return !!(value && (value[cidSymbol] || value.asCID === value));
        }
        get toBaseEncodedString() {
          throw new Error("Deprecated, use .toString()");
        }
        get codec() {
          throw new Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
        }
        get multibaseName() {
          throw new Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw new Error('"prefix" property is deprecated');
        }
        static asCID(value) {
          if (value instanceof CID) {
            return value;
          } else if (value != null && value.asCID === value) {
            const { version: version2, code: code4, multihash, bytes: bytes3 } = value;
            return new CID(version2, code4, multihash, bytes3 || encodeCID(version2, code4, multihash.bytes));
          } else if (value != null && value[cidSymbol] === true) {
            const { version: version2, multihash, code: code4 } = value;
            const digest2 = decode3(multihash);
            return CID.create(version2, code4, digest2);
          } else {
            return null;
          }
        }
        static create(version2, code4, digest2) {
          if (typeof code4 !== "number") {
            throw new Error("String codecs are no longer supported");
          }
          switch (version2) {
            case 0: {
              if (code4 !== DAG_PB_CODE) {
                throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
              } else {
                return new CID(version2, code4, digest2, digest2.bytes);
              }
            }
            case 1: {
              const bytes3 = encodeCID(version2, code4, digest2.bytes);
              return new CID(version2, code4, digest2, bytes3);
            }
            default: {
              throw new Error("Invalid version");
            }
          }
        }
        static createV0(digest2) {
          return CID.create(0, DAG_PB_CODE, digest2);
        }
        static createV1(code4, digest2) {
          return CID.create(1, code4, digest2);
        }
        static decode(bytes3) {
          const [cid2, remainder] = CID.decodeFirst(bytes3);
          if (remainder.length) {
            throw new Error("Incorrect length");
          }
          return cid2;
        }
        static decodeFirst(bytes3) {
          const specs = CID.inspectBytes(bytes3);
          const prefixSize = specs.size - specs.multihashSize;
          const multihashBytes = coerce2(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
          if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
          }
          const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
          const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
          const cid2 = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
          return [
            cid2,
            bytes3.subarray(specs.size)
          ];
        }
        static inspectBytes(initialBytes) {
          let offset = 0;
          const next = () => {
            const [i, length2] = decode2(initialBytes.subarray(offset));
            offset += length2;
            return i;
          };
          let version2 = next();
          let codec = DAG_PB_CODE;
          if (version2 === 18) {
            version2 = 0;
            offset = 0;
          } else if (version2 === 1) {
            codec = next();
          }
          if (version2 !== 0 && version2 !== 1) {
            throw new RangeError(`Invalid CID version ${version2}`);
          }
          const prefixSize = offset;
          const multihashCode = next();
          const digestSize = next();
          const size = offset + digestSize;
          const multihashSize = size - prefixSize;
          return {
            version: version2,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
          };
        }
        static parse(source, base3) {
          const [prefix, bytes3] = parseCIDtoBytes(source, base3);
          const cid2 = CID.decode(bytes3);
          cid2._baseCache.set(prefix, source);
          return cid2;
        }
      };
      var parseCIDtoBytes = (source, base3) => {
        switch (source[0]) {
          case "Q": {
            const decoder2 = base3 || base58btc;
            return [
              base58btc.prefix,
              decoder2.decode(`${base58btc.prefix}${source}`)
            ];
          }
          case base58btc.prefix: {
            const decoder2 = base3 || base58btc;
            return [
              base58btc.prefix,
              decoder2.decode(source)
            ];
          }
          case base32.prefix: {
            const decoder2 = base3 || base32;
            return [
              base32.prefix,
              decoder2.decode(source)
            ];
          }
          default: {
            if (base3 == null) {
              throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            }
            return [
              source[0],
              base3.decode(source)
            ];
          }
        }
      };
      var toStringV0 = (bytes3, cache, base3) => {
        const { prefix } = base3;
        if (prefix !== base58btc.prefix) {
          throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
        }
        const cid2 = cache.get(prefix);
        if (cid2 == null) {
          const cid3 = base3.encode(bytes3).slice(1);
          cache.set(prefix, cid3);
          return cid3;
        } else {
          return cid2;
        }
      };
      var toStringV1 = (bytes3, cache, base3) => {
        const { prefix } = base3;
        const cid2 = cache.get(prefix);
        if (cid2 == null) {
          const cid3 = base3.encode(bytes3);
          cache.set(prefix, cid3);
          return cid3;
        } else {
          return cid2;
        }
      };
      var DAG_PB_CODE = 112;
      var SHA_256_CODE = 18;
      var encodeCID = (version2, code4, multihash) => {
        const codeOffset = encodingLength(version2);
        const hashOffset = codeOffset + encodingLength(code4);
        const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
        encodeTo(version2, bytes3, 0);
        encodeTo(code4, bytes3, codeOffset);
        bytes3.set(multihash, hashOffset);
        return bytes3;
      };
      var cidSymbol = Symbol.for("@ipld/js-cid/CID");
      var readonly = {
        writable: false,
        configurable: false,
        enumerable: true
      };
      var hidden = {
        writable: false,
        enumerable: false,
        configurable: false
      };
      var version = "0.0.0-dev";
      var deprecate = (range, message) => {
        if (range.test(version)) {
          console.warn(message);
        } else {
          throw new Error(message);
        }
      };
      var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
      function equals3(a, b) {
        if (a === b) {
          return true;
        }
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        for (let i = 0; i < a.byteLength; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      var identity_exports = {};
      __export(identity_exports, {
        identity: () => identity
      });
      var identity = from({
        prefix: "\0",
        name: "identity",
        encode: (buf2) => toString(buf2),
        decode: (str) => fromString(str)
      });
      var base2_exports = {};
      __export(base2_exports, {
        base2: () => base2
      });
      var base2 = rfc4648({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
      });
      var base8_exports = {};
      __export(base8_exports, {
        base8: () => base8
      });
      var base8 = rfc4648({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
      });
      var base10_exports = {};
      __export(base10_exports, {
        base10: () => base10
      });
      var base10 = baseX({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
      });
      var base16_exports = {};
      __export(base16_exports, {
        base16: () => base16,
        base16upper: () => base16upper
      });
      var base16 = rfc4648({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
      });
      var base16upper = rfc4648({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      });
      var base36_exports = {};
      __export(base36_exports, {
        base36: () => base36,
        base36upper: () => base36upper
      });
      var base36 = baseX({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
      });
      var base36upper = baseX({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      });
      var base64_exports = {};
      __export(base64_exports, {
        base64: () => base64,
        base64pad: () => base64pad,
        base64url: () => base64url,
        base64urlpad: () => base64urlpad
      });
      var base64 = rfc4648({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
      });
      var base64pad = rfc4648({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      });
      var base64url = rfc4648({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      });
      var base64urlpad = rfc4648({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      });
      var base256emoji_exports = {};
      __export(base256emoji_exports, {
        base256emoji: () => base256emoji
      });
      var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
      var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
        p[i] = c;
        return p;
      }, []);
      var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
        p[c.codePointAt(0)] = i;
        return p;
      }, []);
      function encode3(data) {
        return data.reduce((p, c) => {
          p += alphabetBytesToChars[c];
          return p;
        }, "");
      }
      function decode5(str) {
        const byts = [];
        for (const char of str) {
          const byt = alphabetCharsToBytes[char.codePointAt(0)];
          if (byt === void 0) {
            throw new Error(`Non-base256emoji character: ${char}`);
          }
          byts.push(byt);
        }
        return new Uint8Array(byts);
      }
      var base256emoji = from({
        prefix: "\u{1F680}",
        name: "base256emoji",
        encode: encode3,
        decode: decode5
      });
      var sha2_exports = {};
      __export(sha2_exports, {
        sha256: () => sha256,
        sha512: () => sha512
      });
      var import_crypto = __toESM2(__require("crypto"), 1);
      var from2 = ({ name: name3, code: code4, encode: encode9 }) => new Hasher(name3, code4, encode9);
      var Hasher = class {
        constructor(name3, code4, encode9) {
          this.name = name3;
          this.code = code4;
          this.encode = encode9;
        }
        digest(input) {
          if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      var sha256 = from2({
        name: "sha2-256",
        code: 18,
        encode: (input) => coerce2(import_crypto.default.createHash("sha256").update(input).digest())
      });
      var sha512 = from2({
        name: "sha2-512",
        code: 19,
        encode: (input) => coerce2(import_crypto.default.createHash("sha512").update(input).digest())
      });
      var identity_exports2 = {};
      __export(identity_exports2, {
        identity: () => identity2
      });
      var code = 0;
      var name = "identity";
      var encode4 = coerce2;
      var digest = (input) => create(code, encode4(input));
      var identity2 = {
        code,
        name,
        encode: encode4,
        digest
      };
      var textEncoder = new TextEncoder();
      var textDecoder = new TextDecoder();
      var bases = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity_exports), base2_exports), base8_exports), base10_exports), base16_exports), base32_exports), base36_exports), base58_exports), base64_exports), base256emoji_exports);
      var hashes = __spreadValues(__spreadValues({}, sha2_exports), identity_exports2);
      function createCodec(name3, prefix, encode9, decode9) {
        return {
          name: name3,
          prefix,
          encoder: {
            name: name3,
            prefix,
            encode: encode9
          },
          decoder: { decode: decode9 }
        };
      }
      var string = createCodec("utf8", "u", (buf2) => {
        const decoder2 = new TextDecoder("utf8");
        return "u" + decoder2.decode(buf2);
      }, (str) => {
        const encoder = new TextEncoder();
        return encoder.encode(str.substring(1));
      });
      var ascii = createCodec("ascii", "a", (buf2) => {
        let string3 = "a";
        for (let i = 0; i < buf2.length; i++) {
          string3 += String.fromCharCode(buf2[i]);
        }
        return string3;
      }, (str) => {
        str = str.substring(1);
        const buf2 = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          buf2[i] = str.charCodeAt(i);
        }
        return buf2;
      });
      var BASES = __spreadValues({
        utf8: string,
        "utf-8": string,
        hex: bases.base16,
        latin1: ascii,
        ascii,
        binary: ascii
      }, bases);
      var bases_default = BASES;
      function fromString2(string3, encoding = "utf8") {
        const base3 = bases_default[encoding];
        if (!base3) {
          throw new Error(`Unsupported encoding "${encoding}"`);
        }
        return base3.decoder.decode(`${base3.prefix}${string3}`);
      }
      function toString2(array2, encoding = "utf8") {
        const base3 = bases_default[encoding];
        if (!base3) {
          throw new Error(`Unsupported encoding "${encoding}"`);
        }
        return base3.encoder.encode(array2).substring(1);
      }
      var ipldToJson = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => ipldToJson(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof Uint8Array) {
            return {
              $bytes: toString2(val, "base64")
            };
          }
          if (CID.asCID(val)) {
            return {
              $link: val.toString()
            };
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = ipldToJson(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var cidSchema = z.any().refine((obj) => CID.asCID(obj) !== null, {
        message: "Not a CID"
      }).transform((obj) => CID.asCID(obj));
      var schema = {
        cid: cidSchema,
        bytes: z.instanceof(Uint8Array),
        string: z.string(),
        array: z.array(z.unknown()),
        map: z.record(z.string(), z.unknown()),
        unknown: z.unknown()
      };
      var def = {
        cid: {
          name: "cid",
          schema: schema.cid
        },
        bytes: {
          name: "bytes",
          schema: schema.bytes
        },
        string: {
          name: "string",
          schema: schema.string
        },
        map: {
          name: "map",
          schema: schema.map
        },
        unknown: {
          name: "unknown",
          schema: schema.unknown
        }
      };
      var SECOND = 1e3;
      var MINUTE = SECOND * 60;
      var HOUR = MINUTE * 60;
      var DAY = HOUR * 24;
      var import_graphemer = __toESM2(require_lib());
      var verificationMethod = z.object({
        id: z.string(),
        type: z.string(),
        controller: z.string(),
        publicKeyMultibase: z.string().optional()
      });
      var service = z.object({
        id: z.string(),
        type: z.string(),
        serviceEndpoint: z.union([z.string(), z.record(z.unknown())])
      });
      var didDocument = z.object({
        id: z.string(),
        alsoKnownAs: z.array(z.string()).optional(),
        verificationMethod: z.array(verificationMethod).optional(),
        service: z.array(service).optional()
      });
      var import_iso_datestring_validator = __toESM2(require_dist3());
      var typedJsonBlobRef = z.object({
        $type: z.literal("blob"),
        ref: schema.cid,
        mimeType: z.string(),
        size: z.number()
      }).strict();
      var untypedJsonBlobRef = z.object({
        cid: z.string(),
        mimeType: z.string()
      }).strict();
      var jsonBlobRef = z.union([typedJsonBlobRef, untypedJsonBlobRef]);
      var BlobRef = class {
        constructor(ref, mimeType, size, original) {
          this.ref = ref;
          this.mimeType = mimeType;
          this.size = size;
          this.original = original != null ? original : {
            $type: "blob",
            ref,
            mimeType,
            size
          };
        }
        static asBlobRef(obj) {
          if (check_exports.is(obj, jsonBlobRef)) {
            return BlobRef.fromJsonRef(obj);
          }
          return null;
        }
        static fromJsonRef(json) {
          if (check_exports.is(json, typedJsonBlobRef)) {
            return new BlobRef(json.ref, json.mimeType, json.size);
          } else {
            return new BlobRef(CID.parse(json.cid), json.mimeType, -1, json);
          }
        }
        ipld() {
          return {
            $type: "blob",
            ref: this.ref,
            mimeType: this.mimeType,
            size: this.size
          };
        }
        toJSON() {
          return ipldToJson(this.ipld());
        }
      };
      function requiredPropertiesRefinement(object2, ctx) {
        if (object2.required === void 0) {
          return;
        }
        if (!Array.isArray(object2.required)) {
          ctx.addIssue({
            code: z.ZodIssueCode.invalid_type,
            received: typeof object2.required,
            expected: "array"
          });
          return;
        }
        if (object2.properties === void 0) {
          if (object2.required.length > 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Required fields defined but no properties defined`
            });
          }
          return;
        }
        for (const field of object2.required) {
          if (object2.properties[field] === void 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Required field "${field}" not defined`
            });
          }
        }
      }
      var lexBoolean = z.object({
        type: z.literal("boolean"),
        description: z.string().optional(),
        default: z.boolean().optional(),
        const: z.boolean().optional()
      }).strict();
      var lexInteger = z.object({
        type: z.literal("integer"),
        description: z.string().optional(),
        default: z.number().int().optional(),
        minimum: z.number().int().optional(),
        maximum: z.number().int().optional(),
        enum: z.number().int().array().optional(),
        const: z.number().int().optional()
      }).strict();
      var lexStringFormat = z.enum([
        "datetime",
        "uri",
        "at-uri",
        "did",
        "handle",
        "at-identifier",
        "nsid",
        "cid",
        "language"
      ]);
      var lexString = z.object({
        type: z.literal("string"),
        format: lexStringFormat.optional(),
        description: z.string().optional(),
        default: z.string().optional(),
        minLength: z.number().int().optional(),
        maxLength: z.number().int().optional(),
        minGraphemes: z.number().int().optional(),
        maxGraphemes: z.number().int().optional(),
        enum: z.string().array().optional(),
        const: z.string().optional(),
        knownValues: z.string().array().optional()
      }).strict();
      var lexUnknown = z.object({
        type: z.literal("unknown"),
        description: z.string().optional()
      }).strict();
      var lexPrimitive = z.discriminatedUnion("type", [
        lexBoolean,
        lexInteger,
        lexString,
        lexUnknown
      ]);
      var lexBytes = z.object({
        type: z.literal("bytes"),
        description: z.string().optional(),
        maxLength: z.number().optional(),
        minLength: z.number().optional()
      }).strict();
      var lexCidLink = z.object({
        type: z.literal("cid-link"),
        description: z.string().optional()
      }).strict();
      var lexIpldType = z.discriminatedUnion("type", [lexBytes, lexCidLink]);
      var lexRef = z.object({
        type: z.literal("ref"),
        description: z.string().optional(),
        ref: z.string()
      }).strict();
      var lexRefUnion = z.object({
        type: z.literal("union"),
        description: z.string().optional(),
        refs: z.string().array(),
        closed: z.boolean().optional()
      }).strict();
      var lexRefVariant = z.discriminatedUnion("type", [lexRef, lexRefUnion]);
      var lexBlob = z.object({
        type: z.literal("blob"),
        description: z.string().optional(),
        accept: z.string().array().optional(),
        maxSize: z.number().optional()
      }).strict();
      var lexArray = z.object({
        type: z.literal("array"),
        description: z.string().optional(),
        items: z.union([lexPrimitive, lexIpldType, lexBlob, lexRefVariant]),
        minLength: z.number().int().optional(),
        maxLength: z.number().int().optional()
      }).strict();
      var lexPrimitiveArray = lexArray.merge(z.object({
        items: lexPrimitive
      }).strict());
      var lexToken = z.object({
        type: z.literal("token"),
        description: z.string().optional()
      }).strict();
      var lexObject = z.object({
        type: z.literal("object"),
        description: z.string().optional(),
        required: z.string().array().optional(),
        nullable: z.string().array().optional(),
        properties: z.record(z.union([lexRefVariant, lexIpldType, lexArray, lexBlob, lexPrimitive]))
      }).strict().superRefine(requiredPropertiesRefinement);
      var lexXrpcParameters = z.object({
        type: z.literal("params"),
        description: z.string().optional(),
        required: z.string().array().optional(),
        properties: z.record(z.union([lexPrimitive, lexPrimitiveArray]))
      }).strict().superRefine(requiredPropertiesRefinement);
      var lexXrpcBody = z.object({
        description: z.string().optional(),
        encoding: z.string(),
        schema: z.union([lexRefVariant, lexObject]).optional()
      }).strict();
      var lexXrpcSubscriptionMessage = z.object({
        description: z.string().optional(),
        schema: z.union([lexRefVariant, lexObject]).optional()
      }).strict();
      var lexXrpcError = z.object({
        name: z.string(),
        description: z.string().optional()
      }).strict();
      var lexXrpcQuery = z.object({
        type: z.literal("query"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        output: lexXrpcBody.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexXrpcProcedure = z.object({
        type: z.literal("procedure"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        input: lexXrpcBody.optional(),
        output: lexXrpcBody.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexXrpcSubscription = z.object({
        type: z.literal("subscription"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        message: lexXrpcSubscriptionMessage.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexRecord = z.object({
        type: z.literal("record"),
        description: z.string().optional(),
        key: z.string().optional(),
        record: lexObject
      }).strict();
      var lexUserType = z.custom((val) => {
        if (!val || typeof val !== "object") {
          return;
        }
        if (val["type"] === void 0) {
          return;
        }
        switch (val["type"]) {
          case "record":
            return lexRecord.parse(val);
          case "query":
            return lexXrpcQuery.parse(val);
          case "procedure":
            return lexXrpcProcedure.parse(val);
          case "subscription":
            return lexXrpcSubscription.parse(val);
          case "blob":
            return lexBlob.parse(val);
          case "array":
            return lexArray.parse(val);
          case "token":
            return lexToken.parse(val);
          case "object":
            return lexObject.parse(val);
          case "boolean":
            return lexBoolean.parse(val);
          case "integer":
            return lexInteger.parse(val);
          case "string":
            return lexString.parse(val);
          case "bytes":
            return lexBytes.parse(val);
          case "cid-link":
            return lexCidLink.parse(val);
          case "unknown":
            return lexUnknown.parse(val);
        }
      }, (val) => {
        if (!val || typeof val !== "object") {
          return {
            message: "Must be an object",
            fatal: true
          };
        }
        if (val["type"] === void 0) {
          return {
            message: "Must have a type",
            fatal: true
          };
        }
        return {
          message: `Invalid type: ${val["type"]} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
          fatal: true
        };
      });
      var lexiconDoc = z.object({
        lexicon: z.literal(1),
        id: z.string().refine((v) => NSID.isValid(v), {
          message: "Must be a valid NSID"
        }),
        revision: z.number().optional(),
        description: z.string().optional(),
        defs: z.record(lexUserType)
      }).strict().superRefine((doc, ctx) => {
        for (const defId in doc.defs) {
          const def3 = doc.defs[defId];
          if (defId !== "main" && (def3.type === "record" || def3.type === "procedure" || def3.type === "query" || def3.type === "subscription")) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Records, procedures, queries, and subscriptions must be the main definition.`
            });
          }
        }
      });
      var discriminatedObject = z.object({ $type: z.string() });
      var lexToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => lexToIpld(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof BlobRef) {
            return val.original;
          }
          if (CID.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = lexToIpld(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var ipldToLex = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => ipldToLex(item));
        }
        if (val && typeof val === "object") {
          if ((val["$type"] === "blob" || typeof val["cid"] === "string" && typeof val["mimeType"] === "string") && check_exports.is(val, jsonBlobRef)) {
            return BlobRef.fromJsonRef(val);
          }
          if (CID.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = ipldToLex(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var import_iso_datestring_validator2 = __toESM2(require_dist3());
      var readonly2 = ({ enumerable = true, configurable = false } = {}) => ({
        enumerable,
        configurable,
        writable: false
      });
      var links = function* (source, base3) {
        if (source == null)
          return;
        if (source instanceof Uint8Array)
          return;
        for (const [key, value] of Object.entries(source)) {
          const path = [
            ...base3,
            key
          ];
          if (value != null && typeof value === "object") {
            if (Array.isArray(value)) {
              for (const [index, element] of value.entries()) {
                const elementPath = [
                  ...path,
                  index
                ];
                const cid2 = CID.asCID(element);
                if (cid2) {
                  yield [
                    elementPath.join("/"),
                    cid2
                  ];
                } else if (typeof element === "object") {
                  yield* __yieldStar(links(element, elementPath));
                }
              }
            } else {
              const cid2 = CID.asCID(value);
              if (cid2) {
                yield [
                  path.join("/"),
                  cid2
                ];
              } else {
                yield* __yieldStar(links(value, path));
              }
            }
          }
        }
      };
      var tree = function* (source, base3) {
        if (source == null)
          return;
        for (const [key, value] of Object.entries(source)) {
          const path = [
            ...base3,
            key
          ];
          yield path.join("/");
          if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
            if (Array.isArray(value)) {
              for (const [index, element] of value.entries()) {
                const elementPath = [
                  ...path,
                  index
                ];
                yield elementPath.join("/");
                if (typeof element === "object" && !CID.asCID(element)) {
                  yield* __yieldStar(tree(element, elementPath));
                }
              }
            } else {
              yield* __yieldStar(tree(value, path));
            }
          }
        }
      };
      var get = (source, path) => {
        let node = source;
        for (const [index, key] of path.entries()) {
          node = node[key];
          if (node == null) {
            throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
          }
          const cid2 = CID.asCID(node);
          if (cid2) {
            return {
              value: cid2,
              remaining: path.slice(index + 1).join("/")
            };
          }
        }
        return { value: node };
      };
      var Block = class {
        constructor({ cid: cid2, bytes: bytes3, value }) {
          if (!cid2 || !bytes3 || typeof value === "undefined")
            throw new Error("Missing required argument");
          this.cid = cid2;
          this.bytes = bytes3;
          this.value = value;
          this.asBlock = this;
          Object.defineProperties(this, {
            cid: readonly2(),
            bytes: readonly2(),
            value: readonly2(),
            asBlock: readonly2()
          });
        }
        links() {
          return links(this.value, []);
        }
        tree() {
          return tree(this.value, []);
        }
        get(path = "/") {
          return get(this.value, path.split("/").filter(Boolean));
        }
      };
      var encode5 = (_0) => __async(exports, [_0], function* ({ value, codec, hasher }) {
        if (typeof value === "undefined")
          throw new Error('Missing required argument "value"');
        if (!codec || !hasher)
          throw new Error("Missing required argument: codec or hasher");
        const bytes3 = codec.encode(value);
        const hash2 = yield hasher.digest(bytes3);
        const cid2 = CID.create(1, codec.code, hash2);
        return new Block({
          value,
          bytes: bytes3,
          cid: cid2
        });
      });
      var esm_exports = {};
      __export(esm_exports, {
        code: () => code2,
        decode: () => decode7,
        encode: () => encode7,
        name: () => name2
      });
      var typeofs = [
        "string",
        "number",
        "bigint",
        "symbol"
      ];
      var objectTypeNames = [
        "Function",
        "Generator",
        "AsyncGenerator",
        "GeneratorFunction",
        "AsyncGeneratorFunction",
        "AsyncFunction",
        "Observable",
        "Array",
        "Buffer",
        "Object",
        "RegExp",
        "Date",
        "Error",
        "Map",
        "Set",
        "WeakMap",
        "WeakSet",
        "ArrayBuffer",
        "SharedArrayBuffer",
        "DataView",
        "Promise",
        "URL",
        "HTMLElement",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array"
      ];
      function is2(value) {
        if (value === null) {
          return "null";
        }
        if (value === void 0) {
          return "undefined";
        }
        if (value === true || value === false) {
          return "boolean";
        }
        const typeOf = typeof value;
        if (typeofs.includes(typeOf)) {
          return typeOf;
        }
        if (typeOf === "function") {
          return "Function";
        }
        if (Array.isArray(value)) {
          return "Array";
        }
        if (isBuffer(value)) {
          return "Buffer";
        }
        const objectType2 = getObjectType(value);
        if (objectType2) {
          return objectType2;
        }
        return "Object";
      }
      function isBuffer(value) {
        return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
      }
      function getObjectType(value) {
        const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
        if (objectTypeNames.includes(objectTypeName)) {
          return objectTypeName;
        }
        return void 0;
      }
      var Type = class {
        constructor(major, name3, terminal) {
          this.major = major;
          this.majorEncoded = major << 5;
          this.name = name3;
          this.terminal = terminal;
        }
        toString() {
          return `Type[${this.major}].${this.name}`;
        }
        compare(typ) {
          return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
        }
      };
      Type.uint = new Type(0, "uint", true);
      Type.negint = new Type(1, "negint", true);
      Type.bytes = new Type(2, "bytes", true);
      Type.string = new Type(3, "string", true);
      Type.array = new Type(4, "array", false);
      Type.map = new Type(5, "map", false);
      Type.tag = new Type(6, "tag", false);
      Type.float = new Type(7, "float", true);
      Type.false = new Type(7, "false", true);
      Type.true = new Type(7, "true", true);
      Type.null = new Type(7, "null", true);
      Type.undefined = new Type(7, "undefined", true);
      Type.break = new Type(7, "break", true);
      var Token = class {
        constructor(type, value, encodedLength) {
          this.type = type;
          this.value = value;
          this.encodedLength = encodedLength;
          this.encodedBytes = void 0;
          this.byteValue = void 0;
        }
        toString() {
          return `Token[${this.type}].${this.value}`;
        }
      };
      var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
      var textDecoder2 = new TextDecoder();
      var textEncoder2 = new TextEncoder();
      function isBuffer2(buf2) {
        return useBuffer && globalThis.Buffer.isBuffer(buf2);
      }
      function asU8A(buf2) {
        if (!(buf2 instanceof Uint8Array)) {
          return Uint8Array.from(buf2);
        }
        return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
      }
      var toString3 = useBuffer ? (bytes3, start, end) => {
        return end - start > 64 ? globalThis.Buffer.from(bytes3.subarray(start, end)).toString("utf8") : utf8Slice(bytes3, start, end);
      } : (bytes3, start, end) => {
        return end - start > 64 ? textDecoder2.decode(bytes3.subarray(start, end)) : utf8Slice(bytes3, start, end);
      };
      var fromString3 = useBuffer ? (string3) => {
        return string3.length > 64 ? globalThis.Buffer.from(string3) : utf8ToBytes(string3);
      } : (string3) => {
        return string3.length > 64 ? textEncoder2.encode(string3) : utf8ToBytes(string3);
      };
      var fromArray = (arr) => {
        return Uint8Array.from(arr);
      };
      var slice = useBuffer ? (bytes3, start, end) => {
        if (isBuffer2(bytes3)) {
          return new Uint8Array(bytes3.subarray(start, end));
        }
        return bytes3.slice(start, end);
      } : (bytes3, start, end) => {
        return bytes3.slice(start, end);
      };
      var concat2 = useBuffer ? (chunks, length2) => {
        chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
        return asU8A(globalThis.Buffer.concat(chunks, length2));
      } : (chunks, length2) => {
        const out = new Uint8Array(length2);
        let off = 0;
        for (let b of chunks) {
          if (off + b.length > out.length) {
            b = b.subarray(0, out.length - off);
          }
          out.set(b, off);
          off += b.length;
        }
        return out;
      };
      var alloc = useBuffer ? (size) => {
        return globalThis.Buffer.allocUnsafe(size);
      } : (size) => {
        return new Uint8Array(size);
      };
      function compare2(b1, b2) {
        if (isBuffer2(b1) && isBuffer2(b2)) {
          return b1.compare(b2);
        }
        for (let i = 0; i < b1.length; i++) {
          if (b1[i] === b2[i]) {
            continue;
          }
          return b1[i] < b2[i] ? -1 : 1;
        }
        return 0;
      }
      function utf8ToBytes(string3, units = Infinity) {
        let codePoint;
        const length2 = string3.length;
        let leadSurrogate = null;
        const bytes3 = [];
        for (let i = 0; i < length2; ++i) {
          codePoint = string3.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes3.push(239, 191, 189);
                continue;
              } else if (i + 1 === length2) {
                if ((units -= 3) > -1)
                  bytes3.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes3.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes3.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes3;
      }
      function utf8Slice(buf2, offset, end) {
        const res = [];
        while (offset < end) {
          const firstByte = buf2[offset];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (offset + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf2[offset + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf2[offset + 1];
                thirdByte = buf2[offset + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf2[offset + 1];
                thirdByte = buf2[offset + 2];
                fourthByte = buf2[offset + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          offset += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      var defaultChunkSize = 256;
      var Bl = class {
        constructor(chunkSize = defaultChunkSize) {
          this.chunkSize = chunkSize;
          this.cursor = 0;
          this.maxCursor = -1;
          this.chunks = [];
          this._initReuseChunk = null;
        }
        reset() {
          this.cursor = 0;
          this.maxCursor = -1;
          if (this.chunks.length) {
            this.chunks = [];
          }
          if (this._initReuseChunk !== null) {
            this.chunks.push(this._initReuseChunk);
            this.maxCursor = this._initReuseChunk.length - 1;
          }
        }
        push(bytes3) {
          let topChunk = this.chunks[this.chunks.length - 1];
          const newMax = this.cursor + bytes3.length;
          if (newMax <= this.maxCursor + 1) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            topChunk.set(bytes3, chunkPos);
          } else {
            if (topChunk) {
              const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
              if (chunkPos < topChunk.length) {
                this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
                this.maxCursor = this.cursor - 1;
              }
            }
            if (bytes3.length < 64 && bytes3.length < this.chunkSize) {
              topChunk = alloc(this.chunkSize);
              this.chunks.push(topChunk);
              this.maxCursor += topChunk.length;
              if (this._initReuseChunk === null) {
                this._initReuseChunk = topChunk;
              }
              topChunk.set(bytes3, 0);
            } else {
              this.chunks.push(bytes3);
              this.maxCursor += bytes3.length;
            }
          }
          this.cursor += bytes3.length;
        }
        toBytes(reset = false) {
          let byts;
          if (this.chunks.length === 1) {
            const chunk = this.chunks[0];
            if (reset && this.cursor > chunk.length / 2) {
              byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
              this._initReuseChunk = null;
              this.chunks = [];
            } else {
              byts = slice(chunk, 0, this.cursor);
            }
          } else {
            byts = concat2(this.chunks, this.cursor);
          }
          if (reset) {
            this.reset();
          }
          return byts;
        }
      };
      var decodeErrPrefix = "CBOR decode error:";
      var encodeErrPrefix = "CBOR encode error:";
      var uintMinorPrefixBytes = [];
      uintMinorPrefixBytes[23] = 1;
      uintMinorPrefixBytes[24] = 2;
      uintMinorPrefixBytes[25] = 3;
      uintMinorPrefixBytes[26] = 5;
      uintMinorPrefixBytes[27] = 9;
      function assertEnoughData(data, pos, need) {
        if (data.length - pos < need) {
          throw new Error(`${decodeErrPrefix} not enough data for type`);
        }
      }
      var uintBoundaries = [
        24,
        256,
        65536,
        4294967296,
        BigInt("18446744073709551616")
      ];
      function readUint8(data, offset, options) {
        assertEnoughData(data, offset, 1);
        const value = data[offset];
        if (options.strict === true && value < uintBoundaries[0]) {
          throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
        }
        return value;
      }
      function readUint16(data, offset, options) {
        assertEnoughData(data, offset, 2);
        const value = data[offset] << 8 | data[offset + 1];
        if (options.strict === true && value < uintBoundaries[1]) {
          throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
        }
        return value;
      }
      function readUint32(data, offset, options) {
        assertEnoughData(data, offset, 4);
        const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
        if (options.strict === true && value < uintBoundaries[2]) {
          throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
        }
        return value;
      }
      function readUint64(data, offset, options) {
        assertEnoughData(data, offset, 8);
        const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
        const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
        const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
        if (options.strict === true && value < uintBoundaries[3]) {
          throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
        }
        if (value <= Number.MAX_SAFE_INTEGER) {
          return Number(value);
        }
        if (options.allowBigInt === true) {
          return value;
        }
        throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
      }
      function decodeUint8(data, pos, _minor, options) {
        return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
      }
      function decodeUint16(data, pos, _minor, options) {
        return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
      }
      function decodeUint32(data, pos, _minor, options) {
        return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
      }
      function decodeUint64(data, pos, _minor, options) {
        return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
      }
      function encodeUint(buf2, token) {
        return encodeUintValue(buf2, 0, token.value);
      }
      function encodeUintValue(buf2, major, uint) {
        if (uint < uintBoundaries[0]) {
          const nuint = Number(uint);
          buf2.push([major | nuint]);
        } else if (uint < uintBoundaries[1]) {
          const nuint = Number(uint);
          buf2.push([
            major | 24,
            nuint
          ]);
        } else if (uint < uintBoundaries[2]) {
          const nuint = Number(uint);
          buf2.push([
            major | 25,
            nuint >>> 8,
            nuint & 255
          ]);
        } else if (uint < uintBoundaries[3]) {
          const nuint = Number(uint);
          buf2.push([
            major | 26,
            nuint >>> 24 & 255,
            nuint >>> 16 & 255,
            nuint >>> 8 & 255,
            nuint & 255
          ]);
        } else {
          const buint = BigInt(uint);
          if (buint < uintBoundaries[4]) {
            const set = [
              major | 27,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ];
            let lo = Number(buint & BigInt(4294967295));
            let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
            set[8] = lo & 255;
            lo = lo >> 8;
            set[7] = lo & 255;
            lo = lo >> 8;
            set[6] = lo & 255;
            lo = lo >> 8;
            set[5] = lo & 255;
            set[4] = hi & 255;
            hi = hi >> 8;
            set[3] = hi & 255;
            hi = hi >> 8;
            set[2] = hi & 255;
            hi = hi >> 8;
            set[1] = hi & 255;
            buf2.push(set);
          } else {
            throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
          }
        }
      }
      encodeUint.encodedSize = function encodedSize(token) {
        return encodeUintValue.encodedSize(token.value);
      };
      encodeUintValue.encodedSize = function encodedSize2(uint) {
        if (uint < uintBoundaries[0]) {
          return 1;
        }
        if (uint < uintBoundaries[1]) {
          return 2;
        }
        if (uint < uintBoundaries[2]) {
          return 3;
        }
        if (uint < uintBoundaries[3]) {
          return 5;
        }
        return 9;
      };
      encodeUint.compareTokens = function compareTokens(tok1, tok2) {
        return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
      };
      function decodeNegint8(data, pos, _minor, options) {
        return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
      }
      function decodeNegint16(data, pos, _minor, options) {
        return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
      }
      function decodeNegint32(data, pos, _minor, options) {
        return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
      }
      var neg1b = BigInt(-1);
      var pos1b = BigInt(1);
      function decodeNegint64(data, pos, _minor, options) {
        const int = readUint64(data, pos + 1, options);
        if (typeof int !== "bigint") {
          const value = -1 - int;
          if (value >= Number.MIN_SAFE_INTEGER) {
            return new Token(Type.negint, value, 9);
          }
        }
        if (options.allowBigInt !== true) {
          throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
        }
        return new Token(Type.negint, neg1b - BigInt(int), 9);
      }
      function encodeNegint(buf2, token) {
        const negint = token.value;
        const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
        encodeUintValue(buf2, token.type.majorEncoded, unsigned);
      }
      encodeNegint.encodedSize = function encodedSize3(token) {
        const negint = token.value;
        const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
        if (unsigned < uintBoundaries[0]) {
          return 1;
        }
        if (unsigned < uintBoundaries[1]) {
          return 2;
        }
        if (unsigned < uintBoundaries[2]) {
          return 3;
        }
        if (unsigned < uintBoundaries[3]) {
          return 5;
        }
        return 9;
      };
      encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
        return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
      };
      function toToken(data, pos, prefix, length2) {
        assertEnoughData(data, pos, prefix + length2);
        const buf2 = slice(data, pos + prefix, pos + prefix + length2);
        return new Token(Type.bytes, buf2, prefix + length2);
      }
      function decodeBytesCompact(data, pos, minor, _options) {
        return toToken(data, pos, 1, minor);
      }
      function decodeBytes8(data, pos, _minor, options) {
        return toToken(data, pos, 2, readUint8(data, pos + 1, options));
      }
      function decodeBytes16(data, pos, _minor, options) {
        return toToken(data, pos, 3, readUint16(data, pos + 1, options));
      }
      function decodeBytes32(data, pos, _minor, options) {
        return toToken(data, pos, 5, readUint32(data, pos + 1, options));
      }
      function decodeBytes64(data, pos, _minor, options) {
        const l = readUint64(data, pos + 1, options);
        if (typeof l === "bigint") {
          throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
        }
        return toToken(data, pos, 9, l);
      }
      function tokenBytes(token) {
        if (token.encodedBytes === void 0) {
          token.encodedBytes = token.type === Type.string ? fromString3(token.value) : token.value;
        }
        return token.encodedBytes;
      }
      function encodeBytes(buf2, token) {
        const bytes3 = tokenBytes(token);
        encodeUintValue(buf2, token.type.majorEncoded, bytes3.length);
        buf2.push(bytes3);
      }
      encodeBytes.encodedSize = function encodedSize4(token) {
        const bytes3 = tokenBytes(token);
        return encodeUintValue.encodedSize(bytes3.length) + bytes3.length;
      };
      encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
        return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
      };
      function compareBytes(b1, b2) {
        return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
      }
      function toToken2(data, pos, prefix, length2, options) {
        const totLength = prefix + length2;
        assertEnoughData(data, pos, totLength);
        const tok = new Token(Type.string, toString3(data, pos + prefix, pos + totLength), totLength);
        if (options.retainStringBytes === true) {
          tok.byteValue = slice(data, pos + prefix, pos + totLength);
        }
        return tok;
      }
      function decodeStringCompact(data, pos, minor, options) {
        return toToken2(data, pos, 1, minor, options);
      }
      function decodeString8(data, pos, _minor, options) {
        return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
      }
      function decodeString16(data, pos, _minor, options) {
        return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
      }
      function decodeString32(data, pos, _minor, options) {
        return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
      }
      function decodeString64(data, pos, _minor, options) {
        const l = readUint64(data, pos + 1, options);
        if (typeof l === "bigint") {
          throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
        }
        return toToken2(data, pos, 9, l, options);
      }
      var encodeString = encodeBytes;
      function toToken3(_data, _pos, prefix, length2) {
        return new Token(Type.array, length2, prefix);
      }
      function decodeArrayCompact(data, pos, minor, _options) {
        return toToken3(data, pos, 1, minor);
      }
      function decodeArray8(data, pos, _minor, options) {
        return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
      }
      function decodeArray16(data, pos, _minor, options) {
        return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
      }
      function decodeArray32(data, pos, _minor, options) {
        return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
      }
      function decodeArray64(data, pos, _minor, options) {
        const l = readUint64(data, pos + 1, options);
        if (typeof l === "bigint") {
          throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
        }
        return toToken3(data, pos, 9, l);
      }
      function decodeArrayIndefinite(data, pos, _minor, options) {
        if (options.allowIndefinite === false) {
          throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
        }
        return toToken3(data, pos, 1, Infinity);
      }
      function encodeArray(buf2, token) {
        encodeUintValue(buf2, Type.array.majorEncoded, token.value);
      }
      encodeArray.compareTokens = encodeUint.compareTokens;
      encodeArray.encodedSize = function encodedSize5(token) {
        return encodeUintValue.encodedSize(token.value);
      };
      function toToken4(_data, _pos, prefix, length2) {
        return new Token(Type.map, length2, prefix);
      }
      function decodeMapCompact(data, pos, minor, _options) {
        return toToken4(data, pos, 1, minor);
      }
      function decodeMap8(data, pos, _minor, options) {
        return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
      }
      function decodeMap16(data, pos, _minor, options) {
        return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
      }
      function decodeMap32(data, pos, _minor, options) {
        return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
      }
      function decodeMap64(data, pos, _minor, options) {
        const l = readUint64(data, pos + 1, options);
        if (typeof l === "bigint") {
          throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
        }
        return toToken4(data, pos, 9, l);
      }
      function decodeMapIndefinite(data, pos, _minor, options) {
        if (options.allowIndefinite === false) {
          throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
        }
        return toToken4(data, pos, 1, Infinity);
      }
      function encodeMap(buf2, token) {
        encodeUintValue(buf2, Type.map.majorEncoded, token.value);
      }
      encodeMap.compareTokens = encodeUint.compareTokens;
      encodeMap.encodedSize = function encodedSize6(token) {
        return encodeUintValue.encodedSize(token.value);
      };
      function decodeTagCompact(_data, _pos, minor, _options) {
        return new Token(Type.tag, minor, 1);
      }
      function decodeTag8(data, pos, _minor, options) {
        return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
      }
      function decodeTag16(data, pos, _minor, options) {
        return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
      }
      function decodeTag32(data, pos, _minor, options) {
        return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
      }
      function decodeTag64(data, pos, _minor, options) {
        return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
      }
      function encodeTag(buf2, token) {
        encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
      }
      encodeTag.compareTokens = encodeUint.compareTokens;
      encodeTag.encodedSize = function encodedSize7(token) {
        return encodeUintValue.encodedSize(token.value);
      };
      var MINOR_FALSE = 20;
      var MINOR_TRUE = 21;
      var MINOR_NULL = 22;
      var MINOR_UNDEFINED = 23;
      function decodeUndefined(_data, _pos, _minor, options) {
        if (options.allowUndefined === false) {
          throw new Error(`${decodeErrPrefix} undefined values are not supported`);
        } else if (options.coerceUndefinedToNull === true) {
          return new Token(Type.null, null, 1);
        }
        return new Token(Type.undefined, void 0, 1);
      }
      function decodeBreak(_data, _pos, _minor, options) {
        if (options.allowIndefinite === false) {
          throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
        }
        return new Token(Type.break, void 0, 1);
      }
      function createToken(value, bytes3, options) {
        if (options) {
          if (options.allowNaN === false && Number.isNaN(value)) {
            throw new Error(`${decodeErrPrefix} NaN values are not supported`);
          }
          if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
            throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
          }
        }
        return new Token(Type.float, value, bytes3);
      }
      function decodeFloat16(data, pos, _minor, options) {
        return createToken(readFloat16(data, pos + 1), 3, options);
      }
      function decodeFloat32(data, pos, _minor, options) {
        return createToken(readFloat32(data, pos + 1), 5, options);
      }
      function decodeFloat64(data, pos, _minor, options) {
        return createToken(readFloat64(data, pos + 1), 9, options);
      }
      function encodeFloat(buf2, token, options) {
        const float = token.value;
        if (float === false) {
          buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
        } else if (float === true) {
          buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
        } else if (float === null) {
          buf2.push([Type.float.majorEncoded | MINOR_NULL]);
        } else if (float === void 0) {
          buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
        } else {
          let decoded;
          let success = false;
          if (!options || options.float64 !== true) {
            encodeFloat16(float);
            decoded = readFloat16(ui8a, 1);
            if (float === decoded || Number.isNaN(float)) {
              ui8a[0] = 249;
              buf2.push(ui8a.slice(0, 3));
              success = true;
            } else {
              encodeFloat32(float);
              decoded = readFloat32(ui8a, 1);
              if (float === decoded) {
                ui8a[0] = 250;
                buf2.push(ui8a.slice(0, 5));
                success = true;
              }
            }
          }
          if (!success) {
            encodeFloat64(float);
            decoded = readFloat64(ui8a, 1);
            ui8a[0] = 251;
            buf2.push(ui8a.slice(0, 9));
          }
        }
      }
      encodeFloat.encodedSize = function encodedSize8(token, options) {
        const float = token.value;
        if (float === false || float === true || float === null || float === void 0) {
          return 1;
        }
        if (!options || options.float64 !== true) {
          encodeFloat16(float);
          let decoded = readFloat16(ui8a, 1);
          if (float === decoded || Number.isNaN(float)) {
            return 3;
          }
          encodeFloat32(float);
          decoded = readFloat32(ui8a, 1);
          if (float === decoded) {
            return 5;
          }
        }
        return 9;
      };
      var buffer = new ArrayBuffer(9);
      var dataView = new DataView(buffer, 1);
      var ui8a = new Uint8Array(buffer, 0);
      function encodeFloat16(inp) {
        if (inp === Infinity) {
          dataView.setUint16(0, 31744, false);
        } else if (inp === -Infinity) {
          dataView.setUint16(0, 64512, false);
        } else if (Number.isNaN(inp)) {
          dataView.setUint16(0, 32256, false);
        } else {
          dataView.setFloat32(0, inp);
          const valu32 = dataView.getUint32(0);
          const exponent = (valu32 & 2139095040) >> 23;
          const mantissa = valu32 & 8388607;
          if (exponent === 255) {
            dataView.setUint16(0, 31744, false);
          } else if (exponent === 0) {
            dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
          } else {
            const logicalExponent = exponent - 127;
            if (logicalExponent < -24) {
              dataView.setUint16(0, 0);
            } else if (logicalExponent < -14) {
              dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
            } else {
              dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
            }
          }
        }
      }
      function readFloat16(ui8a2, pos) {
        if (ui8a2.length - pos < 2) {
          throw new Error(`${decodeErrPrefix} not enough data for float16`);
        }
        const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
        if (half === 31744) {
          return Infinity;
        }
        if (half === 64512) {
          return -Infinity;
        }
        if (half === 32256) {
          return NaN;
        }
        const exp = half >> 10 & 31;
        const mant = half & 1023;
        let val;
        if (exp === 0) {
          val = mant * __pow(2, -24);
        } else if (exp !== 31) {
          val = (mant + 1024) * __pow(2, exp - 25);
        } else {
          val = mant === 0 ? Infinity : NaN;
        }
        return half & 32768 ? -val : val;
      }
      function encodeFloat32(inp) {
        dataView.setFloat32(0, inp, false);
      }
      function readFloat32(ui8a2, pos) {
        if (ui8a2.length - pos < 4) {
          throw new Error(`${decodeErrPrefix} not enough data for float32`);
        }
        const offset = (ui8a2.byteOffset || 0) + pos;
        return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
      }
      function encodeFloat64(inp) {
        dataView.setFloat64(0, inp, false);
      }
      function readFloat64(ui8a2, pos) {
        if (ui8a2.length - pos < 8) {
          throw new Error(`${decodeErrPrefix} not enough data for float64`);
        }
        const offset = (ui8a2.byteOffset || 0) + pos;
        return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
      }
      encodeFloat.compareTokens = encodeUint.compareTokens;
      function invalidMinor(data, pos, minor) {
        throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
      }
      function errorer(msg) {
        return () => {
          throw new Error(`${decodeErrPrefix} ${msg}`);
        };
      }
      var jump = [];
      for (let i = 0; i <= 23; i++) {
        jump[i] = invalidMinor;
      }
      jump[24] = decodeUint8;
      jump[25] = decodeUint16;
      jump[26] = decodeUint32;
      jump[27] = decodeUint64;
      jump[28] = invalidMinor;
      jump[29] = invalidMinor;
      jump[30] = invalidMinor;
      jump[31] = invalidMinor;
      for (let i = 32; i <= 55; i++) {
        jump[i] = invalidMinor;
      }
      jump[56] = decodeNegint8;
      jump[57] = decodeNegint16;
      jump[58] = decodeNegint32;
      jump[59] = decodeNegint64;
      jump[60] = invalidMinor;
      jump[61] = invalidMinor;
      jump[62] = invalidMinor;
      jump[63] = invalidMinor;
      for (let i = 64; i <= 87; i++) {
        jump[i] = decodeBytesCompact;
      }
      jump[88] = decodeBytes8;
      jump[89] = decodeBytes16;
      jump[90] = decodeBytes32;
      jump[91] = decodeBytes64;
      jump[92] = invalidMinor;
      jump[93] = invalidMinor;
      jump[94] = invalidMinor;
      jump[95] = errorer("indefinite length bytes/strings are not supported");
      for (let i = 96; i <= 119; i++) {
        jump[i] = decodeStringCompact;
      }
      jump[120] = decodeString8;
      jump[121] = decodeString16;
      jump[122] = decodeString32;
      jump[123] = decodeString64;
      jump[124] = invalidMinor;
      jump[125] = invalidMinor;
      jump[126] = invalidMinor;
      jump[127] = errorer("indefinite length bytes/strings are not supported");
      for (let i = 128; i <= 151; i++) {
        jump[i] = decodeArrayCompact;
      }
      jump[152] = decodeArray8;
      jump[153] = decodeArray16;
      jump[154] = decodeArray32;
      jump[155] = decodeArray64;
      jump[156] = invalidMinor;
      jump[157] = invalidMinor;
      jump[158] = invalidMinor;
      jump[159] = decodeArrayIndefinite;
      for (let i = 160; i <= 183; i++) {
        jump[i] = decodeMapCompact;
      }
      jump[184] = decodeMap8;
      jump[185] = decodeMap16;
      jump[186] = decodeMap32;
      jump[187] = decodeMap64;
      jump[188] = invalidMinor;
      jump[189] = invalidMinor;
      jump[190] = invalidMinor;
      jump[191] = decodeMapIndefinite;
      for (let i = 192; i <= 215; i++) {
        jump[i] = decodeTagCompact;
      }
      jump[216] = decodeTag8;
      jump[217] = decodeTag16;
      jump[218] = decodeTag32;
      jump[219] = decodeTag64;
      jump[220] = invalidMinor;
      jump[221] = invalidMinor;
      jump[222] = invalidMinor;
      jump[223] = invalidMinor;
      for (let i = 224; i <= 243; i++) {
        jump[i] = errorer("simple values are not supported");
      }
      jump[244] = invalidMinor;
      jump[245] = invalidMinor;
      jump[246] = invalidMinor;
      jump[247] = decodeUndefined;
      jump[248] = errorer("simple values are not supported");
      jump[249] = decodeFloat16;
      jump[250] = decodeFloat32;
      jump[251] = decodeFloat64;
      jump[252] = invalidMinor;
      jump[253] = invalidMinor;
      jump[254] = invalidMinor;
      jump[255] = decodeBreak;
      var quick = [];
      for (let i = 0; i < 24; i++) {
        quick[i] = new Token(Type.uint, i, 1);
      }
      for (let i = -1; i >= -24; i--) {
        quick[31 - i] = new Token(Type.negint, i, 1);
      }
      quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
      quick[96] = new Token(Type.string, "", 1);
      quick[128] = new Token(Type.array, 0, 1);
      quick[160] = new Token(Type.map, 0, 1);
      quick[244] = new Token(Type.false, false, 1);
      quick[245] = new Token(Type.true, true, 1);
      quick[246] = new Token(Type.null, null, 1);
      function quickEncodeToken(token) {
        switch (token.type) {
          case Type.false:
            return fromArray([244]);
          case Type.true:
            return fromArray([245]);
          case Type.null:
            return fromArray([246]);
          case Type.bytes:
            if (!token.value.length) {
              return fromArray([64]);
            }
            return;
          case Type.string:
            if (token.value === "") {
              return fromArray([96]);
            }
            return;
          case Type.array:
            if (token.value === 0) {
              return fromArray([128]);
            }
            return;
          case Type.map:
            if (token.value === 0) {
              return fromArray([160]);
            }
            return;
          case Type.uint:
            if (token.value < 24) {
              return fromArray([Number(token.value)]);
            }
            return;
          case Type.negint:
            if (token.value >= -24) {
              return fromArray([31 - Number(token.value)]);
            }
        }
      }
      var defaultEncodeOptions = {
        float64: false,
        mapSorter,
        quickEncodeToken
      };
      function makeCborEncoders() {
        const encoders = [];
        encoders[Type.uint.major] = encodeUint;
        encoders[Type.negint.major] = encodeNegint;
        encoders[Type.bytes.major] = encodeBytes;
        encoders[Type.string.major] = encodeString;
        encoders[Type.array.major] = encodeArray;
        encoders[Type.map.major] = encodeMap;
        encoders[Type.tag.major] = encodeTag;
        encoders[Type.float.major] = encodeFloat;
        return encoders;
      }
      var cborEncoders = makeCborEncoders();
      var buf = new Bl();
      var Ref = class {
        constructor(obj, parent) {
          this.obj = obj;
          this.parent = parent;
        }
        includes(obj) {
          let p = this;
          do {
            if (p.obj === obj) {
              return true;
            }
          } while (p = p.parent);
          return false;
        }
        static createCheck(stack, obj) {
          if (stack && stack.includes(obj)) {
            throw new Error(`${encodeErrPrefix} object contains circular references`);
          }
          return new Ref(obj, stack);
        }
      };
      var simpleTokens = {
        null: new Token(Type.null, null),
        undefined: new Token(Type.undefined, void 0),
        true: new Token(Type.true, true),
        false: new Token(Type.false, false),
        emptyArray: new Token(Type.array, 0),
        emptyMap: new Token(Type.map, 0)
      };
      var typeEncoders = {
        number(obj, _typ, _options, _refStack) {
          if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
            return new Token(Type.float, obj);
          } else if (obj >= 0) {
            return new Token(Type.uint, obj);
          } else {
            return new Token(Type.negint, obj);
          }
        },
        bigint(obj, _typ, _options, _refStack) {
          if (obj >= BigInt(0)) {
            return new Token(Type.uint, obj);
          } else {
            return new Token(Type.negint, obj);
          }
        },
        Uint8Array(obj, _typ, _options, _refStack) {
          return new Token(Type.bytes, obj);
        },
        string(obj, _typ, _options, _refStack) {
          return new Token(Type.string, obj);
        },
        boolean(obj, _typ, _options, _refStack) {
          return obj ? simpleTokens.true : simpleTokens.false;
        },
        null(_obj, _typ, _options, _refStack) {
          return simpleTokens.null;
        },
        undefined(_obj, _typ, _options, _refStack) {
          return simpleTokens.undefined;
        },
        ArrayBuffer(obj, _typ, _options, _refStack) {
          return new Token(Type.bytes, new Uint8Array(obj));
        },
        DataView(obj, _typ, _options, _refStack) {
          return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
        },
        Array(obj, _typ, options, refStack) {
          if (!obj.length) {
            if (options.addBreakTokens === true) {
              return [
                simpleTokens.emptyArray,
                new Token(Type.break)
              ];
            }
            return simpleTokens.emptyArray;
          }
          refStack = Ref.createCheck(refStack, obj);
          const entries = [];
          let i = 0;
          for (const e of obj) {
            entries[i++] = objectToTokens(e, options, refStack);
          }
          if (options.addBreakTokens) {
            return [
              new Token(Type.array, obj.length),
              entries,
              new Token(Type.break)
            ];
          }
          return [
            new Token(Type.array, obj.length),
            entries
          ];
        },
        Object(obj, typ, options, refStack) {
          const isMap = typ !== "Object";
          const keys = isMap ? obj.keys() : Object.keys(obj);
          const length2 = isMap ? obj.size : keys.length;
          if (!length2) {
            if (options.addBreakTokens === true) {
              return [
                simpleTokens.emptyMap,
                new Token(Type.break)
              ];
            }
            return simpleTokens.emptyMap;
          }
          refStack = Ref.createCheck(refStack, obj);
          const entries = [];
          let i = 0;
          for (const key of keys) {
            entries[i++] = [
              objectToTokens(key, options, refStack),
              objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
            ];
          }
          sortMapEntries(entries, options);
          if (options.addBreakTokens) {
            return [
              new Token(Type.map, length2),
              entries,
              new Token(Type.break)
            ];
          }
          return [
            new Token(Type.map, length2),
            entries
          ];
        }
      };
      typeEncoders.Map = typeEncoders.Object;
      typeEncoders.Buffer = typeEncoders.Uint8Array;
      for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
        typeEncoders[`${typ}Array`] = typeEncoders.DataView;
      }
      function objectToTokens(obj, options = {}, refStack) {
        const typ = is2(obj);
        const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
        if (typeof customTypeEncoder === "function") {
          const tokens = customTypeEncoder(obj, typ, options, refStack);
          if (tokens != null) {
            return tokens;
          }
        }
        const typeEncoder = typeEncoders[typ];
        if (!typeEncoder) {
          throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
        }
        return typeEncoder(obj, typ, options, refStack);
      }
      function sortMapEntries(entries, options) {
        if (options.mapSorter) {
          entries.sort(options.mapSorter);
        }
      }
      function mapSorter(e1, e2) {
        const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
        const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
        if (keyToken1.type !== keyToken2.type) {
          return keyToken1.type.compare(keyToken2.type);
        }
        const major = keyToken1.type.major;
        const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
        if (tcmp === 0) {
          console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
        }
        return tcmp;
      }
      function tokensToEncoded(buf2, tokens, encoders, options) {
        if (Array.isArray(tokens)) {
          for (const token of tokens) {
            tokensToEncoded(buf2, token, encoders, options);
          }
        } else {
          encoders[tokens.type.major](buf2, tokens, options);
        }
      }
      function encodeCustom(data, encoders, options) {
        const tokens = objectToTokens(data, options);
        if (!Array.isArray(tokens) && options.quickEncodeToken) {
          const quickBytes = options.quickEncodeToken(tokens);
          if (quickBytes) {
            return quickBytes;
          }
          const encoder = encoders[tokens.type.major];
          if (encoder.encodedSize) {
            const size = encoder.encodedSize(tokens, options);
            const buf2 = new Bl(size);
            encoder(buf2, tokens, options);
            if (buf2.chunks.length !== 1) {
              throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
            }
            return asU8A(buf2.chunks[0]);
          }
        }
        buf.reset();
        tokensToEncoded(buf, tokens, encoders, options);
        return buf.toBytes(true);
      }
      function encode6(data, options) {
        options = Object.assign({}, defaultEncodeOptions, options);
        return encodeCustom(data, cborEncoders, options);
      }
      var defaultDecodeOptions = {
        strict: false,
        allowIndefinite: true,
        allowUndefined: true,
        allowBigInt: true
      };
      var Tokeniser = class {
        constructor(data, options = {}) {
          this.pos = 0;
          this.data = data;
          this.options = options;
        }
        done() {
          return this.pos >= this.data.length;
        }
        next() {
          const byt = this.data[this.pos];
          let token = quick[byt];
          if (token === void 0) {
            const decoder2 = jump[byt];
            if (!decoder2) {
              throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
            }
            const minor = byt & 31;
            token = decoder2(this.data, this.pos, minor, this.options);
          }
          this.pos += token.encodedLength;
          return token;
        }
      };
      var DONE = Symbol.for("DONE");
      var BREAK = Symbol.for("BREAK");
      function tokenToArray(token, tokeniser, options) {
        const arr = [];
        for (let i = 0; i < token.value; i++) {
          const value = tokensToObject(tokeniser, options);
          if (value === BREAK) {
            if (token.value === Infinity) {
              break;
            }
            throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
          }
          if (value === DONE) {
            throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
          }
          arr[i] = value;
        }
        return arr;
      }
      function tokenToMap(token, tokeniser, options) {
        const useMaps = options.useMaps === true;
        const obj = useMaps ? void 0 : {};
        const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
        for (let i = 0; i < token.value; i++) {
          const key = tokensToObject(tokeniser, options);
          if (key === BREAK) {
            if (token.value === Infinity) {
              break;
            }
            throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
          }
          if (key === DONE) {
            throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
          }
          if (useMaps !== true && typeof key !== "string") {
            throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
          }
          if (options.rejectDuplicateMapKeys === true) {
            if (useMaps && m.has(key) || !useMaps && key in obj) {
              throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
            }
          }
          const value = tokensToObject(tokeniser, options);
          if (value === DONE) {
            throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
          }
          if (useMaps) {
            m.set(key, value);
          } else {
            obj[key] = value;
          }
        }
        return useMaps ? m : obj;
      }
      function tokensToObject(tokeniser, options) {
        if (tokeniser.done()) {
          return DONE;
        }
        const token = tokeniser.next();
        if (token.type === Type.break) {
          return BREAK;
        }
        if (token.type.terminal) {
          return token.value;
        }
        if (token.type === Type.array) {
          return tokenToArray(token, tokeniser, options);
        }
        if (token.type === Type.map) {
          return tokenToMap(token, tokeniser, options);
        }
        if (token.type === Type.tag) {
          if (options.tags && typeof options.tags[token.value] === "function") {
            const tagged = tokensToObject(tokeniser, options);
            return options.tags[token.value](tagged);
          }
          throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
        }
        throw new Error("unsupported");
      }
      function decode6(data, options) {
        if (!(data instanceof Uint8Array)) {
          throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
        }
        options = Object.assign({}, defaultDecodeOptions, options);
        const tokeniser = options.tokenizer || new Tokeniser(data, options);
        const decoded = tokensToObject(tokeniser, options);
        if (decoded === DONE) {
          throw new Error(`${decodeErrPrefix} did not find any content to decode`);
        }
        if (decoded === BREAK) {
          throw new Error(`${decodeErrPrefix} got unexpected break`);
        }
        if (!tokeniser.done()) {
          throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
        }
        return decoded;
      }
      var CID_CBOR_TAG = 42;
      function cidEncoder(obj) {
        if (obj.asCID !== obj) {
          return null;
        }
        const cid2 = CID.asCID(obj);
        if (!cid2) {
          return null;
        }
        const bytes3 = new Uint8Array(cid2.bytes.byteLength + 1);
        bytes3.set(cid2.bytes, 1);
        return [
          new Token(Type.tag, CID_CBOR_TAG),
          new Token(Type.bytes, bytes3)
        ];
      }
      function undefinedEncoder() {
        throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
      }
      function numberEncoder(num) {
        if (Number.isNaN(num)) {
          throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
        }
        if (num === Infinity || num === -Infinity) {
          throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
        }
        return null;
      }
      var encodeOptions = {
        float64: true,
        typeEncoders: {
          Object: cidEncoder,
          undefined: undefinedEncoder,
          number: numberEncoder
        }
      };
      function cidDecoder(bytes3) {
        if (bytes3[0] !== 0) {
          throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
        }
        return CID.decode(bytes3.subarray(1));
      }
      var decodeOptions = {
        allowIndefinite: false,
        coerceUndefinedToNull: true,
        allowNaN: false,
        allowInfinity: false,
        allowBigInt: true,
        strict: true,
        useMaps: false,
        tags: []
      };
      decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
      var name2 = "dag-cbor";
      var code2 = 113;
      var encode7 = (node) => encode6(node, encodeOptions);
      var decode7 = (data) => decode6(data, decodeOptions);
      var cborDecode = decode7;
      var dataToCborBlock = (data) => __async(exports, null, function* () {
        return encode5({
          value: data,
          codec: esm_exports,
          hasher: sha256
        });
      });
      var cidForCbor = (data) => __async(exports, null, function* () {
        const block = yield dataToCborBlock(data);
        return block.cid;
      });
      var verifyCidForBytes = (cid2, bytes3) => __async(exports, null, function* () {
        const digest2 = yield sha256.digest(bytes3);
        const expected = CID.createV1(cid2.code, digest2);
        if (!cid2.equals(expected)) {
          throw new Error(`Not a valid CID for bytes. Expected: ${expected.toString()} Got: ${cid2.toString()}`);
        }
      });
      var decoder;
      try {
        decoder = new TextDecoder();
      } catch (error) {
      }
      var src2;
      var srcEnd;
      var position = 0;
      var EMPTY_ARRAY = [];
      var LEGACY_RECORD_INLINE_ID = 105;
      var RECORD_DEFINITIONS_ID = 57342;
      var RECORD_INLINE_ID = 57343;
      var BUNDLED_STRINGS_ID = 57337;
      var PACKED_REFERENCE_TAG_ID = 6;
      var STOP_CODE = {};
      var strings = EMPTY_ARRAY;
      var stringPosition = 0;
      var currentDecoder = {};
      var currentStructures;
      var srcString;
      var srcStringStart = 0;
      var srcStringEnd = 0;
      var bundledStrings;
      var referenceMap;
      var currentExtensions = [];
      var currentExtensionRanges = [];
      var packedValues;
      var dataView2;
      var restoreMapsAsObject;
      var defaultOptions = {
        useRecords: false,
        mapsAsObjects: true
      };
      var sequentialMode = false;
      var Decoder2 = class {
        constructor(options) {
          if (options) {
            if ((options.keyMap || options._keyMap) && !options.useRecords) {
              options.useRecords = false;
              options.mapsAsObjects = true;
            }
            if (options.useRecords === false && options.mapsAsObjects === void 0)
              options.mapsAsObjects = true;
            if (options.getStructures)
              options.getShared = options.getStructures;
            if (options.getShared && !options.structures)
              (options.structures = []).uninitialized = true;
            if (options.keyMap) {
              this.mapKey = /* @__PURE__ */ new Map();
              for (let [k, v] of Object.entries(options.keyMap))
                this.mapKey.set(v, k);
            }
          }
          Object.assign(this, options);
        }
        decodeKey(key) {
          return this.keyMap ? this.mapKey.get(key) || key : key;
        }
        encodeKey(key) {
          return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
        }
        encodeKeys(rec) {
          if (!this._keyMap)
            return rec;
          let map = /* @__PURE__ */ new Map();
          for (let [k, v] of Object.entries(rec))
            map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
          return map;
        }
        decodeKeys(map) {
          if (!this._keyMap || map.constructor.name != "Map")
            return map;
          if (!this._mapKey) {
            this._mapKey = /* @__PURE__ */ new Map();
            for (let [k, v] of Object.entries(this._keyMap))
              this._mapKey.set(v, k);
          }
          let res = {};
          map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
          return res;
        }
        mapDecode(source, end) {
          let res = this.decode(source);
          if (this._keyMap) {
            switch (res.constructor.name) {
              case "Array":
                return res.map((r) => this.decodeKeys(r));
            }
          }
          return res;
        }
        decode(source, end) {
          if (src2) {
            return saveState(() => {
              clearSource();
              return this ? this.decode(source, end) : Decoder2.prototype.decode.call(defaultOptions, source, end);
            });
          }
          srcEnd = end > -1 ? end : source.length;
          position = 0;
          stringPosition = 0;
          srcStringEnd = 0;
          srcString = null;
          strings = EMPTY_ARRAY;
          bundledStrings = null;
          src2 = source;
          try {
            dataView2 = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
          } catch (error) {
            src2 = null;
            if (source instanceof Uint8Array)
              throw error;
            throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
          }
          if (this instanceof Decoder2) {
            currentDecoder = this;
            packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
            if (this.structures) {
              currentStructures = this.structures;
              return checkedRead();
            } else if (!currentStructures || currentStructures.length > 0) {
              currentStructures = [];
            }
          } else {
            currentDecoder = defaultOptions;
            if (!currentStructures || currentStructures.length > 0)
              currentStructures = [];
            packedValues = null;
          }
          return checkedRead();
        }
        decodeMultiple(source, forEach) {
          let values, lastPosition = 0;
          try {
            let size = source.length;
            sequentialMode = true;
            let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
            if (forEach) {
              if (forEach(value) === false) {
                return;
              }
              while (position < size) {
                lastPosition = position;
                if (forEach(checkedRead()) === false) {
                  return;
                }
              }
            } else {
              values = [value];
              while (position < size) {
                lastPosition = position;
                values.push(checkedRead());
              }
              return values;
            }
          } catch (error) {
            error.lastPosition = lastPosition;
            error.values = values;
            throw error;
          } finally {
            sequentialMode = false;
            clearSource();
          }
        }
      };
      function checkedRead() {
        try {
          let result = read2();
          if (bundledStrings) {
            if (position >= bundledStrings.postBundlePosition) {
              let error = new Error("Unexpected bundle position");
              error.incomplete = true;
              throw error;
            }
            position = bundledStrings.postBundlePosition;
            bundledStrings = null;
          }
          if (position == srcEnd) {
            currentStructures = null;
            src2 = null;
            if (referenceMap)
              referenceMap = null;
          } else if (position > srcEnd) {
            let error = new Error("Unexpected end of CBOR data");
            error.incomplete = true;
            throw error;
          } else if (!sequentialMode) {
            throw new Error("Data read, but end of buffer not reached");
          }
          return result;
        } catch (error) {
          clearSource();
          if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
            error.incomplete = true;
          }
          throw error;
        }
      }
      function read2() {
        let token = src2[position++];
        let majorType = token >> 5;
        token = token & 31;
        if (token > 23) {
          switch (token) {
            case 24:
              token = src2[position++];
              break;
            case 25:
              if (majorType == 7) {
                return getFloat16();
              }
              token = dataView2.getUint16(position);
              position += 2;
              break;
            case 26:
              if (majorType == 7) {
                let value = dataView2.getFloat32(position);
                if (currentDecoder.useFloat32 > 2) {
                  let multiplier = mult10[(src2[position] & 127) << 1 | src2[position + 1] >> 7];
                  position += 4;
                  return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
                }
                position += 4;
                return value;
              }
              token = dataView2.getUint32(position);
              position += 4;
              break;
            case 27:
              if (majorType == 7) {
                let value = dataView2.getFloat64(position);
                position += 8;
                return value;
              }
              if (majorType > 1) {
                if (dataView2.getUint32(position) > 0)
                  throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
                token = dataView2.getUint32(position + 4);
              } else if (currentDecoder.int64AsNumber) {
                token = dataView2.getUint32(position) * 4294967296;
                token += dataView2.getUint32(position + 4);
              } else
                token = dataView2.getBigUint64(position);
              position += 8;
              break;
            case 31:
              switch (majorType) {
                case 2:
                case 3:
                  throw new Error("Indefinite length not supported for byte or text strings");
                case 4:
                  let array2 = [];
                  let value, i = 0;
                  while ((value = read2()) != STOP_CODE) {
                    array2[i++] = value;
                  }
                  return majorType == 4 ? array2 : majorType == 3 ? array2.join("") : Buffer.concat(array2);
                case 5:
                  let key;
                  if (currentDecoder.mapsAsObjects) {
                    let object2 = {};
                    if (currentDecoder.keyMap)
                      while ((key = read2()) != STOP_CODE)
                        object2[safeKey(currentDecoder.decodeKey(key))] = read2();
                    else
                      while ((key = read2()) != STOP_CODE)
                        object2[safeKey(key)] = read2();
                    return object2;
                  } else {
                    if (restoreMapsAsObject) {
                      currentDecoder.mapsAsObjects = true;
                      restoreMapsAsObject = false;
                    }
                    let map = /* @__PURE__ */ new Map();
                    if (currentDecoder.keyMap)
                      while ((key = read2()) != STOP_CODE)
                        map.set(currentDecoder.decodeKey(key), read2());
                    else
                      while ((key = read2()) != STOP_CODE)
                        map.set(key, read2());
                    return map;
                  }
                case 7:
                  return STOP_CODE;
                default:
                  throw new Error("Invalid major type for indefinite length " + majorType);
              }
            default:
              throw new Error("Unknown token " + token);
          }
        }
        switch (majorType) {
          case 0:
            return token;
          case 1:
            return ~token;
          case 2:
            return readBin(token);
          case 3:
            if (srcStringEnd >= position) {
              return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
            }
            if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
              let string3 = token < 16 ? shortStringInJS(token) : longStringInJS(token);
              if (string3 != null)
                return string3;
            }
            return readFixedString(token);
          case 4:
            let array2 = new Array(token);
            for (let i = 0; i < token; i++)
              array2[i] = read2();
            return array2;
          case 5:
            if (currentDecoder.mapsAsObjects) {
              let object2 = {};
              if (currentDecoder.keyMap)
                for (let i = 0; i < token; i++)
                  object2[safeKey(currentDecoder.decodeKey(read2()))] = read2();
              else
                for (let i = 0; i < token; i++)
                  object2[safeKey(read2())] = read2();
              return object2;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap)
                for (let i = 0; i < token; i++)
                  map.set(currentDecoder.decodeKey(read2()), read2());
              else
                for (let i = 0; i < token; i++)
                  map.set(read2(), read2());
              return map;
            }
          case 6:
            if (token >= BUNDLED_STRINGS_ID) {
              let structure = currentStructures[token & 8191];
              if (structure) {
                if (!structure.read)
                  structure.read = createStructureReader(structure);
                return structure.read();
              }
              if (token < 65536) {
                if (token == RECORD_INLINE_ID) {
                  let length2 = readJustLength();
                  let id = read2();
                  let structure2 = read2();
                  recordDefinition(id, structure2);
                  let object2 = {};
                  if (currentDecoder.keyMap)
                    for (let i = 2; i < length2; i++) {
                      let key = currentDecoder.decodeKey(structure2[i - 2]);
                      object2[safeKey(key)] = read2();
                    }
                  else
                    for (let i = 2; i < length2; i++) {
                      let key = structure2[i - 2];
                      object2[safeKey(key)] = read2();
                    }
                  return object2;
                } else if (token == RECORD_DEFINITIONS_ID) {
                  let length2 = readJustLength();
                  let id = read2();
                  for (let i = 2; i < length2; i++) {
                    recordDefinition(id++, read2());
                  }
                  return read2();
                } else if (token == BUNDLED_STRINGS_ID) {
                  return readBundleExt();
                }
                if (currentDecoder.getShared) {
                  loadShared();
                  structure = currentStructures[token & 8191];
                  if (structure) {
                    if (!structure.read)
                      structure.read = createStructureReader(structure);
                    return structure.read();
                  }
                }
              }
            }
            let extension = currentExtensions[token];
            if (extension) {
              if (extension.handlesRead)
                return extension(read2);
              else
                return extension(read2());
            } else {
              let input = read2();
              for (let i = 0; i < currentExtensionRanges.length; i++) {
                let value = currentExtensionRanges[i](token, input);
                if (value !== void 0)
                  return value;
              }
              return new Tag(input, token);
            }
          case 7:
            switch (token) {
              case 20:
                return false;
              case 21:
                return true;
              case 22:
                return null;
              case 23:
                return;
              case 31:
              default:
                let packedValue = (packedValues || getPackedValues())[token];
                if (packedValue !== void 0)
                  return packedValue;
                throw new Error("Unknown token " + token);
            }
          default:
            if (isNaN(token)) {
              let error = new Error("Unexpected end of CBOR data");
              error.incomplete = true;
              throw error;
            }
            throw new Error("Unknown CBOR token " + token);
        }
      }
      var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
      function createStructureReader(structure) {
        function readObject() {
          let length2 = src2[position++];
          length2 = length2 & 31;
          if (length2 > 23) {
            switch (length2) {
              case 24:
                length2 = src2[position++];
                break;
              case 25:
                length2 = dataView2.getUint16(position);
                position += 2;
                break;
              case 26:
                length2 = dataView2.getUint32(position);
                position += 4;
                break;
              default:
                throw new Error("Expected array header, but got " + src2[position - 1]);
            }
          }
          let compiledReader = this.compiledReader;
          while (compiledReader) {
            if (compiledReader.propertyCount === length2)
              return compiledReader(read2);
            compiledReader = compiledReader.next;
          }
          if (this.slowReads++ >= 3) {
            let array2 = this.length == length2 ? this : this.slice(0, length2);
            compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array2.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array2.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
            if (this.compiledReader)
              compiledReader.next = this.compiledReader;
            compiledReader.propertyCount = length2;
            this.compiledReader = compiledReader;
            return compiledReader(read2);
          }
          let object2 = {};
          if (currentDecoder.keyMap)
            for (let i = 0; i < length2; i++)
              object2[safeKey(currentDecoder.decodeKey(this[i]))] = read2();
          else
            for (let i = 0; i < length2; i++) {
              object2[safeKey(this[i])] = read2();
            }
          return object2;
        }
        structure.slowReads = 0;
        return readObject;
      }
      function safeKey(key) {
        return key === "__proto__" ? "__proto_" : key;
      }
      var readFixedString = readStringJS;
      var readString8 = readStringJS;
      var readString16 = readStringJS;
      var readString32 = readStringJS;
      var isNativeAccelerationEnabled = false;
      function setExtractor(extractStrings) {
        isNativeAccelerationEnabled = true;
        readFixedString = readString(1);
        readString8 = readString(2);
        readString16 = readString(3);
        readString32 = readString(5);
        function readString(headerLength) {
          return function readString2(length2) {
            let string3 = strings[stringPosition++];
            if (string3 == null) {
              if (bundledStrings)
                return readStringJS(length2);
              let extraction = extractStrings(position, srcEnd, length2, src2);
              if (typeof extraction == "string") {
                string3 = extraction;
                strings = EMPTY_ARRAY;
              } else {
                strings = extraction;
                stringPosition = 1;
                srcStringEnd = 1;
                string3 = strings[0];
                if (string3 === void 0)
                  throw new Error("Unexpected end of buffer");
              }
            }
            let srcStringLength = string3.length;
            if (srcStringLength <= length2) {
              position += length2;
              return string3;
            }
            srcString = string3;
            srcStringStart = position;
            srcStringEnd = position + srcStringLength;
            position += length2;
            return string3.slice(0, length2);
          };
        }
      }
      function readStringJS(length2) {
        let result;
        if (length2 < 16) {
          if (result = shortStringInJS(length2))
            return result;
        }
        if (length2 > 64 && decoder)
          return decoder.decode(src2.subarray(position, position += length2));
        const end = position + length2;
        const units = [];
        result = "";
        while (position < end) {
          const byte1 = src2[position++];
          if ((byte1 & 128) === 0) {
            units.push(byte1);
          } else if ((byte1 & 224) === 192) {
            const byte2 = src2[position++] & 63;
            units.push((byte1 & 31) << 6 | byte2);
          } else if ((byte1 & 240) === 224) {
            const byte2 = src2[position++] & 63;
            const byte3 = src2[position++] & 63;
            units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
          } else if ((byte1 & 248) === 240) {
            const byte2 = src2[position++] & 63;
            const byte3 = src2[position++] & 63;
            const byte4 = src2[position++] & 63;
            let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
            if (unit > 65535) {
              unit -= 65536;
              units.push(unit >>> 10 & 1023 | 55296);
              unit = 56320 | unit & 1023;
            }
            units.push(unit);
          } else {
            units.push(byte1);
          }
          if (units.length >= 4096) {
            result += fromCharCode.apply(String, units);
            units.length = 0;
          }
        }
        if (units.length > 0) {
          result += fromCharCode.apply(String, units);
        }
        return result;
      }
      var fromCharCode = String.fromCharCode;
      function longStringInJS(length2) {
        let start = position;
        let bytes3 = new Array(length2);
        for (let i = 0; i < length2; i++) {
          const byte = src2[position++];
          if ((byte & 128) > 0) {
            position = start;
            return;
          }
          bytes3[i] = byte;
        }
        return fromCharCode.apply(String, bytes3);
      }
      function shortStringInJS(length2) {
        if (length2 < 4) {
          if (length2 < 2) {
            if (length2 === 0)
              return "";
            else {
              let a = src2[position++];
              if ((a & 128) > 1) {
                position -= 1;
                return;
              }
              return fromCharCode(a);
            }
          } else {
            let a = src2[position++];
            let b = src2[position++];
            if ((a & 128) > 0 || (b & 128) > 0) {
              position -= 2;
              return;
            }
            if (length2 < 3)
              return fromCharCode(a, b);
            let c = src2[position++];
            if ((c & 128) > 0) {
              position -= 3;
              return;
            }
            return fromCharCode(a, b, c);
          }
        } else {
          let a = src2[position++];
          let b = src2[position++];
          let c = src2[position++];
          let d = src2[position++];
          if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
            position -= 4;
            return;
          }
          if (length2 < 6) {
            if (length2 === 4)
              return fromCharCode(a, b, c, d);
            else {
              let e = src2[position++];
              if ((e & 128) > 0) {
                position -= 5;
                return;
              }
              return fromCharCode(a, b, c, d, e);
            }
          } else if (length2 < 8) {
            let e = src2[position++];
            let f = src2[position++];
            if ((e & 128) > 0 || (f & 128) > 0) {
              position -= 6;
              return;
            }
            if (length2 < 7)
              return fromCharCode(a, b, c, d, e, f);
            let g = src2[position++];
            if ((g & 128) > 0) {
              position -= 7;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g);
          } else {
            let e = src2[position++];
            let f = src2[position++];
            let g = src2[position++];
            let h = src2[position++];
            if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
              position -= 8;
              return;
            }
            if (length2 < 10) {
              if (length2 === 8)
                return fromCharCode(a, b, c, d, e, f, g, h);
              else {
                let i = src2[position++];
                if ((i & 128) > 0) {
                  position -= 9;
                  return;
                }
                return fromCharCode(a, b, c, d, e, f, g, h, i);
              }
            } else if (length2 < 12) {
              let i = src2[position++];
              let j = src2[position++];
              if ((i & 128) > 0 || (j & 128) > 0) {
                position -= 10;
                return;
              }
              if (length2 < 11)
                return fromCharCode(a, b, c, d, e, f, g, h, i, j);
              let k = src2[position++];
              if ((k & 128) > 0) {
                position -= 11;
                return;
              }
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
            } else {
              let i = src2[position++];
              let j = src2[position++];
              let k = src2[position++];
              let l = src2[position++];
              if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
                position -= 12;
                return;
              }
              if (length2 < 14) {
                if (length2 === 12)
                  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
                else {
                  let m = src2[position++];
                  if ((m & 128) > 0) {
                    position -= 13;
                    return;
                  }
                  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
                }
              } else {
                let m = src2[position++];
                let n = src2[position++];
                if ((m & 128) > 0 || (n & 128) > 0) {
                  position -= 14;
                  return;
                }
                if (length2 < 15)
                  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
                let o = src2[position++];
                if ((o & 128) > 0) {
                  position -= 15;
                  return;
                }
                return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
              }
            }
          }
        }
      }
      function readBin(length2) {
        return currentDecoder.copyBuffers ? Uint8Array.prototype.slice.call(src2, position, position += length2) : src2.subarray(position, position += length2);
      }
      var f32Array = new Float32Array(1);
      var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
      function getFloat16() {
        let byte0 = src2[position++];
        let byte1 = src2[position++];
        let exponent = (byte0 & 127) >> 2;
        if (exponent === 31) {
          if (byte1 || byte0 & 3)
            return NaN;
          return byte0 & 128 ? -Infinity : Infinity;
        }
        if (exponent === 0) {
          let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
          return byte0 & 128 ? -abs : abs;
        }
        u8Array[3] = byte0 & 128 | (exponent >> 1) + 56;
        u8Array[2] = (byte0 & 7) << 5 | byte1 >> 3;
        u8Array[1] = byte1 << 5;
        u8Array[0] = 0;
        return f32Array[0];
      }
      var keyCache = new Array(4096);
      var Tag = class {
        constructor(value, tag) {
          this.value = value;
          this.tag = tag;
        }
      };
      currentExtensions[0] = (dateString) => {
        return new Date(dateString);
      };
      currentExtensions[1] = (epochSec) => {
        return new Date(Math.round(epochSec * 1e3));
      };
      currentExtensions[2] = (buffer2) => {
        let value = BigInt(0);
        for (let i = 0, l = buffer2.byteLength; i < l; i++) {
          value = BigInt(buffer2[i]) + value << BigInt(8);
        }
        return value;
      };
      currentExtensions[3] = (buffer2) => {
        return BigInt(-1) - currentExtensions[2](buffer2);
      };
      currentExtensions[4] = (fraction) => {
        return +(fraction[1] + "e" + fraction[0]);
      };
      currentExtensions[5] = (fraction) => {
        return fraction[1] * Math.exp(fraction[0] * Math.log(2));
      };
      var recordDefinition = (id, structure) => {
        id = id - 57344;
        let existingStructure = currentStructures[id];
        if (existingStructure && existingStructure.isShared) {
          (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
        }
        currentStructures[id] = structure;
        structure.read = createStructureReader(structure);
      };
      currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
        let length2 = data.length;
        let structure = data[1];
        recordDefinition(data[0], structure);
        let object2 = {};
        for (let i = 2; i < length2; i++) {
          let key = structure[i - 2];
          object2[safeKey(key)] = data[i];
        }
        return object2;
      };
      currentExtensions[14] = (value) => {
        if (bundledStrings)
          return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
        return new Tag(value, 14);
      };
      currentExtensions[15] = (value) => {
        if (bundledStrings)
          return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
        return new Tag(value, 15);
      };
      var glbl = { Error, RegExp };
      currentExtensions[27] = (data) => {
        return (glbl[data[0]] || Error)(data[1], data[2]);
      };
      var packedTable = (read3) => {
        if (src2[position++] != 132)
          throw new Error("Packed values structure must be followed by a 4 element array");
        let newPackedValues = read3();
        packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
        packedValues.prefixes = read3();
        packedValues.suffixes = read3();
        return read3();
      };
      packedTable.handlesRead = true;
      currentExtensions[51] = packedTable;
      currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
        if (!packedValues) {
          if (currentDecoder.getShared)
            loadShared();
          else
            return new Tag(data, PACKED_REFERENCE_TAG_ID);
        }
        if (typeof data == "number")
          return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
        throw new Error("No support for non-integer packed references yet");
      };
      currentExtensions[28] = (read3) => {
        if (!referenceMap) {
          referenceMap = /* @__PURE__ */ new Map();
          referenceMap.id = 0;
        }
        let id = referenceMap.id++;
        let token = src2[position];
        let target2;
        if (token >> 5 == 4)
          target2 = [];
        else
          target2 = {};
        let refEntry = { target: target2 };
        referenceMap.set(id, refEntry);
        let targetProperties = read3();
        if (refEntry.used)
          return Object.assign(target2, targetProperties);
        refEntry.target = targetProperties;
        return targetProperties;
      };
      currentExtensions[28].handlesRead = true;
      currentExtensions[29] = (id) => {
        let refEntry = referenceMap.get(id);
        refEntry.used = true;
        return refEntry.target;
      };
      currentExtensions[258] = (array2) => new Set(array2);
      (currentExtensions[259] = (read3) => {
        if (currentDecoder.mapsAsObjects) {
          currentDecoder.mapsAsObjects = false;
          restoreMapsAsObject = true;
        }
        return read3();
      }).handlesRead = true;
      function combine(a, b) {
        if (typeof a === "string")
          return a + b;
        if (a instanceof Array)
          return a.concat(b);
        return Object.assign({}, a, b);
      }
      function getPackedValues() {
        if (!packedValues) {
          if (currentDecoder.getShared)
            loadShared();
          else
            throw new Error("No packed values available");
        }
        return packedValues;
      }
      var SHARED_DATA_TAG_ID = 1399353956;
      currentExtensionRanges.push((tag, input) => {
        if (tag >= 225 && tag <= 255)
          return combine(getPackedValues().prefixes[tag - 224], input);
        if (tag >= 28704 && tag <= 32767)
          return combine(getPackedValues().prefixes[tag - 28672], input);
        if (tag >= 1879052288 && tag <= 2147483647)
          return combine(getPackedValues().prefixes[tag - 1879048192], input);
        if (tag >= 216 && tag <= 223)
          return combine(input, getPackedValues().suffixes[tag - 216]);
        if (tag >= 27647 && tag <= 28671)
          return combine(input, getPackedValues().suffixes[tag - 27639]);
        if (tag >= 1811940352 && tag <= 1879048191)
          return combine(input, getPackedValues().suffixes[tag - 1811939328]);
        if (tag == SHARED_DATA_TAG_ID) {
          return {
            packedValues,
            structures: currentStructures.slice(0),
            version: input
          };
        }
        if (tag == 55799)
          return input;
      });
      var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
      var typedArrays = [
        Uint8Array,
        Uint8ClampedArray,
        Uint16Array,
        Uint32Array,
        typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
        Int8Array,
        Int16Array,
        Int32Array,
        typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
        Float32Array,
        Float64Array
      ];
      var typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
      for (let i = 0; i < typedArrays.length; i++) {
        registerTypedArray(typedArrays[i], typedArrayTags[i]);
      }
      function registerTypedArray(TypedArray, tag) {
        let dvMethod = "get" + TypedArray.name.slice(0, -5);
        if (typeof TypedArray !== "function")
          TypedArray = null;
        let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
        for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
          if (!littleEndian && bytesPerElement == 1)
            continue;
          let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
          currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer2) => {
            if (!TypedArray)
              throw new Error("Could not find typed array for code " + tag);
            return new TypedArray(Uint8Array.prototype.slice.call(buffer2, 0).buffer);
          } : (buffer2) => {
            if (!TypedArray)
              throw new Error("Could not find typed array for code " + tag);
            let dv = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
            let elements = buffer2.length >> sizeShift;
            let ta = new TypedArray(elements);
            let method = dv[dvMethod];
            for (let i = 0; i < elements; i++) {
              ta[i] = method.call(dv, i << sizeShift, littleEndian);
            }
            return ta;
          };
        }
      }
      function readBundleExt() {
        let length2 = readJustLength();
        let bundlePosition = position + read2();
        for (let i = 2; i < length2; i++) {
          let bundleLength = readJustLength();
          position += bundleLength;
        }
        let dataPosition = position;
        position = bundlePosition;
        bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
        bundledStrings.position0 = 0;
        bundledStrings.position1 = 0;
        bundledStrings.postBundlePosition = position;
        position = dataPosition;
        return read2();
      }
      function readJustLength() {
        let token = src2[position++] & 31;
        if (token > 23) {
          switch (token) {
            case 24:
              token = src2[position++];
              break;
            case 25:
              token = dataView2.getUint16(position);
              position += 2;
              break;
            case 26:
              token = dataView2.getUint32(position);
              position += 4;
              break;
          }
        }
        return token;
      }
      function loadShared() {
        if (currentDecoder.getShared) {
          let sharedData = saveState(() => {
            src2 = null;
            return currentDecoder.getShared();
          }) || {};
          let updatedStructures = sharedData.structures || [];
          currentDecoder.sharedVersion = sharedData.version;
          packedValues = currentDecoder.sharedValues = sharedData.packedValues;
          if (currentStructures === true)
            currentDecoder.structures = currentStructures = updatedStructures;
          else
            currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
        }
      }
      function saveState(callback) {
        let savedSrcEnd = srcEnd;
        let savedPosition = position;
        let savedStringPosition = stringPosition;
        let savedSrcStringStart = srcStringStart;
        let savedSrcStringEnd = srcStringEnd;
        let savedSrcString = srcString;
        let savedStrings = strings;
        let savedReferenceMap = referenceMap;
        let savedBundledStrings = bundledStrings;
        let savedSrc = new Uint8Array(src2.slice(0, srcEnd));
        let savedStructures = currentStructures;
        let savedDecoder = currentDecoder;
        let savedSequentialMode = sequentialMode;
        let value = callback();
        srcEnd = savedSrcEnd;
        position = savedPosition;
        stringPosition = savedStringPosition;
        srcStringStart = savedSrcStringStart;
        srcStringEnd = savedSrcStringEnd;
        srcString = savedSrcString;
        strings = savedStrings;
        referenceMap = savedReferenceMap;
        bundledStrings = savedBundledStrings;
        src2 = savedSrc;
        sequentialMode = savedSequentialMode;
        currentStructures = savedStructures;
        currentDecoder = savedDecoder;
        dataView2 = new DataView(src2.buffer, src2.byteOffset, src2.byteLength);
        return value;
      }
      function clearSource() {
        src2 = null;
        referenceMap = null;
        currentStructures = null;
      }
      function addExtension(extension) {
        currentExtensions[extension.tag] = extension.decode;
      }
      var mult10 = new Array(147);
      for (let i = 0; i < 256; i++) {
        mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
      }
      var defaultDecoder = new Decoder2({ useRecords: false });
      var decode8 = defaultDecoder.decode;
      var decodeMultiple = defaultDecoder.decodeMultiple;
      var FLOAT32_OPTIONS = {
        NEVER: 0,
        ALWAYS: 1,
        DECIMAL_ROUND: 3,
        DECIMAL_FIT: 4
      };
      var textEncoder3;
      try {
        textEncoder3 = new TextEncoder();
      } catch (error) {
      }
      var extensions;
      var extensionClasses;
      var Buffer2 = globalThis.Buffer;
      var hasNodeBuffer = typeof Buffer2 !== "undefined";
      var ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;
      var ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;
      var MAX_STRUCTURES = 256;
      var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
      var throwOnIterable;
      var target;
      var targetView;
      var position2 = 0;
      var safeEnd;
      var bundledStrings2 = null;
      var MAX_BUNDLE_SIZE = 61440;
      var hasNonLatin = /[\u0080-\uFFFF]/;
      var RECORD_SYMBOL = Symbol("record-id");
      var Encoder2 = class extends Decoder2 {
        constructor(options) {
          super(options);
          this.offset = 0;
          let typeBuffer;
          let start;
          let sharedStructures;
          let hasSharedUpdate;
          let structures;
          let referenceMap2;
          options = options || {};
          let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string3, position3, maxBytes) {
            return target.utf8Write(string3, position3, maxBytes);
          } : textEncoder3 && textEncoder3.encodeInto ? function(string3, position3) {
            return textEncoder3.encodeInto(string3, target.subarray(position3)).written;
          } : false;
          let encoder = this;
          let hasSharedStructures = options.structures || options.saveStructures;
          let maxSharedStructures = options.maxSharedStructures;
          if (maxSharedStructures == null)
            maxSharedStructures = hasSharedStructures ? 128 : 0;
          if (maxSharedStructures > 8190)
            throw new Error("Maximum maxSharedStructure is 8190");
          let isSequential = options.sequential;
          if (isSequential) {
            maxSharedStructures = 0;
          }
          if (!this.structures)
            this.structures = [];
          if (this.saveStructures)
            this.saveShared = this.saveStructures;
          let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;
          let sharedPackedObjectMap2;
          if (sharedValues) {
            sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
            for (let i = 0, l = sharedValues.length; i < l; i++) {
              sharedPackedObjectMap2[sharedValues[i]] = i;
            }
          }
          let recordIdsToRemove = [];
          let transitionsCount = 0;
          let serializationsSinceTransitionRebuild = 0;
          this.mapEncode = function(value, encodeOptions2) {
            if (this._keyMap && !this._mapped) {
              switch (value.constructor.name) {
                case "Array":
                  value = value.map((r) => this.encodeKeys(r));
                  break;
              }
            }
            return this.encode(value, encodeOptions2);
          };
          this.encode = function(value, encodeOptions2) {
            if (!target) {
              target = new ByteArrayAllocate(8192);
              targetView = new DataView(target.buffer, 0, 8192);
              position2 = 0;
            }
            safeEnd = target.length - 10;
            if (safeEnd - position2 < 2048) {
              target = new ByteArrayAllocate(target.length);
              targetView = new DataView(target.buffer, 0, target.length);
              safeEnd = target.length - 10;
              position2 = 0;
            } else if (encodeOptions2 === REUSE_BUFFER_MODE)
              position2 = position2 + 7 & 2147483640;
            start = position2;
            if (encoder.useSelfDescribedHeader) {
              targetView.setUint32(position2, 3654940416);
              position2 += 3;
            }
            referenceMap2 = encoder.structuredClone ? /* @__PURE__ */ new Map() : null;
            if (encoder.bundleStrings && typeof value !== "string") {
              bundledStrings2 = [];
              bundledStrings2.size = Infinity;
            } else
              bundledStrings2 = null;
            sharedStructures = encoder.structures;
            if (sharedStructures) {
              if (sharedStructures.uninitialized) {
                let sharedData = encoder.getShared() || {};
                encoder.structures = sharedStructures = sharedData.structures || [];
                encoder.sharedVersion = sharedData.version;
                let sharedValues2 = encoder.sharedValues = sharedData.packedValues;
                if (sharedValues2) {
                  sharedPackedObjectMap2 = {};
                  for (let i = 0, l = sharedValues2.length; i < l; i++)
                    sharedPackedObjectMap2[sharedValues2[i]] = i;
                }
              }
              let sharedStructuresLength = sharedStructures.length;
              if (sharedStructuresLength > maxSharedStructures && !isSequential)
                sharedStructuresLength = maxSharedStructures;
              if (!sharedStructures.transitions) {
                sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
                for (let i = 0; i < sharedStructuresLength; i++) {
                  let keys = sharedStructures[i];
                  if (!keys)
                    continue;
                  let nextTransition, transition = sharedStructures.transitions;
                  for (let j = 0, l = keys.length; j < l; j++) {
                    if (transition[RECORD_SYMBOL] === void 0)
                      transition[RECORD_SYMBOL] = i;
                    let key = keys[j];
                    nextTransition = transition[key];
                    if (!nextTransition) {
                      nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                    }
                    transition = nextTransition;
                  }
                  transition[RECORD_SYMBOL] = i | 1048576;
                }
              }
              if (!isSequential)
                sharedStructures.nextId = sharedStructuresLength;
            }
            if (hasSharedUpdate)
              hasSharedUpdate = false;
            structures = sharedStructures || [];
            packedObjectMap2 = sharedPackedObjectMap2;
            if (options.pack) {
              let packedValues2 = /* @__PURE__ */ new Map();
              packedValues2.values = [];
              packedValues2.encoder = encoder;
              packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
              packedValues2.objectMap = sharedPackedObjectMap2 || false;
              packedValues2.samplingPackedValues = samplingPackedValues;
              findRepetitiveStrings(value, packedValues2);
              if (packedValues2.values.length > 0) {
                target[position2++] = 216;
                target[position2++] = 51;
                writeArrayHeader(4);
                let valuesArray = packedValues2.values;
                encode9(valuesArray);
                writeArrayHeader(0);
                writeArrayHeader(0);
                packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
                for (let i = 0, l = valuesArray.length; i < l; i++) {
                  packedObjectMap2[valuesArray[i]] = i;
                }
              }
            }
            throwOnIterable = encodeOptions2 & THROW_ON_ITERABLE;
            try {
              if (throwOnIterable)
                return;
              encode9(value);
              if (bundledStrings2) {
                writeBundles(start, encode9);
              }
              encoder.offset = position2;
              if (referenceMap2 && referenceMap2.idsToInsert) {
                position2 += referenceMap2.idsToInsert.length * 2;
                if (position2 > safeEnd)
                  makeRoom(position2);
                encoder.offset = position2;
                let serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);
                referenceMap2 = null;
                return serialized;
              }
              if (encodeOptions2 & REUSE_BUFFER_MODE) {
                target.start = start;
                target.end = position2;
                return target;
              }
              return target.subarray(start, position2);
            } finally {
              if (sharedStructures) {
                if (serializationsSinceTransitionRebuild < 10)
                  serializationsSinceTransitionRebuild++;
                if (sharedStructures.length > maxSharedStructures)
                  sharedStructures.length = maxSharedStructures;
                if (transitionsCount > 1e4) {
                  sharedStructures.transitions = null;
                  serializationsSinceTransitionRebuild = 0;
                  transitionsCount = 0;
                  if (recordIdsToRemove.length > 0)
                    recordIdsToRemove = [];
                } else if (recordIdsToRemove.length > 0 && !isSequential) {
                  for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
                    recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
                  }
                  recordIdsToRemove = [];
                }
              }
              if (hasSharedUpdate && encoder.saveShared) {
                if (encoder.structures.length > maxSharedStructures) {
                  encoder.structures = encoder.structures.slice(0, maxSharedStructures);
                }
                let returnBuffer = target.subarray(start, position2);
                if (encoder.updateSharedData() === false)
                  return encoder.encode(value);
                return returnBuffer;
              }
              if (encodeOptions2 & RESET_BUFFER_MODE)
                position2 = start;
            }
          };
          this.findCommonStringsToPack = () => {
            samplingPackedValues = /* @__PURE__ */ new Map();
            if (!sharedPackedObjectMap2)
              sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
            return (options2) => {
              let threshold = options2 && options2.threshold || 4;
              let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
              if (!sharedValues)
                sharedValues = this.sharedValues = [];
              for (let [key, status] of samplingPackedValues) {
                if (status.count > threshold) {
                  sharedPackedObjectMap2[key] = position3++;
                  sharedValues.push(key);
                  hasSharedUpdate = true;
                }
              }
              while (this.saveShared && this.updateSharedData() === false) {
              }
              samplingPackedValues = null;
            };
          };
          const encode9 = (value) => {
            if (position2 > safeEnd)
              target = makeRoom(position2);
            var type = typeof value;
            var length2;
            if (type === "string") {
              if (packedObjectMap2) {
                let packedPosition = packedObjectMap2[value];
                if (packedPosition >= 0) {
                  if (packedPosition < 16)
                    target[position2++] = packedPosition + 224;
                  else {
                    target[position2++] = 198;
                    if (packedPosition & 1)
                      encode9(15 - packedPosition >> 1);
                    else
                      encode9(packedPosition - 16 >> 1);
                  }
                  return;
                } else if (samplingPackedValues && !options.pack) {
                  let status = samplingPackedValues.get(value);
                  if (status)
                    status.count++;
                  else
                    samplingPackedValues.set(value, {
                      count: 1
                    });
                }
              }
              let strLength = value.length;
              if (bundledStrings2 && strLength >= 4 && strLength < 1024) {
                if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
                  let extStart;
                  let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
                  if (position2 + maxBytes2 > safeEnd)
                    target = makeRoom(position2 + maxBytes2);
                  target[position2++] = 217;
                  target[position2++] = 223;
                  target[position2++] = 249;
                  target[position2++] = bundledStrings2.position ? 132 : 130;
                  target[position2++] = 26;
                  extStart = position2 - start;
                  position2 += 4;
                  if (bundledStrings2.position) {
                    writeBundles(start, encode9);
                  }
                  bundledStrings2 = ["", ""];
                  bundledStrings2.size = 0;
                  bundledStrings2.position = extStart;
                }
                let twoByte = hasNonLatin.test(value);
                bundledStrings2[twoByte ? 0 : 1] += value;
                target[position2++] = twoByte ? 206 : 207;
                encode9(strLength);
                return;
              }
              let headerSize;
              if (strLength < 32) {
                headerSize = 1;
              } else if (strLength < 256) {
                headerSize = 2;
              } else if (strLength < 65536) {
                headerSize = 3;
              } else {
                headerSize = 5;
              }
              let maxBytes = strLength * 3;
              if (position2 + maxBytes > safeEnd)
                target = makeRoom(position2 + maxBytes);
              if (strLength < 64 || !encodeUtf8) {
                let i, c1, c2, strPosition = position2 + headerSize;
                for (i = 0; i < strLength; i++) {
                  c1 = value.charCodeAt(i);
                  if (c1 < 128) {
                    target[strPosition++] = c1;
                  } else if (c1 < 2048) {
                    target[strPosition++] = c1 >> 6 | 192;
                    target[strPosition++] = c1 & 63 | 128;
                  } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
                    c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                    i++;
                    target[strPosition++] = c1 >> 18 | 240;
                    target[strPosition++] = c1 >> 12 & 63 | 128;
                    target[strPosition++] = c1 >> 6 & 63 | 128;
                    target[strPosition++] = c1 & 63 | 128;
                  } else {
                    target[strPosition++] = c1 >> 12 | 224;
                    target[strPosition++] = c1 >> 6 & 63 | 128;
                    target[strPosition++] = c1 & 63 | 128;
                  }
                }
                length2 = strPosition - position2 - headerSize;
              } else {
                length2 = encodeUtf8(value, position2 + headerSize, maxBytes);
              }
              if (length2 < 24) {
                target[position2++] = 96 | length2;
              } else if (length2 < 256) {
                if (headerSize < 2) {
                  target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length2);
                }
                target[position2++] = 120;
                target[position2++] = length2;
              } else if (length2 < 65536) {
                if (headerSize < 3) {
                  target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length2);
                }
                target[position2++] = 121;
                target[position2++] = length2 >> 8;
                target[position2++] = length2 & 255;
              } else {
                if (headerSize < 5) {
                  target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length2);
                }
                target[position2++] = 122;
                targetView.setUint32(position2, length2);
                position2 += 4;
              }
              position2 += length2;
            } else if (type === "number") {
              if (value >>> 0 === value) {
                if (value < 24) {
                  target[position2++] = value;
                } else if (value < 256) {
                  target[position2++] = 24;
                  target[position2++] = value;
                } else if (value < 65536) {
                  target[position2++] = 25;
                  target[position2++] = value >> 8;
                  target[position2++] = value & 255;
                } else {
                  target[position2++] = 26;
                  targetView.setUint32(position2, value);
                  position2 += 4;
                }
              } else if (value >> 0 === value) {
                if (value >= -24) {
                  target[position2++] = 31 - value;
                } else if (value >= -256) {
                  target[position2++] = 56;
                  target[position2++] = ~value;
                } else if (value >= -65536) {
                  target[position2++] = 57;
                  targetView.setUint16(position2, ~value);
                  position2 += 2;
                } else {
                  target[position2++] = 58;
                  targetView.setUint32(position2, ~value);
                  position2 += 4;
                }
              } else {
                let useFloat32;
                if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
                  target[position2++] = 250;
                  targetView.setFloat32(position2, value);
                  let xShifted;
                  if (useFloat32 < 4 || (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
                    position2 += 4;
                    return;
                  } else
                    position2--;
                }
                target[position2++] = 251;
                targetView.setFloat64(position2, value);
                position2 += 8;
              }
            } else if (type === "object") {
              if (!value)
                target[position2++] = 246;
              else {
                if (referenceMap2) {
                  let referee = referenceMap2.get(value);
                  if (referee) {
                    target[position2++] = 216;
                    target[position2++] = 29;
                    target[position2++] = 25;
                    if (!referee.references) {
                      let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                      referee.references = [];
                      idsToInsert.push(referee);
                    }
                    referee.references.push(position2 - start);
                    position2 += 2;
                    return;
                  } else
                    referenceMap2.set(value, { offset: position2 - start });
                }
                let constructor = value.constructor;
                if (constructor === Object) {
                  writeObject(value, true);
                } else if (constructor === Array) {
                  length2 = value.length;
                  if (length2 < 24) {
                    target[position2++] = 128 | length2;
                  } else {
                    writeArrayHeader(length2);
                  }
                  for (let i = 0; i < length2; i++) {
                    encode9(value[i]);
                  }
                } else if (constructor === Map) {
                  if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                    target[position2++] = 217;
                    target[position2++] = 1;
                    target[position2++] = 3;
                  }
                  length2 = value.size;
                  if (length2 < 24) {
                    target[position2++] = 160 | length2;
                  } else if (length2 < 256) {
                    target[position2++] = 184;
                    target[position2++] = length2;
                  } else if (length2 < 65536) {
                    target[position2++] = 185;
                    target[position2++] = length2 >> 8;
                    target[position2++] = length2 & 255;
                  } else {
                    target[position2++] = 186;
                    targetView.setUint32(position2, length2);
                    position2 += 4;
                  }
                  if (encoder.keyMap) {
                    for (let [key, entryValue] of value) {
                      encode9(encoder.encodeKey(key));
                      encode9(entryValue);
                    }
                  } else {
                    for (let [key, entryValue] of value) {
                      encode9(key);
                      encode9(entryValue);
                    }
                  }
                } else {
                  for (let i = 0, l = extensions.length; i < l; i++) {
                    let extensionClass = extensionClasses[i];
                    if (value instanceof extensionClass) {
                      let extension = extensions[i];
                      let tag = extension.tag;
                      if (tag == void 0)
                        tag = extension.getTag && extension.getTag.call(this, value);
                      if (tag < 24) {
                        target[position2++] = 192 | tag;
                      } else if (tag < 256) {
                        target[position2++] = 216;
                        target[position2++] = tag;
                      } else if (tag < 65536) {
                        target[position2++] = 217;
                        target[position2++] = tag >> 8;
                        target[position2++] = tag & 255;
                      } else if (tag > -1) {
                        target[position2++] = 218;
                        targetView.setUint32(position2, tag);
                        position2 += 4;
                      }
                      extension.encode.call(this, value, encode9, makeRoom);
                      return;
                    }
                  }
                  if (value[Symbol.iterator]) {
                    if (throwOnIterable) {
                      let error = new Error("Iterable should be serialized as iterator");
                      error.iteratorNotHandled = true;
                      throw error;
                    }
                    target[position2++] = 159;
                    for (let entry of value) {
                      encode9(entry);
                    }
                    target[position2++] = 255;
                    return;
                  }
                  if (value[Symbol.asyncIterator] || isBlob(value)) {
                    let error = new Error("Iterable/blob should be serialized as iterator");
                    error.iteratorNotHandled = true;
                    throw error;
                  }
                  writeObject(value, !value.hasOwnProperty);
                }
              }
            } else if (type === "boolean") {
              target[position2++] = value ? 245 : 244;
            } else if (type === "bigint") {
              if (value < BigInt(1) << BigInt(64) && value >= 0) {
                target[position2++] = 27;
                targetView.setBigUint64(position2, value);
              } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
                target[position2++] = 59;
                targetView.setBigUint64(position2, -value - BigInt(1));
              } else {
                if (this.largeBigIntToFloat) {
                  target[position2++] = 251;
                  targetView.setFloat64(position2, Number(value));
                } else {
                  throw new RangeError(value + " was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");
                }
              }
              position2 += 8;
            } else if (type === "undefined") {
              target[position2++] = 247;
            } else {
              throw new Error("Unknown type: " + type);
            }
          };
          const writeObject = this.useRecords === false ? this.variableMapSize ? (object2) => {
            let keys = Object.keys(object2);
            let vals = Object.values(object2);
            let length2 = keys.length;
            if (length2 < 24) {
              target[position2++] = 160 | length2;
            } else if (length2 < 256) {
              target[position2++] = 184;
              target[position2++] = length2;
            } else if (length2 < 65536) {
              target[position2++] = 185;
              target[position2++] = length2 >> 8;
              target[position2++] = length2 & 255;
            } else {
              target[position2++] = 186;
              targetView.setUint32(position2, length2);
              position2 += 4;
            }
            let key;
            if (encoder.keyMap) {
              for (let i = 0; i < length2; i++) {
                encode9(encodeKey(keys[i]));
                encode9(vals[i]);
              }
            } else {
              for (let i = 0; i < length2; i++) {
                encode9(keys[i]);
                encode9(vals[i]);
              }
            }
          } : (object2, safePrototype) => {
            target[position2++] = 185;
            let objectOffset = position2 - start;
            position2 += 2;
            let size = 0;
            if (encoder.keyMap) {
              for (let key in object2)
                if (safePrototype || object2.hasOwnProperty(key)) {
                  encode9(encoder.encodeKey(key));
                  encode9(object2[key]);
                  size++;
                }
            } else {
              for (let key in object2)
                if (safePrototype || object2.hasOwnProperty(key)) {
                  encode9(key);
                  encode9(object2[key]);
                  size++;
                }
            }
            target[objectOffset++ + start] = size >> 8;
            target[objectOffset + start] = size & 255;
          } : (object2, safePrototype) => {
            let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
            let newTransitions = 0;
            let length2 = 0;
            let parentRecordId;
            let keys;
            if (this.keyMap) {
              keys = Object.keys(object2).map((k) => this.encodeKey(k));
              length2 = keys.length;
              for (let i = 0; i < length2; i++) {
                let key = keys[i];
                nextTransition = transition[key];
                if (!nextTransition) {
                  nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
              }
            } else {
              for (let key in object2)
                if (safePrototype || object2.hasOwnProperty(key)) {
                  nextTransition = transition[key];
                  if (!nextTransition) {
                    if (transition[RECORD_SYMBOL] & 1048576) {
                      parentRecordId = transition[RECORD_SYMBOL] & 65535;
                    }
                    nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                    newTransitions++;
                  }
                  transition = nextTransition;
                  length2++;
                }
            }
            let recordId = transition[RECORD_SYMBOL];
            if (recordId !== void 0) {
              recordId &= 65535;
              target[position2++] = 217;
              target[position2++] = recordId >> 8 | 224;
              target[position2++] = recordId & 255;
            } else {
              if (!keys)
                keys = transition.__keys__ || (transition.__keys__ = Object.keys(object2));
              if (parentRecordId === void 0) {
                recordId = structures.nextId++;
                if (!recordId) {
                  recordId = 0;
                  structures.nextId = 1;
                }
                if (recordId >= MAX_STRUCTURES) {
                  structures.nextId = (recordId = maxSharedStructures) + 1;
                }
              } else {
                recordId = parentRecordId;
              }
              structures[recordId] = keys;
              if (recordId < maxSharedStructures) {
                target[position2++] = 217;
                target[position2++] = recordId >> 8 | 224;
                target[position2++] = recordId & 255;
                transition = structures.transitions;
                for (let i = 0; i < length2; i++) {
                  if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
                    transition[RECORD_SYMBOL] = recordId;
                  transition = transition[keys[i]];
                }
                transition[RECORD_SYMBOL] = recordId | 1048576;
                hasSharedUpdate = true;
              } else {
                transition[RECORD_SYMBOL] = recordId;
                targetView.setUint32(position2, 3655335680);
                position2 += 3;
                if (newTransitions)
                  transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
                if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
                  recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
                recordIdsToRemove.push(transition);
                writeArrayHeader(length2 + 2);
                encode9(57344 + recordId);
                encode9(keys);
                if (safePrototype === null)
                  return;
                for (let key in object2)
                  if (safePrototype || object2.hasOwnProperty(key))
                    encode9(object2[key]);
                return;
              }
            }
            if (length2 < 24) {
              target[position2++] = 128 | length2;
            } else {
              writeArrayHeader(length2);
            }
            if (safePrototype === null)
              return;
            for (let key in object2)
              if (safePrototype || object2.hasOwnProperty(key))
                encode9(object2[key]);
          };
          const makeRoom = (end) => {
            let newSize;
            if (end > 16777216) {
              if (end - start > MAX_BUFFER_SIZE)
                throw new Error("Encoded buffer would be larger than maximum buffer size");
              newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
            } else
              newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
            let newBuffer = new ByteArrayAllocate(newSize);
            targetView = new DataView(newBuffer.buffer, 0, newSize);
            if (target.copy)
              target.copy(newBuffer, 0, start, end);
            else
              newBuffer.set(target.slice(start, end));
            position2 -= start;
            start = 0;
            safeEnd = newBuffer.length - 10;
            return target = newBuffer;
          };
          let chunkThreshold = 100;
          let continuedChunkThreshold = 1e3;
          this.encodeAsIterable = function(value, options2) {
            return startEncoding(value, options2, encodeObjectAsIterable);
          };
          this.encodeAsAsyncIterable = function(value, options2) {
            return startEncoding(value, options2, encodeObjectAsAsyncIterable);
          };
          function* encodeObjectAsIterable(object2, iterateProperties, finalIterable) {
            let constructor = object2.constructor;
            if (constructor === Object) {
              let useRecords = encoder.useRecords !== false;
              if (useRecords)
                writeObject(object2, null);
              else
                writeEntityLength(Object.keys(object2).length, 160);
              for (let key in object2) {
                let value = object2[key];
                if (!useRecords)
                  encode9(key);
                if (value && typeof value === "object") {
                  if (iterateProperties[key])
                    yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties[key]));
                  else
                    yield* __yieldStar(tryEncode(value, iterateProperties, key));
                } else
                  encode9(value);
              }
            } else if (constructor === Array) {
              let length2 = object2.length;
              writeArrayHeader(length2);
              for (let i = 0; i < length2; i++) {
                let value = object2[i];
                if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
                  if (iterateProperties.element)
                    yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties.element));
                  else
                    yield* __yieldStar(tryEncode(value, iterateProperties, "element"));
                } else
                  encode9(value);
              }
            } else if (object2[Symbol.iterator]) {
              target[position2++] = 159;
              for (let value of object2) {
                if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
                  if (iterateProperties.element)
                    yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties.element));
                  else
                    yield* __yieldStar(tryEncode(value, iterateProperties, "element"));
                } else
                  encode9(value);
              }
              target[position2++] = 255;
            } else if (isBlob(object2)) {
              writeEntityLength(object2.size, 64);
              yield target.subarray(start, position2);
              yield object2;
              restartEncoding();
            } else if (object2[Symbol.asyncIterator]) {
              target[position2++] = 159;
              yield target.subarray(start, position2);
              yield object2;
              restartEncoding();
              target[position2++] = 255;
            } else {
              encode9(object2);
            }
            if (finalIterable && position2 > start)
              yield target.subarray(start, position2);
            else if (position2 - start > chunkThreshold) {
              yield target.subarray(start, position2);
              restartEncoding();
            }
          }
          function* tryEncode(value, iterateProperties, key) {
            let restart = position2 - start;
            try {
              encode9(value);
              if (position2 - start > chunkThreshold) {
                yield target.subarray(start, position2);
                restartEncoding();
              }
            } catch (error) {
              if (error.iteratorNotHandled) {
                iterateProperties[key] = {};
                position2 = start + restart;
                yield* __yieldStar(encodeObjectAsIterable.call(this, value, iterateProperties[key]));
              } else
                throw error;
            }
          }
          function restartEncoding() {
            chunkThreshold = continuedChunkThreshold;
            encoder.encode(null, THROW_ON_ITERABLE);
          }
          function startEncoding(value, options2, encodeIterable) {
            if (options2 && options2.chunkThreshold)
              chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
            else
              chunkThreshold = 100;
            if (value && typeof value === "object") {
              encoder.encode(null, THROW_ON_ITERABLE);
              return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
            }
            return [encoder.encode(value)];
          }
          function encodeObjectAsAsyncIterable(value, iterateProperties) {
            return __asyncGenerator(this, null, function* () {
              for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
                let constructor = encodedValue.constructor;
                if (constructor === ByteArray || constructor === Uint8Array)
                  yield encodedValue;
                else if (isBlob(encodedValue)) {
                  let reader = encodedValue.stream().getReader();
                  let next;
                  while (!(next = yield new __await(reader.read())).done) {
                    yield next.value;
                  }
                } else if (encodedValue[Symbol.asyncIterator]) {
                  try {
                    for (var iter = __forAwait(encodedValue), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                      let asyncValue = temp.value;
                      restartEncoding();
                      if (asyncValue)
                        yield* __yieldStar(encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {})));
                      else
                        yield encoder.encode(asyncValue);
                    }
                  } catch (temp) {
                    error = [temp];
                  } finally {
                    try {
                      more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                    } finally {
                      if (error)
                        throw error[0];
                    }
                  }
                } else {
                  yield encodedValue;
                }
              }
            });
          }
        }
        useBuffer(buffer2) {
          target = buffer2;
          targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
          position2 = 0;
        }
        clearSharedData() {
          if (this.structures)
            this.structures = [];
          if (this.sharedValues)
            this.sharedValues = void 0;
        }
        updateSharedData() {
          let lastVersion = this.sharedVersion || 0;
          this.sharedVersion = lastVersion + 1;
          let structuresCopy = this.structures.slice(0);
          let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
          let saveResults = this.saveShared(sharedData, (existingShared) => (existingShared && existingShared.version || 0) == lastVersion);
          if (saveResults === false) {
            sharedData = this.getShared() || {};
            this.structures = sharedData.structures || [];
            this.sharedValues = sharedData.packedValues;
            this.sharedVersion = sharedData.version;
            this.structures.nextId = this.structures.length;
          } else {
            structuresCopy.forEach((structure, i) => this.structures[i] = structure);
          }
          return saveResults;
        }
      };
      function writeEntityLength(length2, majorValue) {
        if (length2 < 24)
          target[position2++] = majorValue | length2;
        else if (length2 < 256) {
          target[position2++] = majorValue | 24;
          target[position2++] = length2;
        } else if (length2 < 65536) {
          target[position2++] = majorValue | 25;
          target[position2++] = length2 >> 8;
          target[position2++] = length2 & 255;
        } else {
          target[position2++] = majorValue | 26;
          targetView.setUint32(position2, length2);
          position2 += 4;
        }
      }
      var SharedData = class {
        constructor(structures, values, version2) {
          this.structures = structures;
          this.packedValues = values;
          this.version = version2;
        }
      };
      function writeArrayHeader(length2) {
        if (length2 < 24)
          target[position2++] = 128 | length2;
        else if (length2 < 256) {
          target[position2++] = 152;
          target[position2++] = length2;
        } else if (length2 < 65536) {
          target[position2++] = 153;
          target[position2++] = length2 >> 8;
          target[position2++] = length2 & 255;
        } else {
          target[position2++] = 154;
          targetView.setUint32(position2, length2);
          position2 += 4;
        }
      }
      var BlobConstructor = typeof Blob === "undefined" ? function() {
      } : Blob;
      function isBlob(object2) {
        if (object2 instanceof BlobConstructor)
          return true;
        let tag = object2[Symbol.toStringTag];
        return tag === "Blob" || tag === "File";
      }
      function findRepetitiveStrings(value, packedValues2) {
        switch (typeof value) {
          case "string":
            if (value.length > 3) {
              if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
                return;
              let packedStatus = packedValues2.get(value);
              if (packedStatus) {
                if (++packedStatus.count == 2) {
                  packedValues2.values.push(value);
                }
              } else {
                packedValues2.set(value, {
                  count: 1
                });
                if (packedValues2.samplingPackedValues) {
                  let status = packedValues2.samplingPackedValues.get(value);
                  if (status)
                    status.count++;
                  else
                    packedValues2.samplingPackedValues.set(value, {
                      count: 1
                    });
                }
              }
            }
            break;
          case "object":
            if (value) {
              if (value instanceof Array) {
                for (let i = 0, l = value.length; i < l; i++) {
                  findRepetitiveStrings(value[i], packedValues2);
                }
              } else {
                let includeKeys = !packedValues2.encoder.useRecords;
                for (var key in value) {
                  if (value.hasOwnProperty(key)) {
                    if (includeKeys)
                      findRepetitiveStrings(key, packedValues2);
                    findRepetitiveStrings(value[key], packedValues2);
                  }
                }
              }
            }
            break;
          case "function":
            console.log(value);
        }
      }
      var isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
      extensionClasses = [
        Date,
        Set,
        Error,
        RegExp,
        Tag,
        ArrayBuffer,
        Uint8Array,
        Uint8ClampedArray,
        Uint16Array,
        Uint32Array,
        typeof BigUint64Array == "undefined" ? function() {
        } : BigUint64Array,
        Int8Array,
        Int16Array,
        Int32Array,
        typeof BigInt64Array == "undefined" ? function() {
        } : BigInt64Array,
        Float32Array,
        Float64Array,
        SharedData
      ];
      extensions = [
        {
          tag: 1,
          encode(date, encode9) {
            let seconds = date.getTime() / 1e3;
            if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
              target[position2++] = 26;
              targetView.setUint32(position2, seconds);
              position2 += 4;
            } else {
              target[position2++] = 251;
              targetView.setFloat64(position2, seconds);
              position2 += 8;
            }
          }
        },
        {
          tag: 258,
          encode(set, encode9) {
            let array2 = Array.from(set);
            encode9(array2);
          }
        },
        {
          tag: 27,
          encode(error, encode9) {
            encode9([error.name, error.message]);
          }
        },
        {
          tag: 27,
          encode(regex, encode9) {
            encode9(["RegExp", regex.source, regex.flags]);
          }
        },
        {
          getTag(tag) {
            return tag.tag;
          },
          encode(tag, encode9) {
            encode9(tag.value);
          }
        },
        {
          encode(arrayBuffer, encode9, makeRoom) {
            writeBuffer(arrayBuffer, makeRoom);
          }
        },
        {
          getTag(typedArray) {
            if (typedArray.constructor === Uint8Array) {
              if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
                return 64;
            }
          },
          encode(typedArray, encode9, makeRoom) {
            writeBuffer(typedArray, makeRoom);
          }
        },
        typedArrayEncoder(68, 1),
        typedArrayEncoder(69, 2),
        typedArrayEncoder(70, 4),
        typedArrayEncoder(71, 8),
        typedArrayEncoder(72, 1),
        typedArrayEncoder(77, 2),
        typedArrayEncoder(78, 4),
        typedArrayEncoder(79, 8),
        typedArrayEncoder(85, 4),
        typedArrayEncoder(86, 8),
        {
          encode(sharedData, encode9) {
            let packedValues2 = sharedData.packedValues || [];
            let sharedStructures = sharedData.structures || [];
            if (packedValues2.values.length > 0) {
              target[position2++] = 216;
              target[position2++] = 51;
              writeArrayHeader(4);
              let valuesArray = packedValues2.values;
              encode9(valuesArray);
              writeArrayHeader(0);
              writeArrayHeader(0);
              packedObjectMap = Object.create(sharedPackedObjectMap || null);
              for (let i = 0, l = valuesArray.length; i < l; i++) {
                packedObjectMap[valuesArray[i]] = i;
              }
            }
            if (sharedStructures) {
              targetView.setUint32(position2, 3655335424);
              position2 += 3;
              let definitions = sharedStructures.slice(0);
              definitions.unshift(57344);
              definitions.push(new Tag(sharedData.version, 1399353956));
              encode9(definitions);
            } else
              encode9(new Tag(sharedData.version, 1399353956));
          }
        }
      ];
      function typedArrayEncoder(tag, size) {
        if (!isLittleEndianMachine2 && size > 1)
          tag -= 4;
        return {
          tag,
          encode: function writeExtBuffer(typedArray, encode9) {
            let length2 = typedArray.byteLength;
            let offset = typedArray.byteOffset || 0;
            let buffer2 = typedArray.buffer || typedArray;
            encode9(hasNodeBuffer ? Buffer2.from(buffer2, offset, length2) : new Uint8Array(buffer2, offset, length2));
          }
        };
      }
      function writeBuffer(buffer2, makeRoom) {
        let length2 = buffer2.byteLength;
        if (length2 < 24) {
          target[position2++] = 64 + length2;
        } else if (length2 < 256) {
          target[position2++] = 88;
          target[position2++] = length2;
        } else if (length2 < 65536) {
          target[position2++] = 89;
          target[position2++] = length2 >> 8;
          target[position2++] = length2 & 255;
        } else {
          target[position2++] = 90;
          targetView.setUint32(position2, length2);
          position2 += 4;
        }
        if (position2 + length2 >= target.length) {
          makeRoom(position2 + length2);
        }
        target.set(buffer2.buffer ? buffer2 : new Uint8Array(buffer2), position2);
        position2 += length2;
      }
      function insertIds(serialized, idsToInsert) {
        let nextId;
        let distanceToMove = idsToInsert.length * 2;
        let lastEnd = serialized.length - distanceToMove;
        idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
        for (let id = 0; id < idsToInsert.length; id++) {
          let referee = idsToInsert[id];
          referee.id = id;
          for (let position3 of referee.references) {
            serialized[position3++] = id >> 8;
            serialized[position3] = id & 255;
          }
        }
        while (nextId = idsToInsert.pop()) {
          let offset = nextId.offset;
          serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
          distanceToMove -= 2;
          let position3 = offset + distanceToMove;
          serialized[position3++] = 216;
          serialized[position3++] = 28;
          lastEnd = offset;
        }
        return serialized;
      }
      function writeBundles(start, encode9) {
        targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);
        let writeStrings = bundledStrings2;
        bundledStrings2 = null;
        encode9(writeStrings[0]);
        encode9(writeStrings[1]);
      }
      function addExtension2(extension) {
        if (extension.Class) {
          if (!extension.encode)
            throw new Error("Extension has no encode function");
          extensionClasses.unshift(extension.Class);
          extensions.unshift(extension);
        }
        addExtension(extension);
      }
      var defaultEncoder = new Encoder2({ useRecords: false });
      var encode8 = defaultEncoder.encode;
      var encodeAsIterable = defaultEncoder.encodeAsIterable;
      var encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
      var { NEVER: NEVER2, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
      var REUSE_BUFFER_MODE = 512;
      var RESET_BUFFER_MODE = 1024;
      var THROW_ON_ITERABLE = 2048;
      var import_module = __require("module");
      var import_meta = {};
      var nativeAccelerationDisabled = process.env.CBOR_NATIVE_ACCELERATION_DISABLED !== void 0 && process.env.CBOR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === "true";
      if (!nativeAccelerationDisabled) {
        let extractor;
        try {
          if (typeof __require == "function")
            extractor = require_cbor_extract();
          else
            extractor = (0, import_module.createRequire)(import_meta.url)("cbor-extract");
          if (extractor)
            setExtractor(extractor.extractStrings);
        } catch (error) {
        }
      }
      addExtension2({
        Class: CID,
        tag: 42,
        encode: () => {
          throw new Error("cannot encode cids");
        },
        decode: (bytes3) => {
          if (bytes3[0] !== 0) {
            throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
          }
          return CID.decode(bytes3.subarray(1));
        }
      });
      var import_pino = __toESM2(require_pino());
      var allSystemsEnabled = !process.env.LOG_SYSTEMS;
      var enabledSystems = (process.env.LOG_SYSTEMS || "").replace(",", " ").split(" ");
      var enabledEnv = process.env.LOG_ENABLED;
      var enabled = enabledEnv === "true" || enabledEnv === "t" || enabledEnv === "1";
      var level = process.env.LOG_LEVEL || "info";
      var config = {
        enabled,
        level
      };
      var rootLogger = process.env.LOG_DESTINATION ? (0, import_pino.default)(config, import_pino.default.destination(process.env.LOG_DESTINATION)) : (0, import_pino.default)(config);
      var subsystems = {};
      var subsystemLogger = (name3) => {
        if (subsystems[name3])
          return subsystems[name3];
        const subsystemEnabled = enabled && (allSystemsEnabled || enabledSystems.indexOf(name3) > -1);
        subsystems[name3] = rootLogger.child({ name: name3 }, { level: subsystemEnabled ? level : "silent" });
        return subsystems[name3];
      };
      var import_stream2 = __require("stream");
      var byteIterableToStream = (iter) => {
        return import_stream2.Readable.from(iter, { objectMode: false });
      };
      var BlockMap = class {
        constructor() {
          this.map = /* @__PURE__ */ new Map();
        }
        add(value) {
          return __async(this, null, function* () {
            const block = yield dataToCborBlock(lexToIpld(value));
            this.set(block.cid, block.bytes);
            return block.cid;
          });
        }
        set(cid2, bytes3) {
          this.map.set(cid2.toString(), bytes3);
        }
        get(cid2) {
          return this.map.get(cid2.toString());
        }
        delete(cid2) {
          this.map.delete(cid2.toString());
        }
        getMany(cids) {
          const missing = [];
          const blocks = new BlockMap();
          for (const cid2 of cids) {
            const got = this.map.get(cid2.toString());
            if (got) {
              blocks.set(cid2, got);
            } else {
              missing.push(cid2);
            }
          }
          return { blocks, missing };
        }
        has(cid2) {
          return this.map.has(cid2.toString());
        }
        clear() {
          this.map.clear();
        }
        forEach(cb) {
          this.map.forEach((val, key) => cb(val, CID.parse(key)));
        }
        entries() {
          const entries = [];
          this.forEach((bytes3, cid2) => {
            entries.push({ cid: cid2, bytes: bytes3 });
          });
          return entries;
        }
        cids() {
          return this.entries().map((e) => e.cid);
        }
        addMap(toAdd) {
          toAdd.forEach((bytes3, cid2) => {
            this.set(cid2, bytes3);
          });
        }
        get size() {
          return this.map.size;
        }
        get byteSize() {
          let size = 0;
          this.forEach((bytes3) => {
            size += bytes3.length;
          });
          return size;
        }
        equals(other) {
          if (this.size !== other.size) {
            return false;
          }
          for (const entry of this.entries()) {
            const otherBytes = other.get(entry.cid);
            if (!otherBytes)
              return false;
            if (!equals3(entry.bytes, otherBytes)) {
              return false;
            }
          }
          return true;
        }
      };
      var block_map_default = BlockMap;
      var CidSet = class {
        constructor(arr = []) {
          const strArr = arr.map((c) => c.toString());
          this.set = new Set(strArr);
        }
        add(cid2) {
          this.set.add(cid2.toString());
          return this;
        }
        addSet(toMerge) {
          toMerge.toList().map((c) => this.add(c));
          return this;
        }
        subtractSet(toSubtract) {
          toSubtract.toList().map((c) => this.delete(c));
          return this;
        }
        delete(cid2) {
          this.set.delete(cid2.toString());
          return this;
        }
        has(cid2) {
          return this.set.has(cid2.toString());
        }
        size() {
          return this.set.size;
        }
        clear() {
          this.set.clear();
          return this;
        }
        toList() {
          return [...this.set].map((c) => CID.parse(c));
        }
      };
      var cid_set_default = CidSet;
      var unsignedCommit = z.object({
        did: z.string(),
        version: z.literal(3),
        data: schema.cid,
        rev: z.string(),
        prev: schema.cid.nullable().optional()
      });
      var commit = z.object({
        did: z.string(),
        version: z.literal(3),
        data: schema.cid,
        rev: z.string(),
        prev: schema.cid.nullable().optional(),
        sig: schema.bytes
      });
      var legacyV2Commit = z.object({
        did: z.string(),
        version: z.literal(2),
        data: schema.cid,
        rev: z.string().optional(),
        prev: schema.cid.nullable(),
        sig: schema.bytes
      });
      var versionedCommit = z.discriminatedUnion("version", [
        commit,
        legacyV2Commit
      ]);
      var schema2 = __spreadProps(__spreadValues({}, schema), {
        commit,
        legacyV2Commit,
        versionedCommit
      });
      var def2 = __spreadProps(__spreadValues({}, def), {
        commit: {
          name: "commit",
          schema: schema2.commit
        },
        versionedCommit: {
          name: "versioned_commit",
          schema: schema2.versionedCommit
        }
      });
      var WriteOpAction = /* @__PURE__ */ ((WriteOpAction2) => {
        WriteOpAction2["Create"] = "create";
        WriteOpAction2["Update"] = "update";
        WriteOpAction2["Delete"] = "delete";
        return WriteOpAction2;
      })(WriteOpAction || {});
      var util_exports2 = {};
      __export(util_exports2, {
        InvalidMstKeyError: () => InvalidMstKeyError,
        cidForEntries: () => cidForEntries,
        countPrefixLen: () => countPrefixLen,
        deserializeNodeData: () => deserializeNodeData,
        ensureValidMstKey: () => ensureValidMstKey,
        isValidChars: () => isValidChars,
        isValidMstKey: () => isValidMstKey,
        layerForEntries: () => layerForEntries,
        leadingZerosOnHash: () => leadingZerosOnHash,
        serializeNodeData: () => serializeNodeData,
        validCharsRegex: () => validCharsRegex
      });
      var P256_DID_PREFIX = new Uint8Array([128, 36]);
      var SECP256K1_DID_PREFIX = new Uint8Array([231, 1]);
      var BASE58_MULTIBASE_PREFIX = "z";
      var DID_KEY_PREFIX = "did:key:";
      var P256_JWT_ALG = "ES256";
      var SECP256K1_JWT_ALG = "ES256K";
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      function bytes2(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function output(out, instance) {
        bytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      var assert = {
        number,
        bool,
        bytes: bytes2,
        hash,
        exists,
        output
      };
      var assert_default = assert;
      var nc = __toESM2(__require("node:crypto"), 1);
      var crypto2 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;
      var u8a = (a) => a instanceof Uint8Array;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
      function utf8ToBytes2(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      function toBytes(data) {
        if (typeof data === "string")
          data = utf8ToBytes2(data);
        if (!u8a(data))
          throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
      }
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad);
          pad += a.length;
        });
        return r;
      }
      var Hash = class {
        clone() {
          return this._cloneInto();
        }
      };
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      function randomBytes(bytesLength = 32) {
        if (crypto2 && typeof crypto2.getRandomValues === "function") {
          return crypto2.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      var HMAC = class extends Hash {
        constructor(hash2, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          assert_default.hash(hash2);
          const key = toBytes(_key);
          this.iHash = hash2.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54;
          this.iHash.update(pad);
          this.oHash = hash2.create();
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54 ^ 92;
          this.oHash.update(pad);
          pad.fill(0);
        }
        update(buf2) {
          assert_default.exists(this);
          this.iHash.update(buf2);
          return this;
        }
        digestInto(out) {
          assert_default.exists(this);
          assert_default.bytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
      hmac.create = (hash2, key) => new HMAC(hash2, key);
      var utils_exports = {};
      __export(utils_exports, {
        bitGet: () => bitGet,
        bitLen: () => bitLen,
        bitMask: () => bitMask,
        bitSet: () => bitSet,
        bytesToHex: () => bytesToHex,
        bytesToNumberBE: () => bytesToNumberBE,
        bytesToNumberLE: () => bytesToNumberLE,
        concatBytes: () => concatBytes2,
        createHmacDrbg: () => createHmacDrbg,
        ensureBytes: () => ensureBytes,
        equalBytes: () => equalBytes,
        hexToBytes: () => hexToBytes,
        hexToNumber: () => hexToNumber,
        numberToBytesBE: () => numberToBytesBE,
        numberToBytesLE: () => numberToBytesLE,
        numberToHexUnpadded: () => numberToHexUnpadded,
        numberToVarBytesBE: () => numberToVarBytesBE,
        utf8ToBytes: () => utf8ToBytes3,
        validateObject: () => validateObject
      });
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var u8a2 = (a) => a instanceof Uint8Array;
      var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes3) {
        if (!u8a2(bytes3))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes3.length; i++) {
          hex += hexes2[bytes3[i]];
        }
        return hex;
      }
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      function hexToNumber(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array2 = new Uint8Array(len / 2);
        for (let i = 0; i < array2.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array2[i] = byte;
        }
        return array2;
      }
      function bytesToNumberBE(bytes3) {
        return hexToNumber(bytesToHex(bytes3));
      }
      function bytesToNumberLE(bytes3) {
        if (!u8a2(bytes3))
          throw new Error("Uint8Array expected");
        return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
      }
      function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, "0"));
      }
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
      }
      function ensureBytes(title, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes(hex);
          } catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (u8a2(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      function concatBytes2(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad = 0;
        arrays.forEach((a) => {
          if (!u8a2(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad);
          pad += a.length;
        });
        return r;
      }
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length)
          return false;
        for (let i = 0; i < b1.length; i++)
          if (b1[i] !== b2[i])
            return false;
        return true;
      }
      function utf8ToBytes3(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      var u8n = (data) => new Uint8Array(data);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
          }
          return concatBytes2(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object2) => object2.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object2, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object2[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object2)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object2;
      }
      var _0n2 = BigInt(0);
      var _1n2 = BigInt(1);
      var _2n2 = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var _9n = BigInt(9);
      var _16n = BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n2 ? result : b + result;
      }
      function pow(num, power, modulo) {
        if (modulo <= _0n2 || power < _0n2)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n2)
          return _0n2;
        let res = _1n2;
        while (power > _0n2) {
          if (power & _1n2)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n2;
        }
        return res;
      }
      function pow2(x, power, modulo) {
        let res = x;
        while (power-- > _0n2) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      function invert(number2, modulo) {
        if (number2 === _0n2 || modulo <= _0n2) {
          throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
        }
        let a = mod(number2, modulo);
        let b = modulo;
        let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
        while (a !== _0n2) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n2)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      function tonelliShanks(P) {
        const legendreC = (P - _1n2) / _2n2;
        let Q, S, Z;
        for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
          ;
        for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n2) / _4n;
          return function tonelliFast(Fp3, n) {
            const root = Fp3.pow(n, p1div4);
            if (!Fp3.eql(Fp3.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        const Q1div2 = (Q + _1n2) / _2n2;
        return function tonelliSlow(Fp3, n) {
          if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
          let x = Fp3.pow(n, Q1div2);
          let b = Fp3.pow(n, Q);
          while (!Fp3.eql(b, Fp3.ONE)) {
            if (Fp3.eql(b, Fp3.ZERO))
              return Fp3.ZERO;
            let m = 1;
            for (let t2 = Fp3.sqr(b); m < r; m++) {
              if (Fp3.eql(t2, Fp3.ONE))
                break;
              t2 = Fp3.sqr(t2);
            }
            const ge = Fp3.pow(g, _1n2 << BigInt(r - m - 1));
            g = Fp3.sqr(ge);
            x = Fp3.mul(x, ge);
            b = Fp3.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      function FpSqrt(P) {
        if (P % _4n === _3n) {
          const p1div4 = (P + _1n2) / _4n;
          return function sqrt3mod4(Fp3, n) {
            const root = Fp3.pow(n, p1div4);
            if (!Fp3.eql(Fp3.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        if (P % _8n === _5n) {
          const c1 = (P - _5n) / _8n;
          return function sqrt5mod8(Fp3, n) {
            const n2 = Fp3.mul(n, _2n2);
            const v = Fp3.pow(n2, c1);
            const nv = Fp3.mul(n, v);
            const i = Fp3.mul(Fp3.mul(nv, _2n2), v);
            const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
            if (!Fp3.eql(Fp3.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        if (P % _16n === _9n) {
        }
        return tonelliShanks(P);
      }
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS.reduce((map, val) => {
          map[val] = "function";
          return map;
        }, initial);
        return validateObject(field, opts);
      }
      function FpPow(f, num, power) {
        if (power < _0n2)
          throw new Error("Expected power > 0");
        if (power === _0n2)
          return f.ONE;
        if (power === _1n2)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n2) {
          if (power & _1n2)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n2;
        }
        return p;
      }
      function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      function nLength(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
        if (ORDER <= _0n2)
          throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: bitMask(BITS),
          ZERO: _0n2,
          ONE: _1n2,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n2 <= num && num < ORDER;
          },
          is0: (num) => num === _0n2,
          isOdd: (num) => (num & _1n2) === _1n2,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch(f, lst),
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
          fromBytes: (bytes3) => {
            if (bytes3.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
            return isLE2 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
          }
        });
        return Object.freeze(f);
      }
      function hashToPrivateScalar(hash2, groupOrder, isLE2 = false) {
        hash2 = ensureBytes("privateHash", hash2);
        const hashLen = hash2.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE2 ? bytesToNumberLE(hash2) : bytesToNumberBE(hash2);
        return mod(num, groupOrder - _1n2) + _1n2;
      }
      var _0n3 = BigInt(0);
      var _1n3 = BigInt(1);
      function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = __pow(2, W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate,
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n3) {
              if (n & _1n3)
                p = p.add(d);
              d = d.double();
              n >>= _1n3;
            }
            return p;
          },
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base3 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base3 = p;
              points.push(base3);
              for (let i = 1; i < windowSize; i++) {
                base3 = base3.add(p);
                points.push(base3);
              }
              p = base3.double();
            }
            return points;
          },
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(__pow(2, W) - 1);
            const maxNumber = __pow(2, W);
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n3;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      function validateBasic(curve) {
        validateField(curve.Fp);
        validateObject(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze(__spreadValues(__spreadValues(__spreadValues({}, nLength(curve.n, curve.nBitLength)), curve), { p: curve.Fp.ORDER }));
      }
      function validatePointOpts(curve) {
        const opts = validateBasic(curve);
        validateObject(opts, {
          a: "field",
          b: "field"
        }, {
          allowedPrivateKeyLengths: "array",
          wrapPrivateKey: "boolean",
          isTorsionFree: "function",
          clearCofactor: "function",
          allowInfinityPoint: "boolean",
          fromBytes: "function",
          toBytes: "function"
        });
        const { endo, Fp: Fp3, a } = opts;
        if (endo) {
          if (!Fp3.eql(a, Fp3.ZERO)) {
            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
          }
          if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
          }
        }
        return Object.freeze(__spreadValues({}, opts));
      }
      var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
      var DER = {
        Err: class DERErr extends Error {
          constructor(m = "") {
            super(m);
          }
        },
        _parseInt(data) {
          const { Err: E } = DER;
          if (data.length < 2 || data[0] !== 2)
            throw new E("Invalid signature integer tag");
          const len = data[1];
          const res = data.subarray(2, len + 2);
          if (!len || res.length !== len)
            throw new E("Invalid signature integer: wrong length");
          if (res[0] & 128)
            throw new E("Invalid signature integer: negative");
          if (res[0] === 0 && !(res[1] & 128))
            throw new E("Invalid signature integer: unnecessary leading zero");
          return { d: b2n(res), l: data.subarray(len + 2) };
        },
        toSig(hex) {
          const { Err: E } = DER;
          const data = typeof hex === "string" ? h2b(hex) : hex;
          if (!(data instanceof Uint8Array))
            throw new Error("ui8a expected");
          let l = data.length;
          if (l < 2 || data[0] != 48)
            throw new E("Invalid signature tag");
          if (data[1] !== l - 2)
            throw new E("Invalid signature: incorrect length");
          const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
          const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
          if (rBytesLeft.length)
            throw new E("Invalid signature: left bytes after parsing");
          return { r, s };
        },
        hexFromSig(sig) {
          const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
          const h = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
          };
          const s = slice2(h(sig.s));
          const r = slice2(h(sig.r));
          const shl = s.length / 2;
          const rhl = r.length / 2;
          const sl = h(shl);
          const rl = h(rhl);
          return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
        }
      };
      var _0n4 = BigInt(0);
      var _1n4 = BigInt(1);
      var _2n3 = BigInt(2);
      var _3n2 = BigInt(3);
      var _4n2 = BigInt(4);
      function weierstrassPoints(opts) {
        const CURVE = validatePointOpts(opts);
        const { Fp: Fp3 } = CURVE;
        const toBytes2 = CURVE.toBytes || ((c, point, isCompressed) => {
          const a = point.toAffine();
          return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
        });
        const fromBytes = CURVE.fromBytes || ((bytes3) => {
          const tail = bytes3.subarray(1);
          const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
          const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
          return { x, y };
        });
        function weierstrassEquation(x) {
          const { a, b } = CURVE;
          const x2 = Fp3.sqr(x);
          const x3 = Fp3.mul(x2, x);
          return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b);
        }
        if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
          throw new Error("bad generator point: equation left != right");
        function isWithinCurveOrder(num) {
          return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
        }
        function assertGE(num) {
          if (!isWithinCurveOrder(num))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n");
        }
        function normPrivateKeyToScalar(key) {
          const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
          if (lengths && typeof key !== "bigint") {
            if (key instanceof Uint8Array)
              key = bytesToHex(key);
            if (typeof key !== "string" || !lengths.includes(key.length))
              throw new Error("Invalid key");
            key = key.padStart(nByteLength * 2, "0");
          }
          let num;
          try {
            num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
          } catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
          }
          if (wrapPrivateKey)
            num = mod(num, n);
          assertGE(num);
          return num;
        }
        const pointPrecomputes = /* @__PURE__ */ new Map();
        function assertPrjPoint(other) {
          if (!(other instanceof Point2))
            throw new Error("ProjectivePoint expected");
        }
        class Point2 {
          constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp3.isValid(px))
              throw new Error("x required");
            if (py == null || !Fp3.isValid(py))
              throw new Error("y required");
            if (pz == null || !Fp3.isValid(pz))
              throw new Error("z required");
          }
          static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
              throw new Error("invalid affine point");
            if (p instanceof Point2)
              throw new Error("projective point not allowed");
            const is0 = (i) => Fp3.eql(i, Fp3.ZERO);
            if (is0(x) && is0(y))
              return Point2.ZERO;
            return new Point2(x, y, Fp3.ONE);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static normalizeZ(points) {
            const toInv = Fp3.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
          }
          static fromHex(hex) {
            const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
            P.assertValidity();
            return P;
          }
          static fromPrivateKey(privateKey) {
            return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
          }
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          assertValidity() {
            if (this.is0()) {
              if (CURVE.allowInfinityPoint)
                return;
              throw new Error("bad point: ZERO");
            }
            const { x, y } = this.toAffine();
            if (!Fp3.isValid(x) || !Fp3.isValid(y))
              throw new Error("bad point: x or y not FE");
            const left = Fp3.sqr(y);
            const right = weierstrassEquation(x);
            if (!Fp3.eql(left, right))
              throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
              throw new Error("bad point: not in prime-order subgroup");
          }
          hasEvenY() {
            const { y } = this.toAffine();
            if (Fp3.isOdd)
              return !Fp3.isOdd(y);
            throw new Error("Field doesn't support isOdd");
          }
          equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
            const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
            return U1 && U2;
          }
          negate() {
            return new Point2(this.px, Fp3.neg(this.py), this.pz);
          }
          double() {
            const { a, b } = CURVE;
            const b3 = Fp3.mul(b, _3n2);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
            let t0 = Fp3.mul(X1, X1);
            let t1 = Fp3.mul(Y1, Y1);
            let t2 = Fp3.mul(Z1, Z1);
            let t3 = Fp3.mul(X1, Y1);
            t3 = Fp3.add(t3, t3);
            Z3 = Fp3.mul(X1, Z1);
            Z3 = Fp3.add(Z3, Z3);
            X3 = Fp3.mul(a, Z3);
            Y3 = Fp3.mul(b3, t2);
            Y3 = Fp3.add(X3, Y3);
            X3 = Fp3.sub(t1, Y3);
            Y3 = Fp3.add(t1, Y3);
            Y3 = Fp3.mul(X3, Y3);
            X3 = Fp3.mul(t3, X3);
            Z3 = Fp3.mul(b3, Z3);
            t2 = Fp3.mul(a, t2);
            t3 = Fp3.sub(t0, t2);
            t3 = Fp3.mul(a, t3);
            t3 = Fp3.add(t3, Z3);
            Z3 = Fp3.add(t0, t0);
            t0 = Fp3.add(Z3, t0);
            t0 = Fp3.add(t0, t2);
            t0 = Fp3.mul(t0, t3);
            Y3 = Fp3.add(Y3, t0);
            t2 = Fp3.mul(Y1, Z1);
            t2 = Fp3.add(t2, t2);
            t0 = Fp3.mul(t2, t3);
            X3 = Fp3.sub(X3, t0);
            Z3 = Fp3.mul(t2, t1);
            Z3 = Fp3.add(Z3, Z3);
            Z3 = Fp3.add(Z3, Z3);
            return new Point2(X3, Y3, Z3);
          }
          add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
            const a = CURVE.a;
            const b3 = Fp3.mul(CURVE.b, _3n2);
            let t0 = Fp3.mul(X1, X2);
            let t1 = Fp3.mul(Y1, Y2);
            let t2 = Fp3.mul(Z1, Z2);
            let t3 = Fp3.add(X1, Y1);
            let t4 = Fp3.add(X2, Y2);
            t3 = Fp3.mul(t3, t4);
            t4 = Fp3.add(t0, t1);
            t3 = Fp3.sub(t3, t4);
            t4 = Fp3.add(X1, Z1);
            let t5 = Fp3.add(X2, Z2);
            t4 = Fp3.mul(t4, t5);
            t5 = Fp3.add(t0, t2);
            t4 = Fp3.sub(t4, t5);
            t5 = Fp3.add(Y1, Z1);
            X3 = Fp3.add(Y2, Z2);
            t5 = Fp3.mul(t5, X3);
            X3 = Fp3.add(t1, t2);
            t5 = Fp3.sub(t5, X3);
            Z3 = Fp3.mul(a, t4);
            X3 = Fp3.mul(b3, t2);
            Z3 = Fp3.add(X3, Z3);
            X3 = Fp3.sub(t1, Z3);
            Z3 = Fp3.add(t1, Z3);
            Y3 = Fp3.mul(X3, Z3);
            t1 = Fp3.add(t0, t0);
            t1 = Fp3.add(t1, t0);
            t2 = Fp3.mul(a, t2);
            t4 = Fp3.mul(b3, t4);
            t1 = Fp3.add(t1, t2);
            t2 = Fp3.sub(t0, t2);
            t2 = Fp3.mul(a, t2);
            t4 = Fp3.add(t4, t2);
            t0 = Fp3.mul(t1, t4);
            Y3 = Fp3.add(Y3, t0);
            t0 = Fp3.mul(t5, t4);
            X3 = Fp3.mul(t3, X3);
            X3 = Fp3.sub(X3, t0);
            t0 = Fp3.mul(t3, t1);
            Z3 = Fp3.mul(t5, Z3);
            Z3 = Fp3.add(Z3, t0);
            return new Point2(X3, Y3, Z3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          is0() {
            return this.equals(Point2.ZERO);
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
              const toInv = Fp3.invertBatch(comp.map((p) => p.pz));
              return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
            });
          }
          multiplyUnsafe(n) {
            const I = Point2.ZERO;
            if (n === _0n4)
              return I;
            assertGE(n);
            if (n === _1n4)
              return this;
            const { endo } = CURVE;
            if (!endo)
              return wnaf.unsafeLadder(this, n);
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n4 || k2 > _0n4) {
              if (k1 & _1n4)
                k1p = k1p.add(d);
              if (k2 & _1n4)
                k2p = k2p.add(d);
              d = d.double();
              k1 >>= _1n4;
              k2 >>= _1n4;
            }
            if (k1neg)
              k1p = k1p.negate();
            if (k2neg)
              k2p = k2p.negate();
            k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
          }
          multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake;
            const { endo } = CURVE;
            if (endo) {
              const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
              let { p: k1p, f: f1p } = this.wNAF(k1);
              let { p: k2p, f: f2p } = this.wNAF(k2);
              k1p = wnaf.constTimeNegate(k1neg, k1p);
              k2p = wnaf.constTimeNegate(k2neg, k2p);
              k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
              point = k1p.add(k2p);
              fake = f1p.add(f2p);
            } else {
              const { p, f } = this.wNAF(n);
              point = p;
              fake = f;
            }
            return Point2.normalizeZ([point, fake])[0];
          }
          multiplyAndAddUnsafe(Q, a, b) {
            const G = Point2.BASE;
            const mul = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? void 0 : sum;
          }
          toAffine(iz) {
            const { px: x, py: y, pz: z2 } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? Fp3.ONE : Fp3.inv(z2);
            const ax = Fp3.mul(x, iz);
            const ay = Fp3.mul(y, iz);
            const zz = Fp3.mul(z2, iz);
            if (is0)
              return { x: Fp3.ZERO, y: Fp3.ZERO };
            if (!Fp3.eql(zz, Fp3.ONE))
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n4)
              return true;
            if (isTorsionFree)
              return isTorsionFree(Point2, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
          }
          clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n4)
              return this;
            if (clearCofactor)
              return clearCofactor(Point2, this);
            return this.multiplyUnsafe(CURVE.h);
          }
          toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes2(Point2, this, isCompressed);
          }
          toHex(isCompressed = true) {
            return bytesToHex(this.toRawBytes(isCompressed));
          }
        }
        Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
        Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
        const _bits = CURVE.nBitLength;
        const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
        return {
          CURVE,
          ProjectivePoint: Point2,
          normPrivateKeyToScalar,
          weierstrassEquation,
          isWithinCurveOrder
        };
      }
      function validateOpts(curve) {
        const opts = validateBasic(curve);
        validateObject(opts, {
          hash: "hash",
          hmac: "function",
          randomBytes: "function"
        }, {
          bits2int: "function",
          bits2int_modN: "function",
          lowS: "boolean"
        });
        return Object.freeze(__spreadValues({ lowS: true }, opts));
      }
      function weierstrass(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
        const compressedLen = Fp3.BYTES + 1;
        const uncompressedLen = 2 * Fp3.BYTES + 1;
        function isValidFieldElement(num) {
          return _0n4 < num && num < Fp3.ORDER;
        }
        function modN(a) {
          return mod(a, CURVE_ORDER);
        }
        function invN(a) {
          return invert(a, CURVE_ORDER);
        }
        const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints(__spreadProps(__spreadValues({}, CURVE), {
          toBytes(c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp3.toBytes(a.x);
            const cat = concatBytes2;
            if (isCompressed) {
              return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
            } else {
              return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
            }
          },
          fromBytes(bytes3) {
            const len = bytes3.length;
            const head = bytes3[0];
            const tail = bytes3.subarray(1);
            if (len === compressedLen && (head === 2 || head === 3)) {
              const x = bytesToNumberBE(tail);
              if (!isValidFieldElement(x))
                throw new Error("Point is not on curve");
              const y2 = weierstrassEquation(x);
              let y = Fp3.sqrt(y2);
              const isYOdd = (y & _1n4) === _1n4;
              const isHeadOdd = (head & 1) === 1;
              if (isHeadOdd !== isYOdd)
                y = Fp3.neg(y);
              return { x, y };
            } else if (len === uncompressedLen && head === 4) {
              const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
              const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
              return { x, y };
            } else {
              throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
          }
        }));
        const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
        function isBiggerThanHalfOrder(number2) {
          const HALF = CURVE_ORDER >> _1n4;
          return number2 > HALF;
        }
        function normalizeS(s) {
          return isBiggerThanHalfOrder(s) ? modN(-s) : s;
        }
        const slcNum = (b, from3, to) => bytesToNumberBE(b.slice(from3, to));
        class Signature {
          constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
          }
          static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = ensureBytes("compactSignature", hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
          }
          static fromDER(hex) {
            const { r, s } = DER.toSig(ensureBytes("DER", hex));
            return new Signature(r, s);
          }
          assertValidity() {
            if (!isWithinCurveOrder(this.r))
              throw new Error("r must be 0 < r < CURVE.n");
            if (!isWithinCurveOrder(this.s))
              throw new Error("s must be 0 < s < CURVE.n");
          }
          addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
          }
          recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN(ensureBytes("msgHash", msgHash));
            if (rec == null || ![0, 1, 2, 3].includes(rec))
              throw new Error("recovery id invalid");
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp3.ORDER)
              throw new Error("recovery id 2 or 3 invalid");
            const prefix = (rec & 1) === 0 ? "02" : "03";
            const R = Point2.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj);
            const u1 = modN(-h * ir);
            const u2 = modN(s * ir);
            const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
            if (!Q)
              throw new Error("point at infinify");
            Q.assertValidity();
            return Q;
          }
          hasHighS() {
            return isBiggerThanHalfOrder(this.s);
          }
          normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
          }
          toDERRawBytes() {
            return hexToBytes(this.toDERHex());
          }
          toDERHex() {
            return DER.hexFromSig({ r: this.r, s: this.s });
          }
          toCompactRawBytes() {
            return hexToBytes(this.toCompactHex());
          }
          toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
          }
        }
        const utils = {
          isValidPrivateKey(privateKey) {
            try {
              normPrivateKeyToScalar(privateKey);
              return true;
            } catch (error) {
              return false;
            }
          },
          normPrivateKeyToScalar,
          randomPrivateKey: () => {
            const rand = CURVE.randomBytes(Fp3.BYTES + 8);
            const num = hashToPrivateScalar(rand, CURVE_ORDER);
            return numberToBytesBE(num, CURVE.nByteLength);
          },
          precompute(windowSize = 8, point = Point2.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        function getPublicKey(privateKey, isCompressed = true) {
          return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
        }
        function isProbPub(item) {
          const arr = item instanceof Uint8Array;
          const str = typeof item === "string";
          const len = (arr || str) && item.length;
          if (arr)
            return len === compressedLen || len === uncompressedLen;
          if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
          if (item instanceof Point2)
            return true;
          return false;
        }
        function getSharedSecret(privateA, publicB, isCompressed = true) {
          if (isProbPub(privateA))
            throw new Error("first arg must be private key");
          if (!isProbPub(publicB))
            throw new Error("second arg must be public key");
          const b = Point2.fromHex(publicB);
          return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
        }
        const bits2int = CURVE.bits2int || function(bytes3) {
          const num = bytesToNumberBE(bytes3);
          const delta = bytes3.length * 8 - CURVE.nBitLength;
          return delta > 0 ? num >> BigInt(delta) : num;
        };
        const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
          return modN(bits2int(bytes3));
        };
        const ORDER_MASK = bitMask(CURVE.nBitLength);
        function int2octets(num) {
          if (typeof num !== "bigint")
            throw new Error("bigint expected");
          if (!(_0n4 <= num && num < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
          return numberToBytesBE(num, CURVE.nByteLength);
        }
        function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
          if (["recovered", "canonical"].some((k) => k in opts))
            throw new Error("sign() legacy options not supported");
          const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
          let { lowS, prehash, extraEntropy: ent } = opts;
          if (lowS == null)
            lowS = true;
          msgHash = ensureBytes("msgHash", msgHash);
          if (prehash)
            msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
          const h1int = bits2int_modN(msgHash);
          const d = normPrivateKeyToScalar(privateKey);
          const seedArgs = [int2octets(d), int2octets(h1int)];
          if (ent != null) {
            const e = ent === true ? randomBytes2(Fp3.BYTES) : ent;
            seedArgs.push(ensureBytes("extraEntropy", e, Fp3.BYTES));
          }
          const seed = concatBytes2(...seedArgs);
          const m = h1int;
          function k2sig(kBytes) {
            const k = bits2int(kBytes);
            if (!isWithinCurveOrder(k))
              return;
            const ik = invN(k);
            const q = Point2.BASE.multiply(k).toAffine();
            const r = modN(q.x);
            if (r === _0n4)
              return;
            const s = modN(ik * modN(m + r * d));
            if (s === _0n4)
              return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
              normS = normalizeS(s);
              recovery ^= 1;
            }
            return new Signature(r, normS, recovery);
          }
          return { seed, k2sig };
        }
        const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
        const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
        function sign(msgHash, privKey, opts = defaultSigOpts) {
          const { seed, k2sig } = prepSig(msgHash, privKey, opts);
          const C = CURVE;
          const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
          return drbg(seed, k2sig);
        }
        Point2.BASE._setWindowSize(8);
        function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
          var _a;
          const sg = signature;
          msgHash = ensureBytes("msgHash", msgHash);
          publicKey = ensureBytes("publicKey", publicKey);
          if ("strict" in opts)
            throw new Error("options.strict was renamed to lowS");
          const { lowS, prehash } = opts;
          let _sig = void 0;
          let P;
          try {
            if (typeof sg === "string" || sg instanceof Uint8Array) {
              try {
                _sig = Signature.fromDER(sg);
              } catch (derError) {
                if (!(derError instanceof DER.Err))
                  throw derError;
                _sig = Signature.fromCompact(sg);
              }
            } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
              const { r: r2, s: s2 } = sg;
              _sig = new Signature(r2, s2);
            } else {
              throw new Error("PARSE");
            }
            P = Point2.fromHex(publicKey);
          } catch (error) {
            if (error.message === "PARSE")
              throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
          }
          if (lowS && _sig.hasHighS())
            return false;
          if (prehash)
            msgHash = CURVE.hash(msgHash);
          const { r, s } = _sig;
          const h = bits2int_modN(msgHash);
          const is3 = invN(s);
          const u1 = modN(h * is3);
          const u2 = modN(r * is3);
          const R = (_a = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
          if (!R)
            return false;
          const v = modN(R.x);
          return v === r;
        }
        return {
          CURVE,
          getPublicKey,
          getSharedSecret,
          sign,
          verify,
          ProjectivePoint: Point2,
          Signature,
          utils
        };
      }
      function getHash(hash2) {
        return {
          hash: hash2,
          hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
          randomBytes
        };
      }
      function createCurve(curveDef, defHash) {
        const create3 = (hash2) => weierstrass(__spreadValues(__spreadValues({}, curveDef), getHash(hash2)));
        return Object.freeze(__spreadProps(__spreadValues({}, create3(defHash)), { create: create3 }));
      }
      function setBigUint64(view, byteOffset, value, isLE2) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE2);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE2 ? 4 : 0;
        const l = isLE2 ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE2);
        view.setUint32(byteOffset + l, wl, isLE2);
      }
      var SHA2 = class extends Hash {
        constructor(blockLen, outputLen, padOffset, isLE2) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE2;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = createView(this.buffer);
        }
        update(data) {
          assert_default.exists(this);
          const { view, buffer: buffer2, blockLen } = this;
          data = toBytes(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView3 = createView(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView3, pos);
              continue;
            }
            buffer2.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          assert_default.exists(this);
          assert_default.output(out, this);
          this.finished = true;
          const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
          let { pos } = this;
          buffer2[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer2[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
          this.process(view, 0);
          const oview = createView(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE2);
        }
        digest() {
          const { buffer: buffer2, outputLen } = this;
          this.digestInto(buffer2);
          const res = buffer2.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer: buffer2, length: length2, finished, destroyed, pos } = this;
          to.length = length2;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length2 % blockLen)
            to.buffer.set(buffer2);
          return to;
        }
      };
      var Chi = (a, b, c) => a & b ^ ~a & c;
      var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W = new Uint32Array(64);
      var SHA256 = class extends SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      var sha2562 = wrapConstructor(() => new SHA256());
      var sha224 = wrapConstructor(() => new SHA224());
      var Fp = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
      var CURVE_A = Fp.create(BigInt("-3"));
      var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
      var p256 = createCurve({
        a: CURVE_A,
        b: CURVE_B,
        Fp,
        n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
        Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
        Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
        h: BigInt(1),
        lowS: false
      }, sha2562);
      var decompressPubkey = (compressed) => {
        if (compressed.length !== 33) {
          throw new Error("Expected 33 byte compress pubkey");
        }
        const point = p256.ProjectivePoint.fromHex(compressed);
        return point.toRawBytes(false);
      };
      var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
      var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      var _1n5 = BigInt(1);
      var _2n4 = BigInt(2);
      var divNearest = (a, b) => (a + b / _2n4) / b;
      function sqrtMod(y) {
        const P = secp256k1P;
        const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
        const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
        const b2 = y * y * y % P;
        const b3 = b2 * b2 * y % P;
        const b6 = pow2(b3, _3n3, P) * b3 % P;
        const b9 = pow2(b6, _3n3, P) * b3 % P;
        const b11 = pow2(b9, _2n4, P) * b2 % P;
        const b22 = pow2(b11, _11n, P) * b11 % P;
        const b44 = pow2(b22, _22n, P) * b22 % P;
        const b88 = pow2(b44, _44n, P) * b44 % P;
        const b176 = pow2(b88, _88n, P) * b88 % P;
        const b220 = pow2(b176, _44n, P) * b44 % P;
        const b223 = pow2(b220, _3n3, P) * b3 % P;
        const t1 = pow2(b223, _23n, P) * b22 % P;
        const t2 = pow2(t1, _6n, P) * b2 % P;
        const root = pow2(t2, _2n4, P);
        if (!Fp2.eql(Fp2.sqr(root), y))
          throw new Error("Cannot find square root");
        return root;
      }
      var Fp2 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
      var secp256k1 = createCurve({
        a: BigInt(0),
        b: BigInt(7),
        Fp: Fp2,
        n: secp256k1N,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: true,
        endo: {
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: (k) => {
            const n = secp256k1N;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000");
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = mod(k - c1 * a1 - c2 * a2, n);
            let k2 = mod(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
              k1 = n - k1;
            if (k2neg)
              k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
              throw new Error("splitScalar: Endomorphism failed, k=" + k);
            }
            return { k1neg, k1, k2neg, k2 };
          }
        }
      }, sha2562);
      var _0n5 = BigInt(0);
      var Point = secp256k1.ProjectivePoint;
      var decompressPubkey2 = (compressed) => {
        if (compressed.length !== 33) {
          throw new Error("Expected 33 byte compress pubkey");
        }
        const point = secp256k1.ProjectivePoint.fromHex(compressed);
        return point.toRawBytes(false);
      };
      var verifyDidSig = (did2, data, sig, opts) => __async(exports, null, function* () {
        const { jwtAlg, keyBytes } = parseDidKey(did2);
        if (jwtAlg !== P256_JWT_ALG) {
          throw new Error(`Not a P-256 did:key: ${did2}`);
        }
        return verifySig(keyBytes, data, sig, opts);
      });
      var verifySig = (publicKey, data, sig, opts) => __async(exports, null, function* () {
        var _a;
        const allowMalleable = (_a = opts == null ? void 0 : opts.allowMalleableSig) != null ? _a : false;
        const msgHash = yield sha2562(data);
        if (!allowMalleable && !isCompactFormat(sig)) {
          return false;
        }
        return p256.verify(sig, msgHash, publicKey, {
          lowS: !allowMalleable
        });
      });
      var isCompactFormat = (sig) => {
        try {
          const parsed = p256.Signature.fromCompact(sig);
          return equals3(parsed.toCompactRawBytes(), sig);
        } catch (e) {
          return false;
        }
      };
      var p256Plugin = {
        prefix: P256_DID_PREFIX,
        jwtAlg: P256_JWT_ALG,
        verifySignature: verifyDidSig
      };
      var plugin_default = p256Plugin;
      var verifyDidSig2 = (did2, data, sig, opts) => __async(exports, null, function* () {
        const { jwtAlg, keyBytes } = parseDidKey(did2);
        if (jwtAlg !== SECP256K1_JWT_ALG) {
          throw new Error(`Not a secp256k1 did:key: ${did2}`);
        }
        return verifySig2(keyBytes, data, sig, opts);
      });
      var verifySig2 = (publicKey, data, sig, opts) => __async(exports, null, function* () {
        var _a;
        const allowMalleable = (_a = opts == null ? void 0 : opts.allowMalleableSig) != null ? _a : false;
        const msgHash = yield sha2562(data);
        if (!allowMalleable && !isCompactFormat2(sig)) {
          return false;
        }
        return secp256k1.verify(sig, msgHash, publicKey, {
          lowS: !allowMalleable
        });
      });
      var isCompactFormat2 = (sig) => {
        try {
          const parsed = secp256k1.Signature.fromCompact(sig);
          return equals3(parsed.toCompactRawBytes(), sig);
        } catch (e) {
          return false;
        }
      };
      var secp256k1Plugin = {
        prefix: SECP256K1_DID_PREFIX,
        jwtAlg: SECP256K1_JWT_ALG,
        verifySignature: verifyDidSig2
      };
      var plugin_default2 = secp256k1Plugin;
      var plugins = [plugin_default, plugin_default2];
      var plugins_default = plugins;
      var parseMultikey = (multikey) => {
        if (!multikey.startsWith(BASE58_MULTIBASE_PREFIX)) {
          throw new Error(`Incorrect prefix for multikey: ${multikey}`);
        }
        const prefixedBytes = fromString2(multikey.slice(BASE58_MULTIBASE_PREFIX.length), "base58btc");
        const plugin = plugins_default.find((p) => hasPrefix(prefixedBytes, p.prefix));
        if (!plugin) {
          throw new Error("Unsupported key type");
        }
        let keyBytes = prefixedBytes.slice(plugin.prefix.length);
        if (plugin.jwtAlg === P256_JWT_ALG) {
          keyBytes = decompressPubkey(keyBytes);
        } else if (plugin.jwtAlg === SECP256K1_JWT_ALG) {
          keyBytes = decompressPubkey2(keyBytes);
        }
        return {
          jwtAlg: plugin.jwtAlg,
          keyBytes
        };
      };
      var parseDidKey = (did2) => {
        if (!did2.startsWith(DID_KEY_PREFIX)) {
          throw new Error(`Incorrect prefix for did:key: ${did2}`);
        }
        return parseMultikey(did2.slice(DID_KEY_PREFIX.length));
      };
      var hasPrefix = (bytes3, prefix) => {
        return equals3(prefix, bytes3.subarray(0, prefix.byteLength));
      };
      var sha2563 = (input) => __async(exports, null, function* () {
        const bytes3 = typeof input === "string" ? fromString2(input, "utf8") : input;
        return sha2562(bytes3);
      });
      var verifySignature = (didKey, data, sig, opts) => {
        const parsed = parseDidKey(didKey);
        const plugin = plugins_default.find((p) => p.jwtAlg === parsed.jwtAlg);
        if (!plugin) {
          throw new Error(`Unsupported signature alg: ${parsed.jwtAlg}`);
        }
        return plugin.verifySignature(didKey, data, sig, opts);
      };
      var leadingZerosOnHash = (key) => __async(exports, null, function* () {
        const hash2 = yield sha2563(key);
        let leadingZeros = 0;
        for (let i = 0; i < hash2.length; i++) {
          const byte = hash2[i];
          if (byte < 64)
            leadingZeros++;
          if (byte < 16)
            leadingZeros++;
          if (byte < 4)
            leadingZeros++;
          if (byte === 0) {
            leadingZeros++;
          } else {
            break;
          }
        }
        return leadingZeros;
      });
      var layerForEntries = (entries) => __async(exports, null, function* () {
        const firstLeaf = entries.find((entry) => entry.isLeaf());
        if (!firstLeaf || firstLeaf.isTree())
          return null;
        return yield leadingZerosOnHash(firstLeaf.key);
      });
      var deserializeNodeData = (storage, data, opts) => __async(exports, null, function* () {
        const { layer } = opts || {};
        const entries = [];
        if (data.l !== null) {
          entries.push(yield MST.load(storage, data.l, {
            layer: layer ? layer - 1 : void 0
          }));
        }
        let lastKey = "";
        for (const entry of data.e) {
          const keyStr = toString2(entry.k, "ascii");
          const key = lastKey.slice(0, entry.p) + keyStr;
          ensureValidMstKey(key);
          entries.push(new Leaf(key, entry.v));
          lastKey = key;
          if (entry.t !== null) {
            entries.push(yield MST.load(storage, entry.t, {
              layer: layer ? layer - 1 : void 0
            }));
          }
        }
        return entries;
      });
      var serializeNodeData = (entries) => {
        var _a;
        const data = {
          l: null,
          e: []
        };
        let i = 0;
        if ((_a = entries[0]) == null ? void 0 : _a.isTree()) {
          i++;
          data.l = entries[0].pointer;
        }
        let lastKey = "";
        while (i < entries.length) {
          const leaf = entries[i];
          const next = entries[i + 1];
          if (!leaf.isLeaf()) {
            throw new Error("Not a valid node: two subtrees next to each other");
          }
          i++;
          let subtree = null;
          if (next == null ? void 0 : next.isTree()) {
            subtree = next.pointer;
            i++;
          }
          ensureValidMstKey(leaf.key);
          const prefixLen = countPrefixLen(lastKey, leaf.key);
          data.e.push({
            p: prefixLen,
            k: fromString2(leaf.key.slice(prefixLen), "ascii"),
            v: leaf.value,
            t: subtree
          });
          lastKey = leaf.key;
        }
        return data;
      };
      var countPrefixLen = (a, b) => {
        let i;
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            break;
          }
        }
        return i;
      };
      var cidForEntries = (entries) => __async(exports, null, function* () {
        const data = serializeNodeData(entries);
        return cidForCbor(data);
      });
      var isValidMstKey = (str) => {
        const split = str.split("/");
        return str.length <= 256 && split.length === 2 && split[0].length > 0 && split[1].length > 0 && isValidChars(split[0]) && isValidChars(split[1]);
      };
      var validCharsRegex = /^[a-zA-Z0-9_\-:.]*$/;
      var isValidChars = (str) => {
        return str.match(validCharsRegex) !== null;
      };
      var ensureValidMstKey = (str) => {
        if (!isValidMstKey(str)) {
          throw new InvalidMstKeyError(str);
        }
      };
      var InvalidMstKeyError = class extends Error {
        constructor(key) {
          super(`Not a valid MST key: ${key}`);
          this.key = key;
        }
      };
      var MissingBlockError = class extends Error {
        constructor(cid2, def3) {
          let msg = `block not found: ${cid2.toString()}`;
          if (def3) {
            msg += `, expected type: ${def3}`;
          }
          super(msg);
          this.cid = cid2;
        }
      };
      var MissingBlocksError = class extends Error {
        constructor(context, cids) {
          const cidStr = cids.map((c) => c.toString());
          super(`missing ${context} blocks: ${cidStr}`);
          this.context = context;
          this.cids = cids;
        }
      };
      var UnexpectedObjectError = class extends Error {
        constructor(cid2, def3) {
          super(`unexpected object at ${cid2.toString()}, expected: ${def3}`);
          this.cid = cid2;
          this.def = def3;
        }
      };
      var import_fs = __toESM2(__require("fs"), 1);
      var import_util7 = __require("util");
      var import_varint2 = __toESM2(require_varint(), 1);
      var CIDV0_BYTES = {
        SHA2_256: 18,
        LENGTH: 32,
        DAG_PB: 112
      };
      function readVarint(reader) {
        return __async(this, null, function* () {
          const bytes3 = yield reader.upTo(8);
          const i = import_varint2.default.decode(bytes3);
          reader.seek(import_varint2.default.decode.bytes);
          return i;
        });
      }
      function readHeader(reader) {
        return __async(this, null, function* () {
          const length2 = yield readVarint(reader);
          if (length2 === 0) {
            throw new Error("Invalid CAR header (zero length)");
          }
          const header = yield reader.exactly(length2);
          reader.seek(length2);
          const block = decode7(header);
          if (block == null || Array.isArray(block) || typeof block !== "object") {
            throw new Error("Invalid CAR header format");
          }
          if (block.version !== 1) {
            if (typeof block.version === "string") {
              throw new Error(`Invalid CAR version: "${block.version}"`);
            }
            throw new Error(`Invalid CAR version: ${block.version}`);
          }
          if (!Array.isArray(block.roots)) {
            throw new Error("Invalid CAR header format");
          }
          if (Object.keys(block).filter((p) => p !== "roots" && p !== "version").length) {
            throw new Error("Invalid CAR header format");
          }
          return block;
        });
      }
      function readMultihash(reader) {
        return __async(this, null, function* () {
          const bytes3 = yield reader.upTo(8);
          import_varint2.default.decode(bytes3);
          const codeLength = import_varint2.default.decode.bytes;
          const length2 = import_varint2.default.decode(bytes3.subarray(import_varint2.default.decode.bytes));
          const lengthLength = import_varint2.default.decode.bytes;
          const mhLength = codeLength + lengthLength + length2;
          const multihash = yield reader.exactly(mhLength);
          reader.seek(mhLength);
          return multihash;
        });
      }
      function readCid(reader) {
        return __async(this, null, function* () {
          const first = yield reader.exactly(2);
          if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
            const bytes4 = yield reader.exactly(34);
            reader.seek(34);
            const multihash2 = decode3(bytes4);
            return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
          }
          const version2 = yield readVarint(reader);
          if (version2 !== 1) {
            throw new Error(`Unexpected CID version (${version2})`);
          }
          const codec = yield readVarint(reader);
          const bytes3 = yield readMultihash(reader);
          const multihash = decode3(bytes3);
          return CID.create(version2, codec, multihash);
        });
      }
      function readBlockHead(reader) {
        return __async(this, null, function* () {
          const start = reader.pos;
          let length2 = yield readVarint(reader);
          if (length2 === 0) {
            throw new Error("Invalid CAR section (zero length)");
          }
          length2 += reader.pos - start;
          const cid2 = yield readCid(reader);
          const blockLength = length2 - (reader.pos - start);
          return {
            cid: cid2,
            length: length2,
            blockLength
          };
        });
      }
      function readBlock(reader) {
        return __async(this, null, function* () {
          const { cid: cid2, blockLength } = yield readBlockHead(reader);
          const bytes3 = yield reader.exactly(blockLength);
          reader.seek(blockLength);
          return {
            bytes: bytes3,
            cid: cid2
          };
        });
      }
      function readBlockIndex(reader) {
        return __async(this, null, function* () {
          const offset = reader.pos;
          const { cid: cid2, length: length2, blockLength } = yield readBlockHead(reader);
          const index = {
            cid: cid2,
            length: length2,
            blockLength,
            offset,
            blockOffset: reader.pos
          };
          reader.seek(index.blockLength);
          return index;
        });
      }
      function createDecoder(reader) {
        const headerPromise = readHeader(reader);
        return {
          header: () => headerPromise,
          blocks() {
            return __asyncGenerator(this, null, function* () {
              yield new __await(headerPromise);
              while ((yield new __await(reader.upTo(8))).length > 0) {
                yield yield new __await(readBlock(reader));
              }
            });
          },
          blocksIndex() {
            return __asyncGenerator(this, null, function* () {
              yield new __await(headerPromise);
              while ((yield new __await(reader.upTo(8))).length > 0) {
                yield yield new __await(readBlockIndex(reader));
              }
            });
          }
        };
      }
      function bytesReader(bytes3) {
        let pos = 0;
        return {
          upTo(length2) {
            return __async(this, null, function* () {
              return bytes3.subarray(pos, pos + Math.min(length2, bytes3.length - pos));
            });
          },
          exactly(length2) {
            return __async(this, null, function* () {
              if (length2 > bytes3.length - pos) {
                throw new Error("Unexpected end of data");
              }
              return bytes3.subarray(pos, pos + length2);
            });
          },
          seek(length2) {
            pos += length2;
          },
          get pos() {
            return pos;
          }
        };
      }
      function chunkReader(readChunk) {
        let pos = 0;
        let have = 0;
        let offset = 0;
        let currentChunk = new Uint8Array(0);
        const read3 = (length2) => __async(this, null, function* () {
          have = currentChunk.length - offset;
          const bufa = [currentChunk.subarray(offset)];
          while (have < length2) {
            const chunk = yield readChunk();
            if (chunk == null) {
              break;
            }
            if (have < 0) {
              if (chunk.length > have) {
                bufa.push(chunk.subarray(-have));
              }
            } else {
              bufa.push(chunk);
            }
            have += chunk.length;
          }
          currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
          let off = 0;
          for (const b of bufa) {
            currentChunk.set(b, off);
            off += b.length;
          }
          offset = 0;
        });
        return {
          upTo(length2) {
            return __async(this, null, function* () {
              if (currentChunk.length - offset < length2) {
                yield read3(length2);
              }
              return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
            });
          },
          exactly(length2) {
            return __async(this, null, function* () {
              if (currentChunk.length - offset < length2) {
                yield read3(length2);
              }
              if (currentChunk.length - offset < length2) {
                throw new Error("Unexpected end of data");
              }
              return currentChunk.subarray(offset, offset + length2);
            });
          },
          seek(length2) {
            pos += length2;
            offset += length2;
          },
          get pos() {
            return pos;
          }
        };
      }
      function asyncIterableReader(asyncIterable) {
        const iterator = asyncIterable[Symbol.asyncIterator]();
        function readChunk() {
          return __async(this, null, function* () {
            const next = yield iterator.next();
            if (next.done) {
              return null;
            }
            return next.value;
          });
        }
        return chunkReader(readChunk);
      }
      var CarReader = class {
        constructor(version2, roots, blocks) {
          this._version = version2;
          this._roots = roots;
          this._blocks = blocks;
          this._keys = blocks.map((b) => b.cid.toString());
        }
        get version() {
          return this._version;
        }
        getRoots() {
          return __async(this, null, function* () {
            return this._roots;
          });
        }
        has(key) {
          return __async(this, null, function* () {
            return this._keys.indexOf(key.toString()) > -1;
          });
        }
        get(key) {
          return __async(this, null, function* () {
            const index = this._keys.indexOf(key.toString());
            return index > -1 ? this._blocks[index] : void 0;
          });
        }
        blocks() {
          return __asyncGenerator(this, null, function* () {
            for (const block of this._blocks) {
              yield block;
            }
          });
        }
        cids() {
          return __asyncGenerator(this, null, function* () {
            for (const block of this._blocks) {
              yield block.cid;
            }
          });
        }
        static fromBytes(bytes3) {
          return __async(this, null, function* () {
            if (!(bytes3 instanceof Uint8Array)) {
              throw new TypeError("fromBytes() requires a Uint8Array");
            }
            return decodeReaderComplete(bytesReader(bytes3));
          });
        }
        static fromIterable(asyncIterable) {
          return __async(this, null, function* () {
            if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
              throw new TypeError("fromIterable() requires an async iterable");
            }
            return decodeReaderComplete(asyncIterableReader(asyncIterable));
          });
        }
      };
      function decodeReaderComplete(reader) {
        return __async(this, null, function* () {
          const decoder2 = createDecoder(reader);
          const { version: version2, roots } = yield decoder2.header();
          const blocks = [];
          try {
            for (var iter = __forAwait(decoder2.blocks()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const block = temp.value;
              blocks.push(block);
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          return new CarReader(version2, roots, blocks);
        });
      }
      var fsread = (0, import_util7.promisify)(import_fs.default.read);
      var CarReader2 = class extends CarReader {
        static readRaw(fd, blockIndex) {
          return __async(this, null, function* () {
            const { cid: cid2, blockLength, blockOffset } = blockIndex;
            const bytes3 = new Uint8Array(blockLength);
            let read3;
            if (typeof fd === "number") {
              read3 = (yield fsread(fd, bytes3, 0, blockLength, blockOffset)).bytesRead;
            } else if (typeof fd === "object" && typeof fd.read === "function") {
              read3 = (yield fd.read(bytes3, 0, blockLength, blockOffset)).bytesRead;
            } else {
              throw new TypeError("Bad fd");
            }
            if (read3 !== blockLength) {
              throw new Error(`Failed to read entire block (${read3} instead of ${blockLength})`);
            }
            return {
              cid: cid2,
              bytes: bytes3
            };
          });
        }
      };
      var import_fs2 = __toESM2(__require("fs"), 1);
      var import_util8 = __require("util");
      var import_varint3 = __toESM2(require_varint(), 1);
      function createHeader(roots) {
        const headerBytes = encode7({
          version: 1,
          roots
        });
        const varintBytes = import_varint3.default.encode(headerBytes.length);
        const header = new Uint8Array(varintBytes.length + headerBytes.length);
        header.set(varintBytes, 0);
        header.set(headerBytes, varintBytes.length);
        return header;
      }
      function createEncoder(writer) {
        return {
          setRoots(roots) {
            return __async(this, null, function* () {
              const bytes3 = createHeader(roots);
              yield writer.write(bytes3);
            });
          },
          writeBlock(block) {
            return __async(this, null, function* () {
              const { cid: cid2, bytes: bytes3 } = block;
              yield writer.write(new Uint8Array(import_varint3.default.encode(cid2.bytes.length + bytes3.length)));
              yield writer.write(cid2.bytes);
              if (bytes3.length) {
                yield writer.write(bytes3);
              }
            });
          },
          close() {
            return __async(this, null, function* () {
              return writer.end();
            });
          }
        };
      }
      function noop() {
      }
      function create2() {
        const chunkQueue = [];
        let drainer = null;
        let drainerResolver = noop;
        let ended = false;
        let outWait = null;
        let outWaitResolver = noop;
        const makeDrainer = () => {
          if (!drainer) {
            drainer = new Promise((resolve) => {
              drainerResolver = () => {
                drainer = null;
                drainerResolver = noop;
                resolve();
              };
            });
          }
          return drainer;
        };
        const writer = {
          write(chunk) {
            chunkQueue.push(chunk);
            const drainer2 = makeDrainer();
            outWaitResolver();
            return drainer2;
          },
          end() {
            return __async(this, null, function* () {
              ended = true;
              const drainer2 = makeDrainer();
              outWaitResolver();
              return drainer2;
            });
          }
        };
        const iterator = {
          next() {
            return __async(this, null, function* () {
              const chunk = chunkQueue.shift();
              if (chunk) {
                if (chunkQueue.length === 0) {
                  drainerResolver();
                }
                return {
                  done: false,
                  value: chunk
                };
              }
              if (ended) {
                drainerResolver();
                return {
                  done: true,
                  value: void 0
                };
              }
              if (!outWait) {
                outWait = new Promise((resolve) => {
                  outWaitResolver = () => {
                    outWait = null;
                    outWaitResolver = noop;
                    return resolve(iterator.next());
                  };
                });
              }
              return outWait;
            });
          }
        };
        return {
          writer,
          iterator
        };
      }
      var CarWriter = class {
        constructor(roots, encoder) {
          this._encoder = encoder;
          this._mutex = encoder.setRoots(roots);
          this._ended = false;
        }
        put(block) {
          return __async(this, null, function* () {
            if (!(block.bytes instanceof Uint8Array) || !block.cid) {
              throw new TypeError("Can only write {cid, bytes} objects");
            }
            if (this._ended) {
              throw new Error("Already closed");
            }
            const cid2 = CID.asCID(block.cid);
            if (!cid2) {
              throw new TypeError("Can only write {cid, bytes} objects");
            }
            this._mutex = this._mutex.then(() => this._encoder.writeBlock({
              cid: cid2,
              bytes: block.bytes
            }));
            return this._mutex;
          });
        }
        close() {
          return __async(this, null, function* () {
            if (this._ended) {
              throw new Error("Already closed");
            }
            yield this._mutex;
            this._ended = true;
            return this._encoder.close();
          });
        }
        static create(roots) {
          roots = toRoots(roots);
          const { encoder, iterator } = encodeWriter();
          const writer = new CarWriter(roots, encoder);
          const out = new CarWriterOut(iterator);
          return {
            writer,
            out
          };
        }
        static createAppender() {
          const { encoder, iterator } = encodeWriter();
          encoder.setRoots = () => Promise.resolve();
          const writer = new CarWriter([], encoder);
          const out = new CarWriterOut(iterator);
          return {
            writer,
            out
          };
        }
        static updateRootsInBytes(bytes3, roots) {
          return __async(this, null, function* () {
            const reader = bytesReader(bytes3);
            yield readHeader(reader);
            const newHeader = createHeader(roots);
            if (reader.pos !== newHeader.length) {
              throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
            }
            bytes3.set(newHeader, 0);
            return bytes3;
          });
        }
      };
      var CarWriterOut = class {
        constructor(iterator) {
          this._iterator = iterator;
        }
        [Symbol.asyncIterator]() {
          if (this._iterating) {
            throw new Error("Multiple iterator not supported");
          }
          this._iterating = true;
          return this._iterator;
        }
      };
      function encodeWriter() {
        const iw = create2();
        const { writer, iterator } = iw;
        const encoder = createEncoder(writer);
        return {
          encoder,
          iterator
        };
      }
      function toRoots(roots) {
        if (roots === void 0) {
          return [];
        }
        if (!Array.isArray(roots)) {
          const cid2 = CID.asCID(roots);
          if (!cid2) {
            throw new TypeError("roots must be a single CID or an array of CIDs");
          }
          return [cid2];
        }
        const _roots = [];
        for (const root of roots) {
          const _root = CID.asCID(root);
          if (!_root) {
            throw new TypeError("roots must be a single CID or an array of CIDs");
          }
          _roots.push(_root);
        }
        return _roots;
      }
      var fsread2 = (0, import_util8.promisify)(import_fs2.default.read);
      var fswrite = (0, import_util8.promisify)(import_fs2.default.write);
      var CarWriter2 = class extends CarWriter {
        static updateRootsInFile(fd, roots) {
          return __async(this, null, function* () {
            const chunkSize = 256;
            let bytes3;
            let offset = 0;
            let readChunk;
            if (typeof fd === "number") {
              readChunk = () => __async(this, null, function* () {
                return (yield fsread2(fd, bytes3, 0, chunkSize, offset)).bytesRead;
              });
            } else if (typeof fd === "object" && typeof fd.read === "function") {
              readChunk = () => __async(this, null, function* () {
                return (yield fd.read(bytes3, 0, chunkSize, offset)).bytesRead;
              });
            } else {
              throw new TypeError("Bad fd");
            }
            const fdReader = chunkReader(() => __async(this, null, function* () {
              bytes3 = new Uint8Array(chunkSize);
              const read3 = yield readChunk();
              offset += read3;
              return read3 < chunkSize ? bytes3.subarray(0, read3) : bytes3;
            }));
            yield readHeader(fdReader);
            const newHeader = createHeader(roots);
            if (fdReader.pos !== newHeader.length) {
              throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${fdReader.pos} bytes, new header is ${newHeader.length} bytes)`);
            }
            if (typeof fd === "number") {
              yield fswrite(fd, newHeader, 0, newHeader.length, 0);
            } else if (typeof fd === "object" && typeof fd.read === "function") {
              yield fd.write(newHeader, 0, newHeader.length, 0);
            }
          });
        }
      };
      function verifyIncomingCarBlocks(car) {
        return __asyncGenerator(this, null, function* () {
          try {
            for (var iter = __forAwait(car), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
              const block = temp.value;
              yield new __await(verifyCidForBytes(block.cid, block.bytes));
              yield block;
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield new __await(temp.call(iter)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        });
      }
      function writeCarStream(root, fn) {
        const { writer, out } = root !== null ? CarWriter2.create(root) : CarWriter2.create();
        const stream = byteIterableToStream(out);
        fn(writer).catch((err) => {
          stream.destroy(err);
        }).finally(() => writer.close());
        return stream;
      }
      function writeCar(root, fn) {
        return __asyncGenerator(this, null, function* () {
          const stream = writeCarStream(root, fn);
          try {
            for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
              const chunk = temp.value;
              yield chunk;
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield new __await(temp.call(iter)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        });
      }
      var blocksToCarStream = (root, blocks) => {
        return writeCar(root, (writer) => __async(exports, null, function* () {
          for (const entry of blocks.entries()) {
            yield writer.put(entry);
          }
        }));
      };
      var blocksToCarFile = (root, blocks) => {
        const carStream = blocksToCarStream(root, blocks);
        return streamToBuffer(carStream);
      };
      var readCar = (bytes3) => __async(exports, null, function* () {
        const car = yield CarReader2.fromBytes(bytes3);
        const roots = yield car.getRoots();
        const blocks = new block_map_default();
        try {
          for (var iter = __forAwait(verifyIncomingCarBlocks(car.blocks())), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const block = temp.value;
            blocks.set(block.cid, block.bytes);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        return {
          roots,
          blocks
        };
      });
      var readCarWithRoot = (bytes3) => __async(exports, null, function* () {
        const { roots, blocks } = yield readCar(bytes3);
        if (roots.length !== 1) {
          throw new Error(`Expected one root, got ${roots.length}`);
        }
        const root = roots[0];
        return {
          root,
          blocks
        };
      });
      var diffToWriteDescripts = (diff, blocks) => {
        return Promise.all([
          ...diff.addList().map((add) => __async(exports, null, function* () {
            const { collection, rkey } = parseDataKey(add.key);
            const value = yield getAndParseRecord(blocks, add.cid);
            return {
              action: "create",
              collection,
              rkey,
              cid: add.cid,
              record: value.record
            };
          })),
          ...diff.updateList().map((upd) => __async(exports, null, function* () {
            const { collection, rkey } = parseDataKey(upd.key);
            const value = yield getAndParseRecord(blocks, upd.cid);
            return {
              action: "update",
              collection,
              rkey,
              cid: upd.cid,
              prev: upd.prev,
              record: value.record
            };
          })),
          ...diff.deleteList().map((del) => {
            const { collection, rkey } = parseDataKey(del.key);
            return {
              action: "delete",
              collection,
              rkey,
              cid: del.cid
            };
          })
        ]);
      };
      var ensureCreates = (descripts) => {
        const creates = [];
        for (const descript of descripts) {
          if (descript.action !== "create") {
            throw new Error(`Unexpected action: ${descript.action}`);
          } else {
            creates.push(descript);
          }
        }
        return creates;
      };
      var parseDataKey = (key) => {
        const parts = key.split("/");
        if (parts.length !== 2)
          throw new Error(`Invalid record key: ${key}`);
        return { collection: parts[0], rkey: parts[1] };
      };
      var formatDataKey = (collection, rkey) => {
        return collection + "/" + rkey;
      };
      var metaEqual = (a, b) => {
        return a.did === b.did && a.version === b.version;
      };
      var signCommit = (unsigned, keypair) => __async(exports, null, function* () {
        const encoded = encode7(unsigned);
        const sig = yield keypair.sign(encoded);
        return __spreadProps(__spreadValues({}, unsigned), {
          sig
        });
      });
      var verifyCommitSig = (commit2, didKey) => __async(exports, null, function* () {
        const _a = commit2, { sig } = _a, rest = __objRest(_a, ["sig"]);
        const encoded = encode7(rest);
        return verifySignature(didKey, encoded, sig);
      });
      var cborToLex = (val) => {
        return ipldToLex(cborDecode(val));
      };
      var cborToLexRecord = (val) => {
        const parsed = cborToLex(val);
        if (!check_exports.is(parsed, schema.map)) {
          throw new Error("lexicon records be a json object");
        }
        return parsed;
      };
      var cidForRecord = (val) => __async(exports, null, function* () {
        return cidForCbor(lexToIpld(val));
      });
      var ensureV3Commit = (commit2) => {
        var _a;
        if (commit2.version === 3) {
          return commit2;
        } else {
          return __spreadProps(__spreadValues({}, commit2), {
            version: 3,
            rev: (_a = commit2.rev) != null ? _a : TID.nextStr()
          });
        }
      };
      var getAndParseRecord = (blocks, cid2) => __async(exports, null, function* () {
        const bytes3 = blocks.get(cid2);
        if (!bytes3) {
          throw new MissingBlockError(cid2, "record");
        }
        const record = yield cborToLexRecord(bytes3);
        return { record, bytes: bytes3 };
      });
      var getAndParseByDef = (blocks, cid2, def3) => __async(exports, null, function* () {
        const bytes3 = blocks.get(cid2);
        if (!bytes3) {
          throw new MissingBlockError(cid2, def3.name);
        }
        return parseObjByDef(bytes3, cid2, def3);
      });
      var parseObjByDef = (bytes3, cid2, def3) => {
        const obj = cborDecode(bytes3);
        const res = def3.schema.safeParse(obj);
        if (res.success) {
          return { obj: res.data, bytes: bytes3 };
        } else {
          throw new UnexpectedObjectError(cid2, def3.name);
        }
      };
      var subTreePointer = z.nullable(schema.cid);
      var treeEntry = z.object({
        p: z.number(),
        k: schema.bytes,
        v: schema.cid,
        t: subTreePointer
      });
      var nodeData = z.object({
        l: subTreePointer,
        e: z.array(treeEntry)
      });
      var nodeDataDef = {
        name: "mst node",
        schema: nodeData
      };
      var MST = class {
        constructor(storage, pointer, entries, layer) {
          this.outdatedPointer = false;
          this.storage = storage;
          this.entries = entries;
          this.layer = layer;
          this.pointer = pointer;
        }
        static create(_0) {
          return __async(this, arguments, function* (storage, entries = [], opts) {
            const pointer = yield cidForEntries(entries);
            const { layer = null } = opts || {};
            return new MST(storage, pointer, entries, layer);
          });
        }
        static fromData(storage, data, opts) {
          return __async(this, null, function* () {
            const { layer = null } = opts || {};
            const entries = yield deserializeNodeData(storage, data, opts);
            const pointer = yield cidForCbor(data);
            return new MST(storage, pointer, entries, layer);
          });
        }
        static load(storage, cid2, opts) {
          const { layer = null } = opts || {};
          return new MST(storage, cid2, null, layer);
        }
        newTree(entries) {
          return __async(this, null, function* () {
            const mst = new MST(this.storage, this.pointer, entries, this.layer);
            mst.outdatedPointer = true;
            return mst;
          });
        }
        getEntries() {
          return __async(this, null, function* () {
            if (this.entries)
              return [...this.entries];
            if (this.pointer) {
              const data = yield this.storage.readObj(this.pointer, nodeDataDef);
              const firstLeaf = data.e[0];
              const layer = firstLeaf !== void 0 ? yield leadingZerosOnHash(firstLeaf.k) : void 0;
              this.entries = yield deserializeNodeData(this.storage, data, {
                layer
              });
              return this.entries;
            }
            throw new Error("No entries or CID provided");
          });
        }
        getPointer() {
          return __async(this, null, function* () {
            if (!this.outdatedPointer)
              return this.pointer;
            const { cid: cid2 } = yield this.serialize();
            this.pointer = cid2;
            this.outdatedPointer = false;
            return this.pointer;
          });
        }
        serialize() {
          return __async(this, null, function* () {
            let entries = yield this.getEntries();
            const outdated = entries.filter((e) => e.isTree() && e.outdatedPointer);
            if (outdated.length > 0) {
              yield Promise.all(outdated.map((e) => e.getPointer()));
              entries = yield this.getEntries();
            }
            const data = serializeNodeData(entries);
            const block = yield dataToCborBlock(data);
            return {
              cid: block.cid,
              bytes: block.bytes
            };
          });
        }
        getLayer() {
          return __async(this, null, function* () {
            this.layer = yield this.attemptGetLayer();
            if (this.layer === null)
              this.layer = 0;
            return this.layer;
          });
        }
        attemptGetLayer() {
          return __async(this, null, function* () {
            if (this.layer !== null)
              return this.layer;
            const entries = yield this.getEntries();
            let layer = yield layerForEntries(entries);
            if (layer === null) {
              for (const entry of entries) {
                if (entry.isTree()) {
                  const childLayer = yield entry.attemptGetLayer();
                  if (childLayer !== null) {
                    layer = childLayer + 1;
                    break;
                  }
                }
              }
            }
            if (layer !== null)
              this.layer = layer;
            return layer;
          });
        }
        getUnstoredBlocks() {
          return __async(this, null, function* () {
            const blocks = new block_map_default();
            const pointer = yield this.getPointer();
            const alreadyHas = yield this.storage.has(pointer);
            if (alreadyHas)
              return { root: pointer, blocks };
            const entries = yield this.getEntries();
            const data = serializeNodeData(entries);
            yield blocks.add(data);
            for (const entry of entries) {
              if (entry.isTree()) {
                const subtree = yield entry.getUnstoredBlocks();
                blocks.addMap(subtree.blocks);
              }
            }
            return { root: pointer, blocks };
          });
        }
        add(key, value, knownZeros) {
          return __async(this, null, function* () {
            ensureValidMstKey(key);
            const keyZeros = knownZeros != null ? knownZeros : yield leadingZerosOnHash(key);
            const layer = yield this.getLayer();
            const newLeaf = new Leaf(key, value);
            if (keyZeros === layer) {
              const index = yield this.findGtOrEqualLeafIndex(key);
              const found = yield this.atIndex(index);
              if ((found == null ? void 0 : found.isLeaf()) && found.key === key) {
                throw new Error(`There is already a value at key: ${key}`);
              }
              const prevNode = yield this.atIndex(index - 1);
              if (!prevNode || prevNode.isLeaf()) {
                return this.spliceIn(newLeaf, index);
              } else {
                const splitSubTree = yield prevNode.splitAround(key);
                return this.replaceWithSplit(index - 1, splitSubTree[0], newLeaf, splitSubTree[1]);
              }
            } else if (keyZeros < layer) {
              const index = yield this.findGtOrEqualLeafIndex(key);
              const prevNode = yield this.atIndex(index - 1);
              if (prevNode && prevNode.isTree()) {
                const newSubtree = yield prevNode.add(key, value, keyZeros);
                return this.updateEntry(index - 1, newSubtree);
              } else {
                const subTree = yield this.createChild();
                const newSubTree = yield subTree.add(key, value, keyZeros);
                return this.spliceIn(newSubTree, index);
              }
            } else {
              const split = yield this.splitAround(key);
              let left = split[0];
              let right = split[1];
              const layer2 = yield this.getLayer();
              const extraLayersToAdd = keyZeros - layer2;
              for (let i = 1; i < extraLayersToAdd; i++) {
                if (left !== null) {
                  left = yield left.createParent();
                }
                if (right !== null) {
                  right = yield right.createParent();
                }
              }
              const updated = [];
              if (left)
                updated.push(left);
              updated.push(new Leaf(key, value));
              if (right)
                updated.push(right);
              const newRoot = yield MST.create(this.storage, updated, {
                layer: keyZeros
              });
              newRoot.outdatedPointer = true;
              return newRoot;
            }
          });
        }
        get(key) {
          return __async(this, null, function* () {
            const index = yield this.findGtOrEqualLeafIndex(key);
            const found = yield this.atIndex(index);
            if (found && found.isLeaf() && found.key === key) {
              return found.value;
            }
            const prev = yield this.atIndex(index - 1);
            if (prev && prev.isTree()) {
              return prev.get(key);
            }
            return null;
          });
        }
        update(key, value) {
          return __async(this, null, function* () {
            ensureValidMstKey(key);
            const index = yield this.findGtOrEqualLeafIndex(key);
            const found = yield this.atIndex(index);
            if (found && found.isLeaf() && found.key === key) {
              return this.updateEntry(index, new Leaf(key, value));
            }
            const prev = yield this.atIndex(index - 1);
            if (prev && prev.isTree()) {
              const updatedTree = yield prev.update(key, value);
              return this.updateEntry(index - 1, updatedTree);
            }
            throw new Error(`Could not find a record with key: ${key}`);
          });
        }
        delete(key) {
          return __async(this, null, function* () {
            const altered = yield this.deleteRecurse(key);
            return altered.trimTop();
          });
        }
        deleteRecurse(key) {
          return __async(this, null, function* () {
            const index = yield this.findGtOrEqualLeafIndex(key);
            const found = yield this.atIndex(index);
            if ((found == null ? void 0 : found.isLeaf()) && found.key === key) {
              const prev2 = yield this.atIndex(index - 1);
              const next = yield this.atIndex(index + 1);
              if ((prev2 == null ? void 0 : prev2.isTree()) && (next == null ? void 0 : next.isTree())) {
                const merged = yield prev2.appendMerge(next);
                return this.newTree([
                  ...yield this.slice(0, index - 1),
                  merged,
                  ...yield this.slice(index + 2)
                ]);
              } else {
                return this.removeEntry(index);
              }
            }
            const prev = yield this.atIndex(index - 1);
            if (prev == null ? void 0 : prev.isTree()) {
              const subtree = yield prev.deleteRecurse(key);
              const subTreeEntries = yield subtree.getEntries();
              if (subTreeEntries.length === 0) {
                return this.removeEntry(index - 1);
              } else {
                return this.updateEntry(index - 1, subtree);
              }
            } else {
              throw new Error(`Could not find a record with key: ${key}`);
            }
          });
        }
        updateEntry(index, entry) {
          return __async(this, null, function* () {
            const update = [
              ...yield this.slice(0, index),
              entry,
              ...yield this.slice(index + 1)
            ];
            return this.newTree(update);
          });
        }
        removeEntry(index) {
          return __async(this, null, function* () {
            const updated = [
              ...yield this.slice(0, index),
              ...yield this.slice(index + 1)
            ];
            return this.newTree(updated);
          });
        }
        append(entry) {
          return __async(this, null, function* () {
            const entries = yield this.getEntries();
            return this.newTree([...entries, entry]);
          });
        }
        prepend(entry) {
          return __async(this, null, function* () {
            const entries = yield this.getEntries();
            return this.newTree([entry, ...entries]);
          });
        }
        atIndex(index) {
          return __async(this, null, function* () {
            var _a;
            const entries = yield this.getEntries();
            return (_a = entries[index]) != null ? _a : null;
          });
        }
        slice(start, end) {
          return __async(this, null, function* () {
            const entries = yield this.getEntries();
            return entries.slice(start, end);
          });
        }
        spliceIn(entry, index) {
          return __async(this, null, function* () {
            const update = [
              ...yield this.slice(0, index),
              entry,
              ...yield this.slice(index)
            ];
            return this.newTree(update);
          });
        }
        replaceWithSplit(index, left, leaf, right) {
          return __async(this, null, function* () {
            const update = yield this.slice(0, index);
            if (left)
              update.push(left);
            update.push(leaf);
            if (right)
              update.push(right);
            update.push(...yield this.slice(index + 1));
            return this.newTree(update);
          });
        }
        trimTop() {
          return __async(this, null, function* () {
            const entries = yield this.getEntries();
            if (entries.length === 1 && entries[0].isTree()) {
              return entries[0].trimTop();
            } else {
              return this;
            }
          });
        }
        splitAround(key) {
          return __async(this, null, function* () {
            const index = yield this.findGtOrEqualLeafIndex(key);
            const leftData = yield this.slice(0, index);
            const rightData = yield this.slice(index);
            let left = yield this.newTree(leftData);
            let right = yield this.newTree(rightData);
            const lastInLeft = leftData[leftData.length - 1];
            if (lastInLeft == null ? void 0 : lastInLeft.isTree()) {
              left = yield left.removeEntry(leftData.length - 1);
              const split = yield lastInLeft.splitAround(key);
              if (split[0]) {
                left = yield left.append(split[0]);
              }
              if (split[1]) {
                right = yield right.prepend(split[1]);
              }
            }
            return [
              (yield left.getEntries()).length > 0 ? left : null,
              (yield right.getEntries()).length > 0 ? right : null
            ];
          });
        }
        appendMerge(toMerge) {
          return __async(this, null, function* () {
            if ((yield this.getLayer()) !== (yield toMerge.getLayer())) {
              throw new Error("Trying to merge two nodes from different layers of the MST");
            }
            const thisEntries = yield this.getEntries();
            const toMergeEntries = yield toMerge.getEntries();
            const lastInLeft = thisEntries[thisEntries.length - 1];
            const firstInRight = toMergeEntries[0];
            if ((lastInLeft == null ? void 0 : lastInLeft.isTree()) && (firstInRight == null ? void 0 : firstInRight.isTree())) {
              const merged = yield lastInLeft.appendMerge(firstInRight);
              return this.newTree([
                ...thisEntries.slice(0, thisEntries.length - 1),
                merged,
                ...toMergeEntries.slice(1)
              ]);
            } else {
              return this.newTree([...thisEntries, ...toMergeEntries]);
            }
          });
        }
        createChild() {
          return __async(this, null, function* () {
            const layer = yield this.getLayer();
            return MST.create(this.storage, [], {
              layer: layer - 1
            });
          });
        }
        createParent() {
          return __async(this, null, function* () {
            const layer = yield this.getLayer();
            const parent = yield MST.create(this.storage, [this], {
              layer: layer + 1
            });
            parent.outdatedPointer = true;
            return parent;
          });
        }
        findGtOrEqualLeafIndex(key) {
          return __async(this, null, function* () {
            const entries = yield this.getEntries();
            const maybeIndex = entries.findIndex((entry) => entry.isLeaf() && entry.key >= key);
            return maybeIndex >= 0 ? maybeIndex : entries.length;
          });
        }
        walkLeavesFrom(key) {
          return __asyncGenerator(this, null, function* () {
            const index = yield new __await(this.findGtOrEqualLeafIndex(key));
            const entries = yield new __await(this.getEntries());
            const prev = entries[index - 1];
            if (prev && prev.isTree()) {
              try {
                for (var iter = __forAwait(prev.walkLeavesFrom(key)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                  const e = temp.value;
                  yield e;
                }
              } catch (temp) {
                error = [temp];
              } finally {
                try {
                  more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                } finally {
                  if (error)
                    throw error[0];
                }
              }
            }
            for (let i = index; i < entries.length; i++) {
              const entry = entries[i];
              if (entry.isLeaf()) {
                yield entry;
              } else {
                try {
                  for (var iter2 = __forAwait(entry.walkLeavesFrom(key)), more2, temp2, error2; more2 = !(temp2 = yield new __await(iter2.next())).done; more2 = false) {
                    const e = temp2.value;
                    yield e;
                  }
                } catch (temp2) {
                  error2 = [temp2];
                } finally {
                  try {
                    more2 && (temp2 = iter2.return) && (yield new __await(temp2.call(iter2)));
                  } finally {
                    if (error2)
                      throw error2[0];
                  }
                }
              }
            }
          });
        }
        list() {
          return __async(this, arguments, function* (count = Number.MAX_SAFE_INTEGER, after, before) {
            const vals = [];
            try {
              for (var iter = __forAwait(this.walkLeavesFrom(after || "")), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                const leaf = temp.value;
                if (leaf.key === after)
                  continue;
                if (vals.length >= count)
                  break;
                if (before && leaf.key >= before)
                  break;
                vals.push(leaf);
              }
            } catch (temp) {
              error = [temp];
            } finally {
              try {
                more && (temp = iter.return) && (yield temp.call(iter));
              } finally {
                if (error)
                  throw error[0];
              }
            }
            return vals;
          });
        }
        listWithPrefix(_0) {
          return __async(this, arguments, function* (prefix, count = Number.MAX_SAFE_INTEGER) {
            const vals = [];
            try {
              for (var iter = __forAwait(this.walkLeavesFrom(prefix)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                const leaf = temp.value;
                if (vals.length >= count || !leaf.key.startsWith(prefix))
                  break;
                vals.push(leaf);
              }
            } catch (temp) {
              error = [temp];
            } finally {
              try {
                more && (temp = iter.return) && (yield temp.call(iter));
              } finally {
                if (error)
                  throw error[0];
              }
            }
            return vals;
          });
        }
        walk() {
          return __asyncGenerator(this, null, function* () {
            yield this;
            const entries = yield new __await(this.getEntries());
            for (const entry of entries) {
              if (entry.isTree()) {
                try {
                  for (var iter = __forAwait(entry.walk()), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                    const e = temp.value;
                    yield e;
                  }
                } catch (temp) {
                  error = [temp];
                } finally {
                  try {
                    more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                  } finally {
                    if (error)
                      throw error[0];
                  }
                }
              } else {
                yield entry;
              }
            }
          });
        }
        paths() {
          return __async(this, null, function* () {
            const entries = yield this.getEntries();
            let paths = [];
            for (const entry of entries) {
              if (entry.isLeaf()) {
                paths.push([entry]);
              }
              if (entry.isTree()) {
                const subPaths = yield entry.paths();
                paths = [...paths, ...subPaths.map((p) => [entry, ...p])];
              }
            }
            return paths;
          });
        }
        allNodes() {
          return __async(this, null, function* () {
            const nodes = [];
            try {
              for (var iter = __forAwait(this.walk()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                const entry = temp.value;
                nodes.push(entry);
              }
            } catch (temp) {
              error = [temp];
            } finally {
              try {
                more && (temp = iter.return) && (yield temp.call(iter));
              } finally {
                if (error)
                  throw error[0];
              }
            }
            return nodes;
          });
        }
        allCids() {
          return __async(this, null, function* () {
            const cids = new cid_set_default();
            const entries = yield this.getEntries();
            for (const entry of entries) {
              if (entry.isLeaf()) {
                cids.add(entry.value);
              } else {
                const subtreeCids = yield entry.allCids();
                cids.addSet(subtreeCids);
              }
            }
            cids.add(yield this.getPointer());
            return cids;
          });
        }
        leaves() {
          return __async(this, null, function* () {
            const leaves = [];
            try {
              for (var iter = __forAwait(this.walk()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                const entry = temp.value;
                if (entry.isLeaf())
                  leaves.push(entry);
              }
            } catch (temp) {
              error = [temp];
            } finally {
              try {
                more && (temp = iter.return) && (yield temp.call(iter));
              } finally {
                if (error)
                  throw error[0];
              }
            }
            return leaves;
          });
        }
        leafCount() {
          return __async(this, null, function* () {
            const leaves = yield this.leaves();
            return leaves.length;
          });
        }
        walkReachable() {
          return __asyncGenerator(this, null, function* () {
            yield this;
            const entries = yield new __await(this.getEntries());
            for (const entry of entries) {
              if (entry.isTree()) {
                try {
                  try {
                    for (var iter = __forAwait(entry.walkReachable()), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                      const e = temp.value;
                      yield e;
                    }
                  } catch (temp) {
                    error = [temp];
                  } finally {
                    try {
                      more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                    } finally {
                      if (error)
                        throw error[0];
                    }
                  }
                } catch (err) {
                  if (err instanceof MissingBlockError) {
                    continue;
                  } else {
                    throw err;
                  }
                }
              } else {
                yield entry;
              }
            }
          });
        }
        reachableLeaves() {
          return __async(this, null, function* () {
            const leaves = [];
            try {
              for (var iter = __forAwait(this.walkReachable()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                const entry = temp.value;
                if (entry.isLeaf())
                  leaves.push(entry);
              }
            } catch (temp) {
              error = [temp];
            } finally {
              try {
                more && (temp = iter.return) && (yield temp.call(iter));
              } finally {
                if (error)
                  throw error[0];
              }
            }
            return leaves;
          });
        }
        writeToCarStream(car) {
          return __async(this, null, function* () {
            const leaves = new cid_set_default();
            let toFetch = new cid_set_default();
            toFetch.add(yield this.getPointer());
            while (toFetch.size() > 0) {
              const nextLayer = new cid_set_default();
              const fetched = yield this.storage.getBlocks(toFetch.toList());
              if (fetched.missing.length > 0) {
                throw new MissingBlocksError("mst node", fetched.missing);
              }
              for (const cid2 of toFetch.toList()) {
                const found = yield getAndParseByDef(fetched.blocks, cid2, nodeDataDef);
                yield car.put({ cid: cid2, bytes: found.bytes });
                const entries = yield deserializeNodeData(this.storage, found.obj);
                for (const entry of entries) {
                  if (entry.isLeaf()) {
                    leaves.add(entry.value);
                  } else {
                    nextLayer.add(yield entry.getPointer());
                  }
                }
              }
              toFetch = nextLayer;
            }
            const leafData = yield this.storage.getBlocks(leaves.toList());
            if (leafData.missing.length > 0) {
              throw new MissingBlocksError("mst leaf", leafData.missing);
            }
            for (const leaf of leafData.blocks.entries()) {
              yield car.put(leaf);
            }
          });
        }
        cidsForPath(key) {
          return __async(this, null, function* () {
            const cids = [yield this.getPointer()];
            const index = yield this.findGtOrEqualLeafIndex(key);
            const found = yield this.atIndex(index);
            if (found && found.isLeaf() && found.key === key) {
              return [...cids, found.value];
            }
            const prev = yield this.atIndex(index - 1);
            if (prev && prev.isTree()) {
              return [...cids, ...yield prev.cidsForPath(key)];
            }
            return cids;
          });
        }
        isTree() {
          return true;
        }
        isLeaf() {
          return false;
        }
        equals(other) {
          return __async(this, null, function* () {
            if (other.isLeaf())
              return false;
            const thisPointer = yield this.getPointer();
            const otherPointer = yield other.getPointer();
            return thisPointer.equals(otherPointer);
          });
        }
      };
      var Leaf = class {
        constructor(key, value) {
          this.key = key;
          this.value = value;
        }
        isTree() {
          return false;
        }
        isLeaf() {
          return true;
        }
        equals(entry) {
          if (entry.isLeaf()) {
            return this.key === entry.key && this.value.equals(entry.value);
          } else {
            return false;
          }
        }
      };
      var DataDiff = class {
        constructor() {
          this.adds = {};
          this.updates = {};
          this.deletes = {};
          this.newMstBlocks = new block_map_default();
          this.newLeafCids = new cid_set_default();
          this.removedCids = new cid_set_default();
        }
        static of(curr, prev) {
          return __async(this, null, function* () {
            return mstDiff(curr, prev);
          });
        }
        nodeAdd(node) {
          return __async(this, null, function* () {
            if (node.isLeaf()) {
              this.leafAdd(node.key, node.value);
            } else {
              const data = yield node.serialize();
              this.treeAdd(data.cid, data.bytes);
            }
          });
        }
        nodeDelete(node) {
          return __async(this, null, function* () {
            if (node.isLeaf()) {
              const key = node.key;
              const cid2 = node.value;
              this.deletes[key] = { key, cid: cid2 };
              this.removedCids.add(cid2);
            } else {
              const cid2 = yield node.getPointer();
              this.treeDelete(cid2);
            }
          });
        }
        leafAdd(key, cid2) {
          this.adds[key] = { key, cid: cid2 };
          if (this.removedCids.has(cid2)) {
            this.removedCids.delete(cid2);
          } else {
            this.newLeafCids.add(cid2);
          }
        }
        leafUpdate(key, prev, cid2) {
          if (prev.equals(cid2))
            return;
          this.updates[key] = { key, prev, cid: cid2 };
          this.removedCids.add(prev);
          this.newLeafCids.add(cid2);
        }
        leafDelete(key, cid2) {
          this.deletes[key] = { key, cid: cid2 };
          if (this.newLeafCids.has(cid2)) {
            this.newLeafCids.delete(cid2);
          } else {
            this.removedCids.add(cid2);
          }
        }
        treeAdd(cid2, bytes3) {
          if (this.removedCids.has(cid2)) {
            this.removedCids.delete(cid2);
          } else {
            this.newMstBlocks.set(cid2, bytes3);
          }
        }
        treeDelete(cid2) {
          if (this.newMstBlocks.has(cid2)) {
            this.newMstBlocks.delete(cid2);
          } else {
            this.removedCids.add(cid2);
          }
        }
        addList() {
          return Object.values(this.adds);
        }
        updateList() {
          return Object.values(this.updates);
        }
        deleteList() {
          return Object.values(this.deletes);
        }
        updatedKeys() {
          const keys = [
            ...Object.keys(this.adds),
            ...Object.keys(this.updates),
            ...Object.keys(this.deletes)
          ];
          return [...new Set(keys)];
        }
      };
      var data_diff_default = DataDiff;
      var MstWalker = class {
        constructor(root) {
          this.root = root;
          this.stack = [];
          this.status = {
            done: false,
            curr: root,
            walking: null,
            index: 0
          };
        }
        layer() {
          var _a, _b;
          if (this.status.done) {
            throw new Error("Walk is done");
          }
          if (this.status.walking) {
            return (_a = this.status.walking.layer) != null ? _a : 0;
          }
          if (this.status.curr.isTree()) {
            return ((_b = this.status.curr.layer) != null ? _b : 0) + 1;
          }
          throw new Error("Could not identify layer of walk");
        }
        stepOver() {
          return __async(this, null, function* () {
            if (this.status.done)
              return;
            if (this.status.walking === null) {
              this.status = { done: true };
              return;
            }
            const entries = yield this.status.walking.getEntries();
            this.status.index++;
            const next = entries[this.status.index];
            if (!next) {
              const popped = this.stack.pop();
              if (!popped) {
                this.status = { done: true };
                return;
              } else {
                this.status = popped;
                yield this.stepOver();
                return;
              }
            } else {
              this.status.curr = next;
            }
          });
        }
        stepInto() {
          return __async(this, null, function* () {
            if (this.status.done)
              return;
            if (this.status.walking === null) {
              if (!this.status.curr.isTree()) {
                throw new Error("The root of the tree cannot be a leaf");
              }
              const next2 = yield this.status.curr.atIndex(0);
              if (!next2) {
                this.status = { done: true };
              } else {
                this.status = {
                  done: false,
                  walking: this.status.curr,
                  curr: next2,
                  index: 0
                };
              }
              return;
            }
            if (!this.status.curr.isTree()) {
              throw new Error("No tree at pointer, cannot step into");
            }
            const next = yield this.status.curr.atIndex(0);
            if (!next) {
              throw new Error("Tried to step into a node with 0 entries which is invalid");
            }
            this.stack.push(__spreadValues({}, this.status));
            this.status.walking = this.status.curr;
            this.status.curr = next;
            this.status.index = 0;
          });
        }
        advance() {
          return __async(this, null, function* () {
            if (this.status.done)
              return;
            if (this.status.curr.isLeaf()) {
              yield this.stepOver();
            } else {
              yield this.stepInto();
            }
          });
        }
      };
      var walker_default = MstWalker;
      var nullDiff = (tree2) => __async(exports, null, function* () {
        const diff = new DataDiff();
        try {
          for (var iter = __forAwait(tree2.walk()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const entry = temp.value;
            yield diff.nodeAdd(entry);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        return diff;
      });
      var mstDiff = (curr, prev) => __async(exports, null, function* () {
        yield curr.getPointer();
        if (prev === null) {
          return nullDiff(curr);
        }
        yield prev.getPointer();
        const diff = new DataDiff();
        const leftWalker = new walker_default(prev);
        const rightWalker = new walker_default(curr);
        while (!leftWalker.status.done || !rightWalker.status.done) {
          if (leftWalker.status.done && !rightWalker.status.done) {
            yield diff.nodeAdd(rightWalker.status.curr);
            yield rightWalker.advance();
            continue;
          } else if (!leftWalker.status.done && rightWalker.status.done) {
            yield diff.nodeDelete(leftWalker.status.curr);
            yield leftWalker.advance();
            continue;
          }
          if (leftWalker.status.done || rightWalker.status.done)
            break;
          const left = leftWalker.status.curr;
          const right = rightWalker.status.curr;
          if (left === null || right === null)
            break;
          if (left.isLeaf() && right.isLeaf()) {
            if (left.key === right.key) {
              if (!left.value.equals(right.value)) {
                diff.leafUpdate(left.key, left.value, right.value);
              }
              yield leftWalker.advance();
              yield rightWalker.advance();
            } else if (left.key < right.key) {
              diff.leafDelete(left.key, left.value);
              yield leftWalker.advance();
            } else {
              diff.leafAdd(right.key, right.value);
              yield rightWalker.advance();
            }
            continue;
          }
          if (leftWalker.layer() > rightWalker.layer()) {
            if (left.isLeaf()) {
              yield diff.nodeAdd(right);
              yield rightWalker.advance();
            } else {
              yield diff.nodeDelete(left);
              yield leftWalker.stepInto();
            }
            continue;
          } else if (leftWalker.layer() < rightWalker.layer()) {
            if (right.isLeaf()) {
              yield diff.nodeDelete(left);
              yield leftWalker.advance();
            } else {
              yield diff.nodeAdd(right);
              yield rightWalker.stepInto();
            }
            continue;
          }
          if (left.isTree() && right.isTree()) {
            if (left.pointer.equals(right.pointer)) {
              yield leftWalker.stepOver();
              yield rightWalker.stepOver();
            } else {
              yield diff.nodeAdd(right);
              yield diff.nodeDelete(left);
              yield leftWalker.stepInto();
              yield rightWalker.stepInto();
            }
            continue;
          }
          if (left.isLeaf() && right.isTree()) {
            yield diff.nodeAdd(right);
            yield rightWalker.stepInto();
            continue;
          } else if (left.isTree() && right.isLeaf()) {
            yield diff.nodeDelete(left);
            yield leftWalker.stepInto();
            continue;
          }
          throw new Error("Unidentifiable case in diff walk");
        }
        return diff;
      });
      var logger = subsystemLogger("repo");
      var logger_default = logger;
      var ReadableRepo = class {
        constructor(params2) {
          this.storage = params2.storage;
          this.data = params2.data;
          this.commit = params2.commit;
          this.cid = params2.cid;
        }
        static load(storage, commitCid) {
          return __async(this, null, function* () {
            const commit2 = yield storage.readObj(commitCid, def2.versionedCommit);
            const data = yield MST.load(storage, commit2.data);
            logger_default.info({ did: commit2.did }, "loaded repo for");
            return new ReadableRepo({
              storage,
              data,
              commit: ensureV3Commit(commit2),
              cid: commitCid
            });
          });
        }
        get did() {
          return this.commit.did;
        }
        get version() {
          return this.commit.version;
        }
        getRecord(collection, rkey) {
          return __async(this, null, function* () {
            const dataKey = collection + "/" + rkey;
            const cid2 = yield this.data.get(dataKey);
            if (!cid2)
              return null;
            return this.storage.readObj(cid2, def2.unknown);
          });
        }
        getContents() {
          return __async(this, null, function* () {
            var _a;
            const entries = yield this.data.list();
            const cids = entries.map((e) => e.value);
            const { blocks, missing } = yield this.storage.getBlocks(cids);
            if (missing.length > 0) {
              throw new MissingBlocksError("getContents record", missing);
            }
            const contents = {};
            for (const entry of entries) {
              const { collection, rkey } = parseDataKey(entry.key);
              (_a = contents[collection]) != null ? _a : contents[collection] = {};
              const parsed = yield getAndParseRecord(blocks, entry.value);
              contents[collection][rkey] = parsed.record;
            }
            return contents;
          });
        }
      };
      var readable_repo_default = ReadableRepo;
      var Repo = class extends ReadableRepo {
        constructor(params2) {
          super(params2);
          this.storage = params2.storage;
        }
        static formatInitCommit(_0, _1, _2) {
          return __async(this, arguments, function* (storage, did2, keypair, initialWrites = []) {
            const newBlocks = new block_map_default();
            let data = yield MST.create(storage);
            for (const record of initialWrites) {
              const cid2 = yield newBlocks.add(record.record);
              const dataKey = formatDataKey(record.collection, record.rkey);
              data = yield data.add(dataKey, cid2);
            }
            const dataCid = yield data.getPointer();
            const diff = yield data_diff_default.of(data, null);
            newBlocks.addMap(diff.newMstBlocks);
            const rev = TID.nextStr();
            const commit2 = yield signCommit({
              did: did2,
              version: 3,
              rev,
              prev: null,
              data: dataCid
            }, keypair);
            const commitCid = yield newBlocks.add(commit2);
            return {
              cid: commitCid,
              rev,
              since: null,
              prev: null,
              newBlocks,
              removedCids: diff.removedCids
            };
          });
        }
        static createFromCommit(storage, commit2) {
          return __async(this, null, function* () {
            yield storage.applyCommit(commit2);
            return Repo.load(storage, commit2.cid);
          });
        }
        static create(_0, _1, _2) {
          return __async(this, arguments, function* (storage, did2, keypair, initialWrites = []) {
            const commit2 = yield Repo.formatInitCommit(storage, did2, keypair, initialWrites);
            return Repo.createFromCommit(storage, commit2);
          });
        }
        static load(storage, cid2) {
          return __async(this, null, function* () {
            const commitCid = cid2 || (yield storage.getRoot());
            if (!commitCid) {
              throw new Error("No cid provided and none in storage");
            }
            const commit2 = yield storage.readObj(commitCid, def2.versionedCommit);
            const data = yield MST.load(storage, commit2.data);
            logger_default.info({ did: commit2.did }, "loaded repo for");
            return new Repo({
              storage,
              data,
              commit: ensureV3Commit(commit2),
              cid: commitCid
            });
          });
        }
        formatCommit(toWrite, keypair) {
          return __async(this, null, function* () {
            const writes = Array.isArray(toWrite) ? toWrite : [toWrite];
            const leaves = new block_map_default();
            let data = this.data;
            for (const write of writes) {
              if (write.action === "create") {
                const cid2 = yield leaves.add(write.record);
                const dataKey = write.collection + "/" + write.rkey;
                data = yield data.add(dataKey, cid2);
              } else if (write.action === "update") {
                const cid2 = yield leaves.add(write.record);
                const dataKey = write.collection + "/" + write.rkey;
                data = yield data.update(dataKey, cid2);
              } else if (write.action === "delete") {
                const dataKey = write.collection + "/" + write.rkey;
                data = yield data.delete(dataKey);
              }
            }
            const dataCid = yield data.getPointer();
            const diff = yield data_diff_default.of(data, this.data);
            const newBlocks = diff.newMstBlocks;
            const removedCids = diff.removedCids;
            const addedLeaves = leaves.getMany(diff.newLeafCids.toList());
            if (addedLeaves.missing.length > 0) {
              throw new Error(`Missing leaf blocks: ${addedLeaves.missing}`);
            }
            newBlocks.addMap(addedLeaves.blocks);
            const rev = TID.nextStr(this.commit.rev);
            const commit2 = yield signCommit({
              did: this.did,
              version: 3,
              rev,
              prev: null,
              data: dataCid
            }, keypair);
            const commitCid = yield newBlocks.add(commit2);
            if (commitCid.equals(this.cid)) {
              newBlocks.delete(commitCid);
            } else {
              removedCids.add(this.cid);
            }
            return {
              cid: commitCid,
              rev,
              since: this.commit.rev,
              prev: this.cid,
              newBlocks,
              removedCids
            };
          });
        }
        applyCommit(commitData) {
          return __async(this, null, function* () {
            yield this.storage.applyCommit(commitData);
            return Repo.load(this.storage, commitData.cid);
          });
        }
        applyWrites(toWrite, keypair) {
          return __async(this, null, function* () {
            const commit2 = yield this.formatCommit(toWrite, keypair);
            return this.applyCommit(commit2);
          });
        }
      };
      var ReadableBlockstore = class {
        attemptRead(cid2, def3) {
          return __async(this, null, function* () {
            const bytes3 = yield this.getBytes(cid2);
            if (!bytes3)
              return null;
            return parseObjByDef(bytes3, cid2, def3);
          });
        }
        readObjAndBytes(cid2, def3) {
          return __async(this, null, function* () {
            const read3 = yield this.attemptRead(cid2, def3);
            if (!read3) {
              throw new MissingBlockError(cid2, def3.name);
            }
            return read3;
          });
        }
        readObj(cid2, def3) {
          return __async(this, null, function* () {
            const obj = yield this.readObjAndBytes(cid2, def3);
            return obj.obj;
          });
        }
        attemptReadRecord(cid2) {
          return __async(this, null, function* () {
            try {
              return yield this.readRecord(cid2);
            } catch (e) {
              return null;
            }
          });
        }
        readRecord(cid2) {
          return __async(this, null, function* () {
            const bytes3 = yield this.getBytes(cid2);
            if (!bytes3) {
              throw new MissingBlockError(cid2);
            }
            return cborToLexRecord(bytes3);
          });
        }
      };
      var readable_blockstore_default = ReadableBlockstore;
      var MemoryBlockstore = class extends readable_blockstore_default {
        constructor(blocks) {
          super();
          this.root = null;
          this.blocks = new block_map_default();
          if (blocks) {
            this.blocks.addMap(blocks);
          }
        }
        getRoot() {
          return __async(this, null, function* () {
            return this.root;
          });
        }
        getBytes(cid2) {
          return __async(this, null, function* () {
            return this.blocks.get(cid2) || null;
          });
        }
        has(cid2) {
          return __async(this, null, function* () {
            return this.blocks.has(cid2);
          });
        }
        getBlocks(cids) {
          return __async(this, null, function* () {
            return this.blocks.getMany(cids);
          });
        }
        putBlock(cid2, block) {
          return __async(this, null, function* () {
            this.blocks.set(cid2, block);
          });
        }
        putMany(blocks) {
          return __async(this, null, function* () {
            this.blocks.addMap(blocks);
          });
        }
        updateRoot(cid2) {
          return __async(this, null, function* () {
            this.root = cid2;
          });
        }
        applyCommit(commit2) {
          return __async(this, null, function* () {
            this.root = commit2.cid;
            const rmCids = commit2.removedCids.toList();
            for (const cid2 of rmCids) {
              this.blocks.delete(cid2);
            }
            commit2.newBlocks.forEach((bytes3, cid2) => {
              this.blocks.set(cid2, bytes3);
            });
          });
        }
        sizeInBytes() {
          return __async(this, null, function* () {
            let total = 0;
            this.blocks.forEach((bytes3) => {
              total += bytes3.byteLength;
            });
            return total;
          });
        }
        destroy() {
          return __async(this, null, function* () {
            this.blocks.clear();
          });
        }
      };
      var SyncStorage = class extends readable_blockstore_default {
        constructor(staged, saved) {
          super();
          this.staged = staged;
          this.saved = saved;
        }
        getBytes(cid2) {
          return __async(this, null, function* () {
            const got = yield this.staged.getBytes(cid2);
            if (got)
              return got;
            return this.saved.getBytes(cid2);
          });
        }
        getBlocks(cids) {
          return __async(this, null, function* () {
            const fromStaged = yield this.staged.getBlocks(cids);
            const fromSaved = yield this.saved.getBlocks(fromStaged.missing);
            const blocks = fromStaged.blocks;
            blocks.addMap(fromSaved.blocks);
            return {
              blocks,
              missing: fromSaved.missing
            };
          });
        }
        has(cid2) {
          return __async(this, null, function* () {
            return (yield this.staged.has(cid2)) || (yield this.saved.has(cid2));
          });
        }
      };
      var BlobNotFoundError = class extends Error {
      };
      var verifyRepoCar = (carBytes, did2, signingKey) => __async(exports, null, function* () {
        const car = yield readCarWithRoot(carBytes);
        return verifyRepo(car.blocks, car.root, did2, signingKey);
      });
      var verifyRepo = (blocks, head, did2, signingKey) => __async(exports, null, function* () {
        const diff = yield verifyDiff(null, blocks, head, did2, signingKey);
        const creates = ensureCreates(diff.writes);
        return {
          creates,
          commit: diff.commit
        };
      });
      var verifyDiffCar = (repo, carBytes, did2, signingKey) => __async(exports, null, function* () {
        const car = yield readCarWithRoot(carBytes);
        return verifyDiff(repo, car.blocks, car.root, did2, signingKey);
      });
      var verifyDiff = (repo, updateBlocks, updateRoot, did2, signingKey) => __async(exports, null, function* () {
        var _a, _b, _c;
        const stagedStorage = new MemoryBlockstore(updateBlocks);
        const updateStorage = repo ? new SyncStorage(stagedStorage, repo.storage) : stagedStorage;
        const updated = yield verifyRepoRoot(updateStorage, updateRoot, did2, signingKey);
        const diff = yield data_diff_default.of(updated.data, (_a = repo == null ? void 0 : repo.data) != null ? _a : null);
        const writes = yield diffToWriteDescripts(diff, updateBlocks);
        const newBlocks = diff.newMstBlocks;
        const leaves = updateBlocks.getMany(diff.newLeafCids.toList());
        if (leaves.missing.length > 0) {
          throw new Error(`missing leaf blocks: ${leaves.missing}`);
        }
        newBlocks.addMap(leaves.blocks);
        const removedCids = diff.removedCids;
        const commitCid = yield newBlocks.add(updated.commit);
        if (repo) {
          if (commitCid.equals(repo.cid)) {
            newBlocks.delete(commitCid);
          } else {
            removedCids.add(repo.cid);
          }
        }
        return {
          writes,
          commit: {
            cid: updated.cid,
            rev: updated.commit.rev,
            prev: (_b = repo == null ? void 0 : repo.cid) != null ? _b : null,
            since: (_c = repo == null ? void 0 : repo.commit.rev) != null ? _c : null,
            newBlocks,
            removedCids
          }
        };
      });
      var verifyRepoRoot = (storage, head, did2, signingKey) => __async(exports, null, function* () {
        const repo = yield readable_repo_default.load(storage, head);
        if (did2 !== void 0 && repo.did !== did2) {
          throw new RepoVerificationError(`Invalid repo did: ${repo.did}`);
        }
        if (signingKey !== void 0) {
          const validSig = yield verifyCommitSig(repo.commit, signingKey);
          if (!validSig) {
            throw new RepoVerificationError(`Invalid signature on commit: ${repo.cid.toString()}`);
          }
        }
        return repo;
      });
      var verifyProofs = (proofs, claims, did2, didKey) => __async(exports, null, function* () {
        const car = yield readCarWithRoot(proofs);
        const blockstore = new MemoryBlockstore(car.blocks);
        const commit2 = yield blockstore.readObj(car.root, def2.commit);
        if (commit2.did !== did2) {
          throw new RepoVerificationError(`Invalid repo did: ${commit2.did}`);
        }
        const validSig = yield verifyCommitSig(commit2, didKey);
        if (!validSig) {
          throw new RepoVerificationError(`Invalid signature on commit: ${car.root.toString()}`);
        }
        const mst = MST.load(blockstore, commit2.data);
        const verified = [];
        const unverified = [];
        for (const claim of claims) {
          const found = yield mst.get(formatDataKey(claim.collection, claim.rkey));
          const record = found ? yield blockstore.readObj(found, def2.map) : null;
          if (claim.record === null) {
            if (record === null) {
              verified.push(claim);
            } else {
              unverified.push(claim);
            }
          } else {
            const expected = yield cidForCbor(claim.record);
            if (expected.equals(found)) {
              verified.push(claim);
            } else {
              unverified.push(claim);
            }
          }
        }
        return { verified, unverified };
      });
      var verifyRecords = (proofs, did2, signingKey) => __async(exports, null, function* () {
        const car = yield readCarWithRoot(proofs);
        const blockstore = new MemoryBlockstore(car.blocks);
        const commit2 = yield blockstore.readObj(car.root, def2.commit);
        if (commit2.did !== did2) {
          throw new RepoVerificationError(`Invalid repo did: ${commit2.did}`);
        }
        const validSig = yield verifyCommitSig(commit2, signingKey);
        if (!validSig) {
          throw new RepoVerificationError(`Invalid signature on commit: ${car.root.toString()}`);
        }
        const mst = MST.load(blockstore, commit2.data);
        const records = [];
        const leaves = yield mst.reachableLeaves();
        for (const leaf of leaves) {
          const { collection, rkey } = parseDataKey(leaf.key);
          const record = yield blockstore.attemptReadRecord(leaf.value);
          if (record) {
            records.push({
              collection,
              rkey,
              record
            });
          }
        }
        return records;
      });
      var RepoVerificationError = class extends Error {
      };
      var getFullRepo = (storage, commitCid) => {
        return writeCar(commitCid, (car) => __async(exports, null, function* () {
          const commit2 = yield storage.readObjAndBytes(commitCid, def2.commit);
          yield car.put({ cid: commitCid, bytes: commit2.bytes });
          const mst = MST.load(storage, commit2.obj.data);
          yield mst.writeToCarStream(car);
        }));
      };
      var getRecords = (storage, commitCid, paths) => {
        return writeCar(commitCid, (car) => __async(exports, null, function* () {
          const commit2 = yield storage.readObjAndBytes(commitCid, def2.commit);
          yield car.put({ cid: commitCid, bytes: commit2.bytes });
          const mst = MST.load(storage, commit2.obj.data);
          const cidsForPaths = yield Promise.all(paths.map((p) => mst.cidsForPath(formatDataKey(p.collection, p.rkey))));
          const allCids = cidsForPaths.reduce((acc, cur) => {
            return acc.addSet(new cid_set_default(cur));
          }, new cid_set_default());
          const found = yield storage.getBlocks(allCids.toList());
          if (found.missing.length > 0) {
            throw new MissingBlocksError("writeRecordsToCarStream", found.missing);
          }
          for (const block of found.blocks.entries()) {
            yield car.put(block);
          }
        }));
      };
    }
  });

  // node_modules/xterm/lib/xterm.js
  var require_xterm = __commonJS({
    "node_modules/xterm/lib/xterm.js"(exports, module) {
      !function(e, t) {
        if ("object" == typeof exports && "object" == typeof module)
          module.exports = t();
        else if ("function" == typeof define && define.amd)
          define([], t);
        else {
          var i = t();
          for (var s in i)
            ("object" == typeof exports ? exports : e)[s] = i[s];
        }
      }(self, () => (() => {
        "use strict";
        var e = { 4567: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.AccessibilityManager = void 0;
          const n = i2(9042), o = i2(6114), a = i2(9924), h = i2(844), c = i2(5596), l = i2(4725), d = i2(3656);
          let _ = t2.AccessibilityManager = class extends h.Disposable {
            constructor(e3, t3) {
              super(), this._terminal = e3, this._renderService = t3, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
              for (let e4 = 0; e4 < this._terminal.rows; e4++)
                this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
              if (this._topBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 0), this._bottomBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new a.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element)
                throw new Error("Cannot enable accessibility before Terminal.open");
              this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((e4) => this._handleResize(e4.rows))), this.register(this._terminal.onRender((e4) => this._refreshRows(e4.start, e4.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((e4) => this._handleChar(e4))), this.register(this._terminal.onLineFeed(() => this._handleChar("\n"))), this.register(this._terminal.onA11yTab((e4) => this._handleTab(e4))), this.register(this._terminal.onKey((e4) => this._handleKey(e4.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new c.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, d.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, h.toDisposable)(() => {
                this._accessibilityContainer.remove(), this._rowElements.length = 0;
              }));
            }
            _handleTab(e3) {
              for (let t3 = 0; t3 < e3; t3++)
                this._handleChar(" ");
            }
            _handleChar(e3) {
              this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e3 && (this._charsToAnnounce += e3) : this._charsToAnnounce += e3, "\n" === e3 && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += n.tooMuchOutput)), o.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {
                this._accessibilityContainer.appendChild(this._liveRegion);
              }, 0));
            }
            _clearLiveRegion() {
              this._liveRegion.textContent = "", this._liveRegionLineCount = 0, o.isMac && this._liveRegion.remove();
            }
            _handleKey(e3) {
              this._clearLiveRegion(), new RegExp("\\p{Control}", "u").test(e3) || this._charsToConsume.push(e3);
            }
            _refreshRows(e3, t3) {
              this._liveRegionDebouncer.refresh(e3, t3, this._terminal.rows);
            }
            _renderRows(e3, t3) {
              const i3 = this._terminal.buffer, s3 = i3.lines.length.toString();
              for (let r2 = e3; r2 <= t3; r2++) {
                const e4 = i3.translateBufferLineToString(i3.ydisp + r2, true), t4 = (i3.ydisp + r2 + 1).toString(), n2 = this._rowElements[r2];
                n2 && (0 === e4.length ? n2.innerText = "\xA0" : n2.textContent = e4, n2.setAttribute("aria-posinset", t4), n2.setAttribute("aria-setsize", s3));
              }
              this._announceCharacters();
            }
            _announceCharacters() {
              0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
            }
            _handleBoundaryFocus(e3, t3) {
              const i3 = e3.target, s3 = this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2];
              if (i3.getAttribute("aria-posinset") === (0 === t3 ? "1" : `${this._terminal.buffer.lines.length}`))
                return;
              if (e3.relatedTarget !== s3)
                return;
              let r2, n2;
              if (0 === t3 ? (r2 = i3, n2 = this._rowElements.pop(), this._rowContainer.removeChild(n2)) : (r2 = this._rowElements.shift(), n2 = i3, this._rowContainer.removeChild(r2)), r2.removeEventListener("focus", this._topBoundaryFocusListener), n2.removeEventListener("focus", this._bottomBoundaryFocusListener), 0 === t3) {
                const e4 = this._createAccessibilityTreeNode();
                this._rowElements.unshift(e4), this._rowContainer.insertAdjacentElement("afterbegin", e4);
              } else {
                const e4 = this._createAccessibilityTreeNode();
                this._rowElements.push(e4), this._rowContainer.appendChild(e4);
              }
              this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t3 ? -1 : 1), this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2].focus(), e3.preventDefault(), e3.stopImmediatePropagation();
            }
            _handleResize(e3) {
              this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
              for (let e4 = this._rowContainer.children.length; e4 < this._terminal.rows; e4++)
                this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
              for (; this._rowElements.length > e3; )
                this._rowContainer.removeChild(this._rowElements.pop());
              this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
            }
            _createAccessibilityTreeNode() {
              const e3 = document.createElement("div");
              return e3.setAttribute("role", "listitem"), e3.tabIndex = -1, this._refreshRowDimensions(e3), e3;
            }
            _refreshRowsDimensions() {
              if (this._renderService.dimensions.css.cell.height) {
                this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
                for (let e3 = 0; e3 < this._terminal.rows; e3++)
                  this._refreshRowDimensions(this._rowElements[e3]);
              }
            }
            _refreshRowDimensions(e3) {
              e3.style.height = `${this._renderService.dimensions.css.cell.height}px`;
            }
          };
          t2.AccessibilityManager = _ = s2([r(1, l.IRenderService)], _);
        }, 3614: (e2, t2) => {
          function i2(e3) {
            return e3.replace(/\r?\n/g, "\r");
          }
          function s2(e3, t3) {
            return t3 ? "\x1B[200~" + e3 + "\x1B[201~" : e3;
          }
          function r(e3, t3, r2, n2) {
            e3 = s2(e3 = i2(e3), r2.decPrivateModes.bracketedPasteMode && true !== n2.rawOptions.ignoreBracketedPasteMode), r2.triggerDataEvent(e3, true), t3.value = "";
          }
          function n(e3, t3, i3) {
            const s3 = i3.getBoundingClientRect(), r2 = e3.clientX - s3.left - 10, n2 = e3.clientY - s3.top - 10;
            t3.style.width = "20px", t3.style.height = "20px", t3.style.left = `${r2}px`, t3.style.top = `${n2}px`, t3.style.zIndex = "1000", t3.focus();
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.rightClickHandler = t2.moveTextAreaUnderMouseCursor = t2.paste = t2.handlePasteEvent = t2.copyHandler = t2.bracketTextForPaste = t2.prepareTextForTerminal = void 0, t2.prepareTextForTerminal = i2, t2.bracketTextForPaste = s2, t2.copyHandler = function(e3, t3) {
            e3.clipboardData && e3.clipboardData.setData("text/plain", t3.selectionText), e3.preventDefault();
          }, t2.handlePasteEvent = function(e3, t3, i3, s3) {
            e3.stopPropagation(), e3.clipboardData && r(e3.clipboardData.getData("text/plain"), t3, i3, s3);
          }, t2.paste = r, t2.moveTextAreaUnderMouseCursor = n, t2.rightClickHandler = function(e3, t3, i3, s3, r2) {
            n(e3, t3, i3), r2 && s3.rightClickSelect(e3), t3.value = s3.selectionText, t3.select();
          };
        }, 7239: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorContrastCache = void 0;
          const s2 = i2(1505);
          t2.ColorContrastCache = class {
            constructor() {
              this._color = new s2.TwoKeyMap(), this._css = new s2.TwoKeyMap();
            }
            setCss(e3, t3, i3) {
              this._css.set(e3, t3, i3);
            }
            getCss(e3, t3) {
              return this._css.get(e3, t3);
            }
            setColor(e3, t3, i3) {
              this._color.set(e3, t3, i3);
            }
            getColor(e3, t3) {
              return this._color.get(e3, t3);
            }
            clear() {
              this._color.clear(), this._css.clear();
            }
          };
        }, 3656: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.addDisposableDomListener = void 0, t2.addDisposableDomListener = function(e3, t3, i2, s2) {
            e3.addEventListener(t3, i2, s2);
            let r = false;
            return { dispose: () => {
              r || (r = true, e3.removeEventListener(t3, i2, s2));
            } };
          };
        }, 6465: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Linkifier2 = void 0;
          const n = i2(3656), o = i2(8460), a = i2(844), h = i2(2585);
          let c = t2.Linkifier2 = class extends a.Disposable {
            get currentLink() {
              return this._currentLink;
            }
            constructor(e3) {
              super(), this._bufferService = e3, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)(() => {
                this._lastMouseEvent = void 0;
              })), this.register(this._bufferService.onResize(() => {
                this._clearCurrentLink(), this._wasResized = true;
              }));
            }
            registerLinkProvider(e3) {
              return this._linkProviders.push(e3), { dispose: () => {
                const t3 = this._linkProviders.indexOf(e3);
                -1 !== t3 && this._linkProviders.splice(t3, 1);
              } };
            }
            attachToDom(e3, t3, i3) {
              this._element = e3, this._mouseService = t3, this._renderService = i3, this.register((0, n.addDisposableDomListener)(this._element, "mouseleave", () => {
                this._isMouseOut = true, this._clearCurrentLink();
              })), this.register((0, n.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
            }
            _handleMouseMove(e3) {
              if (this._lastMouseEvent = e3, !this._element || !this._mouseService)
                return;
              const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
              if (!t3)
                return;
              this._isMouseOut = false;
              const i3 = e3.composedPath();
              for (let e4 = 0; e4 < i3.length; e4++) {
                const t4 = i3[e4];
                if (t4.classList.contains("xterm"))
                  break;
                if (t4.classList.contains("xterm-hover"))
                  return;
              }
              this._lastBufferCell && t3.x === this._lastBufferCell.x && t3.y === this._lastBufferCell.y || (this._handleHover(t3), this._lastBufferCell = t3);
            }
            _handleHover(e3) {
              if (this._activeLine !== e3.y || this._wasResized)
                return this._clearCurrentLink(), this._askForLink(e3, false), void (this._wasResized = false);
              this._currentLink && this._linkAtPosition(this._currentLink.link, e3) || (this._clearCurrentLink(), this._askForLink(e3, true));
            }
            _askForLink(e3, t3) {
              var i3, s3;
              this._activeProviderReplies && t3 || (null === (i3 = this._activeProviderReplies) || void 0 === i3 || i3.forEach((e4) => {
                null == e4 || e4.forEach((e5) => {
                  e5.link.dispose && e5.link.dispose();
                });
              }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = e3.y);
              let r2 = false;
              for (const [i4, n2] of this._linkProviders.entries())
                t3 ? (null === (s3 = this._activeProviderReplies) || void 0 === s3 ? void 0 : s3.get(i4)) && (r2 = this._checkLinkProviderResult(i4, e3, r2)) : n2.provideLinks(e3.y, (t4) => {
                  var s4, n3;
                  if (this._isMouseOut)
                    return;
                  const o2 = null == t4 ? void 0 : t4.map((e4) => ({ link: e4 }));
                  null === (s4 = this._activeProviderReplies) || void 0 === s4 || s4.set(i4, o2), r2 = this._checkLinkProviderResult(i4, e3, r2), (null === (n3 = this._activeProviderReplies) || void 0 === n3 ? void 0 : n3.size) === this._linkProviders.length && this._removeIntersectingLinks(e3.y, this._activeProviderReplies);
                });
            }
            _removeIntersectingLinks(e3, t3) {
              const i3 = /* @__PURE__ */ new Set();
              for (let s3 = 0; s3 < t3.size; s3++) {
                const r2 = t3.get(s3);
                if (r2)
                  for (let t4 = 0; t4 < r2.length; t4++) {
                    const s4 = r2[t4], n2 = s4.link.range.start.y < e3 ? 0 : s4.link.range.start.x, o2 = s4.link.range.end.y > e3 ? this._bufferService.cols : s4.link.range.end.x;
                    for (let e4 = n2; e4 <= o2; e4++) {
                      if (i3.has(e4)) {
                        r2.splice(t4--, 1);
                        break;
                      }
                      i3.add(e4);
                    }
                  }
              }
            }
            _checkLinkProviderResult(e3, t3, i3) {
              var s3;
              if (!this._activeProviderReplies)
                return i3;
              const r2 = this._activeProviderReplies.get(e3);
              let n2 = false;
              for (let t4 = 0; t4 < e3; t4++)
                this._activeProviderReplies.has(t4) && !this._activeProviderReplies.get(t4) || (n2 = true);
              if (!n2 && r2) {
                const e4 = r2.find((e5) => this._linkAtPosition(e5.link, t3));
                e4 && (i3 = true, this._handleNewLink(e4));
              }
              if (this._activeProviderReplies.size === this._linkProviders.length && !i3)
                for (let e4 = 0; e4 < this._activeProviderReplies.size; e4++) {
                  const r3 = null === (s3 = this._activeProviderReplies.get(e4)) || void 0 === s3 ? void 0 : s3.find((e5) => this._linkAtPosition(e5.link, t3));
                  if (r3) {
                    i3 = true, this._handleNewLink(r3);
                    break;
                  }
                }
              return i3;
            }
            _handleMouseDown() {
              this._mouseDownLink = this._currentLink;
            }
            _handleMouseUp(e3) {
              if (!this._element || !this._mouseService || !this._currentLink)
                return;
              const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
              t3 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t3) && this._currentLink.link.activate(e3, this._currentLink.link.text);
            }
            _clearCurrentLink(e3, t3) {
              this._element && this._currentLink && this._lastMouseEvent && (!e3 || !t3 || this._currentLink.link.range.start.y >= e3 && this._currentLink.link.range.end.y <= t3) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));
            }
            _handleNewLink(e3) {
              if (!this._element || !this._lastMouseEvent || !this._mouseService)
                return;
              const t3 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
              t3 && this._linkAtPosition(e3.link, t3) && (this._currentLink = e3, this._currentLink.state = { decorations: { underline: void 0 === e3.link.decorations || e3.link.decorations.underline, pointerCursor: void 0 === e3.link.decorations || e3.link.decorations.pointerCursor }, isHovered: true }, this._linkHover(this._element, e3.link, this._lastMouseEvent), e3.link.decorations = {}, Object.defineProperties(e3.link.decorations, { pointerCursor: { get: () => {
                var e4, t4;
                return null === (t4 = null === (e4 = this._currentLink) || void 0 === e4 ? void 0 : e4.state) || void 0 === t4 ? void 0 : t4.decorations.pointerCursor;
              }, set: (e4) => {
                var t4, i3;
                (null === (t4 = this._currentLink) || void 0 === t4 ? void 0 : t4.state) && this._currentLink.state.decorations.pointerCursor !== e4 && (this._currentLink.state.decorations.pointerCursor = e4, this._currentLink.state.isHovered && (null === (i3 = this._element) || void 0 === i3 || i3.classList.toggle("xterm-cursor-pointer", e4)));
              } }, underline: { get: () => {
                var e4, t4;
                return null === (t4 = null === (e4 = this._currentLink) || void 0 === e4 ? void 0 : e4.state) || void 0 === t4 ? void 0 : t4.decorations.underline;
              }, set: (t4) => {
                var i3, s3, r2;
                (null === (i3 = this._currentLink) || void 0 === i3 ? void 0 : i3.state) && (null === (r2 = null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) || void 0 === r2 ? void 0 : r2.decorations.underline) !== t4 && (this._currentLink.state.decorations.underline = t4, this._currentLink.state.isHovered && this._fireUnderlineEvent(e3.link, t4));
              } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((e4) => {
                if (!this._currentLink)
                  return;
                const t4 = 0 === e4.start ? 0 : e4.start + 1 + this._bufferService.buffer.ydisp, i3 = this._bufferService.buffer.ydisp + 1 + e4.end;
                if (this._currentLink.link.range.start.y >= t4 && this._currentLink.link.range.end.y <= i3 && (this._clearCurrentLink(t4, i3), this._lastMouseEvent && this._element)) {
                  const e5 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                  e5 && this._askForLink(e5, false);
                }
              })));
            }
            _linkHover(e3, t3, i3) {
              var s3;
              (null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, true), this._currentLink.state.decorations.pointerCursor && e3.classList.add("xterm-cursor-pointer")), t3.hover && t3.hover(i3, t3.text);
            }
            _fireUnderlineEvent(e3, t3) {
              const i3 = e3.range, s3 = this._bufferService.buffer.ydisp, r2 = this._createLinkUnderlineEvent(i3.start.x - 1, i3.start.y - s3 - 1, i3.end.x, i3.end.y - s3 - 1, void 0);
              (t3 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r2);
            }
            _linkLeave(e3, t3, i3) {
              var s3;
              (null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, false), this._currentLink.state.decorations.pointerCursor && e3.classList.remove("xterm-cursor-pointer")), t3.leave && t3.leave(i3, t3.text);
            }
            _linkAtPosition(e3, t3) {
              const i3 = e3.range.start.y * this._bufferService.cols + e3.range.start.x, s3 = e3.range.end.y * this._bufferService.cols + e3.range.end.x, r2 = t3.y * this._bufferService.cols + t3.x;
              return i3 <= r2 && r2 <= s3;
            }
            _positionFromMouseEvent(e3, t3, i3) {
              const s3 = i3.getCoords(e3, t3, this._bufferService.cols, this._bufferService.rows);
              if (s3)
                return { x: s3[0], y: s3[1] + this._bufferService.buffer.ydisp };
            }
            _createLinkUnderlineEvent(e3, t3, i3, s3, r2) {
              return { x1: e3, y1: t3, x2: i3, y2: s3, cols: this._bufferService.cols, fg: r2 };
            }
          };
          t2.Linkifier2 = c = s2([r(0, h.IBufferService)], c);
        }, 9042: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.tooMuchOutput = t2.promptLabel = void 0, t2.promptLabel = "Terminal input", t2.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
        }, 3730: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkProvider = void 0;
          const n = i2(511), o = i2(2585);
          let a = t2.OscLinkProvider = class {
            constructor(e3, t3, i3) {
              this._bufferService = e3, this._optionsService = t3, this._oscLinkService = i3;
            }
            provideLinks(e3, t3) {
              var i3;
              const s3 = this._bufferService.buffer.lines.get(e3 - 1);
              if (!s3)
                return void t3(void 0);
              const r2 = [], o2 = this._optionsService.rawOptions.linkHandler, a2 = new n.CellData(), c = s3.getTrimmedLength();
              let l = -1, d = -1, _ = false;
              for (let t4 = 0; t4 < c; t4++)
                if (-1 !== d || s3.hasContent(t4)) {
                  if (s3.loadCell(t4, a2), a2.hasExtendedAttrs() && a2.extended.urlId) {
                    if (-1 === d) {
                      d = t4, l = a2.extended.urlId;
                      continue;
                    }
                    _ = a2.extended.urlId !== l;
                  } else
                    -1 !== d && (_ = true);
                  if (_ || -1 !== d && t4 === c - 1) {
                    const s4 = null === (i3 = this._oscLinkService.getLinkData(l)) || void 0 === i3 ? void 0 : i3.uri;
                    if (s4) {
                      const i4 = { start: { x: d + 1, y: e3 }, end: { x: t4 + (_ || t4 !== c - 1 ? 0 : 1), y: e3 } };
                      let n2 = false;
                      if (!(null == o2 ? void 0 : o2.allowNonHttpProtocols))
                        try {
                          const e4 = new URL(s4);
                          ["http:", "https:"].includes(e4.protocol) || (n2 = true);
                        } catch (e4) {
                          n2 = true;
                        }
                      n2 || r2.push({ text: s4, range: i4, activate: (e4, t5) => o2 ? o2.activate(e4, t5, i4) : h(0, t5), hover: (e4, t5) => {
                        var s5;
                        return null === (s5 = null == o2 ? void 0 : o2.hover) || void 0 === s5 ? void 0 : s5.call(o2, e4, t5, i4);
                      }, leave: (e4, t5) => {
                        var s5;
                        return null === (s5 = null == o2 ? void 0 : o2.leave) || void 0 === s5 ? void 0 : s5.call(o2, e4, t5, i4);
                      } });
                    }
                    _ = false, a2.hasExtendedAttrs() && a2.extended.urlId ? (d = t4, l = a2.extended.urlId) : (d = -1, l = -1);
                  }
                }
              t3(r2);
            }
          };
          function h(e3, t3) {
            if (confirm(`Do you want to navigate to ${t3}?

WARNING: This link could potentially be dangerous`)) {
              const e4 = window.open();
              if (e4) {
                try {
                  e4.opener = null;
                } catch (e5) {
                }
                e4.location.href = t3;
              } else
                console.warn("Opening link blocked as opener could not be cleared");
            }
          }
          t2.OscLinkProvider = a = s2([r(0, o.IBufferService), r(1, o.IOptionsService), r(2, o.IOscLinkService)], a);
        }, 6193: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderDebouncer = void 0, t2.RenderDebouncer = class {
            constructor(e3, t3) {
              this._parentWindow = e3, this._renderCallback = t3, this._refreshCallbacks = [];
            }
            dispose() {
              this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
            }
            addRefreshCallback(e3) {
              return this._refreshCallbacks.push(e3), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
            }
            refresh(e3, t3, i2) {
              this._rowCount = i2, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
            }
            _innerRefresh() {
              if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount)
                return void this._runRefreshCallbacks();
              const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
              this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3), this._runRefreshCallbacks();
            }
            _runRefreshCallbacks() {
              for (const e3 of this._refreshCallbacks)
                e3(0);
              this._refreshCallbacks = [];
            }
          };
        }, 5596: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ScreenDprMonitor = void 0;
          const s2 = i2(844);
          class r extends s2.Disposable {
            constructor(e3) {
              super(), this._parentWindow = e3, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, s2.toDisposable)(() => {
                this.clearListener();
              }));
            }
            setListener(e3) {
              this._listener && this.clearListener(), this._listener = e3, this._outerListener = () => {
                this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
              }, this._updateDpr();
            }
            _updateDpr() {
              var e3;
              this._outerListener && (null === (e3 = this._resolutionMediaMatchList) || void 0 === e3 || e3.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
            }
            clearListener() {
              this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
            }
          }
          t2.ScreenDprMonitor = r;
        }, 3236: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Terminal = void 0;
          const s2 = i2(3614), r = i2(3656), n = i2(6465), o = i2(9042), a = i2(3730), h = i2(1680), c = i2(3107), l = i2(5744), d = i2(2950), _ = i2(1296), u = i2(428), f = i2(4269), v = i2(5114), p = i2(8934), g = i2(3230), m = i2(9312), S = i2(4725), C = i2(6731), b = i2(8055), y = i2(8969), w = i2(8460), E = i2(844), k = i2(6114), L = i2(8437), D = i2(2584), R = i2(7399), x = i2(5941), A = i2(9074), B = i2(2585), T = i2(5435), M = i2(4567), O = "undefined" != typeof window ? window.document : null;
          class P extends y.CoreTerminal {
            get onFocus() {
              return this._onFocus.event;
            }
            get onBlur() {
              return this._onBlur.event;
            }
            get onA11yChar() {
              return this._onA11yCharEmitter.event;
            }
            get onA11yTab() {
              return this._onA11yTabEmitter.event;
            }
            get onWillOpen() {
              return this._onWillOpen.event;
            }
            constructor(e3 = {}) {
              super(e3), this.browser = k, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._accessibilityManager = this.register(new E.MutableDisposable()), this._onCursorMove = this.register(new w.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new w.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new w.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new w.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new w.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new w.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new w.EventEmitter()), this._onBlur = this.register(new w.EventEmitter()), this._onA11yCharEmitter = this.register(new w.EventEmitter()), this._onA11yTabEmitter = this.register(new w.EventEmitter()), this._onWillOpen = this.register(new w.EventEmitter()), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(n.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(a.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(B.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((e4, t3) => this.refresh(e4, t3))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((e4) => this._reportWindowsOptions(e4))), this.register(this._inputHandler.onColor((e4) => this._handleColorEvent(e4))), this.register((0, w.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, w.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, w.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, w.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((e4) => this._afterResize(e4.cols, e4.rows))), this.register((0, E.toDisposable)(() => {
                var e4, t3;
                this._customKeyEventHandler = void 0, null === (t3 = null === (e4 = this.element) || void 0 === e4 ? void 0 : e4.parentNode) || void 0 === t3 || t3.removeChild(this.element);
              }));
            }
            _handleColorEvent(e3) {
              if (this._themeService)
                for (const t3 of e3) {
                  let e4, i3 = "";
                  switch (t3.index) {
                    case 256:
                      e4 = "foreground", i3 = "10";
                      break;
                    case 257:
                      e4 = "background", i3 = "11";
                      break;
                    case 258:
                      e4 = "cursor", i3 = "12";
                      break;
                    default:
                      e4 = "ansi", i3 = "4;" + t3.index;
                  }
                  switch (t3.type) {
                    case 0:
                      const s3 = b.color.toColorRGB("ansi" === e4 ? this._themeService.colors.ansi[t3.index] : this._themeService.colors[e4]);
                      this.coreService.triggerDataEvent(`${D.C0.ESC}]${i3};${(0, x.toRgbString)(s3)}${D.C1_ESCAPED.ST}`);
                      break;
                    case 1:
                      if ("ansi" === e4)
                        this._themeService.modifyColors((e5) => e5.ansi[t3.index] = b.rgba.toColor(...t3.color));
                      else {
                        const i4 = e4;
                        this._themeService.modifyColors((e5) => e5[i4] = b.rgba.toColor(...t3.color));
                      }
                      break;
                    case 2:
                      this._themeService.restoreColor(t3.index);
                  }
                }
            }
            _setup() {
              super._setup(), this._customKeyEventHandler = void 0;
            }
            get buffer() {
              return this.buffers.active;
            }
            focus() {
              this.textarea && this.textarea.focus({ preventScroll: true });
            }
            _handleScreenReaderModeOptionChange(e3) {
              e3 ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)) : this._accessibilityManager.clear();
            }
            _handleTextAreaFocus(e3) {
              this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[I"), this.updateCursorStyle(e3), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
            }
            blur() {
              var e3;
              return null === (e3 = this.textarea) || void 0 === e3 ? void 0 : e3.blur();
            }
            _handleTextAreaBlur() {
              this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
            }
            _syncTextArea() {
              if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService)
                return;
              const e3 = this.buffer.ybase + this.buffer.y, t3 = this.buffer.lines.get(e3);
              if (!t3)
                return;
              const i3 = Math.min(this.buffer.x, this.cols - 1), s3 = this._renderService.dimensions.css.cell.height, r2 = t3.getWidth(i3), n2 = this._renderService.dimensions.css.cell.width * r2, o2 = this.buffer.y * this._renderService.dimensions.css.cell.height, a2 = i3 * this._renderService.dimensions.css.cell.width;
              this.textarea.style.left = a2 + "px", this.textarea.style.top = o2 + "px", this.textarea.style.width = n2 + "px", this.textarea.style.height = s3 + "px", this.textarea.style.lineHeight = s3 + "px", this.textarea.style.zIndex = "-5";
            }
            _initGlobal() {
              this._bindKeys(), this.register((0, r.addDisposableDomListener)(this.element, "copy", (e4) => {
                this.hasSelection() && (0, s2.copyHandler)(e4, this._selectionService);
              }));
              const e3 = (e4) => (0, s2.handlePasteEvent)(e4, this.textarea, this.coreService, this.optionsService);
              this.register((0, r.addDisposableDomListener)(this.textarea, "paste", e3)), this.register((0, r.addDisposableDomListener)(this.element, "paste", e3)), k.isFirefox ? this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => {
                2 === e4.button && (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
              })) : this.register((0, r.addDisposableDomListener)(this.element, "contextmenu", (e4) => {
                (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
              })), k.isLinux && this.register((0, r.addDisposableDomListener)(this.element, "auxclick", (e4) => {
                1 === e4.button && (0, s2.moveTextAreaUnderMouseCursor)(e4, this.textarea, this.screenElement);
              }));
            }
            _bindKeys() {
              this.register((0, r.addDisposableDomListener)(this.textarea, "keyup", (e3) => this._keyUp(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keydown", (e3) => this._keyDown(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keypress", (e3) => this._keyPress(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionupdate", (e3) => this._compositionHelper.compositionupdate(e3))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, r.addDisposableDomListener)(this.textarea, "input", (e3) => this._inputEvent(e3), true)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
            }
            open(e3) {
              var t3;
              if (!e3)
                throw new Error("Terminal requires a parent element.");
              e3.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = e3.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e3.appendChild(this.element);
              const i3 = O.createDocumentFragment();
              this._viewportElement = O.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), i3.appendChild(this._viewportElement), this._viewportScrollArea = O.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = O.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = O.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), i3.appendChild(this.screenElement), this.textarea = O.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", o.promptLabel), k.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(v.CoreBrowserService, this.textarea, null !== (t3 = this._document.defaultView) && void 0 !== t3 ? t3 : window), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, r.addDisposableDomListener)(this.textarea, "focus", (e4) => this._handleTextAreaFocus(e4))), this.register((0, r.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(u.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(C.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(f.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(g.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((e4) => this._onRender.fire(e4))), this.onResize((e4) => this._renderService.resize(e4.cols, e4.rows)), this._compositionView = O.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(d.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(i3);
              try {
                this._onWillOpen.fire(this.element);
              } catch (e4) {
              }
              this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(p.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(h.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
                this._renderService.handleCursorMove(), this._syncTextArea();
              })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(m.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((e4) => this._renderService.handleSelectionChanged(e4.start, e4.end, e4.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((e4) => {
                this.textarea.value = e4, this.textarea.focus(), this.textarea.select();
              })), this.register(this._onScroll.event((e4) => {
                this.viewport.syncScrollArea(), this._selectionService.refresh();
              })), this.register((0, r.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(c.BufferDecorationRenderer, this.screenElement)), this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => this._selectionService.handleMouseDown(e4))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (e4) => this._handleScreenReaderModeOptionChange(e4))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (e4) => {
                !this._overviewRulerRenderer && e4 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
              }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
            }
            _createRenderer() {
              return this._instantiationService.createInstance(_.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
            }
            bindMouse() {
              const e3 = this, t3 = this.element;
              function i3(t4) {
                const i4 = e3._mouseService.getMouseReportCoords(t4, e3.screenElement);
                if (!i4)
                  return false;
                let s4, r2;
                switch (t4.overrideType || t4.type) {
                  case "mousemove":
                    r2 = 32, void 0 === t4.buttons ? (s4 = 3, void 0 !== t4.button && (s4 = t4.button < 3 ? t4.button : 3)) : s4 = 1 & t4.buttons ? 0 : 4 & t4.buttons ? 1 : 2 & t4.buttons ? 2 : 3;
                    break;
                  case "mouseup":
                    r2 = 0, s4 = t4.button < 3 ? t4.button : 3;
                    break;
                  case "mousedown":
                    r2 = 1, s4 = t4.button < 3 ? t4.button : 3;
                    break;
                  case "wheel":
                    if (0 === e3.viewport.getLinesScrolled(t4))
                      return false;
                    r2 = t4.deltaY < 0 ? 0 : 1, s4 = 4;
                    break;
                  default:
                    return false;
                }
                return !(void 0 === r2 || void 0 === s4 || s4 > 4) && e3.coreMouseService.triggerMouseEvent({ col: i4.col, row: i4.row, x: i4.x, y: i4.y, button: s4, action: r2, ctrl: t4.ctrlKey, alt: t4.altKey, shift: t4.shiftKey });
              }
              const s3 = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, n2 = { mouseup: (e4) => (i3(e4), e4.buttons || (this._document.removeEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.removeEventListener("mousemove", s3.mousedrag)), this.cancel(e4)), wheel: (e4) => (i3(e4), this.cancel(e4, true)), mousedrag: (e4) => {
                e4.buttons && i3(e4);
              }, mousemove: (e4) => {
                e4.buttons || i3(e4);
              } };
              this.register(this.coreMouseService.onProtocolChange((e4) => {
                e4 ? ("debug" === this.optionsService.rawOptions.logLevel && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e4)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e4 ? s3.mousemove || (t3.addEventListener("mousemove", n2.mousemove), s3.mousemove = n2.mousemove) : (t3.removeEventListener("mousemove", s3.mousemove), s3.mousemove = null), 16 & e4 ? s3.wheel || (t3.addEventListener("wheel", n2.wheel, { passive: false }), s3.wheel = n2.wheel) : (t3.removeEventListener("wheel", s3.wheel), s3.wheel = null), 2 & e4 ? s3.mouseup || (t3.addEventListener("mouseup", n2.mouseup), s3.mouseup = n2.mouseup) : (this._document.removeEventListener("mouseup", s3.mouseup), t3.removeEventListener("mouseup", s3.mouseup), s3.mouseup = null), 4 & e4 ? s3.mousedrag || (s3.mousedrag = n2.mousedrag) : (this._document.removeEventListener("mousemove", s3.mousedrag), s3.mousedrag = null);
              })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, r.addDisposableDomListener)(t3, "mousedown", (e4) => {
                if (e4.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e4))
                  return i3(e4), s3.mouseup && this._document.addEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.addEventListener("mousemove", s3.mousedrag), this.cancel(e4);
              })), this.register((0, r.addDisposableDomListener)(t3, "wheel", (e4) => {
                if (!s3.wheel) {
                  if (!this.buffer.hasScrollback) {
                    const t4 = this.viewport.getLinesScrolled(e4);
                    if (0 === t4)
                      return;
                    const i4 = D.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e4.deltaY < 0 ? "A" : "B");
                    let s4 = "";
                    for (let e5 = 0; e5 < Math.abs(t4); e5++)
                      s4 += i4;
                    return this.coreService.triggerDataEvent(s4, true), this.cancel(e4, true);
                  }
                  return this.viewport.handleWheel(e4) ? this.cancel(e4) : void 0;
                }
              }, { passive: false })), this.register((0, r.addDisposableDomListener)(t3, "touchstart", (e4) => {
                if (!this.coreMouseService.areMouseEventsActive)
                  return this.viewport.handleTouchStart(e4), this.cancel(e4);
              }, { passive: true })), this.register((0, r.addDisposableDomListener)(t3, "touchmove", (e4) => {
                if (!this.coreMouseService.areMouseEventsActive)
                  return this.viewport.handleTouchMove(e4) ? void 0 : this.cancel(e4);
              }, { passive: false }));
            }
            refresh(e3, t3) {
              var i3;
              null === (i3 = this._renderService) || void 0 === i3 || i3.refreshRows(e3, t3);
            }
            updateCursorStyle(e3) {
              var t3;
              (null === (t3 = this._selectionService) || void 0 === t3 ? void 0 : t3.shouldColumnSelect(e3)) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
            }
            _showCursor() {
              this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
            }
            scrollLines(e3, t3, i3 = 0) {
              var s3;
              1 === i3 ? (super.scrollLines(e3, t3, i3), this.refresh(0, this.rows - 1)) : null === (s3 = this.viewport) || void 0 === s3 || s3.scrollLines(e3);
            }
            paste(e3) {
              (0, s2.paste)(e3, this.textarea, this.coreService, this.optionsService);
            }
            attachCustomKeyEventHandler(e3) {
              this._customKeyEventHandler = e3;
            }
            registerLinkProvider(e3) {
              return this.linkifier2.registerLinkProvider(e3);
            }
            registerCharacterJoiner(e3) {
              if (!this._characterJoinerService)
                throw new Error("Terminal must be opened first");
              const t3 = this._characterJoinerService.register(e3);
              return this.refresh(0, this.rows - 1), t3;
            }
            deregisterCharacterJoiner(e3) {
              if (!this._characterJoinerService)
                throw new Error("Terminal must be opened first");
              this._characterJoinerService.deregister(e3) && this.refresh(0, this.rows - 1);
            }
            get markers() {
              return this.buffer.markers;
            }
            registerMarker(e3) {
              return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e3);
            }
            registerDecoration(e3) {
              return this._decorationService.registerDecoration(e3);
            }
            hasSelection() {
              return !!this._selectionService && this._selectionService.hasSelection;
            }
            select(e3, t3, i3) {
              this._selectionService.setSelection(e3, t3, i3);
            }
            getSelection() {
              return this._selectionService ? this._selectionService.selectionText : "";
            }
            getSelectionPosition() {
              if (this._selectionService && this._selectionService.hasSelection)
                return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
            }
            clearSelection() {
              var e3;
              null === (e3 = this._selectionService) || void 0 === e3 || e3.clearSelection();
            }
            selectAll() {
              var e3;
              null === (e3 = this._selectionService) || void 0 === e3 || e3.selectAll();
            }
            selectLines(e3, t3) {
              var i3;
              null === (i3 = this._selectionService) || void 0 === i3 || i3.selectLines(e3, t3);
            }
            _keyDown(e3) {
              if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && false === this._customKeyEventHandler(e3))
                return false;
              const t3 = this.browser.isMac && this.options.macOptionIsMeta && e3.altKey;
              if (!t3 && !this._compositionHelper.keydown(e3))
                return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), false;
              t3 || "Dead" !== e3.key && "AltGraph" !== e3.key || (this._unprocessedDeadKey = true);
              const i3 = (0, R.evaluateKeyboardEvent)(e3, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
              if (this.updateCursorStyle(e3), 3 === i3.type || 2 === i3.type) {
                const t4 = this.rows - 1;
                return this.scrollLines(2 === i3.type ? -t4 : t4), this.cancel(e3, true);
              }
              return 1 === i3.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e3) || (i3.cancel && this.cancel(e3, true), !i3.key || !!(e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && 1 === e3.key.length && e3.key.charCodeAt(0) >= 65 && e3.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (i3.key !== D.C0.ETX && i3.key !== D.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: i3.key, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(i3.key, true), !this.optionsService.rawOptions.screenReaderMode || e3.altKey || e3.ctrlKey ? this.cancel(e3, true) : void (this._keyDownHandled = true))));
            }
            _isThirdLevelShift(e3, t3) {
              const i3 = e3.isMac && !this.options.macOptionIsMeta && t3.altKey && !t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.altKey && t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.getModifierState("AltGraph");
              return "keypress" === t3.type ? i3 : i3 && (!t3.keyCode || t3.keyCode > 47);
            }
            _keyUp(e3) {
              this._keyDownSeen = false, this._customKeyEventHandler && false === this._customKeyEventHandler(e3) || (function(e4) {
                return 16 === e4.keyCode || 17 === e4.keyCode || 18 === e4.keyCode;
              }(e3) || this.focus(), this.updateCursorStyle(e3), this._keyPressHandled = false);
            }
            _keyPress(e3) {
              let t3;
              if (this._keyPressHandled = false, this._keyDownHandled)
                return false;
              if (this._customKeyEventHandler && false === this._customKeyEventHandler(e3))
                return false;
              if (this.cancel(e3), e3.charCode)
                t3 = e3.charCode;
              else if (null === e3.which || void 0 === e3.which)
                t3 = e3.keyCode;
              else {
                if (0 === e3.which || 0 === e3.charCode)
                  return false;
                t3 = e3.which;
              }
              return !(!t3 || (e3.altKey || e3.ctrlKey || e3.metaKey) && !this._isThirdLevelShift(this.browser, e3) || (t3 = String.fromCharCode(t3), this._onKey.fire({ key: t3, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(t3, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
            }
            _inputEvent(e3) {
              if (e3.data && "insertText" === e3.inputType && (!e3.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
                if (this._keyPressHandled)
                  return false;
                this._unprocessedDeadKey = false;
                const t3 = e3.data;
                return this.coreService.triggerDataEvent(t3, true), this.cancel(e3), true;
              }
              return false;
            }
            resize(e3, t3) {
              e3 !== this.cols || t3 !== this.rows ? super.resize(e3, t3) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
            }
            _afterResize(e3, t3) {
              var i3, s3;
              null === (i3 = this._charSizeService) || void 0 === i3 || i3.measure(), null === (s3 = this.viewport) || void 0 === s3 || s3.syncScrollArea(true);
            }
            clear() {
              var e3;
              if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
                this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
                for (let e4 = 1; e4 < this.rows; e4++)
                  this.buffer.lines.push(this.buffer.getBlankLine(L.DEFAULT_ATTR_DATA));
                this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), null === (e3 = this.viewport) || void 0 === e3 || e3.reset(), this.refresh(0, this.rows - 1);
              }
            }
            reset() {
              var e3, t3;
              this.options.rows = this.rows, this.options.cols = this.cols;
              const i3 = this._customKeyEventHandler;
              this._setup(), super.reset(), null === (e3 = this._selectionService) || void 0 === e3 || e3.reset(), this._decorationService.reset(), null === (t3 = this.viewport) || void 0 === t3 || t3.reset(), this._customKeyEventHandler = i3, this.refresh(0, this.rows - 1);
            }
            clearTextureAtlas() {
              var e3;
              null === (e3 = this._renderService) || void 0 === e3 || e3.clearTextureAtlas();
            }
            _reportFocus() {
              var e3;
              (null === (e3 = this.element) || void 0 === e3 ? void 0 : e3.classList.contains("focus")) ? this.coreService.triggerDataEvent(D.C0.ESC + "[I") : this.coreService.triggerDataEvent(D.C0.ESC + "[O");
            }
            _reportWindowsOptions(e3) {
              if (this._renderService)
                switch (e3) {
                  case T.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                    const e4 = this._renderService.dimensions.css.canvas.width.toFixed(0), t3 = this._renderService.dimensions.css.canvas.height.toFixed(0);
                    this.coreService.triggerDataEvent(`${D.C0.ESC}[4;${t3};${e4}t`);
                    break;
                  case T.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                    const i3 = this._renderService.dimensions.css.cell.width.toFixed(0), s3 = this._renderService.dimensions.css.cell.height.toFixed(0);
                    this.coreService.triggerDataEvent(`${D.C0.ESC}[6;${s3};${i3}t`);
                }
            }
            cancel(e3, t3) {
              if (this.options.cancelEvents || t3)
                return e3.preventDefault(), e3.stopPropagation(), false;
            }
          }
          t2.Terminal = P;
        }, 9924: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.TimeBasedDebouncer = void 0, t2.TimeBasedDebouncer = class {
            constructor(e3, t3 = 1e3) {
              this._renderCallback = e3, this._debounceThresholdMS = t3, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
            }
            dispose() {
              this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
            }
            refresh(e3, t3, i2) {
              this._rowCount = i2, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3;
              const s2 = Date.now();
              if (s2 - this._lastRefreshMs >= this._debounceThresholdMS)
                this._lastRefreshMs = s2, this._innerRefresh();
              else if (!this._additionalRefreshRequested) {
                const e4 = s2 - this._lastRefreshMs, t4 = this._debounceThresholdMS - e4;
                this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout(() => {
                  this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = void 0;
                }, t4);
              }
            }
            _innerRefresh() {
              if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount)
                return;
              const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
              this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3);
            }
          };
        }, 1680: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Viewport = void 0;
          const n = i2(3656), o = i2(4725), a = i2(8460), h = i2(844), c = i2(2585);
          let l = t2.Viewport = class extends h.Disposable {
            constructor(e3, t3, i3, s3, r2, o2, h2, c2) {
              super(), this._viewportElement = e3, this._scrollArea = t3, this._bufferService = i3, this._optionsService = s3, this._charSizeService = r2, this._renderService = o2, this._coreBrowserService = h2, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new a.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((e4) => this._renderDimensions = e4)), this._handleThemeChange(c2.colors), this.register(c2.onChangeColors((e4) => this._handleThemeChange(e4))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
            }
            _handleThemeChange(e3) {
              this._viewportElement.style.backgroundColor = e3.background.css;
            }
            reset() {
              this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
            }
            _refresh(e3) {
              if (e3)
                return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
              null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
            }
            _innerRefresh() {
              if (this._charSizeService.height > 0) {
                this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
                const e4 = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
                this._lastRecordedBufferHeight !== e4 && (this._lastRecordedBufferHeight = e4, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
              }
              const e3 = this._bufferService.buffer.ydisp * this._currentRowHeight;
              this._viewportElement.scrollTop !== e3 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = e3), this._refreshAnimationFrame = null;
            }
            syncScrollArea(e3 = false) {
              if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length)
                return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e3);
              this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e3);
            }
            _handleScroll(e3) {
              if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent)
                return;
              if (this._ignoreNextScrollEvent)
                return this._ignoreNextScrollEvent = false, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: true });
              const t3 = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
              this._onRequestScrollLines.fire({ amount: t3, suppressScrollEvent: true });
            }
            _smoothScroll() {
              if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target)
                return;
              const e3 = this._smoothScrollPercent();
              this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e3 * (this._smoothScrollState.target - this._smoothScrollState.origin)), e3 < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
            }
            _smoothScrollPercent() {
              return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
            }
            _clearSmoothScrollState() {
              this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
            }
            _bubbleScroll(e3, t3) {
              const i3 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
              return !(t3 < 0 && 0 !== this._viewportElement.scrollTop || t3 > 0 && i3 < this._lastRecordedBufferHeight) || (e3.cancelable && e3.preventDefault(), false);
            }
            handleWheel(e3) {
              const t3 = this._getPixelsScrolled(e3);
              return 0 !== t3 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t3 : this._smoothScrollState.target += t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
            }
            scrollLines(e3) {
              if (0 !== e3)
                if (this._optionsService.rawOptions.smoothScrollDuration) {
                  const t3 = e3 * this._currentRowHeight;
                  this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
                } else
                  this._onRequestScrollLines.fire({ amount: e3, suppressScrollEvent: false });
            }
            _getPixelsScrolled(e3) {
              if (0 === e3.deltaY || e3.shiftKey)
                return 0;
              let t3 = this._applyScrollModifier(e3.deltaY, e3);
              return e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? t3 *= this._currentRowHeight : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._currentRowHeight * this._bufferService.rows), t3;
            }
            getBufferElements(e3, t3) {
              var i3;
              let s3, r2 = "";
              const n2 = [], o2 = null != t3 ? t3 : this._bufferService.buffer.lines.length, a2 = this._bufferService.buffer.lines;
              for (let t4 = e3; t4 < o2; t4++) {
                const e4 = a2.get(t4);
                if (!e4)
                  continue;
                const o3 = null === (i3 = a2.get(t4 + 1)) || void 0 === i3 ? void 0 : i3.isWrapped;
                if (r2 += e4.translateToString(!o3), !o3 || t4 === a2.length - 1) {
                  const e5 = document.createElement("div");
                  e5.textContent = r2, n2.push(e5), r2.length > 0 && (s3 = e5), r2 = "";
                }
              }
              return { bufferElements: n2, cursorElement: s3 };
            }
            getLinesScrolled(e3) {
              if (0 === e3.deltaY || e3.shiftKey)
                return 0;
              let t3 = this._applyScrollModifier(e3.deltaY, e3);
              return e3.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t3 /= this._currentRowHeight + 0, this._wheelPartialScroll += t3, t3 = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._bufferService.rows), t3;
            }
            _applyScrollModifier(e3, t3) {
              const i3 = this._optionsService.rawOptions.fastScrollModifier;
              return "alt" === i3 && t3.altKey || "ctrl" === i3 && t3.ctrlKey || "shift" === i3 && t3.shiftKey ? e3 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e3 * this._optionsService.rawOptions.scrollSensitivity;
            }
            handleTouchStart(e3) {
              this._lastTouchY = e3.touches[0].pageY;
            }
            handleTouchMove(e3) {
              const t3 = this._lastTouchY - e3.touches[0].pageY;
              return this._lastTouchY = e3.touches[0].pageY, 0 !== t3 && (this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
            }
          };
          t2.Viewport = l = s2([r(2, c.IBufferService), r(3, c.IOptionsService), r(4, o.ICharSizeService), r(5, o.IRenderService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], l);
        }, 3107: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferDecorationRenderer = void 0;
          const n = i2(3656), o = i2(4725), a = i2(844), h = i2(2585);
          let c = t2.BufferDecorationRenderer = class extends a.Disposable {
            constructor(e3, t3, i3, s3) {
              super(), this._screenElement = e3, this._bufferService = t3, this._decorationService = i3, this._renderService = s3, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
                this._dimensionsChanged = true, this._queueRefresh();
              })), this.register((0, n.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
                this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
              })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((e4) => this._removeDecoration(e4))), this.register((0, a.toDisposable)(() => {
                this._container.remove(), this._decorationElements.clear();
              }));
            }
            _queueRefresh() {
              void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback(() => {
                this._doRefreshDecorations(), this._animationFrame = void 0;
              }));
            }
            _doRefreshDecorations() {
              for (const e3 of this._decorationService.decorations)
                this._renderDecoration(e3);
              this._dimensionsChanged = false;
            }
            _renderDecoration(e3) {
              this._refreshStyle(e3), this._dimensionsChanged && this._refreshXPosition(e3);
            }
            _createElement(e3) {
              var t3, i3;
              const s3 = document.createElement("div");
              s3.classList.add("xterm-decoration"), s3.classList.toggle("xterm-decoration-top-layer", "top" === (null === (t3 = null == e3 ? void 0 : e3.options) || void 0 === t3 ? void 0 : t3.layer)), s3.style.width = `${Math.round((e3.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, s3.style.height = (e3.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", s3.style.top = (e3.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", s3.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
              const r2 = null !== (i3 = e3.options.x) && void 0 !== i3 ? i3 : 0;
              return r2 && r2 > this._bufferService.cols && (s3.style.display = "none"), this._refreshXPosition(e3, s3), s3;
            }
            _refreshStyle(e3) {
              const t3 = e3.marker.line - this._bufferService.buffers.active.ydisp;
              if (t3 < 0 || t3 >= this._bufferService.rows)
                e3.element && (e3.element.style.display = "none", e3.onRenderEmitter.fire(e3.element));
              else {
                let i3 = this._decorationElements.get(e3);
                i3 || (i3 = this._createElement(e3), e3.element = i3, this._decorationElements.set(e3, i3), this._container.appendChild(i3), e3.onDispose(() => {
                  this._decorationElements.delete(e3), i3.remove();
                })), i3.style.top = t3 * this._renderService.dimensions.css.cell.height + "px", i3.style.display = this._altBufferIsActive ? "none" : "block", e3.onRenderEmitter.fire(i3);
              }
            }
            _refreshXPosition(e3, t3 = e3.element) {
              var i3;
              if (!t3)
                return;
              const s3 = null !== (i3 = e3.options.x) && void 0 !== i3 ? i3 : 0;
              "right" === (e3.options.anchor || "left") ? t3.style.right = s3 ? s3 * this._renderService.dimensions.css.cell.width + "px" : "" : t3.style.left = s3 ? s3 * this._renderService.dimensions.css.cell.width + "px" : "";
            }
            _removeDecoration(e3) {
              var t3;
              null === (t3 = this._decorationElements.get(e3)) || void 0 === t3 || t3.remove(), this._decorationElements.delete(e3), e3.dispose();
            }
          };
          t2.BufferDecorationRenderer = c = s2([r(1, h.IBufferService), r(2, h.IDecorationService), r(3, o.IRenderService)], c);
        }, 5871: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorZoneStore = void 0, t2.ColorZoneStore = class {
            constructor() {
              this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
            }
            get zones() {
              return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
            }
            clear() {
              this._zones.length = 0, this._zonePoolIndex = 0;
            }
            addDecoration(e3) {
              if (e3.options.overviewRulerOptions) {
                for (const t3 of this._zones)
                  if (t3.color === e3.options.overviewRulerOptions.color && t3.position === e3.options.overviewRulerOptions.position) {
                    if (this._lineIntersectsZone(t3, e3.marker.line))
                      return;
                    if (this._lineAdjacentToZone(t3, e3.marker.line, e3.options.overviewRulerOptions.position))
                      return void this._addLineToZone(t3, e3.marker.line);
                  }
                if (this._zonePoolIndex < this._zonePool.length)
                  return this._zonePool[this._zonePoolIndex].color = e3.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e3.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e3.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e3.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
                this._zones.push({ color: e3.options.overviewRulerOptions.color, position: e3.options.overviewRulerOptions.position, startBufferLine: e3.marker.line, endBufferLine: e3.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
              }
            }
            setPadding(e3) {
              this._linePadding = e3;
            }
            _lineIntersectsZone(e3, t3) {
              return t3 >= e3.startBufferLine && t3 <= e3.endBufferLine;
            }
            _lineAdjacentToZone(e3, t3, i2) {
              return t3 >= e3.startBufferLine - this._linePadding[i2 || "full"] && t3 <= e3.endBufferLine + this._linePadding[i2 || "full"];
            }
            _addLineToZone(e3, t3) {
              e3.startBufferLine = Math.min(e3.startBufferLine, t3), e3.endBufferLine = Math.max(e3.endBufferLine, t3);
            }
          };
        }, 5744: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OverviewRulerRenderer = void 0;
          const n = i2(5871), o = i2(3656), a = i2(4725), h = i2(844), c = i2(2585), l = { full: 0, left: 0, center: 0, right: 0 }, d = { full: 0, left: 0, center: 0, right: 0 }, _ = { full: 0, left: 0, center: 0, right: 0 };
          let u = t2.OverviewRulerRenderer = class extends h.Disposable {
            get _width() {
              return this._optionsService.options.overviewRulerWidth || 0;
            }
            constructor(e3, t3, i3, s3, r2, o2, a2) {
              var c2;
              super(), this._viewportElement = e3, this._screenElement = t3, this._bufferService = i3, this._decorationService = s3, this._renderService = r2, this._optionsService = o2, this._coreBrowseService = a2, this._colorZoneStore = new n.ColorZoneStore(), this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), null === (c2 = this._viewportElement.parentElement) || void 0 === c2 || c2.insertBefore(this._canvas, this._viewportElement);
              const l2 = this._canvas.getContext("2d");
              if (!l2)
                throw new Error("Ctx cannot be null");
              this._ctx = l2, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, h.toDisposable)(() => {
                var e4;
                null === (e4 = this._canvas) || void 0 === e4 || e4.remove();
              }));
            }
            _registerDecorationListeners() {
              this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, true))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, true)));
            }
            _registerBufferChangeListeners() {
              this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
                this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
              })), this.register(this._bufferService.onScroll(() => {
                this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
              }));
            }
            _registerDimensionChangeListeners() {
              this.register(this._renderService.onRender(() => {
                this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
              })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(true))), this.register((0, o.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(true))), this._queueRefresh(true);
            }
            _refreshDrawConstants() {
              const e3 = Math.floor(this._canvas.width / 3), t3 = Math.ceil(this._canvas.width / 3);
              d.full = this._canvas.width, d.left = e3, d.center = t3, d.right = e3, this._refreshDrawHeightConstants(), _.full = 0, _.left = 0, _.center = d.left, _.right = d.left + d.center;
            }
            _refreshDrawHeightConstants() {
              l.full = Math.round(2 * this._coreBrowseService.dpr);
              const e3 = this._canvas.height / this._bufferService.buffer.lines.length, t3 = Math.round(Math.max(Math.min(e3, 12), 6) * this._coreBrowseService.dpr);
              l.left = t3, l.center = t3, l.right = t3;
            }
            _refreshColorZonePadding() {
              this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
            }
            _refreshCanvasDimensions() {
              this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
            }
            _refreshDecorations() {
              this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
              for (const e4 of this._decorationService.decorations)
                this._colorZoneStore.addDecoration(e4);
              this._ctx.lineWidth = 1;
              const e3 = this._colorZoneStore.zones;
              for (const t3 of e3)
                "full" !== t3.position && this._renderColorZone(t3);
              for (const t3 of e3)
                "full" === t3.position && this._renderColorZone(t3);
              this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
            }
            _renderColorZone(e3) {
              this._ctx.fillStyle = e3.color, this._ctx.fillRect(_[e3.position || "full"], Math.round((this._canvas.height - 1) * (e3.startBufferLine / this._bufferService.buffers.active.lines.length) - l[e3.position || "full"] / 2), d[e3.position || "full"], Math.round((this._canvas.height - 1) * ((e3.endBufferLine - e3.startBufferLine) / this._bufferService.buffers.active.lines.length) + l[e3.position || "full"]));
            }
            _queueRefresh(e3, t3) {
              this._shouldUpdateDimensions = e3 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t3 || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {
                this._refreshDecorations(), this._animationFrame = void 0;
              }));
            }
          };
          t2.OverviewRulerRenderer = u = s2([r(2, c.IBufferService), r(3, c.IDecorationService), r(4, a.IRenderService), r(5, c.IOptionsService), r(6, a.ICoreBrowserService)], u);
        }, 2950: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CompositionHelper = void 0;
          const n = i2(4725), o = i2(2585), a = i2(2584);
          let h = t2.CompositionHelper = class {
            get isComposing() {
              return this._isComposing;
            }
            constructor(e3, t3, i3, s3, r2, n2) {
              this._textarea = e3, this._compositionView = t3, this._bufferService = i3, this._optionsService = s3, this._coreService = r2, this._renderService = n2, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
            }
            compositionstart() {
              this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
            }
            compositionupdate(e3) {
              this._compositionView.textContent = e3.data, this.updateCompositionElements(), setTimeout(() => {
                this._compositionPosition.end = this._textarea.value.length;
              }, 0);
            }
            compositionend() {
              this._finalizeComposition(true);
            }
            keydown(e3) {
              if (this._isComposing || this._isSendingComposition) {
                if (229 === e3.keyCode)
                  return false;
                if (16 === e3.keyCode || 17 === e3.keyCode || 18 === e3.keyCode)
                  return false;
                this._finalizeComposition(false);
              }
              return 229 !== e3.keyCode || (this._handleAnyTextareaChanges(), false);
            }
            _finalizeComposition(e3) {
              if (this._compositionView.classList.remove("active"), this._isComposing = false, e3) {
                const e4 = { start: this._compositionPosition.start, end: this._compositionPosition.end };
                this._isSendingComposition = true, setTimeout(() => {
                  if (this._isSendingComposition) {
                    let t3;
                    this._isSendingComposition = false, e4.start += this._dataAlreadySent.length, t3 = this._isComposing ? this._textarea.value.substring(e4.start, e4.end) : this._textarea.value.substring(e4.start), t3.length > 0 && this._coreService.triggerDataEvent(t3, true);
                  }
                }, 0);
              } else {
                this._isSendingComposition = false;
                const e4 = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
                this._coreService.triggerDataEvent(e4, true);
              }
            }
            _handleAnyTextareaChanges() {
              const e3 = this._textarea.value;
              setTimeout(() => {
                if (!this._isComposing) {
                  const t3 = this._textarea.value, i3 = t3.replace(e3, "");
                  this._dataAlreadySent = i3, t3.length > e3.length ? this._coreService.triggerDataEvent(i3, true) : t3.length < e3.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, true) : t3.length === e3.length && t3 !== e3 && this._coreService.triggerDataEvent(t3, true);
                }
              }, 0);
            }
            updateCompositionElements(e3) {
              if (this._isComposing) {
                if (this._bufferService.buffer.isCursorInViewport) {
                  const e4 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t3 = this._renderService.dimensions.css.cell.height, i3 = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s3 = e4 * this._renderService.dimensions.css.cell.width;
                  this._compositionView.style.left = s3 + "px", this._compositionView.style.top = i3 + "px", this._compositionView.style.height = t3 + "px", this._compositionView.style.lineHeight = t3 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                  const r2 = this._compositionView.getBoundingClientRect();
                  this._textarea.style.left = s3 + "px", this._textarea.style.top = i3 + "px", this._textarea.style.width = Math.max(r2.width, 1) + "px", this._textarea.style.height = Math.max(r2.height, 1) + "px", this._textarea.style.lineHeight = r2.height + "px";
                }
                e3 || setTimeout(() => this.updateCompositionElements(true), 0);
              }
            }
          };
          t2.CompositionHelper = h = s2([r(2, o.IBufferService), r(3, o.IOptionsService), r(4, o.ICoreService), r(5, n.IRenderService)], h);
        }, 9806: (e2, t2) => {
          function i2(e3, t3, i3) {
            const s2 = i3.getBoundingClientRect(), r = e3.getComputedStyle(i3), n = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
            return [t3.clientX - s2.left - n, t3.clientY - s2.top - o];
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getCoords = t2.getCoordsRelativeToElement = void 0, t2.getCoordsRelativeToElement = i2, t2.getCoords = function(e3, t3, s2, r, n, o, a, h, c) {
            if (!o)
              return;
            const l = i2(e3, t3, s2);
            return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : void 0;
          };
        }, 9504: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.moveToCellSequence = void 0;
          const s2 = i2(2584);
          function r(e3, t3, i3, s3) {
            const r2 = e3 - n(e3, i3), a2 = t3 - n(t3, i3), l = Math.abs(r2 - a2) - function(e4, t4, i4) {
              let s4 = 0;
              const r3 = e4 - n(e4, i4), a3 = t4 - n(t4, i4);
              for (let n2 = 0; n2 < Math.abs(r3 - a3); n2++) {
                const a4 = "A" === o(e4, t4) ? -1 : 1, h2 = i4.buffer.lines.get(r3 + a4 * n2);
                (null == h2 ? void 0 : h2.isWrapped) && s4++;
              }
              return s4;
            }(e3, t3, i3);
            return c(l, h(o(e3, t3), s3));
          }
          function n(e3, t3) {
            let i3 = 0, s3 = t3.buffer.lines.get(e3), r2 = null == s3 ? void 0 : s3.isWrapped;
            for (; r2 && e3 >= 0 && e3 < t3.rows; )
              i3++, s3 = t3.buffer.lines.get(--e3), r2 = null == s3 ? void 0 : s3.isWrapped;
            return i3;
          }
          function o(e3, t3) {
            return e3 > t3 ? "A" : "B";
          }
          function a(e3, t3, i3, s3, r2, n2) {
            let o2 = e3, a2 = t3, h2 = "";
            for (; o2 !== i3 || a2 !== s3; )
              o2 += r2 ? 1 : -1, r2 && o2 > n2.cols - 1 ? (h2 += n2.buffer.translateBufferLineToString(a2, false, e3, o2), o2 = 0, e3 = 0, a2++) : !r2 && o2 < 0 && (h2 += n2.buffer.translateBufferLineToString(a2, false, 0, e3 + 1), o2 = n2.cols - 1, e3 = o2, a2--);
            return h2 + n2.buffer.translateBufferLineToString(a2, false, e3, o2);
          }
          function h(e3, t3) {
            const i3 = t3 ? "O" : "[";
            return s2.C0.ESC + i3 + e3;
          }
          function c(e3, t3) {
            e3 = Math.floor(e3);
            let i3 = "";
            for (let s3 = 0; s3 < e3; s3++)
              i3 += t3;
            return i3;
          }
          t2.moveToCellSequence = function(e3, t3, i3, s3) {
            const o2 = i3.buffer.x, l = i3.buffer.y;
            if (!i3.buffer.hasScrollback)
              return function(e4, t4, i4, s4, o3, l2) {
                return 0 === r(t4, s4, o3, l2).length ? "" : c(a(e4, t4, e4, t4 - n(t4, o3), false, o3).length, h("D", l2));
              }(o2, l, 0, t3, i3, s3) + r(l, t3, i3, s3) + function(e4, t4, i4, s4, o3, l2) {
                let d2;
                d2 = r(t4, s4, o3, l2).length > 0 ? s4 - n(s4, o3) : t4;
                const _2 = s4, u = function(e5, t5, i5, s5, o4, a2) {
                  let h2;
                  return h2 = r(i5, s5, o4, a2).length > 0 ? s5 - n(s5, o4) : t5, e5 < i5 && h2 <= s5 || e5 >= i5 && h2 < s5 ? "C" : "D";
                }(e4, t4, i4, s4, o3, l2);
                return c(a(e4, d2, i4, _2, "C" === u, o3).length, h(u, l2));
              }(o2, l, e3, t3, i3, s3);
            let d;
            if (l === t3)
              return d = o2 > e3 ? "D" : "C", c(Math.abs(o2 - e3), h(d, s3));
            d = l > t3 ? "D" : "C";
            const _ = Math.abs(l - t3);
            return c(function(e4, t4) {
              return t4.cols - e4;
            }(l > t3 ? e3 : o2, i3) + (_ - 1) * i3.cols + 1 + ((l > t3 ? o2 : e3) - 1), h(d, s3));
          };
        }, 1296: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRenderer = void 0;
          const n = i2(3787), o = i2(2550), a = i2(2223), h = i2(6171), c = i2(4725), l = i2(8055), d = i2(8460), _ = i2(844), u = i2(2585), f = "xterm-dom-renderer-owner-", v = "xterm-rows", p = "xterm-fg-", g = "xterm-bg-", m = "xterm-focus", S = "xterm-selection";
          let C = 1, b = t2.DomRenderer = class extends _.Disposable {
            constructor(e3, t3, i3, s3, r2, a2, c2, l2, u2, p2) {
              super(), this._element = e3, this._screenElement = t3, this._viewportElement = i3, this._linkifier2 = s3, this._charSizeService = a2, this._optionsService = c2, this._bufferService = l2, this._coreBrowserService = u2, this._themeService = p2, this._terminalClass = C++, this._rowElements = [], this.onRequestRedraw = this.register(new d.EventEmitter()).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add(v), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add(S), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, h.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((e4) => this._injectCss(e4))), this._injectCss(this._themeService.colors), this._rowFactory = r2.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(f + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((e4) => this._handleLinkHover(e4))), this.register(this._linkifier2.onHideLinkUnderline((e4) => this._handleLinkLeave(e4))), this.register((0, _.toDisposable)(() => {
                this._element.classList.remove(f + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
              })), this._widthCache = new o.WidthCache(document), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
            }
            _updateDimensions() {
              const e3 = this._coreBrowserService.dpr;
              this.dimensions.device.char.width = this._charSizeService.width * e3, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e3), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e3), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e3), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
              for (const e4 of this._rowElements)
                e4.style.width = `${this.dimensions.css.canvas.width}px`, e4.style.height = `${this.dimensions.css.cell.height}px`, e4.style.lineHeight = `${this.dimensions.css.cell.height}px`, e4.style.overflow = "hidden";
              this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
              const t3 = `${this._terminalSelector} .${v} span { display: inline-block; height: 100%; vertical-align: top;}`;
              this._dimensionsStyleElement.textContent = t3, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
            }
            _injectCss(e3) {
              this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
              let t3 = `${this._terminalSelector} .${v} { color: ${e3.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
              t3 += `${this._terminalSelector} .${v} .xterm-dim { color: ${l.color.multiplyOpacity(e3.foreground, 0.5).css};}`, t3 += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`, t3 += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  border-bottom-style: hidden; }}", t3 += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${e3.cursor.css};  color: ${e3.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${e3.cursor.css}; }}`, t3 += `${this._terminalSelector} .${v}.${m} .xterm-cursor.xterm-cursor-blink:not(.xterm-cursor-block) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${v}.${m} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-block { background-color: ${e3.cursor.css}; color: ${e3.cursorAccent.css};}${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${e3.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e3.cursor.css} inset;}${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${e3.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, t3 += `${this._terminalSelector} .${S} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${S} div { position: absolute; background-color: ${e3.selectionBackgroundOpaque.css};}${this._terminalSelector} .${S} div { position: absolute; background-color: ${e3.selectionInactiveBackgroundOpaque.css};}`;
              for (const [i3, s3] of e3.ansi.entries())
                t3 += `${this._terminalSelector} .${p}${i3} { color: ${s3.css}; }${this._terminalSelector} .${p}${i3}.xterm-dim { color: ${l.color.multiplyOpacity(s3, 0.5).css}; }${this._terminalSelector} .${g}${i3} { background-color: ${s3.css}; }`;
              t3 += `${this._terminalSelector} .${p}${a.INVERTED_DEFAULT_COLOR} { color: ${l.color.opaque(e3.background).css}; }${this._terminalSelector} .${p}${a.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${l.color.multiplyOpacity(l.color.opaque(e3.background), 0.5).css}; }${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR} { background-color: ${e3.foreground.css}; }`, this._themeStyleElement.textContent = t3;
            }
            _setDefaultSpacing() {
              const e3 = this.dimensions.css.cell.width - this._widthCache.get("W", false, false);
              this._rowContainer.style.letterSpacing = `${e3}px`, this._rowFactory.defaultSpacing = e3;
            }
            handleDevicePixelRatioChange() {
              this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
            }
            _refreshRowElements(e3, t3) {
              for (let e4 = this._rowElements.length; e4 <= t3; e4++) {
                const e5 = document.createElement("div");
                this._rowContainer.appendChild(e5), this._rowElements.push(e5);
              }
              for (; this._rowElements.length > t3; )
                this._rowContainer.removeChild(this._rowElements.pop());
            }
            handleResize(e3, t3) {
              this._refreshRowElements(e3, t3), this._updateDimensions();
            }
            handleCharSizeChanged() {
              this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
            }
            handleBlur() {
              this._rowContainer.classList.remove(m);
            }
            handleFocus() {
              this._rowContainer.classList.add(m), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
            }
            handleSelectionChanged(e3, t3, i3) {
              if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(e3, t3, i3), this.renderRows(0, this._bufferService.rows - 1), !e3 || !t3)
                return;
              const s3 = e3[1] - this._bufferService.buffer.ydisp, r2 = t3[1] - this._bufferService.buffer.ydisp, n2 = Math.max(s3, 0), o2 = Math.min(r2, this._bufferService.rows - 1);
              if (n2 >= this._bufferService.rows || o2 < 0)
                return;
              const a2 = document.createDocumentFragment();
              if (i3) {
                const i4 = e3[0] > t3[0];
                a2.appendChild(this._createSelectionElement(n2, i4 ? t3[0] : e3[0], i4 ? e3[0] : t3[0], o2 - n2 + 1));
              } else {
                const i4 = s3 === n2 ? e3[0] : 0, h2 = n2 === r2 ? t3[0] : this._bufferService.cols;
                a2.appendChild(this._createSelectionElement(n2, i4, h2));
                const c2 = o2 - n2 - 1;
                if (a2.appendChild(this._createSelectionElement(n2 + 1, 0, this._bufferService.cols, c2)), n2 !== o2) {
                  const e4 = r2 === o2 ? t3[0] : this._bufferService.cols;
                  a2.appendChild(this._createSelectionElement(o2, 0, e4));
                }
              }
              this._selectionContainer.appendChild(a2);
            }
            _createSelectionElement(e3, t3, i3, s3 = 1) {
              const r2 = document.createElement("div");
              return r2.style.height = s3 * this.dimensions.css.cell.height + "px", r2.style.top = e3 * this.dimensions.css.cell.height + "px", r2.style.left = t3 * this.dimensions.css.cell.width + "px", r2.style.width = this.dimensions.css.cell.width * (i3 - t3) + "px", r2;
            }
            handleCursorMove() {
            }
            _handleOptionsChanged() {
              this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
            }
            clear() {
              for (const e3 of this._rowElements)
                e3.replaceChildren();
            }
            renderRows(e3, t3) {
              const i3 = this._bufferService.buffer, s3 = i3.ybase + i3.y, r2 = Math.min(i3.x, this._bufferService.cols - 1), n2 = this._optionsService.rawOptions.cursorBlink, o2 = this._optionsService.rawOptions.cursorStyle, a2 = this._optionsService.rawOptions.cursorInactiveStyle;
              for (let h2 = e3; h2 <= t3; h2++) {
                const e4 = h2 + i3.ydisp, t4 = this._rowElements[h2], c2 = i3.lines.get(e4);
                if (!t4 || !c2)
                  break;
                t4.replaceChildren(...this._rowFactory.createRow(c2, e4, e4 === s3, o2, a2, r2, n2, this.dimensions.css.cell.width, this._widthCache, -1, -1));
              }
            }
            get _terminalSelector() {
              return `.${f}${this._terminalClass}`;
            }
            _handleLinkHover(e3) {
              this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, true);
            }
            _handleLinkLeave(e3) {
              this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, false);
            }
            _setCellUnderline(e3, t3, i3, s3, r2, n2) {
              i3 < 0 && (e3 = 0), s3 < 0 && (t3 = 0);
              const o2 = this._bufferService.rows - 1;
              i3 = Math.max(Math.min(i3, o2), 0), s3 = Math.max(Math.min(s3, o2), 0), r2 = Math.min(r2, this._bufferService.cols);
              const a2 = this._bufferService.buffer, h2 = a2.ybase + a2.y, c2 = Math.min(a2.x, r2 - 1), l2 = this._optionsService.rawOptions.cursorBlink, d2 = this._optionsService.rawOptions.cursorStyle, _2 = this._optionsService.rawOptions.cursorInactiveStyle;
              for (let o3 = i3; o3 <= s3; ++o3) {
                const u2 = o3 + a2.ydisp, f2 = this._rowElements[o3], v2 = a2.lines.get(u2);
                if (!f2 || !v2)
                  break;
                f2.replaceChildren(...this._rowFactory.createRow(v2, u2, u2 === h2, d2, _2, c2, l2, this.dimensions.css.cell.width, this._widthCache, n2 ? o3 === i3 ? e3 : 0 : -1, n2 ? (o3 === s3 ? t3 : r2) - 1 : -1));
              }
            }
          };
          t2.DomRenderer = b = s2([r(4, u.IInstantiationService), r(5, c.ICharSizeService), r(6, u.IOptionsService), r(7, u.IBufferService), r(8, c.ICoreBrowserService), r(9, c.IThemeService)], b);
        }, 3787: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRendererRowFactory = void 0;
          const n = i2(2223), o = i2(643), a = i2(511), h = i2(2585), c = i2(8055), l = i2(4725), d = i2(4269), _ = i2(6171), u = i2(3734);
          let f = t2.DomRendererRowFactory = class {
            constructor(e3, t3, i3, s3, r2, n2, o2) {
              this._document = e3, this._characterJoinerService = t3, this._optionsService = i3, this._coreBrowserService = s3, this._coreService = r2, this._decorationService = n2, this._themeService = o2, this._workCell = new a.CellData(), this._columnSelectMode = false, this.defaultSpacing = 0;
            }
            handleSelectionChanged(e3, t3, i3) {
              this._selectionStart = e3, this._selectionEnd = t3, this._columnSelectMode = i3;
            }
            createRow(e3, t3, i3, s3, r2, a2, h2, l2, _2, f2, p) {
              const g = [], m = this._characterJoinerService.getJoinedCharacters(t3), S = this._themeService.colors;
              let C, b = e3.getNoBgTrimmedLength();
              i3 && b < a2 + 1 && (b = a2 + 1);
              let y = 0, w = "", E = 0, k = 0, L = 0, D = false, R = 0, x = false, A = 0;
              const B = [], T = -1 !== f2 && -1 !== p;
              for (let M = 0; M < b; M++) {
                e3.loadCell(M, this._workCell);
                let b2 = this._workCell.getWidth();
                if (0 === b2)
                  continue;
                let O = false, P = M, I = this._workCell;
                if (m.length > 0 && M === m[0][0]) {
                  O = true;
                  const t4 = m.shift();
                  I = new d.JoinedCellData(this._workCell, e3.translateToString(true, t4[0], t4[1]), t4[1] - t4[0]), P = t4[1] - 1, b2 = I.getWidth();
                }
                const H = this._isCellInSelection(M, t3), F = i3 && M === a2, W = T && M >= f2 && M <= p;
                let U = false;
                this._decorationService.forEachDecorationAtCell(M, t3, void 0, (e4) => {
                  U = true;
                });
                let N = I.getChars() || o.WHITESPACE_CELL_CHAR;
                if (" " === N && (I.isUnderline() || I.isOverline()) && (N = "\xA0"), A = b2 * l2 - _2.get(N, I.isBold(), I.isItalic()), C) {
                  if (y && (H && x || !H && !x && I.bg === E) && (H && x && S.selectionForeground || I.fg === k) && I.extended.ext === L && W === D && A === R && !F && !O && !U) {
                    w += N, y++;
                    continue;
                  }
                  y && (C.textContent = w), C = this._document.createElement("span"), y = 0, w = "";
                } else
                  C = this._document.createElement("span");
                if (E = I.bg, k = I.fg, L = I.extended.ext, D = W, R = A, x = H, O && a2 >= M && a2 <= P && (a2 = M), !this._coreService.isCursorHidden && F) {
                  if (B.push("xterm-cursor"), this._coreBrowserService.isFocused)
                    h2 && B.push("xterm-cursor-blink"), B.push("bar" === s3 ? "xterm-cursor-bar" : "underline" === s3 ? "xterm-cursor-underline" : "xterm-cursor-block");
                  else if (r2)
                    switch (r2) {
                      case "outline":
                        B.push("xterm-cursor-outline");
                        break;
                      case "block":
                        B.push("xterm-cursor-block");
                        break;
                      case "bar":
                        B.push("xterm-cursor-bar");
                        break;
                      case "underline":
                        B.push("xterm-cursor-underline");
                    }
                }
                if (I.isBold() && B.push("xterm-bold"), I.isItalic() && B.push("xterm-italic"), I.isDim() && B.push("xterm-dim"), w = I.isInvisible() ? o.WHITESPACE_CELL_CHAR : I.getChars() || o.WHITESPACE_CELL_CHAR, I.isUnderline() && (B.push(`xterm-underline-${I.extended.underlineStyle}`), " " === w && (w = "\xA0"), !I.isUnderlineColorDefault()))
                  if (I.isUnderlineColorRGB())
                    C.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(I.getUnderlineColor()).join(",")})`;
                  else {
                    let e4 = I.getUnderlineColor();
                    this._optionsService.rawOptions.drawBoldTextInBrightColors && I.isBold() && e4 < 8 && (e4 += 8), C.style.textDecorationColor = S.ansi[e4].css;
                  }
                I.isOverline() && (B.push("xterm-overline"), " " === w && (w = "\xA0")), I.isStrikethrough() && B.push("xterm-strikethrough"), W && (C.style.textDecoration = "underline");
                let $ = I.getFgColor(), j = I.getFgColorMode(), z = I.getBgColor(), K = I.getBgColorMode();
                const q = !!I.isInverse();
                if (q) {
                  const e4 = $;
                  $ = z, z = e4;
                  const t4 = j;
                  j = K, K = t4;
                }
                let V, G, X, J = false;
                switch (this._decorationService.forEachDecorationAtCell(M, t3, void 0, (e4) => {
                  "top" !== e4.options.layer && J || (e4.backgroundColorRGB && (K = 50331648, z = e4.backgroundColorRGB.rgba >> 8 & 16777215, V = e4.backgroundColorRGB), e4.foregroundColorRGB && (j = 50331648, $ = e4.foregroundColorRGB.rgba >> 8 & 16777215, G = e4.foregroundColorRGB), J = "top" === e4.options.layer);
                }), !J && H && (V = this._coreBrowserService.isFocused ? S.selectionBackgroundOpaque : S.selectionInactiveBackgroundOpaque, z = V.rgba >> 8 & 16777215, K = 50331648, J = true, S.selectionForeground && (j = 50331648, $ = S.selectionForeground.rgba >> 8 & 16777215, G = S.selectionForeground)), J && B.push("xterm-decoration-top"), K) {
                  case 16777216:
                  case 33554432:
                    X = S.ansi[z], B.push(`xterm-bg-${z}`);
                    break;
                  case 50331648:
                    X = c.rgba.toColor(z >> 16, z >> 8 & 255, 255 & z), this._addStyle(C, `background-color:#${v((z >>> 0).toString(16), "0", 6)}`);
                    break;
                  default:
                    q ? (X = S.foreground, B.push(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : X = S.background;
                }
                switch (V || I.isDim() && (V = c.color.multiplyOpacity(X, 0.5)), j) {
                  case 16777216:
                  case 33554432:
                    I.isBold() && $ < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && ($ += 8), this._applyMinimumContrast(C, X, S.ansi[$], I, V, void 0) || B.push(`xterm-fg-${$}`);
                    break;
                  case 50331648:
                    const e4 = c.rgba.toColor($ >> 16 & 255, $ >> 8 & 255, 255 & $);
                    this._applyMinimumContrast(C, X, e4, I, V, G) || this._addStyle(C, `color:#${v($.toString(16), "0", 6)}`);
                    break;
                  default:
                    this._applyMinimumContrast(C, X, S.foreground, I, V, void 0) || q && B.push(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);
                }
                B.length && (C.className = B.join(" "), B.length = 0), F || O || U ? C.textContent = w : y++, A !== this.defaultSpacing && (C.style.letterSpacing = `${A}px`), g.push(C), M = P;
              }
              return C && y && (C.textContent = w), g;
            }
            _applyMinimumContrast(e3, t3, i3, s3, r2, n2) {
              if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _.excludeFromContrastRatioDemands)(s3.getCode()))
                return false;
              const o2 = this._getContrastCache(s3);
              let a2;
              if (r2 || n2 || (a2 = o2.getColor(t3.rgba, i3.rgba)), void 0 === a2) {
                const e4 = this._optionsService.rawOptions.minimumContrastRatio / (s3.isDim() ? 2 : 1);
                a2 = c.color.ensureContrastRatio(r2 || t3, n2 || i3, e4), o2.setColor((r2 || t3).rgba, (n2 || i3).rgba, null != a2 ? a2 : null);
              }
              return !!a2 && (this._addStyle(e3, `color:${a2.css}`), true);
            }
            _getContrastCache(e3) {
              return e3.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
            }
            _addStyle(e3, t3) {
              e3.setAttribute("style", `${e3.getAttribute("style") || ""}${t3};`);
            }
            _isCellInSelection(e3, t3) {
              const i3 = this._selectionStart, s3 = this._selectionEnd;
              return !(!i3 || !s3) && (this._columnSelectMode ? i3[0] <= s3[0] ? e3 >= i3[0] && t3 >= i3[1] && e3 < s3[0] && t3 <= s3[1] : e3 < i3[0] && t3 >= i3[1] && e3 >= s3[0] && t3 <= s3[1] : t3 > i3[1] && t3 < s3[1] || i3[1] === s3[1] && t3 === i3[1] && e3 >= i3[0] && e3 < s3[0] || i3[1] < s3[1] && t3 === s3[1] && e3 < s3[0] || i3[1] < s3[1] && t3 === i3[1] && e3 >= i3[0]);
            }
          };
          function v(e3, t3, i3) {
            for (; e3.length < i3; )
              e3 = t3 + e3;
            return e3;
          }
          t2.DomRendererRowFactory = f = s2([r(1, l.ICharacterJoinerService), r(2, h.IOptionsService), r(3, l.ICoreBrowserService), r(4, h.ICoreService), r(5, h.IDecorationService), r(6, l.IThemeService)], f);
        }, 2550: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.WidthCache = void 0, t2.WidthCache = class {
            constructor(e3) {
              this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = e3.createElement("div"), this._container.style.position = "absolute", this._container.style.top = "-50000px", this._container.style.width = "50000px", this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
              const t3 = e3.createElement("span"), i2 = e3.createElement("span");
              i2.style.fontWeight = "bold";
              const s2 = e3.createElement("span");
              s2.style.fontStyle = "italic";
              const r = e3.createElement("span");
              r.style.fontWeight = "bold", r.style.fontStyle = "italic", this._measureElements = [t3, i2, s2, r], this._container.appendChild(t3), this._container.appendChild(i2), this._container.appendChild(s2), this._container.appendChild(r), e3.body.appendChild(this._container), this.clear();
            }
            dispose() {
              this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
            }
            clear() {
              this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
            }
            setFont(e3, t3, i2, s2) {
              e3 === this._font && t3 === this._fontSize && i2 === this._weight && s2 === this._weightBold || (this._font = e3, this._fontSize = t3, this._weight = i2, this._weightBold = s2, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${i2}`, this._measureElements[1].style.fontWeight = `${s2}`, this._measureElements[2].style.fontWeight = `${i2}`, this._measureElements[3].style.fontWeight = `${s2}`, this.clear());
            }
            get(e3, t3, i2) {
              let s2 = 0;
              if (!t3 && !i2 && 1 === e3.length && (s2 = e3.charCodeAt(0)) < 256)
                return -9999 !== this._flat[s2] ? this._flat[s2] : this._flat[s2] = this._measure(e3, 0);
              let r = e3;
              t3 && (r += "B"), i2 && (r += "I");
              let n = this._holey.get(r);
              if (void 0 === n) {
                let s3 = 0;
                t3 && (s3 |= 1), i2 && (s3 |= 2), n = this._measure(e3, s3), this._holey.set(r, n);
              }
              return n;
            }
            _measure(e3, t3) {
              const i2 = this._measureElements[t3];
              return i2.textContent = e3.repeat(32), i2.offsetWidth / 32;
            }
          };
        }, 2223: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.TEXT_BASELINE = t2.DIM_OPACITY = t2.INVERTED_DEFAULT_COLOR = void 0;
          const s2 = i2(6114);
          t2.INVERTED_DEFAULT_COLOR = 257, t2.DIM_OPACITY = 0.5, t2.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
        }, 6171: (e2, t2) => {
          function i2(e3) {
            return 57508 <= e3 && e3 <= 57558;
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.createRenderDimensions = t2.excludeFromContrastRatioDemands = t2.isRestrictedPowerlineGlyph = t2.isPowerlineGlyph = t2.throwIfFalsy = void 0, t2.throwIfFalsy = function(e3) {
            if (!e3)
              throw new Error("value must not be falsy");
            return e3;
          }, t2.isPowerlineGlyph = i2, t2.isRestrictedPowerlineGlyph = function(e3) {
            return 57520 <= e3 && e3 <= 57527;
          }, t2.excludeFromContrastRatioDemands = function(e3) {
            return i2(e3) || function(e4) {
              return 9472 <= e4 && e4 <= 9631;
            }(e3);
          }, t2.createRenderDimensions = function() {
            return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
          };
        }, 456: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionModel = void 0, t2.SelectionModel = class {
            constructor(e3) {
              this._bufferService = e3, this.isSelectAllActive = false, this.selectionStartLength = 0;
            }
            clearSelection() {
              this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = false, this.selectionStartLength = 0;
            }
            get finalSelectionStart() {
              return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
            }
            get finalSelectionEnd() {
              if (this.isSelectAllActive)
                return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
              if (this.selectionStart) {
                if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                  const e3 = this.selectionStart[0] + this.selectionStartLength;
                  return e3 > this._bufferService.cols ? e3 % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols) - 1] : [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [e3, this.selectionStart[1]];
                }
                if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                  const e3 = this.selectionStart[0] + this.selectionStartLength;
                  return e3 > this._bufferService.cols ? [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [Math.max(e3, this.selectionEnd[0]), this.selectionEnd[1]];
                }
                return this.selectionEnd;
              }
            }
            areSelectionValuesReversed() {
              const e3 = this.selectionStart, t3 = this.selectionEnd;
              return !(!e3 || !t3) && (e3[1] > t3[1] || e3[1] === t3[1] && e3[0] > t3[0]);
            }
            handleTrim(e3) {
              return this.selectionStart && (this.selectionStart[1] -= e3), this.selectionEnd && (this.selectionEnd[1] -= e3), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
            }
          };
        }, 428: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CharSizeService = void 0;
          const n = i2(2585), o = i2(8460), a = i2(844);
          let h = t2.CharSizeService = class extends a.Disposable {
            get hasValidSize() {
              return this.width > 0 && this.height > 0;
            }
            constructor(e3, t3, i3) {
              super(), this._optionsService = i3, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new c(e3, t3, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
            }
            measure() {
              const e3 = this._measureStrategy.measure();
              e3.width === this.width && e3.height === this.height || (this.width = e3.width, this.height = e3.height, this._onCharSizeChange.fire());
            }
          };
          t2.CharSizeService = h = s2([r(2, n.IOptionsService)], h);
          class c {
            constructor(e3, t3, i3) {
              this._document = e3, this._parentElement = t3, this._optionsService = i3, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
            }
            measure() {
              this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
              const e3 = { height: Number(this._measureElement.offsetHeight), width: Number(this._measureElement.offsetWidth) };
              return 0 !== e3.width && 0 !== e3.height && (this._result.width = e3.width / 32, this._result.height = Math.ceil(e3.height)), this._result;
            }
          }
        }, 4269: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CharacterJoinerService = t2.JoinedCellData = void 0;
          const n = i2(3734), o = i2(643), a = i2(511), h = i2(2585);
          class c extends n.AttributeData {
            constructor(e3, t3, i3) {
              super(), this.content = 0, this.combinedData = "", this.fg = e3.fg, this.bg = e3.bg, this.combinedData = t3, this._width = i3;
            }
            isCombined() {
              return 2097152;
            }
            getWidth() {
              return this._width;
            }
            getChars() {
              return this.combinedData;
            }
            getCode() {
              return 2097151;
            }
            setFromCharData(e3) {
              throw new Error("not implemented");
            }
            getAsCharData() {
              return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
            }
          }
          t2.JoinedCellData = c;
          let l = t2.CharacterJoinerService = class e3 {
            constructor(e4) {
              this._bufferService = e4, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();
            }
            register(e4) {
              const t3 = { id: this._nextCharacterJoinerId++, handler: e4 };
              return this._characterJoiners.push(t3), t3.id;
            }
            deregister(e4) {
              for (let t3 = 0; t3 < this._characterJoiners.length; t3++)
                if (this._characterJoiners[t3].id === e4)
                  return this._characterJoiners.splice(t3, 1), true;
              return false;
            }
            getJoinedCharacters(e4) {
              if (0 === this._characterJoiners.length)
                return [];
              const t3 = this._bufferService.buffer.lines.get(e4);
              if (!t3 || 0 === t3.length)
                return [];
              const i3 = [], s3 = t3.translateToString(true);
              let r2 = 0, n2 = 0, a2 = 0, h2 = t3.getFg(0), c2 = t3.getBg(0);
              for (let e5 = 0; e5 < t3.getTrimmedLength(); e5++)
                if (t3.loadCell(e5, this._workCell), 0 !== this._workCell.getWidth()) {
                  if (this._workCell.fg !== h2 || this._workCell.bg !== c2) {
                    if (e5 - r2 > 1) {
                      const e6 = this._getJoinedRanges(s3, a2, n2, t3, r2);
                      for (let t4 = 0; t4 < e6.length; t4++)
                        i3.push(e6[t4]);
                    }
                    r2 = e5, a2 = n2, h2 = this._workCell.fg, c2 = this._workCell.bg;
                  }
                  n2 += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
                }
              if (this._bufferService.cols - r2 > 1) {
                const e5 = this._getJoinedRanges(s3, a2, n2, t3, r2);
                for (let t4 = 0; t4 < e5.length; t4++)
                  i3.push(e5[t4]);
              }
              return i3;
            }
            _getJoinedRanges(t3, i3, s3, r2, n2) {
              const o2 = t3.substring(i3, s3);
              let a2 = [];
              try {
                a2 = this._characterJoiners[0].handler(o2);
              } catch (e4) {
                console.error(e4);
              }
              for (let t4 = 1; t4 < this._characterJoiners.length; t4++)
                try {
                  const i4 = this._characterJoiners[t4].handler(o2);
                  for (let t5 = 0; t5 < i4.length; t5++)
                    e3._mergeRanges(a2, i4[t5]);
                } catch (e4) {
                  console.error(e4);
                }
              return this._stringRangesToCellRanges(a2, r2, n2), a2;
            }
            _stringRangesToCellRanges(e4, t3, i3) {
              let s3 = 0, r2 = false, n2 = 0, a2 = e4[s3];
              if (a2) {
                for (let h2 = i3; h2 < this._bufferService.cols; h2++) {
                  const i4 = t3.getWidth(h2), c2 = t3.getString(h2).length || o.WHITESPACE_CELL_CHAR.length;
                  if (0 !== i4) {
                    if (!r2 && a2[0] <= n2 && (a2[0] = h2, r2 = true), a2[1] <= n2) {
                      if (a2[1] = h2, a2 = e4[++s3], !a2)
                        break;
                      a2[0] <= n2 ? (a2[0] = h2, r2 = true) : r2 = false;
                    }
                    n2 += c2;
                  }
                }
                a2 && (a2[1] = this._bufferService.cols);
              }
            }
            static _mergeRanges(e4, t3) {
              let i3 = false;
              for (let s3 = 0; s3 < e4.length; s3++) {
                const r2 = e4[s3];
                if (i3) {
                  if (t3[1] <= r2[0])
                    return e4[s3 - 1][1] = t3[1], e4;
                  if (t3[1] <= r2[1])
                    return e4[s3 - 1][1] = Math.max(t3[1], r2[1]), e4.splice(s3, 1), e4;
                  e4.splice(s3, 1), s3--;
                } else {
                  if (t3[1] <= r2[0])
                    return e4.splice(s3, 0, t3), e4;
                  if (t3[1] <= r2[1])
                    return r2[0] = Math.min(t3[0], r2[0]), e4;
                  t3[0] < r2[1] && (r2[0] = Math.min(t3[0], r2[0]), i3 = true);
                }
              }
              return i3 ? e4[e4.length - 1][1] = t3[1] : e4.push(t3), e4;
            }
          };
          t2.CharacterJoinerService = l = s2([r(0, h.IBufferService)], l);
        }, 5114: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreBrowserService = void 0, t2.CoreBrowserService = class {
            constructor(e3, t3) {
              this._textarea = e3, this.window = t3, this._isFocused = false, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = true), this._textarea.addEventListener("blur", () => this._isFocused = false);
            }
            get dpr() {
              return this.window.devicePixelRatio;
            }
            get isFocused() {
              return void 0 === this._cachedIsFocused && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
            }
          };
        }, 8934: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.MouseService = void 0;
          const n = i2(4725), o = i2(9806);
          let a = t2.MouseService = class {
            constructor(e3, t3) {
              this._renderService = e3, this._charSizeService = t3;
            }
            getCoords(e3, t3, i3, s3, r2) {
              return (0, o.getCoords)(window, e3, t3, i3, s3, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r2);
            }
            getMouseReportCoords(e3, t3) {
              const i3 = (0, o.getCoordsRelativeToElement)(window, e3, t3);
              if (this._charSizeService.hasValidSize)
                return i3[0] = Math.min(Math.max(i3[0], 0), this._renderService.dimensions.css.canvas.width - 1), i3[1] = Math.min(Math.max(i3[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(i3[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(i3[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(i3[0]), y: Math.floor(i3[1]) };
            }
          };
          t2.MouseService = a = s2([r(0, n.IRenderService), r(1, n.ICharSizeService)], a);
        }, 3230: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderService = void 0;
          const n = i2(3656), o = i2(6193), a = i2(5596), h = i2(4725), c = i2(8460), l = i2(844), d = i2(7226), _ = i2(2585);
          let u = t2.RenderService = class extends l.Disposable {
            get dimensions() {
              return this._renderer.value.dimensions;
            }
            constructor(e3, t3, i3, s3, r2, h2, _2, u2) {
              if (super(), this._rowCount = e3, this._charSizeService = s3, this._renderer = this.register(new l.MutableDisposable()), this._pausedResizeTask = new d.DebouncedIdleTask(), this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: false }, this._onDimensionsChange = this.register(new c.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new c.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new c.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new c.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new o.RenderDebouncer(_2.window, (e4, t4) => this._renderRows(e4, t4)), this.register(this._renderDebouncer), this._screenDprMonitor = new a.ScreenDprMonitor(_2.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(h2.onResize(() => this._fullRefresh())), this.register(h2.buffers.onBufferActivate(() => {
                var e4;
                return null === (e4 = this._renderer.value) || void 0 === e4 ? void 0 : e4.clear();
              })), this.register(i3.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(r2.onDecorationRegistered(() => this._fullRefresh())), this.register(r2.onDecorationRemoved(() => this._fullRefresh())), this.register(i3.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
                this.clear(), this.handleResize(h2.cols, h2.rows), this._fullRefresh();
              })), this.register(i3.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(h2.buffer.y, h2.buffer.y, true))), this.register((0, n.addDisposableDomListener)(_2.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(u2.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in _2.window) {
                const e4 = new _2.window.IntersectionObserver((e5) => this._handleIntersectionChange(e5[e5.length - 1]), { threshold: 0 });
                e4.observe(t3), this.register({ dispose: () => e4.disconnect() });
              }
            }
            _handleIntersectionChange(e3) {
              this._isPaused = void 0 === e3.isIntersecting ? 0 === e3.intersectionRatio : !e3.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
            }
            refreshRows(e3, t3, i3 = false) {
              this._isPaused ? this._needsFullRefresh = true : (i3 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(e3, t3, this._rowCount));
            }
            _renderRows(e3, t3) {
              this._renderer.value && (e3 = Math.min(e3, this._rowCount - 1), t3 = Math.min(t3, this._rowCount - 1), this._renderer.value.renderRows(e3, t3), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: e3, end: t3 }), this._onRender.fire({ start: e3, end: t3 }), this._isNextRenderRedrawOnly = true);
            }
            resize(e3, t3) {
              this._rowCount = t3, this._fireOnCanvasResize();
            }
            _handleOptionsChanged() {
              this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
            }
            _fireOnCanvasResize() {
              this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
            }
            hasRenderer() {
              return !!this._renderer.value;
            }
            setRenderer(e3) {
              this._renderer.value = e3, this._renderer.value.onRequestRedraw((e4) => this.refreshRows(e4.start, e4.end, true)), this._needsSelectionRefresh = true, this._fullRefresh();
            }
            addRefreshCallback(e3) {
              return this._renderDebouncer.addRefreshCallback(e3);
            }
            _fullRefresh() {
              this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
            }
            clearTextureAtlas() {
              var e3, t3;
              this._renderer.value && (null === (t3 = (e3 = this._renderer.value).clearTextureAtlas) || void 0 === t3 || t3.call(e3), this._fullRefresh());
            }
            handleDevicePixelRatioChange() {
              this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
            }
            handleResize(e3, t3) {
              this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value.handleResize(e3, t3)) : this._renderer.value.handleResize(e3, t3), this._fullRefresh());
            }
            handleCharSizeChanged() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.handleCharSizeChanged();
            }
            handleBlur() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.handleBlur();
            }
            handleFocus() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.handleFocus();
            }
            handleSelectionChanged(e3, t3, i3) {
              var s3;
              this._selectionState.start = e3, this._selectionState.end = t3, this._selectionState.columnSelectMode = i3, null === (s3 = this._renderer.value) || void 0 === s3 || s3.handleSelectionChanged(e3, t3, i3);
            }
            handleCursorMove() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.handleCursorMove();
            }
            clear() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.clear();
            }
          };
          t2.RenderService = u = s2([r(2, _.IOptionsService), r(3, h.ICharSizeService), r(4, _.IDecorationService), r(5, _.IBufferService), r(6, h.ICoreBrowserService), r(7, h.IThemeService)], u);
        }, 9312: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionService = void 0;
          const n = i2(9806), o = i2(9504), a = i2(456), h = i2(4725), c = i2(8460), l = i2(844), d = i2(6114), _ = i2(4841), u = i2(511), f = i2(2585), v = String.fromCharCode(160), p = new RegExp(v, "g");
          let g = t2.SelectionService = class extends l.Disposable {
            constructor(e3, t3, i3, s3, r2, n2, o2, h2, d2) {
              super(), this._element = e3, this._screenElement = t3, this._linkifier = i3, this._bufferService = s3, this._coreService = r2, this._mouseService = n2, this._optionsService = o2, this._renderService = h2, this._coreBrowserService = d2, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new u.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new c.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new c.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new c.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new c.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e4) => this._handleMouseMove(e4), this._mouseUpListener = (e4) => this._handleMouseUp(e4), this._coreService.onUserInput(() => {
                this.hasSelection && this.clearSelection();
              }), this._trimListener = this._bufferService.buffer.lines.onTrim((e4) => this._handleTrim(e4)), this.register(this._bufferService.buffers.onBufferActivate((e4) => this._handleBufferActivate(e4))), this.enable(), this._model = new a.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, l.toDisposable)(() => {
                this._removeMouseDownListeners();
              }));
            }
            reset() {
              this.clearSelection();
            }
            disable() {
              this.clearSelection(), this._enabled = false;
            }
            enable() {
              this._enabled = true;
            }
            get selectionStart() {
              return this._model.finalSelectionStart;
            }
            get selectionEnd() {
              return this._model.finalSelectionEnd;
            }
            get hasSelection() {
              const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
              return !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
            }
            get selectionText() {
              const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
              if (!e3 || !t3)
                return "";
              const i3 = this._bufferService.buffer, s3 = [];
              if (3 === this._activeSelectionMode) {
                if (e3[0] === t3[0])
                  return "";
                const r2 = e3[0] < t3[0] ? e3[0] : t3[0], n2 = e3[0] < t3[0] ? t3[0] : e3[0];
                for (let o2 = e3[1]; o2 <= t3[1]; o2++) {
                  const e4 = i3.translateBufferLineToString(o2, true, r2, n2);
                  s3.push(e4);
                }
              } else {
                const r2 = e3[1] === t3[1] ? t3[0] : void 0;
                s3.push(i3.translateBufferLineToString(e3[1], true, e3[0], r2));
                for (let r3 = e3[1] + 1; r3 <= t3[1] - 1; r3++) {
                  const e4 = i3.lines.get(r3), t4 = i3.translateBufferLineToString(r3, true);
                  (null == e4 ? void 0 : e4.isWrapped) ? s3[s3.length - 1] += t4 : s3.push(t4);
                }
                if (e3[1] !== t3[1]) {
                  const e4 = i3.lines.get(t3[1]), r3 = i3.translateBufferLineToString(t3[1], true, 0, t3[0]);
                  e4 && e4.isWrapped ? s3[s3.length - 1] += r3 : s3.push(r3);
                }
              }
              return s3.map((e4) => e4.replace(p, " ")).join(d.isWindows ? "\r\n" : "\n");
            }
            clearSelection() {
              this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
            }
            refresh(e3) {
              this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), d.isLinux && e3 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
            }
            _refresh() {
              this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: 3 === this._activeSelectionMode });
            }
            _isClickInSelection(e3) {
              const t3 = this._getMouseBufferCoords(e3), i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
              return !!(i3 && s3 && t3) && this._areCoordsInSelection(t3, i3, s3);
            }
            isCellInSelection(e3, t3) {
              const i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
              return !(!i3 || !s3) && this._areCoordsInSelection([e3, t3], i3, s3);
            }
            _areCoordsInSelection(e3, t3, i3) {
              return e3[1] > t3[1] && e3[1] < i3[1] || t3[1] === i3[1] && e3[1] === t3[1] && e3[0] >= t3[0] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === i3[1] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === t3[1] && e3[0] >= t3[0];
            }
            _selectWordAtCursor(e3, t3) {
              var i3, s3;
              const r2 = null === (s3 = null === (i3 = this._linkifier.currentLink) || void 0 === i3 ? void 0 : i3.link) || void 0 === s3 ? void 0 : s3.range;
              if (r2)
                return this._model.selectionStart = [r2.start.x - 1, r2.start.y - 1], this._model.selectionStartLength = (0, _.getRangeLength)(r2, this._bufferService.cols), this._model.selectionEnd = void 0, true;
              const n2 = this._getMouseBufferCoords(e3);
              return !!n2 && (this._selectWordAt(n2, t3), this._model.selectionEnd = void 0, true);
            }
            selectAll() {
              this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
            }
            selectLines(e3, t3) {
              this._model.clearSelection(), e3 = Math.max(e3, 0), t3 = Math.min(t3, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, e3], this._model.selectionEnd = [this._bufferService.cols, t3], this.refresh(), this._onSelectionChange.fire();
            }
            _handleTrim(e3) {
              this._model.handleTrim(e3) && this.refresh();
            }
            _getMouseBufferCoords(e3) {
              const t3 = this._mouseService.getCoords(e3, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
              if (t3)
                return t3[0]--, t3[1]--, t3[1] += this._bufferService.buffer.ydisp, t3;
            }
            _getMouseEventScrollAmount(e3) {
              let t3 = (0, n.getCoordsRelativeToElement)(this._coreBrowserService.window, e3, this._screenElement)[1];
              const i3 = this._renderService.dimensions.css.canvas.height;
              return t3 >= 0 && t3 <= i3 ? 0 : (t3 > i3 && (t3 -= i3), t3 = Math.min(Math.max(t3, -50), 50), t3 /= 50, t3 / Math.abs(t3) + Math.round(14 * t3));
            }
            shouldForceSelection(e3) {
              return d.isMac ? e3.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e3.shiftKey;
            }
            handleMouseDown(e3) {
              if (this._mouseDownTimeStamp = e3.timeStamp, (2 !== e3.button || !this.hasSelection) && 0 === e3.button) {
                if (!this._enabled) {
                  if (!this.shouldForceSelection(e3))
                    return;
                  e3.stopPropagation();
                }
                e3.preventDefault(), this._dragScrollAmount = 0, this._enabled && e3.shiftKey ? this._handleIncrementalClick(e3) : 1 === e3.detail ? this._handleSingleClick(e3) : 2 === e3.detail ? this._handleDoubleClick(e3) : 3 === e3.detail && this._handleTripleClick(e3), this._addMouseDownListeners(), this.refresh(true);
              }
            }
            _addMouseDownListeners() {
              this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
            }
            _removeMouseDownListeners() {
              this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
            }
            _handleIncrementalClick(e3) {
              this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e3));
            }
            _handleSingleClick(e3) {
              if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(e3) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e3), !this._model.selectionStart)
                return;
              this._model.selectionEnd = void 0;
              const t3 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
              t3 && t3.length !== this._model.selectionStart[0] && 0 === t3.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;
            }
            _handleDoubleClick(e3) {
              this._selectWordAtCursor(e3, true) && (this._activeSelectionMode = 1);
            }
            _handleTripleClick(e3) {
              const t3 = this._getMouseBufferCoords(e3);
              t3 && (this._activeSelectionMode = 2, this._selectLineAt(t3[1]));
            }
            shouldColumnSelect(e3) {
              return e3.altKey && !(d.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
            }
            _handleMouseMove(e3) {
              if (e3.stopImmediatePropagation(), !this._model.selectionStart)
                return;
              const t3 = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
              if (this._model.selectionEnd = this._getMouseBufferCoords(e3), !this._model.selectionEnd)
                return void this.refresh(true);
              2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e3), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
              const i3 = this._bufferService.buffer;
              if (this._model.selectionEnd[1] < i3.lines.length) {
                const e4 = i3.lines.get(this._model.selectionEnd[1]);
                e4 && 0 === e4.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0]++;
              }
              t3 && t3[0] === this._model.selectionEnd[0] && t3[1] === this._model.selectionEnd[1] || this.refresh(true);
            }
            _dragScroll() {
              if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
                this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: false });
                const e3 = this._bufferService.buffer;
                this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e3.ydisp + this._bufferService.rows, e3.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e3.ydisp), this.refresh();
              }
            }
            _handleMouseUp(e3) {
              const t3 = e3.timeStamp - this._mouseDownTimeStamp;
              if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t3 < 500 && e3.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
                if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                  const t4 = this._mouseService.getCoords(e3, this._element, this._bufferService.cols, this._bufferService.rows, false);
                  if (t4 && void 0 !== t4[0] && void 0 !== t4[1]) {
                    const e4 = (0, o.moveToCellSequence)(t4[0] - 1, t4[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                    this._coreService.triggerDataEvent(e4, true);
                  }
                }
              } else
                this._fireEventIfSelectionChanged();
            }
            _fireEventIfSelectionChanged() {
              const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd, i3 = !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
              i3 ? e3 && t3 && (this._oldSelectionStart && this._oldSelectionEnd && e3[0] === this._oldSelectionStart[0] && e3[1] === this._oldSelectionStart[1] && t3[0] === this._oldSelectionEnd[0] && t3[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e3, t3, i3)) : this._oldHasSelection && this._fireOnSelectionChange(e3, t3, i3);
            }
            _fireOnSelectionChange(e3, t3, i3) {
              this._oldSelectionStart = e3, this._oldSelectionEnd = t3, this._oldHasSelection = i3, this._onSelectionChange.fire();
            }
            _handleBufferActivate(e3) {
              this.clearSelection(), this._trimListener.dispose(), this._trimListener = e3.activeBuffer.lines.onTrim((e4) => this._handleTrim(e4));
            }
            _convertViewportColToCharacterIndex(e3, t3) {
              let i3 = t3;
              for (let s3 = 0; t3 >= s3; s3++) {
                const r2 = e3.loadCell(s3, this._workCell).getChars().length;
                0 === this._workCell.getWidth() ? i3-- : r2 > 1 && t3 !== s3 && (i3 += r2 - 1);
              }
              return i3;
            }
            setSelection(e3, t3, i3) {
              this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [e3, t3], this._model.selectionStartLength = i3, this.refresh(), this._fireEventIfSelectionChanged();
            }
            rightClickSelect(e3) {
              this._isClickInSelection(e3) || (this._selectWordAtCursor(e3, false) && this.refresh(true), this._fireEventIfSelectionChanged());
            }
            _getWordAt(e3, t3, i3 = true, s3 = true) {
              if (e3[0] >= this._bufferService.cols)
                return;
              const r2 = this._bufferService.buffer, n2 = r2.lines.get(e3[1]);
              if (!n2)
                return;
              const o2 = r2.translateBufferLineToString(e3[1], false);
              let a2 = this._convertViewportColToCharacterIndex(n2, e3[0]), h2 = a2;
              const c2 = e3[0] - a2;
              let l2 = 0, d2 = 0, _2 = 0, u2 = 0;
              if (" " === o2.charAt(a2)) {
                for (; a2 > 0 && " " === o2.charAt(a2 - 1); )
                  a2--;
                for (; h2 < o2.length && " " === o2.charAt(h2 + 1); )
                  h2++;
              } else {
                let t4 = e3[0], i4 = e3[0];
                0 === n2.getWidth(t4) && (l2++, t4--), 2 === n2.getWidth(i4) && (d2++, i4++);
                const s4 = n2.getString(i4).length;
                for (s4 > 1 && (u2 += s4 - 1, h2 += s4 - 1); t4 > 0 && a2 > 0 && !this._isCharWordSeparator(n2.loadCell(t4 - 1, this._workCell)); ) {
                  n2.loadCell(t4 - 1, this._workCell);
                  const e4 = this._workCell.getChars().length;
                  0 === this._workCell.getWidth() ? (l2++, t4--) : e4 > 1 && (_2 += e4 - 1, a2 -= e4 - 1), a2--, t4--;
                }
                for (; i4 < n2.length && h2 + 1 < o2.length && !this._isCharWordSeparator(n2.loadCell(i4 + 1, this._workCell)); ) {
                  n2.loadCell(i4 + 1, this._workCell);
                  const e4 = this._workCell.getChars().length;
                  2 === this._workCell.getWidth() ? (d2++, i4++) : e4 > 1 && (u2 += e4 - 1, h2 += e4 - 1), h2++, i4++;
                }
              }
              h2++;
              let f2 = a2 + c2 - l2 + _2, v2 = Math.min(this._bufferService.cols, h2 - a2 + l2 + d2 - _2 - u2);
              if (t3 || "" !== o2.slice(a2, h2).trim()) {
                if (i3 && 0 === f2 && 32 !== n2.getCodePoint(0)) {
                  const t4 = r2.lines.get(e3[1] - 1);
                  if (t4 && n2.isWrapped && 32 !== t4.getCodePoint(this._bufferService.cols - 1)) {
                    const t5 = this._getWordAt([this._bufferService.cols - 1, e3[1] - 1], false, true, false);
                    if (t5) {
                      const e4 = this._bufferService.cols - t5.start;
                      f2 -= e4, v2 += e4;
                    }
                  }
                }
                if (s3 && f2 + v2 === this._bufferService.cols && 32 !== n2.getCodePoint(this._bufferService.cols - 1)) {
                  const t4 = r2.lines.get(e3[1] + 1);
                  if ((null == t4 ? void 0 : t4.isWrapped) && 32 !== t4.getCodePoint(0)) {
                    const t5 = this._getWordAt([0, e3[1] + 1], false, false, true);
                    t5 && (v2 += t5.length);
                  }
                }
                return { start: f2, length: v2 };
              }
            }
            _selectWordAt(e3, t3) {
              const i3 = this._getWordAt(e3, t3);
              if (i3) {
                for (; i3.start < 0; )
                  i3.start += this._bufferService.cols, e3[1]--;
                this._model.selectionStart = [i3.start, e3[1]], this._model.selectionStartLength = i3.length;
              }
            }
            _selectToWordAt(e3) {
              const t3 = this._getWordAt(e3, true);
              if (t3) {
                let i3 = e3[1];
                for (; t3.start < 0; )
                  t3.start += this._bufferService.cols, i3--;
                if (!this._model.areSelectionValuesReversed())
                  for (; t3.start + t3.length > this._bufferService.cols; )
                    t3.length -= this._bufferService.cols, i3++;
                this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? t3.start : t3.start + t3.length, i3];
              }
            }
            _isCharWordSeparator(e3) {
              return 0 !== e3.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e3.getChars()) >= 0;
            }
            _selectLineAt(e3) {
              const t3 = this._bufferService.buffer.getWrappedRangeForLine(e3), i3 = { start: { x: 0, y: t3.first }, end: { x: this._bufferService.cols - 1, y: t3.last } };
              this._model.selectionStart = [0, t3.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, _.getRangeLength)(i3, this._bufferService.cols);
            }
          };
          t2.SelectionService = g = s2([r(3, f.IBufferService), r(4, f.ICoreService), r(5, h.IMouseService), r(6, f.IOptionsService), r(7, h.IRenderService), r(8, h.ICoreBrowserService)], g);
        }, 4725: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.IThemeService = t2.ICharacterJoinerService = t2.ISelectionService = t2.IRenderService = t2.IMouseService = t2.ICoreBrowserService = t2.ICharSizeService = void 0;
          const s2 = i2(8343);
          t2.ICharSizeService = (0, s2.createDecorator)("CharSizeService"), t2.ICoreBrowserService = (0, s2.createDecorator)("CoreBrowserService"), t2.IMouseService = (0, s2.createDecorator)("MouseService"), t2.IRenderService = (0, s2.createDecorator)("RenderService"), t2.ISelectionService = (0, s2.createDecorator)("SelectionService"), t2.ICharacterJoinerService = (0, s2.createDecorator)("CharacterJoinerService"), t2.IThemeService = (0, s2.createDecorator)("ThemeService");
        }, 6731: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ThemeService = t2.DEFAULT_ANSI_COLORS = void 0;
          const n = i2(7239), o = i2(8055), a = i2(8460), h = i2(844), c = i2(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _ = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
          t2.DEFAULT_ANSI_COLORS = Object.freeze((() => {
            const e3 = [o.css.toColor("#2e3436"), o.css.toColor("#cc0000"), o.css.toColor("#4e9a06"), o.css.toColor("#c4a000"), o.css.toColor("#3465a4"), o.css.toColor("#75507b"), o.css.toColor("#06989a"), o.css.toColor("#d3d7cf"), o.css.toColor("#555753"), o.css.toColor("#ef2929"), o.css.toColor("#8ae234"), o.css.toColor("#fce94f"), o.css.toColor("#729fcf"), o.css.toColor("#ad7fa8"), o.css.toColor("#34e2e2"), o.css.toColor("#eeeeec")], t3 = [0, 95, 135, 175, 215, 255];
            for (let i3 = 0; i3 < 216; i3++) {
              const s3 = t3[i3 / 36 % 6 | 0], r2 = t3[i3 / 6 % 6 | 0], n2 = t3[i3 % 6];
              e3.push({ css: o.channels.toCss(s3, r2, n2), rgba: o.channels.toRgba(s3, r2, n2) });
            }
            for (let t4 = 0; t4 < 24; t4++) {
              const i3 = 8 + 10 * t4;
              e3.push({ css: o.channels.toCss(i3, i3, i3), rgba: o.channels.toRgba(i3, i3, i3) });
            }
            return e3;
          })());
          let v = t2.ThemeService = class extends h.Disposable {
            get colors() {
              return this._colors;
            }
            constructor(e3) {
              super(), this._optionsService = e3, this._contrastCache = new n.ColorContrastCache(), this._halfContrastCache = new n.ColorContrastCache(), this._onChangeColors = this.register(new a.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: l, background: d, cursor: _, cursorAccent: u, selectionForeground: void 0, selectionBackgroundTransparent: f, selectionBackgroundOpaque: o.color.blend(d, f), selectionInactiveBackgroundTransparent: f, selectionInactiveBackgroundOpaque: o.color.blend(d, f), ansi: t2.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
            }
            _setTheme(e3 = {}) {
              const i3 = this._colors;
              if (i3.foreground = p(e3.foreground, l), i3.background = p(e3.background, d), i3.cursor = p(e3.cursor, _), i3.cursorAccent = p(e3.cursorAccent, u), i3.selectionBackgroundTransparent = p(e3.selectionBackground, f), i3.selectionBackgroundOpaque = o.color.blend(i3.background, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundTransparent = p(e3.selectionInactiveBackground, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundOpaque = o.color.blend(i3.background, i3.selectionInactiveBackgroundTransparent), i3.selectionForeground = e3.selectionForeground ? p(e3.selectionForeground, o.NULL_COLOR) : void 0, i3.selectionForeground === o.NULL_COLOR && (i3.selectionForeground = void 0), o.color.isOpaque(i3.selectionBackgroundTransparent)) {
                const e4 = 0.3;
                i3.selectionBackgroundTransparent = o.color.opacity(i3.selectionBackgroundTransparent, e4);
              }
              if (o.color.isOpaque(i3.selectionInactiveBackgroundTransparent)) {
                const e4 = 0.3;
                i3.selectionInactiveBackgroundTransparent = o.color.opacity(i3.selectionInactiveBackgroundTransparent, e4);
              }
              if (i3.ansi = t2.DEFAULT_ANSI_COLORS.slice(), i3.ansi[0] = p(e3.black, t2.DEFAULT_ANSI_COLORS[0]), i3.ansi[1] = p(e3.red, t2.DEFAULT_ANSI_COLORS[1]), i3.ansi[2] = p(e3.green, t2.DEFAULT_ANSI_COLORS[2]), i3.ansi[3] = p(e3.yellow, t2.DEFAULT_ANSI_COLORS[3]), i3.ansi[4] = p(e3.blue, t2.DEFAULT_ANSI_COLORS[4]), i3.ansi[5] = p(e3.magenta, t2.DEFAULT_ANSI_COLORS[5]), i3.ansi[6] = p(e3.cyan, t2.DEFAULT_ANSI_COLORS[6]), i3.ansi[7] = p(e3.white, t2.DEFAULT_ANSI_COLORS[7]), i3.ansi[8] = p(e3.brightBlack, t2.DEFAULT_ANSI_COLORS[8]), i3.ansi[9] = p(e3.brightRed, t2.DEFAULT_ANSI_COLORS[9]), i3.ansi[10] = p(e3.brightGreen, t2.DEFAULT_ANSI_COLORS[10]), i3.ansi[11] = p(e3.brightYellow, t2.DEFAULT_ANSI_COLORS[11]), i3.ansi[12] = p(e3.brightBlue, t2.DEFAULT_ANSI_COLORS[12]), i3.ansi[13] = p(e3.brightMagenta, t2.DEFAULT_ANSI_COLORS[13]), i3.ansi[14] = p(e3.brightCyan, t2.DEFAULT_ANSI_COLORS[14]), i3.ansi[15] = p(e3.brightWhite, t2.DEFAULT_ANSI_COLORS[15]), e3.extendedAnsi) {
                const s3 = Math.min(i3.ansi.length - 16, e3.extendedAnsi.length);
                for (let r2 = 0; r2 < s3; r2++)
                  i3.ansi[r2 + 16] = p(e3.extendedAnsi[r2], t2.DEFAULT_ANSI_COLORS[r2 + 16]);
              }
              this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
            }
            restoreColor(e3) {
              this._restoreColor(e3), this._onChangeColors.fire(this.colors);
            }
            _restoreColor(e3) {
              if (void 0 !== e3)
                switch (e3) {
                  case 256:
                    this._colors.foreground = this._restoreColors.foreground;
                    break;
                  case 257:
                    this._colors.background = this._restoreColors.background;
                    break;
                  case 258:
                    this._colors.cursor = this._restoreColors.cursor;
                    break;
                  default:
                    this._colors.ansi[e3] = this._restoreColors.ansi[e3];
                }
              else
                for (let e4 = 0; e4 < this._restoreColors.ansi.length; ++e4)
                  this._colors.ansi[e4] = this._restoreColors.ansi[e4];
            }
            modifyColors(e3) {
              e3(this._colors), this._onChangeColors.fire(this.colors);
            }
            _updateRestoreColors() {
              this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
            }
          };
          function p(e3, t3) {
            if (void 0 !== e3)
              try {
                return o.css.toColor(e3);
              } catch (e4) {
              }
            return t3;
          }
          t2.ThemeService = v = s2([r(0, c.IOptionsService)], v);
        }, 6349: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CircularList = void 0;
          const s2 = i2(8460), r = i2(844);
          class n extends r.Disposable {
            constructor(e3) {
              super(), this._maxLength = e3, this.onDeleteEmitter = this.register(new s2.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s2.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s2.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
            }
            get maxLength() {
              return this._maxLength;
            }
            set maxLength(e3) {
              if (this._maxLength === e3)
                return;
              const t3 = new Array(e3);
              for (let i3 = 0; i3 < Math.min(e3, this.length); i3++)
                t3[i3] = this._array[this._getCyclicIndex(i3)];
              this._array = t3, this._maxLength = e3, this._startIndex = 0;
            }
            get length() {
              return this._length;
            }
            set length(e3) {
              if (e3 > this._length)
                for (let t3 = this._length; t3 < e3; t3++)
                  this._array[t3] = void 0;
              this._length = e3;
            }
            get(e3) {
              return this._array[this._getCyclicIndex(e3)];
            }
            set(e3, t3) {
              this._array[this._getCyclicIndex(e3)] = t3;
            }
            push(e3) {
              this._array[this._getCyclicIndex(this._length)] = e3, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
            }
            recycle() {
              if (this._length !== this._maxLength)
                throw new Error("Can only recycle when the buffer is full");
              return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
            }
            get isFull() {
              return this._length === this._maxLength;
            }
            pop() {
              return this._array[this._getCyclicIndex(this._length-- - 1)];
            }
            splice(e3, t3, ...i3) {
              if (t3) {
                for (let i4 = e3; i4 < this._length - t3; i4++)
                  this._array[this._getCyclicIndex(i4)] = this._array[this._getCyclicIndex(i4 + t3)];
                this._length -= t3, this.onDeleteEmitter.fire({ index: e3, amount: t3 });
              }
              for (let t4 = this._length - 1; t4 >= e3; t4--)
                this._array[this._getCyclicIndex(t4 + i3.length)] = this._array[this._getCyclicIndex(t4)];
              for (let t4 = 0; t4 < i3.length; t4++)
                this._array[this._getCyclicIndex(e3 + t4)] = i3[t4];
              if (i3.length && this.onInsertEmitter.fire({ index: e3, amount: i3.length }), this._length + i3.length > this._maxLength) {
                const e4 = this._length + i3.length - this._maxLength;
                this._startIndex += e4, this._length = this._maxLength, this.onTrimEmitter.fire(e4);
              } else
                this._length += i3.length;
            }
            trimStart(e3) {
              e3 > this._length && (e3 = this._length), this._startIndex += e3, this._length -= e3, this.onTrimEmitter.fire(e3);
            }
            shiftElements(e3, t3, i3) {
              if (!(t3 <= 0)) {
                if (e3 < 0 || e3 >= this._length)
                  throw new Error("start argument out of range");
                if (e3 + i3 < 0)
                  throw new Error("Cannot shift elements in list beyond index 0");
                if (i3 > 0) {
                  for (let s4 = t3 - 1; s4 >= 0; s4--)
                    this.set(e3 + s4 + i3, this.get(e3 + s4));
                  const s3 = e3 + t3 + i3 - this._length;
                  if (s3 > 0)
                    for (this._length += s3; this._length > this._maxLength; )
                      this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
                } else
                  for (let s3 = 0; s3 < t3; s3++)
                    this.set(e3 + s3 + i3, this.get(e3 + s3));
              }
            }
            _getCyclicIndex(e3) {
              return (this._startIndex + e3) % this._maxLength;
            }
          }
          t2.CircularList = n;
        }, 1439: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.clone = void 0, t2.clone = function e3(t3, i2 = 5) {
            if ("object" != typeof t3)
              return t3;
            const s2 = Array.isArray(t3) ? [] : {};
            for (const r in t3)
              s2[r] = i2 <= 1 ? t3[r] : t3[r] && e3(t3[r], i2 - 1);
            return s2;
          };
        }, 8055: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.contrastRatio = t2.toPaddedHex = t2.rgba = t2.rgb = t2.css = t2.color = t2.channels = t2.NULL_COLOR = void 0;
          const s2 = i2(6114);
          let r = 0, n = 0, o = 0, a = 0;
          var h, c, l, d, _;
          function u(e3) {
            const t3 = e3.toString(16);
            return t3.length < 2 ? "0" + t3 : t3;
          }
          function f(e3, t3) {
            return e3 < t3 ? (t3 + 0.05) / (e3 + 0.05) : (e3 + 0.05) / (t3 + 0.05);
          }
          t2.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(e3) {
            e3.toCss = function(e4, t3, i3, s3) {
              return void 0 !== s3 ? `#${u(e4)}${u(t3)}${u(i3)}${u(s3)}` : `#${u(e4)}${u(t3)}${u(i3)}`;
            }, e3.toRgba = function(e4, t3, i3, s3 = 255) {
              return (e4 << 24 | t3 << 16 | i3 << 8 | s3) >>> 0;
            };
          }(h || (t2.channels = h = {})), function(e3) {
            function t3(e4, t4) {
              return a = Math.round(255 * t4), [r, n, o] = _.toChannels(e4.rgba), { css: h.toCss(r, n, o, a), rgba: h.toRgba(r, n, o, a) };
            }
            e3.blend = function(e4, t4) {
              if (a = (255 & t4.rgba) / 255, 1 === a)
                return { css: t4.css, rgba: t4.rgba };
              const i3 = t4.rgba >> 24 & 255, s3 = t4.rgba >> 16 & 255, c2 = t4.rgba >> 8 & 255, l2 = e4.rgba >> 24 & 255, d2 = e4.rgba >> 16 & 255, _2 = e4.rgba >> 8 & 255;
              return r = l2 + Math.round((i3 - l2) * a), n = d2 + Math.round((s3 - d2) * a), o = _2 + Math.round((c2 - _2) * a), { css: h.toCss(r, n, o), rgba: h.toRgba(r, n, o) };
            }, e3.isOpaque = function(e4) {
              return 255 == (255 & e4.rgba);
            }, e3.ensureContrastRatio = function(e4, t4, i3) {
              const s3 = _.ensureContrastRatio(e4.rgba, t4.rgba, i3);
              if (s3)
                return _.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
            }, e3.opaque = function(e4) {
              const t4 = (255 | e4.rgba) >>> 0;
              return [r, n, o] = _.toChannels(t4), { css: h.toCss(r, n, o), rgba: t4 };
            }, e3.opacity = t3, e3.multiplyOpacity = function(e4, i3) {
              return a = 255 & e4.rgba, t3(e4, a * i3 / 255);
            }, e3.toColorRGB = function(e4) {
              return [e4.rgba >> 24 & 255, e4.rgba >> 16 & 255, e4.rgba >> 8 & 255];
            };
          }(c || (t2.color = c = {})), function(e3) {
            let t3, i3;
            if (!s2.isNode) {
              const e4 = document.createElement("canvas");
              e4.width = 1, e4.height = 1;
              const s3 = e4.getContext("2d", { willReadFrequently: true });
              s3 && (t3 = s3, t3.globalCompositeOperation = "copy", i3 = t3.createLinearGradient(0, 0, 1, 1));
            }
            e3.toColor = function(e4) {
              if (e4.match(/#[\da-f]{3,8}/i))
                switch (e4.length) {
                  case 4:
                    return r = parseInt(e4.slice(1, 2).repeat(2), 16), n = parseInt(e4.slice(2, 3).repeat(2), 16), o = parseInt(e4.slice(3, 4).repeat(2), 16), _.toColor(r, n, o);
                  case 5:
                    return r = parseInt(e4.slice(1, 2).repeat(2), 16), n = parseInt(e4.slice(2, 3).repeat(2), 16), o = parseInt(e4.slice(3, 4).repeat(2), 16), a = parseInt(e4.slice(4, 5).repeat(2), 16), _.toColor(r, n, o, a);
                  case 7:
                    return { css: e4, rgba: (parseInt(e4.slice(1), 16) << 8 | 255) >>> 0 };
                  case 9:
                    return { css: e4, rgba: parseInt(e4.slice(1), 16) >>> 0 };
                }
              const s3 = e4.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
              if (s3)
                return r = parseInt(s3[1]), n = parseInt(s3[2]), o = parseInt(s3[3]), a = Math.round(255 * (void 0 === s3[5] ? 1 : parseFloat(s3[5]))), _.toColor(r, n, o, a);
              if (!t3 || !i3)
                throw new Error("css.toColor: Unsupported css format");
              if (t3.fillStyle = i3, t3.fillStyle = e4, "string" != typeof t3.fillStyle)
                throw new Error("css.toColor: Unsupported css format");
              if (t3.fillRect(0, 0, 1, 1), [r, n, o, a] = t3.getImageData(0, 0, 1, 1).data, 255 !== a)
                throw new Error("css.toColor: Unsupported css format");
              return { rgba: h.toRgba(r, n, o, a), css: e4 };
            };
          }(l || (t2.css = l = {})), function(e3) {
            function t3(e4, t4, i3) {
              const s3 = e4 / 255, r2 = t4 / 255, n2 = i3 / 255;
              return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n2 <= 0.03928 ? n2 / 12.92 : Math.pow((n2 + 0.055) / 1.055, 2.4));
            }
            e3.relativeLuminance = function(e4) {
              return t3(e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4);
            }, e3.relativeLuminance2 = t3;
          }(d || (t2.rgb = d = {})), function(e3) {
            function t3(e4, t4, i4) {
              const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
              let o2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
              for (; c2 < i4 && (o2 > 0 || a2 > 0 || h2 > 0); )
                o2 -= Math.max(0, Math.ceil(0.1 * o2)), a2 -= Math.max(0, Math.ceil(0.1 * a2)), h2 -= Math.max(0, Math.ceil(0.1 * h2)), c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
              return (o2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
            }
            function i3(e4, t4, i4) {
              const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
              let o2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
              for (; c2 < i4 && (o2 < 255 || a2 < 255 || h2 < 255); )
                o2 = Math.min(255, o2 + Math.ceil(0.1 * (255 - o2))), a2 = Math.min(255, a2 + Math.ceil(0.1 * (255 - a2))), h2 = Math.min(255, h2 + Math.ceil(0.1 * (255 - h2))), c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
              return (o2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
            }
            e3.ensureContrastRatio = function(e4, s3, r2) {
              const n2 = d.relativeLuminance(e4 >> 8), o2 = d.relativeLuminance(s3 >> 8);
              if (f(n2, o2) < r2) {
                if (o2 < n2) {
                  const o3 = t3(e4, s3, r2), a3 = f(n2, d.relativeLuminance(o3 >> 8));
                  if (a3 < r2) {
                    const t4 = i3(e4, s3, r2);
                    return a3 > f(n2, d.relativeLuminance(t4 >> 8)) ? o3 : t4;
                  }
                  return o3;
                }
                const a2 = i3(e4, s3, r2), h2 = f(n2, d.relativeLuminance(a2 >> 8));
                if (h2 < r2) {
                  const i4 = t3(e4, s3, r2);
                  return h2 > f(n2, d.relativeLuminance(i4 >> 8)) ? a2 : i4;
                }
                return a2;
              }
            }, e3.reduceLuminance = t3, e3.increaseLuminance = i3, e3.toChannels = function(e4) {
              return [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
            }, e3.toColor = function(e4, t4, i4, s3) {
              return { css: h.toCss(e4, t4, i4, s3), rgba: h.toRgba(e4, t4, i4, s3) };
            };
          }(_ || (t2.rgba = _ = {})), t2.toPaddedHex = u, t2.contrastRatio = f;
        }, 8969: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreTerminal = void 0;
          const s2 = i2(844), r = i2(2585), n = i2(4348), o = i2(7866), a = i2(744), h = i2(7302), c = i2(6975), l = i2(8460), d = i2(1753), _ = i2(1480), u = i2(7994), f = i2(9282), v = i2(5435), p = i2(5981), g = i2(2660);
          let m = false;
          class S extends s2.Disposable {
            get onScroll() {
              return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter()), this._onScroll.event((e3) => {
                var t3;
                null === (t3 = this._onScrollApi) || void 0 === t3 || t3.fire(e3.position);
              })), this._onScrollApi.event;
            }
            get cols() {
              return this._bufferService.cols;
            }
            get rows() {
              return this._bufferService.rows;
            }
            get buffers() {
              return this._bufferService.buffers;
            }
            get options() {
              return this.optionsService.options;
            }
            set options(e3) {
              for (const t3 in e3)
                this.optionsService.options[t3] = e3[t3];
            }
            constructor(e3) {
              super(), this._windowsWrappingHeuristics = this.register(new s2.MutableDisposable()), this._onBinary = this.register(new l.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter()), this._instantiationService = new n.InstantiationService(), this.optionsService = this.register(new h.OptionsService(e3)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(g.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((e4) => {
                this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
              })), this.register(this._inputHandler.onScroll((e4) => {
                this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
              })), this._writeBuffer = this.register(new p.WriteBuffer((e4, t3) => this._inputHandler.parse(e4, t3))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
            }
            write(e3, t3) {
              this._writeBuffer.write(e3, t3);
            }
            writeSync(e3, t3) {
              this._logService.logLevel <= r.LogLevelEnum.WARN && !m && (this._logService.warn("writeSync is unreliable and will be removed soon."), m = true), this._writeBuffer.writeSync(e3, t3);
            }
            resize(e3, t3) {
              isNaN(e3) || isNaN(t3) || (e3 = Math.max(e3, a.MINIMUM_COLS), t3 = Math.max(t3, a.MINIMUM_ROWS), this._bufferService.resize(e3, t3));
            }
            scroll(e3, t3 = false) {
              this._bufferService.scroll(e3, t3);
            }
            scrollLines(e3, t3, i3) {
              this._bufferService.scrollLines(e3, t3, i3);
            }
            scrollPages(e3) {
              this.scrollLines(e3 * (this.rows - 1));
            }
            scrollToTop() {
              this.scrollLines(-this._bufferService.buffer.ydisp);
            }
            scrollToBottom() {
              this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
            }
            scrollToLine(e3) {
              const t3 = e3 - this._bufferService.buffer.ydisp;
              0 !== t3 && this.scrollLines(t3);
            }
            registerEscHandler(e3, t3) {
              return this._inputHandler.registerEscHandler(e3, t3);
            }
            registerDcsHandler(e3, t3) {
              return this._inputHandler.registerDcsHandler(e3, t3);
            }
            registerCsiHandler(e3, t3) {
              return this._inputHandler.registerCsiHandler(e3, t3);
            }
            registerOscHandler(e3, t3) {
              return this._inputHandler.registerOscHandler(e3, t3);
            }
            _setup() {
              this._handleWindowsPtyOptionChange();
            }
            reset() {
              this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
            }
            _handleWindowsPtyOptionChange() {
              let e3 = false;
              const t3 = this.optionsService.rawOptions.windowsPty;
              t3 && void 0 !== t3.buildNumber && void 0 !== t3.buildNumber ? e3 = !!("conpty" === t3.backend && t3.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (e3 = true), e3 ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
            }
            _enableWindowsWrappingHeuristics() {
              if (!this._windowsWrappingHeuristics.value) {
                const e3 = [];
                e3.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e3.push(this.registerCsiHandler({ final: "H" }, () => ((0, f.updateWindowsModeWrappedState)(this._bufferService), false))), this._windowsWrappingHeuristics.value = (0, s2.toDisposable)(() => {
                  for (const t3 of e3)
                    t3.dispose();
                });
              }
            }
          }
          t2.CoreTerminal = S;
        }, 8460: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.forwardEvent = t2.EventEmitter = void 0, t2.EventEmitter = class {
            constructor() {
              this._listeners = [], this._disposed = false;
            }
            get event() {
              return this._event || (this._event = (e3) => (this._listeners.push(e3), { dispose: () => {
                if (!this._disposed) {
                  for (let t3 = 0; t3 < this._listeners.length; t3++)
                    if (this._listeners[t3] === e3)
                      return void this._listeners.splice(t3, 1);
                }
              } })), this._event;
            }
            fire(e3, t3) {
              const i2 = [];
              for (let e4 = 0; e4 < this._listeners.length; e4++)
                i2.push(this._listeners[e4]);
              for (let s2 = 0; s2 < i2.length; s2++)
                i2[s2].call(void 0, e3, t3);
            }
            dispose() {
              this.clearListeners(), this._disposed = true;
            }
            clearListeners() {
              this._listeners && (this._listeners.length = 0);
            }
          }, t2.forwardEvent = function(e3, t3) {
            return e3((e4) => t3.fire(e4));
          };
        }, 5435: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.InputHandler = t2.WindowsOptionsReportType = void 0;
          const n = i2(2584), o = i2(7116), a = i2(2015), h = i2(844), c = i2(482), l = i2(8437), d = i2(8460), _ = i2(643), u = i2(511), f = i2(3734), v = i2(2585), p = i2(6242), g = i2(6351), m = i2(5941), S = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, C = 131072;
          function b(e3, t3) {
            if (e3 > 24)
              return t3.setWinLines || false;
            switch (e3) {
              case 1:
                return !!t3.restoreWin;
              case 2:
                return !!t3.minimizeWin;
              case 3:
                return !!t3.setWinPosition;
              case 4:
                return !!t3.setWinSizePixels;
              case 5:
                return !!t3.raiseWin;
              case 6:
                return !!t3.lowerWin;
              case 7:
                return !!t3.refreshWin;
              case 8:
                return !!t3.setWinSizeChars;
              case 9:
                return !!t3.maximizeWin;
              case 10:
                return !!t3.fullscreenWin;
              case 11:
                return !!t3.getWinState;
              case 13:
                return !!t3.getWinPosition;
              case 14:
                return !!t3.getWinSizePixels;
              case 15:
                return !!t3.getScreenSizePixels;
              case 16:
                return !!t3.getCellSizePixels;
              case 18:
                return !!t3.getWinSizeChars;
              case 19:
                return !!t3.getScreenSizeChars;
              case 20:
                return !!t3.getIconTitle;
              case 21:
                return !!t3.getWinTitle;
              case 22:
                return !!t3.pushTitle;
              case 23:
                return !!t3.popTitle;
              case 24:
                return !!t3.setWinLines;
            }
            return false;
          }
          var y;
          !function(e3) {
            e3[e3.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e3[e3.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
          }(y || (t2.WindowsOptionsReportType = y = {}));
          let w = 0;
          class E extends h.Disposable {
            getAttrData() {
              return this._curAttrData;
            }
            constructor(e3, t3, i3, s3, r2, h2, _2, f2, v2 = new a.EscapeSequenceParser()) {
              super(), this._bufferService = e3, this._charsetService = t3, this._coreService = i3, this._logService = s3, this._optionsService = r2, this._oscLinkService = h2, this._coreMouseService = _2, this._unicodeService = f2, this._parser = v2, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32(), this._utf8Decoder = new c.Utf8ToUtf32(), this._workCell = new u.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: false, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new k(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._parser.setCsiHandlerFallback((e4, t4) => {
                this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(e4), params: t4.toArray() });
              }), this._parser.setEscHandlerFallback((e4) => {
                this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(e4) });
              }), this._parser.setExecuteHandlerFallback((e4) => {
                this._logService.debug("Unknown EXECUTE code: ", { code: e4 });
              }), this._parser.setOscHandlerFallback((e4, t4, i4) => {
                this._logService.debug("Unknown OSC code: ", { identifier: e4, action: t4, data: i4 });
              }), this._parser.setDcsHandlerFallback((e4, t4, i4) => {
                "HOOK" === t4 && (i4 = i4.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(e4), action: t4, payload: i4 });
              }), this._parser.setPrintHandler((e4, t4, i4) => this.print(e4, t4, i4)), this._parser.registerCsiHandler({ final: "@" }, (e4) => this.insertChars(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (e4) => this.scrollLeft(e4)), this._parser.registerCsiHandler({ final: "A" }, (e4) => this.cursorUp(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (e4) => this.scrollRight(e4)), this._parser.registerCsiHandler({ final: "B" }, (e4) => this.cursorDown(e4)), this._parser.registerCsiHandler({ final: "C" }, (e4) => this.cursorForward(e4)), this._parser.registerCsiHandler({ final: "D" }, (e4) => this.cursorBackward(e4)), this._parser.registerCsiHandler({ final: "E" }, (e4) => this.cursorNextLine(e4)), this._parser.registerCsiHandler({ final: "F" }, (e4) => this.cursorPrecedingLine(e4)), this._parser.registerCsiHandler({ final: "G" }, (e4) => this.cursorCharAbsolute(e4)), this._parser.registerCsiHandler({ final: "H" }, (e4) => this.cursorPosition(e4)), this._parser.registerCsiHandler({ final: "I" }, (e4) => this.cursorForwardTab(e4)), this._parser.registerCsiHandler({ final: "J" }, (e4) => this.eraseInDisplay(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (e4) => this.eraseInDisplay(e4, true)), this._parser.registerCsiHandler({ final: "K" }, (e4) => this.eraseInLine(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (e4) => this.eraseInLine(e4, true)), this._parser.registerCsiHandler({ final: "L" }, (e4) => this.insertLines(e4)), this._parser.registerCsiHandler({ final: "M" }, (e4) => this.deleteLines(e4)), this._parser.registerCsiHandler({ final: "P" }, (e4) => this.deleteChars(e4)), this._parser.registerCsiHandler({ final: "S" }, (e4) => this.scrollUp(e4)), this._parser.registerCsiHandler({ final: "T" }, (e4) => this.scrollDown(e4)), this._parser.registerCsiHandler({ final: "X" }, (e4) => this.eraseChars(e4)), this._parser.registerCsiHandler({ final: "Z" }, (e4) => this.cursorBackwardTab(e4)), this._parser.registerCsiHandler({ final: "`" }, (e4) => this.charPosAbsolute(e4)), this._parser.registerCsiHandler({ final: "a" }, (e4) => this.hPositionRelative(e4)), this._parser.registerCsiHandler({ final: "b" }, (e4) => this.repeatPrecedingCharacter(e4)), this._parser.registerCsiHandler({ final: "c" }, (e4) => this.sendDeviceAttributesPrimary(e4)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (e4) => this.sendDeviceAttributesSecondary(e4)), this._parser.registerCsiHandler({ final: "d" }, (e4) => this.linePosAbsolute(e4)), this._parser.registerCsiHandler({ final: "e" }, (e4) => this.vPositionRelative(e4)), this._parser.registerCsiHandler({ final: "f" }, (e4) => this.hVPosition(e4)), this._parser.registerCsiHandler({ final: "g" }, (e4) => this.tabClear(e4)), this._parser.registerCsiHandler({ final: "h" }, (e4) => this.setMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (e4) => this.setModePrivate(e4)), this._parser.registerCsiHandler({ final: "l" }, (e4) => this.resetMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (e4) => this.resetModePrivate(e4)), this._parser.registerCsiHandler({ final: "m" }, (e4) => this.charAttributes(e4)), this._parser.registerCsiHandler({ final: "n" }, (e4) => this.deviceStatus(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (e4) => this.deviceStatusPrivate(e4)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (e4) => this.softReset(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (e4) => this.setCursorStyle(e4)), this._parser.registerCsiHandler({ final: "r" }, (e4) => this.setScrollRegion(e4)), this._parser.registerCsiHandler({ final: "s" }, (e4) => this.saveCursor(e4)), this._parser.registerCsiHandler({ final: "t" }, (e4) => this.windowOptions(e4)), this._parser.registerCsiHandler({ final: "u" }, (e4) => this.restoreCursor(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (e4) => this.insertColumns(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (e4) => this.deleteColumns(e4)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (e4) => this.selectProtected(e4)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, true)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, false)), this._parser.setExecuteHandler(n.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n.C1.IND, () => this.index()), this._parser.setExecuteHandler(n.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new p.OscHandler((e4) => (this.setTitle(e4), this.setIconName(e4), true))), this._parser.registerOscHandler(1, new p.OscHandler((e4) => this.setIconName(e4))), this._parser.registerOscHandler(2, new p.OscHandler((e4) => this.setTitle(e4))), this._parser.registerOscHandler(4, new p.OscHandler((e4) => this.setOrReportIndexedColor(e4))), this._parser.registerOscHandler(8, new p.OscHandler((e4) => this.setHyperlink(e4))), this._parser.registerOscHandler(10, new p.OscHandler((e4) => this.setOrReportFgColor(e4))), this._parser.registerOscHandler(11, new p.OscHandler((e4) => this.setOrReportBgColor(e4))), this._parser.registerOscHandler(12, new p.OscHandler((e4) => this.setOrReportCursorColor(e4))), this._parser.registerOscHandler(104, new p.OscHandler((e4) => this.restoreIndexedColor(e4))), this._parser.registerOscHandler(110, new p.OscHandler((e4) => this.restoreFgColor(e4))), this._parser.registerOscHandler(111, new p.OscHandler((e4) => this.restoreBgColor(e4))), this._parser.registerOscHandler(112, new p.OscHandler((e4) => this.restoreCursorColor(e4))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
              for (const e4 in o.CHARSETS)
                this._parser.registerEscHandler({ intermediates: "(", final: e4 }, () => this.selectCharset("(" + e4)), this._parser.registerEscHandler({ intermediates: ")", final: e4 }, () => this.selectCharset(")" + e4)), this._parser.registerEscHandler({ intermediates: "*", final: e4 }, () => this.selectCharset("*" + e4)), this._parser.registerEscHandler({ intermediates: "+", final: e4 }, () => this.selectCharset("+" + e4)), this._parser.registerEscHandler({ intermediates: "-", final: e4 }, () => this.selectCharset("-" + e4)), this._parser.registerEscHandler({ intermediates: ".", final: e4 }, () => this.selectCharset("." + e4)), this._parser.registerEscHandler({ intermediates: "/", final: e4 }, () => this.selectCharset("/" + e4));
              this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((e4) => (this._logService.error("Parsing error: ", e4), e4)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new g.DcsHandler((e4, t4) => this.requestStatusString(e4, t4)));
            }
            _preserveStack(e3, t3, i3, s3) {
              this._parseStack.paused = true, this._parseStack.cursorStartX = e3, this._parseStack.cursorStartY = t3, this._parseStack.decodedLength = i3, this._parseStack.position = s3;
            }
            _logSlowResolvingAsync(e3) {
              this._logService.logLevel <= v.LogLevelEnum.WARN && Promise.race([e3, new Promise((e4, t3) => setTimeout(() => t3("#SLOW_TIMEOUT"), 5e3))]).catch((e4) => {
                if ("#SLOW_TIMEOUT" !== e4)
                  throw e4;
                console.warn("async parser handler taking longer than 5000 ms");
              });
            }
            _getCurrentLinkId() {
              return this._curAttrData.extended.urlId;
            }
            parse(e3, t3) {
              let i3, s3 = this._activeBuffer.x, r2 = this._activeBuffer.y, n2 = 0;
              const o2 = this._parseStack.paused;
              if (o2) {
                if (i3 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t3))
                  return this._logSlowResolvingAsync(i3), i3;
                s3 = this._parseStack.cursorStartX, r2 = this._parseStack.cursorStartY, this._parseStack.paused = false, e3.length > C && (n2 = this._parseStack.position + C);
              }
              if (this._logService.logLevel <= v.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + ("string" == typeof e3 ? ` "${e3}"` : ` "${Array.prototype.map.call(e3, (e4) => String.fromCharCode(e4)).join("")}"`), "string" == typeof e3 ? e3.split("").map((e4) => e4.charCodeAt(0)) : e3), this._parseBuffer.length < e3.length && this._parseBuffer.length < C && (this._parseBuffer = new Uint32Array(Math.min(e3.length, C))), o2 || this._dirtyRowTracker.clearRange(), e3.length > C)
                for (let t4 = n2; t4 < e3.length; t4 += C) {
                  const n3 = t4 + C < e3.length ? t4 + C : e3.length, o3 = "string" == typeof e3 ? this._stringDecoder.decode(e3.substring(t4, n3), this._parseBuffer) : this._utf8Decoder.decode(e3.subarray(t4, n3), this._parseBuffer);
                  if (i3 = this._parser.parse(this._parseBuffer, o3))
                    return this._preserveStack(s3, r2, o3, t4), this._logSlowResolvingAsync(i3), i3;
                }
              else if (!o2) {
                const t4 = "string" == typeof e3 ? this._stringDecoder.decode(e3, this._parseBuffer) : this._utf8Decoder.decode(e3, this._parseBuffer);
                if (i3 = this._parser.parse(this._parseBuffer, t4))
                  return this._preserveStack(s3, r2, t4, 0), this._logSlowResolvingAsync(i3), i3;
              }
              this._activeBuffer.x === s3 && this._activeBuffer.y === r2 || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
            }
            print(e3, t3, i3) {
              let s3, r2;
              const n2 = this._charsetService.charset, o2 = this._optionsService.rawOptions.screenReaderMode, a2 = this._bufferService.cols, h2 = this._coreService.decPrivateModes.wraparound, l2 = this._coreService.modes.insertMode, d2 = this._curAttrData;
              let u2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i3 - t3 > 0 && 2 === u2.getWidth(this._activeBuffer.x - 1) && u2.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, d2.fg, d2.bg, d2.extended);
              for (let f2 = t3; f2 < i3; ++f2) {
                if (s3 = e3[f2], r2 = this._unicodeService.wcwidth(s3), s3 < 127 && n2) {
                  const e4 = n2[String.fromCharCode(s3)];
                  e4 && (s3 = e4.charCodeAt(0));
                }
                if (o2 && this._onA11yChar.fire((0, c.stringFromCodePoint)(s3)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), r2 || !this._activeBuffer.x) {
                  if (this._activeBuffer.x + r2 - 1 >= a2) {
                    if (h2) {
                      for (; this._activeBuffer.x < a2; )
                        u2.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, d2.fg, d2.bg, d2.extended);
                      this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), u2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                    } else if (this._activeBuffer.x = a2 - 1, 2 === r2)
                      continue;
                  }
                  if (l2 && (u2.insertCells(this._activeBuffer.x, r2, this._activeBuffer.getNullCell(d2), d2), 2 === u2.getWidth(a2 - 1) && u2.setCellFromCodePoint(a2 - 1, _.NULL_CELL_CODE, _.NULL_CELL_WIDTH, d2.fg, d2.bg, d2.extended)), u2.setCellFromCodePoint(this._activeBuffer.x++, s3, r2, d2.fg, d2.bg, d2.extended), r2 > 0)
                    for (; --r2; )
                      u2.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, d2.fg, d2.bg, d2.extended);
                } else
                  u2.getWidth(this._activeBuffer.x - 1) ? u2.addCodepointToCell(this._activeBuffer.x - 1, s3) : u2.addCodepointToCell(this._activeBuffer.x - 2, s3);
              }
              i3 - t3 > 0 && (u2.loadCell(this._activeBuffer.x - 1, this._workCell), 2 === this._workCell.getWidth() || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < a2 && i3 - t3 > 0 && 0 === u2.getWidth(this._activeBuffer.x) && !u2.hasContent(this._activeBuffer.x) && u2.setCellFromCodePoint(this._activeBuffer.x, 0, 1, d2.fg, d2.bg, d2.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            registerCsiHandler(e3, t3) {
              return "t" !== e3.final || e3.prefix || e3.intermediates ? this._parser.registerCsiHandler(e3, t3) : this._parser.registerCsiHandler(e3, (e4) => !b(e4.params[0], this._optionsService.rawOptions.windowOptions) || t3(e4));
            }
            registerDcsHandler(e3, t3) {
              return this._parser.registerDcsHandler(e3, new g.DcsHandler(t3));
            }
            registerEscHandler(e3, t3) {
              return this._parser.registerEscHandler(e3, t3);
            }
            registerOscHandler(e3, t3) {
              return this._parser.registerOscHandler(e3, new p.OscHandler(t3));
            }
            bell() {
              return this._onRequestBell.fire(), true;
            }
            lineFeed() {
              return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
            }
            carriageReturn() {
              return this._activeBuffer.x = 0, true;
            }
            backspace() {
              var e3;
              if (!this._coreService.decPrivateModes.reverseWraparound)
                return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
              if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0)
                this._activeBuffer.x--;
              else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (null === (e3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) || void 0 === e3 ? void 0 : e3.isWrapped)) {
                this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
                const e4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                e4.hasWidth(this._activeBuffer.x) && !e4.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
              }
              return this._restrictCursor(), true;
            }
            tab() {
              if (this._activeBuffer.x >= this._bufferService.cols)
                return true;
              const e3 = this._activeBuffer.x;
              return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e3), true;
            }
            shiftOut() {
              return this._charsetService.setgLevel(1), true;
            }
            shiftIn() {
              return this._charsetService.setgLevel(0), true;
            }
            _restrictCursor(e3 = this._bufferService.cols - 1) {
              this._activeBuffer.x = Math.min(e3, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            _setCursor(e3, t3) {
              this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e3, this._activeBuffer.y = this._activeBuffer.scrollTop + t3) : (this._activeBuffer.x = e3, this._activeBuffer.y = t3), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            _moveCursor(e3, t3) {
              this._restrictCursor(), this._setCursor(this._activeBuffer.x + e3, this._activeBuffer.y + t3);
            }
            cursorUp(e3) {
              const t3 = this._activeBuffer.y - this._activeBuffer.scrollTop;
              return t3 >= 0 ? this._moveCursor(0, -Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, -(e3.params[0] || 1)), true;
            }
            cursorDown(e3) {
              const t3 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
              return t3 >= 0 ? this._moveCursor(0, Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, e3.params[0] || 1), true;
            }
            cursorForward(e3) {
              return this._moveCursor(e3.params[0] || 1, 0), true;
            }
            cursorBackward(e3) {
              return this._moveCursor(-(e3.params[0] || 1), 0), true;
            }
            cursorNextLine(e3) {
              return this.cursorDown(e3), this._activeBuffer.x = 0, true;
            }
            cursorPrecedingLine(e3) {
              return this.cursorUp(e3), this._activeBuffer.x = 0, true;
            }
            cursorCharAbsolute(e3) {
              return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
            }
            cursorPosition(e3) {
              return this._setCursor(e3.length >= 2 ? (e3.params[1] || 1) - 1 : 0, (e3.params[0] || 1) - 1), true;
            }
            charPosAbsolute(e3) {
              return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
            }
            hPositionRelative(e3) {
              return this._moveCursor(e3.params[0] || 1, 0), true;
            }
            linePosAbsolute(e3) {
              return this._setCursor(this._activeBuffer.x, (e3.params[0] || 1) - 1), true;
            }
            vPositionRelative(e3) {
              return this._moveCursor(0, e3.params[0] || 1), true;
            }
            hVPosition(e3) {
              return this.cursorPosition(e3), true;
            }
            tabClear(e3) {
              const t3 = e3.params[0];
              return 0 === t3 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t3 && (this._activeBuffer.tabs = {}), true;
            }
            cursorForwardTab(e3) {
              if (this._activeBuffer.x >= this._bufferService.cols)
                return true;
              let t3 = e3.params[0] || 1;
              for (; t3--; )
                this._activeBuffer.x = this._activeBuffer.nextStop();
              return true;
            }
            cursorBackwardTab(e3) {
              if (this._activeBuffer.x >= this._bufferService.cols)
                return true;
              let t3 = e3.params[0] || 1;
              for (; t3--; )
                this._activeBuffer.x = this._activeBuffer.prevStop();
              return true;
            }
            selectProtected(e3) {
              const t3 = e3.params[0];
              return 1 === t3 && (this._curAttrData.bg |= 536870912), 2 !== t3 && 0 !== t3 || (this._curAttrData.bg &= -536870913), true;
            }
            _eraseInBufferLine(e3, t3, i3, s3 = false, r2 = false) {
              const n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
              n2.replaceCells(t3, i3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), r2), s3 && (n2.isWrapped = false);
            }
            _resetBufferLine(e3, t3 = false) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
              i3 && (i3.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t3), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e3), i3.isWrapped = false);
            }
            eraseInDisplay(e3, t3 = false) {
              let i3;
              switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
                case 0:
                  for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3); i3 < this._bufferService.rows; i3++)
                    this._resetBufferLine(i3, t3);
                  this._dirtyRowTracker.markDirty(i3);
                  break;
                case 1:
                  for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3, 0, this._activeBuffer.x + 1, true, t3), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i3 + 1).isWrapped = false); i3--; )
                    this._resetBufferLine(i3, t3);
                  this._dirtyRowTracker.markDirty(0);
                  break;
                case 2:
                  for (i3 = this._bufferService.rows, this._dirtyRowTracker.markDirty(i3 - 1); i3--; )
                    this._resetBufferLine(i3, t3);
                  this._dirtyRowTracker.markDirty(0);
                  break;
                case 3:
                  const e4 = this._activeBuffer.lines.length - this._bufferService.rows;
                  e4 > 0 && (this._activeBuffer.lines.trimStart(e4), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e4, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e4, 0), this._onScroll.fire(0));
              }
              return true;
            }
            eraseInLine(e3, t3 = false) {
              switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
                case 0:
                  this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3);
                  break;
                case 1:
                  this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, t3);
                  break;
                case 2:
                  this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, t3);
              }
              return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
            }
            insertLines(e3) {
              this._restrictCursor();
              let t3 = e3.params[0] || 1;
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const i3 = this._activeBuffer.ybase + this._activeBuffer.y, s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r2 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3 + 1;
              for (; t3--; )
                this._activeBuffer.lines.splice(r2 - 1, 1), this._activeBuffer.lines.splice(i3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
            }
            deleteLines(e3) {
              this._restrictCursor();
              let t3 = e3.params[0] || 1;
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const i3 = this._activeBuffer.ybase + this._activeBuffer.y;
              let s3;
              for (s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s3 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3; t3--; )
                this._activeBuffer.lines.splice(i3, 1), this._activeBuffer.lines.splice(s3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
            }
            insertChars(e3) {
              this._restrictCursor();
              const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t3 && (t3.insertCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            deleteChars(e3) {
              this._restrictCursor();
              const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t3 && (t3.deleteCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            scrollUp(e3) {
              let t3 = e3.params[0] || 1;
              for (; t3--; )
                this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollDown(e3) {
              let t3 = e3.params[0] || 1;
              for (; t3--; )
                this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollLeft(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const t3 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i3.deleteCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollRight(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const t3 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i3.insertCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            insertColumns(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const t3 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i3.insertCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            deleteColumns(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const t3 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i3.deleteCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            eraseChars(e3) {
              this._restrictCursor();
              const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t3 && (t3.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e3.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            repeatPrecedingCharacter(e3) {
              if (!this._parser.precedingCodepoint)
                return true;
              const t3 = e3.params[0] || 1, i3 = new Uint32Array(t3);
              for (let e4 = 0; e4 < t3; ++e4)
                i3[e4] = this._parser.precedingCodepoint;
              return this.print(i3, 0, i3.length), true;
            }
            sendDeviceAttributesPrimary(e3) {
              return e3.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), true;
            }
            sendDeviceAttributesSecondary(e3) {
              return e3.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e3.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), true;
            }
            _is(e3) {
              return 0 === (this._optionsService.rawOptions.termName + "").indexOf(e3);
            }
            setMode(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                switch (e3.params[t3]) {
                  case 4:
                    this._coreService.modes.insertMode = true;
                    break;
                  case 20:
                    this._optionsService.options.convertEol = true;
                }
              return true;
            }
            setModePrivate(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                switch (e3.params[t3]) {
                  case 1:
                    this._coreService.decPrivateModes.applicationCursorKeys = true;
                    break;
                  case 2:
                    this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
                    break;
                  case 3:
                    this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                    break;
                  case 6:
                    this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
                    break;
                  case 7:
                    this._coreService.decPrivateModes.wraparound = true;
                    break;
                  case 12:
                    this._optionsService.options.cursorBlink = true;
                    break;
                  case 45:
                    this._coreService.decPrivateModes.reverseWraparound = true;
                    break;
                  case 66:
                    this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
                    break;
                  case 9:
                    this._coreMouseService.activeProtocol = "X10";
                    break;
                  case 1e3:
                    this._coreMouseService.activeProtocol = "VT200";
                    break;
                  case 1002:
                    this._coreMouseService.activeProtocol = "DRAG";
                    break;
                  case 1003:
                    this._coreMouseService.activeProtocol = "ANY";
                    break;
                  case 1004:
                    this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
                    break;
                  case 1005:
                    this._logService.debug("DECSET 1005 not supported (see #2507)");
                    break;
                  case 1006:
                    this._coreMouseService.activeEncoding = "SGR";
                    break;
                  case 1015:
                    this._logService.debug("DECSET 1015 not supported (see #2507)");
                    break;
                  case 1016:
                    this._coreMouseService.activeEncoding = "SGR_PIXELS";
                    break;
                  case 25:
                    this._coreService.isCursorHidden = false;
                    break;
                  case 1048:
                    this.saveCursor();
                    break;
                  case 1049:
                    this.saveCursor();
                  case 47:
                  case 1047:
                    this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                    break;
                  case 2004:
                    this._coreService.decPrivateModes.bracketedPasteMode = true;
                }
              return true;
            }
            resetMode(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                switch (e3.params[t3]) {
                  case 4:
                    this._coreService.modes.insertMode = false;
                    break;
                  case 20:
                    this._optionsService.options.convertEol = false;
                }
              return true;
            }
            resetModePrivate(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                switch (e3.params[t3]) {
                  case 1:
                    this._coreService.decPrivateModes.applicationCursorKeys = false;
                    break;
                  case 3:
                    this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                    break;
                  case 6:
                    this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
                    break;
                  case 7:
                    this._coreService.decPrivateModes.wraparound = false;
                    break;
                  case 12:
                    this._optionsService.options.cursorBlink = false;
                    break;
                  case 45:
                    this._coreService.decPrivateModes.reverseWraparound = false;
                    break;
                  case 66:
                    this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
                    break;
                  case 9:
                  case 1e3:
                  case 1002:
                  case 1003:
                    this._coreMouseService.activeProtocol = "NONE";
                    break;
                  case 1004:
                    this._coreService.decPrivateModes.sendFocus = false;
                    break;
                  case 1005:
                    this._logService.debug("DECRST 1005 not supported (see #2507)");
                    break;
                  case 1006:
                  case 1016:
                    this._coreMouseService.activeEncoding = "DEFAULT";
                    break;
                  case 1015:
                    this._logService.debug("DECRST 1015 not supported (see #2507)");
                    break;
                  case 25:
                    this._coreService.isCursorHidden = true;
                    break;
                  case 1048:
                    this.restoreCursor();
                    break;
                  case 1049:
                  case 47:
                  case 1047:
                    this._bufferService.buffers.activateNormalBuffer(), 1049 === e3.params[t3] && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                    break;
                  case 2004:
                    this._coreService.decPrivateModes.bracketedPasteMode = false;
                }
              return true;
            }
            requestMode(e3, t3) {
              const i3 = this._coreService.decPrivateModes, { activeProtocol: s3, activeEncoding: r2 } = this._coreMouseService, o2 = this._coreService, { buffers: a2, cols: h2 } = this._bufferService, { active: c2, alt: l2 } = a2, d2 = this._optionsService.rawOptions, _2 = (e4) => e4 ? 1 : 2, u2 = e3.params[0];
              return f2 = u2, v2 = t3 ? 2 === u2 ? 4 : 4 === u2 ? _2(o2.modes.insertMode) : 12 === u2 ? 3 : 20 === u2 ? _2(d2.convertEol) : 0 : 1 === u2 ? _2(i3.applicationCursorKeys) : 3 === u2 ? d2.windowOptions.setWinLines ? 80 === h2 ? 2 : 132 === h2 ? 1 : 0 : 0 : 6 === u2 ? _2(i3.origin) : 7 === u2 ? _2(i3.wraparound) : 8 === u2 ? 3 : 9 === u2 ? _2("X10" === s3) : 12 === u2 ? _2(d2.cursorBlink) : 25 === u2 ? _2(!o2.isCursorHidden) : 45 === u2 ? _2(i3.reverseWraparound) : 66 === u2 ? _2(i3.applicationKeypad) : 67 === u2 ? 4 : 1e3 === u2 ? _2("VT200" === s3) : 1002 === u2 ? _2("DRAG" === s3) : 1003 === u2 ? _2("ANY" === s3) : 1004 === u2 ? _2(i3.sendFocus) : 1005 === u2 ? 4 : 1006 === u2 ? _2("SGR" === r2) : 1015 === u2 ? 4 : 1016 === u2 ? _2("SGR_PIXELS" === r2) : 1048 === u2 ? 1 : 47 === u2 || 1047 === u2 || 1049 === u2 ? _2(c2 === l2) : 2004 === u2 ? _2(i3.bracketedPasteMode) : 0, o2.triggerDataEvent(`${n.C0.ESC}[${t3 ? "" : "?"}${f2};${v2}$y`), true;
              var f2, v2;
            }
            _updateAttrColor(e3, t3, i3, s3, r2) {
              return 2 === t3 ? (e3 |= 50331648, e3 &= -16777216, e3 |= f.AttributeData.fromColorRGB([i3, s3, r2])) : 5 === t3 && (e3 &= -50331904, e3 |= 33554432 | 255 & i3), e3;
            }
            _extractColor(e3, t3, i3) {
              const s3 = [0, 0, -1, 0, 0, 0];
              let r2 = 0, n2 = 0;
              do {
                if (s3[n2 + r2] = e3.params[t3 + n2], e3.hasSubParams(t3 + n2)) {
                  const i4 = e3.getSubParams(t3 + n2);
                  let o2 = 0;
                  do {
                    5 === s3[1] && (r2 = 1), s3[n2 + o2 + 1 + r2] = i4[o2];
                  } while (++o2 < i4.length && o2 + n2 + 1 + r2 < s3.length);
                  break;
                }
                if (5 === s3[1] && n2 + r2 >= 2 || 2 === s3[1] && n2 + r2 >= 5)
                  break;
                s3[1] && (r2 = 1);
              } while (++n2 + t3 < e3.length && n2 + r2 < s3.length);
              for (let e4 = 2; e4 < s3.length; ++e4)
                -1 === s3[e4] && (s3[e4] = 0);
              switch (s3[0]) {
                case 38:
                  i3.fg = this._updateAttrColor(i3.fg, s3[1], s3[3], s3[4], s3[5]);
                  break;
                case 48:
                  i3.bg = this._updateAttrColor(i3.bg, s3[1], s3[3], s3[4], s3[5]);
                  break;
                case 58:
                  i3.extended = i3.extended.clone(), i3.extended.underlineColor = this._updateAttrColor(i3.extended.underlineColor, s3[1], s3[3], s3[4], s3[5]);
              }
              return n2;
            }
            _processUnderline(e3, t3) {
              t3.extended = t3.extended.clone(), (!~e3 || e3 > 5) && (e3 = 1), t3.extended.underlineStyle = e3, t3.fg |= 268435456, 0 === e3 && (t3.fg &= -268435457), t3.updateExtended();
            }
            _processSGR0(e3) {
              e3.fg = l.DEFAULT_ATTR_DATA.fg, e3.bg = l.DEFAULT_ATTR_DATA.bg, e3.extended = e3.extended.clone(), e3.extended.underlineStyle = 0, e3.extended.underlineColor &= -67108864, e3.updateExtended();
            }
            charAttributes(e3) {
              if (1 === e3.length && 0 === e3.params[0])
                return this._processSGR0(this._curAttrData), true;
              const t3 = e3.length;
              let i3;
              const s3 = this._curAttrData;
              for (let r2 = 0; r2 < t3; r2++)
                i3 = e3.params[r2], i3 >= 30 && i3 <= 37 ? (s3.fg &= -50331904, s3.fg |= 16777216 | i3 - 30) : i3 >= 40 && i3 <= 47 ? (s3.bg &= -50331904, s3.bg |= 16777216 | i3 - 40) : i3 >= 90 && i3 <= 97 ? (s3.fg &= -50331904, s3.fg |= 16777224 | i3 - 90) : i3 >= 100 && i3 <= 107 ? (s3.bg &= -50331904, s3.bg |= 16777224 | i3 - 100) : 0 === i3 ? this._processSGR0(s3) : 1 === i3 ? s3.fg |= 134217728 : 3 === i3 ? s3.bg |= 67108864 : 4 === i3 ? (s3.fg |= 268435456, this._processUnderline(e3.hasSubParams(r2) ? e3.getSubParams(r2)[0] : 1, s3)) : 5 === i3 ? s3.fg |= 536870912 : 7 === i3 ? s3.fg |= 67108864 : 8 === i3 ? s3.fg |= 1073741824 : 9 === i3 ? s3.fg |= 2147483648 : 2 === i3 ? s3.bg |= 134217728 : 21 === i3 ? this._processUnderline(2, s3) : 22 === i3 ? (s3.fg &= -134217729, s3.bg &= -134217729) : 23 === i3 ? s3.bg &= -67108865 : 24 === i3 ? (s3.fg &= -268435457, this._processUnderline(0, s3)) : 25 === i3 ? s3.fg &= -536870913 : 27 === i3 ? s3.fg &= -67108865 : 28 === i3 ? s3.fg &= -1073741825 : 29 === i3 ? s3.fg &= 2147483647 : 39 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : 49 === i3 ? (s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : 38 === i3 || 48 === i3 || 58 === i3 ? r2 += this._extractColor(e3, r2, s3) : 53 === i3 ? s3.bg |= 1073741824 : 55 === i3 ? s3.bg &= -1073741825 : 59 === i3 ? (s3.extended = s3.extended.clone(), s3.extended.underlineColor = -1, s3.updateExtended()) : 100 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i3);
              return true;
            }
            deviceStatus(e3) {
              switch (e3.params[0]) {
                case 5:
                  this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
                  break;
                case 6:
                  const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
                  this._coreService.triggerDataEvent(`${n.C0.ESC}[${e4};${t3}R`);
              }
              return true;
            }
            deviceStatusPrivate(e3) {
              if (6 === e3.params[0]) {
                const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${n.C0.ESC}[?${e4};${t3}R`);
              }
              return true;
            }
            softReset(e3) {
              return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
            }
            setCursorStyle(e3) {
              const t3 = e3.params[0] || 1;
              switch (t3) {
                case 1:
                case 2:
                  this._optionsService.options.cursorStyle = "block";
                  break;
                case 3:
                case 4:
                  this._optionsService.options.cursorStyle = "underline";
                  break;
                case 5:
                case 6:
                  this._optionsService.options.cursorStyle = "bar";
              }
              const i3 = t3 % 2 == 1;
              return this._optionsService.options.cursorBlink = i3, true;
            }
            setScrollRegion(e3) {
              const t3 = e3.params[0] || 1;
              let i3;
              return (e3.length < 2 || (i3 = e3.params[1]) > this._bufferService.rows || 0 === i3) && (i3 = this._bufferService.rows), i3 > t3 && (this._activeBuffer.scrollTop = t3 - 1, this._activeBuffer.scrollBottom = i3 - 1, this._setCursor(0, 0)), true;
            }
            windowOptions(e3) {
              if (!b(e3.params[0], this._optionsService.rawOptions.windowOptions))
                return true;
              const t3 = e3.length > 1 ? e3.params[1] : 0;
              switch (e3.params[0]) {
                case 14:
                  2 !== t3 && this._onRequestWindowsOptionsReport.fire(y.GET_WIN_SIZE_PIXELS);
                  break;
                case 16:
                  this._onRequestWindowsOptionsReport.fire(y.GET_CELL_SIZE_PIXELS);
                  break;
                case 18:
                  this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                  break;
                case 22:
                  0 !== t3 && 2 !== t3 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t3 && 1 !== t3 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                  break;
                case 23:
                  0 !== t3 && 2 !== t3 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t3 && 1 !== t3 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
              }
              return true;
            }
            saveCursor(e3) {
              return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
            }
            restoreCursor(e3) {
              return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
            }
            setTitle(e3) {
              return this._windowTitle = e3, this._onTitleChange.fire(e3), true;
            }
            setIconName(e3) {
              return this._iconName = e3, true;
            }
            setOrReportIndexedColor(e3) {
              const t3 = [], i3 = e3.split(";");
              for (; i3.length > 1; ) {
                const e4 = i3.shift(), s3 = i3.shift();
                if (/^\d+$/.exec(e4)) {
                  const i4 = parseInt(e4);
                  if (L(i4))
                    if ("?" === s3)
                      t3.push({ type: 0, index: i4 });
                    else {
                      const e5 = (0, m.parseColor)(s3);
                      e5 && t3.push({ type: 1, index: i4, color: e5 });
                    }
                }
              }
              return t3.length && this._onColor.fire(t3), true;
            }
            setHyperlink(e3) {
              const t3 = e3.split(";");
              return !(t3.length < 2) && (t3[1] ? this._createHyperlink(t3[0], t3[1]) : !t3[0] && this._finishHyperlink());
            }
            _createHyperlink(e3, t3) {
              this._getCurrentLinkId() && this._finishHyperlink();
              const i3 = e3.split(":");
              let s3;
              const r2 = i3.findIndex((e4) => e4.startsWith("id="));
              return -1 !== r2 && (s3 = i3[r2].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: s3, uri: t3 }), this._curAttrData.updateExtended(), true;
            }
            _finishHyperlink() {
              return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
            }
            _setOrReportSpecialColor(e3, t3) {
              const i3 = e3.split(";");
              for (let e4 = 0; e4 < i3.length && !(t3 >= this._specialColors.length); ++e4, ++t3)
                if ("?" === i3[e4])
                  this._onColor.fire([{ type: 0, index: this._specialColors[t3] }]);
                else {
                  const s3 = (0, m.parseColor)(i3[e4]);
                  s3 && this._onColor.fire([{ type: 1, index: this._specialColors[t3], color: s3 }]);
                }
              return true;
            }
            setOrReportFgColor(e3) {
              return this._setOrReportSpecialColor(e3, 0);
            }
            setOrReportBgColor(e3) {
              return this._setOrReportSpecialColor(e3, 1);
            }
            setOrReportCursorColor(e3) {
              return this._setOrReportSpecialColor(e3, 2);
            }
            restoreIndexedColor(e3) {
              if (!e3)
                return this._onColor.fire([{ type: 2 }]), true;
              const t3 = [], i3 = e3.split(";");
              for (let e4 = 0; e4 < i3.length; ++e4)
                if (/^\d+$/.exec(i3[e4])) {
                  const s3 = parseInt(i3[e4]);
                  L(s3) && t3.push({ type: 2, index: s3 });
                }
              return t3.length && this._onColor.fire(t3), true;
            }
            restoreFgColor(e3) {
              return this._onColor.fire([{ type: 2, index: 256 }]), true;
            }
            restoreBgColor(e3) {
              return this._onColor.fire([{ type: 2, index: 257 }]), true;
            }
            restoreCursorColor(e3) {
              return this._onColor.fire([{ type: 2, index: 258 }]), true;
            }
            nextLine() {
              return this._activeBuffer.x = 0, this.index(), true;
            }
            keypadApplicationMode() {
              return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
            }
            keypadNumericMode() {
              return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
            }
            selectDefaultCharset() {
              return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), true;
            }
            selectCharset(e3) {
              return 2 !== e3.length ? (this.selectDefaultCharset(), true) : ("/" === e3[0] || this._charsetService.setgCharset(S[e3[0]], o.CHARSETS[e3[1]] || o.DEFAULT_CHARSET), true);
            }
            index() {
              return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
            }
            tabSet() {
              return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
            }
            reverseIndex() {
              if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
                const e3 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
                this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e3, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
              } else
                this._activeBuffer.y--, this._restrictCursor();
              return true;
            }
            fullReset() {
              return this._parser.reset(), this._onRequestReset.fire(), true;
            }
            reset() {
              this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
            }
            _eraseAttrData() {
              return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
            }
            setgLevel(e3) {
              return this._charsetService.setgLevel(e3), true;
            }
            screenAlignmentPattern() {
              const e3 = new u.CellData();
              e3.content = 1 << 22 | "E".charCodeAt(0), e3.fg = this._curAttrData.fg, e3.bg = this._curAttrData.bg, this._setCursor(0, 0);
              for (let t3 = 0; t3 < this._bufferService.rows; ++t3) {
                const i3 = this._activeBuffer.ybase + this._activeBuffer.y + t3, s3 = this._activeBuffer.lines.get(i3);
                s3 && (s3.fill(e3), s3.isWrapped = false);
              }
              return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
            }
            requestStatusString(e3, t3) {
              const i3 = this._bufferService.buffer, s3 = this._optionsService.rawOptions;
              return ((e4) => (this._coreService.triggerDataEvent(`${n.C0.ESC}${e4}${n.C0.ESC}\\`), true))('"q' === e3 ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : '"p' === e3 ? 'P1$r61;1"p' : "r" === e3 ? `P1$r${i3.scrollTop + 1};${i3.scrollBottom + 1}r` : "m" === e3 ? "P1$r0m" : " q" === e3 ? `P1$r${{ block: 2, underline: 4, bar: 6 }[s3.cursorStyle] - (s3.cursorBlink ? 1 : 0)} q` : "P0$r");
            }
            markRangeDirty(e3, t3) {
              this._dirtyRowTracker.markRangeDirty(e3, t3);
            }
          }
          t2.InputHandler = E;
          let k = class {
            constructor(e3) {
              this._bufferService = e3, this.clearRange();
            }
            clearRange() {
              this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
            }
            markDirty(e3) {
              e3 < this.start ? this.start = e3 : e3 > this.end && (this.end = e3);
            }
            markRangeDirty(e3, t3) {
              e3 > t3 && (w = e3, e3 = t3, t3 = w), e3 < this.start && (this.start = e3), t3 > this.end && (this.end = t3);
            }
            markAllDirty() {
              this.markRangeDirty(0, this._bufferService.rows - 1);
            }
          };
          function L(e3) {
            return 0 <= e3 && e3 < 256;
          }
          k = s2([r(0, v.IBufferService)], k);
        }, 844: (e2, t2) => {
          function i2(e3) {
            for (const t3 of e3)
              t3.dispose();
            e3.length = 0;
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getDisposeArrayDisposable = t2.disposeArray = t2.toDisposable = t2.MutableDisposable = t2.Disposable = void 0, t2.Disposable = class {
            constructor() {
              this._disposables = [], this._isDisposed = false;
            }
            dispose() {
              this._isDisposed = true;
              for (const e3 of this._disposables)
                e3.dispose();
              this._disposables.length = 0;
            }
            register(e3) {
              return this._disposables.push(e3), e3;
            }
            unregister(e3) {
              const t3 = this._disposables.indexOf(e3);
              -1 !== t3 && this._disposables.splice(t3, 1);
            }
          }, t2.MutableDisposable = class {
            constructor() {
              this._isDisposed = false;
            }
            get value() {
              return this._isDisposed ? void 0 : this._value;
            }
            set value(e3) {
              var t3;
              this._isDisposed || e3 === this._value || (null === (t3 = this._value) || void 0 === t3 || t3.dispose(), this._value = e3);
            }
            clear() {
              this.value = void 0;
            }
            dispose() {
              var e3;
              this._isDisposed = true, null === (e3 = this._value) || void 0 === e3 || e3.dispose(), this._value = void 0;
            }
          }, t2.toDisposable = function(e3) {
            return { dispose: e3 };
          }, t2.disposeArray = i2, t2.getDisposeArrayDisposable = function(e3) {
            return { dispose: () => i2(e3) };
          };
        }, 1505: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.FourKeyMap = t2.TwoKeyMap = void 0;
          class i2 {
            constructor() {
              this._data = {};
            }
            set(e3, t3, i3) {
              this._data[e3] || (this._data[e3] = {}), this._data[e3][t3] = i3;
            }
            get(e3, t3) {
              return this._data[e3] ? this._data[e3][t3] : void 0;
            }
            clear() {
              this._data = {};
            }
          }
          t2.TwoKeyMap = i2, t2.FourKeyMap = class {
            constructor() {
              this._data = new i2();
            }
            set(e3, t3, s2, r, n) {
              this._data.get(e3, t3) || this._data.set(e3, t3, new i2()), this._data.get(e3, t3).set(s2, r, n);
            }
            get(e3, t3, i3, s2) {
              var r;
              return null === (r = this._data.get(e3, t3)) || void 0 === r ? void 0 : r.get(i3, s2);
            }
            clear() {
              this._data.clear();
            }
          };
        }, 6114: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.isChromeOS = t2.isLinux = t2.isWindows = t2.isIphone = t2.isIpad = t2.isMac = t2.getSafariVersion = t2.isSafari = t2.isLegacyEdge = t2.isFirefox = t2.isNode = void 0, t2.isNode = "undefined" == typeof navigator;
          const i2 = t2.isNode ? "node" : navigator.userAgent, s2 = t2.isNode ? "node" : navigator.platform;
          t2.isFirefox = i2.includes("Firefox"), t2.isLegacyEdge = i2.includes("Edge"), t2.isSafari = /^((?!chrome|android).)*safari/i.test(i2), t2.getSafariVersion = function() {
            if (!t2.isSafari)
              return 0;
            const e3 = i2.match(/Version\/(\d+)/);
            return null === e3 || e3.length < 2 ? 0 : parseInt(e3[1]);
          }, t2.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(s2), t2.isIpad = "iPad" === s2, t2.isIphone = "iPhone" === s2, t2.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(s2), t2.isLinux = s2.indexOf("Linux") >= 0, t2.isChromeOS = /\bCrOS\b/.test(i2);
        }, 6106: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.SortedList = void 0;
          let i2 = 0;
          t2.SortedList = class {
            constructor(e3) {
              this._getKey = e3, this._array = [];
            }
            clear() {
              this._array.length = 0;
            }
            insert(e3) {
              0 !== this._array.length ? (i2 = this._search(this._getKey(e3)), this._array.splice(i2, 0, e3)) : this._array.push(e3);
            }
            delete(e3) {
              if (0 === this._array.length)
                return false;
              const t3 = this._getKey(e3);
              if (void 0 === t3)
                return false;
              if (i2 = this._search(t3), -1 === i2)
                return false;
              if (this._getKey(this._array[i2]) !== t3)
                return false;
              do {
                if (this._array[i2] === e3)
                  return this._array.splice(i2, 1), true;
              } while (++i2 < this._array.length && this._getKey(this._array[i2]) === t3);
              return false;
            }
            *getKeyIterator(e3) {
              if (0 !== this._array.length && (i2 = this._search(e3), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3))
                do {
                  yield this._array[i2];
                } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
            }
            forEachByKey(e3, t3) {
              if (0 !== this._array.length && (i2 = this._search(e3), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3))
                do {
                  t3(this._array[i2]);
                } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
            }
            values() {
              return [...this._array].values();
            }
            _search(e3) {
              let t3 = 0, i3 = this._array.length - 1;
              for (; i3 >= t3; ) {
                let s2 = t3 + i3 >> 1;
                const r = this._getKey(this._array[s2]);
                if (r > e3)
                  i3 = s2 - 1;
                else {
                  if (!(r < e3)) {
                    for (; s2 > 0 && this._getKey(this._array[s2 - 1]) === e3; )
                      s2--;
                    return s2;
                  }
                  t3 = s2 + 1;
                }
              }
              return t3;
            }
          };
        }, 7226: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DebouncedIdleTask = t2.IdleTaskQueue = t2.PriorityTaskQueue = void 0;
          const s2 = i2(6114);
          class r {
            constructor() {
              this._tasks = [], this._i = 0;
            }
            enqueue(e3) {
              this._tasks.push(e3), this._start();
            }
            flush() {
              for (; this._i < this._tasks.length; )
                this._tasks[this._i]() || this._i++;
              this.clear();
            }
            clear() {
              this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
            }
            _start() {
              this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
            }
            _process(e3) {
              this._idleCallback = void 0;
              let t3 = 0, i3 = 0, s3 = e3.timeRemaining(), r2 = 0;
              for (; this._i < this._tasks.length; ) {
                if (t3 = Date.now(), this._tasks[this._i]() || this._i++, t3 = Math.max(1, Date.now() - t3), i3 = Math.max(t3, i3), r2 = e3.timeRemaining(), 1.5 * i3 > r2)
                  return s3 - t3 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t3))}ms`), void this._start();
                s3 = r2;
              }
              this.clear();
            }
          }
          class n extends r {
            _requestCallback(e3) {
              return setTimeout(() => e3(this._createDeadline(16)));
            }
            _cancelCallback(e3) {
              clearTimeout(e3);
            }
            _createDeadline(e3) {
              const t3 = Date.now() + e3;
              return { timeRemaining: () => Math.max(0, t3 - Date.now()) };
            }
          }
          t2.PriorityTaskQueue = n, t2.IdleTaskQueue = !s2.isNode && "requestIdleCallback" in window ? class extends r {
            _requestCallback(e3) {
              return requestIdleCallback(e3);
            }
            _cancelCallback(e3) {
              cancelIdleCallback(e3);
            }
          } : n, t2.DebouncedIdleTask = class {
            constructor() {
              this._queue = new t2.IdleTaskQueue();
            }
            set(e3) {
              this._queue.clear(), this._queue.enqueue(e3);
            }
            flush() {
              this._queue.flush();
            }
          };
        }, 9282: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.updateWindowsModeWrappedState = void 0;
          const s2 = i2(643);
          t2.updateWindowsModeWrappedState = function(e3) {
            const t3 = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y - 1), i3 = null == t3 ? void 0 : t3.get(e3.cols - 1), r = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y);
            r && i3 && (r.isWrapped = i3[s2.CHAR_DATA_CODE_INDEX] !== s2.NULL_CELL_CODE && i3[s2.CHAR_DATA_CODE_INDEX] !== s2.WHITESPACE_CELL_CODE);
          };
        }, 3734: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ExtendedAttrs = t2.AttributeData = void 0;
          class i2 {
            constructor() {
              this.fg = 0, this.bg = 0, this.extended = new s2();
            }
            static toColorRGB(e3) {
              return [e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
            }
            static fromColorRGB(e3) {
              return (255 & e3[0]) << 16 | (255 & e3[1]) << 8 | 255 & e3[2];
            }
            clone() {
              const e3 = new i2();
              return e3.fg = this.fg, e3.bg = this.bg, e3.extended = this.extended.clone(), e3;
            }
            isInverse() {
              return 67108864 & this.fg;
            }
            isBold() {
              return 134217728 & this.fg;
            }
            isUnderline() {
              return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
            }
            isBlink() {
              return 536870912 & this.fg;
            }
            isInvisible() {
              return 1073741824 & this.fg;
            }
            isItalic() {
              return 67108864 & this.bg;
            }
            isDim() {
              return 134217728 & this.bg;
            }
            isStrikethrough() {
              return 2147483648 & this.fg;
            }
            isProtected() {
              return 536870912 & this.bg;
            }
            isOverline() {
              return 1073741824 & this.bg;
            }
            getFgColorMode() {
              return 50331648 & this.fg;
            }
            getBgColorMode() {
              return 50331648 & this.bg;
            }
            isFgRGB() {
              return 50331648 == (50331648 & this.fg);
            }
            isBgRGB() {
              return 50331648 == (50331648 & this.bg);
            }
            isFgPalette() {
              return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
            }
            isBgPalette() {
              return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
            }
            isFgDefault() {
              return 0 == (50331648 & this.fg);
            }
            isBgDefault() {
              return 0 == (50331648 & this.bg);
            }
            isAttributeDefault() {
              return 0 === this.fg && 0 === this.bg;
            }
            getFgColor() {
              switch (50331648 & this.fg) {
                case 16777216:
                case 33554432:
                  return 255 & this.fg;
                case 50331648:
                  return 16777215 & this.fg;
                default:
                  return -1;
              }
            }
            getBgColor() {
              switch (50331648 & this.bg) {
                case 16777216:
                case 33554432:
                  return 255 & this.bg;
                case 50331648:
                  return 16777215 & this.bg;
                default:
                  return -1;
              }
            }
            hasExtendedAttrs() {
              return 268435456 & this.bg;
            }
            updateExtended() {
              this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
            }
            getUnderlineColor() {
              if (268435456 & this.bg && ~this.extended.underlineColor)
                switch (50331648 & this.extended.underlineColor) {
                  case 16777216:
                  case 33554432:
                    return 255 & this.extended.underlineColor;
                  case 50331648:
                    return 16777215 & this.extended.underlineColor;
                  default:
                    return this.getFgColor();
                }
              return this.getFgColor();
            }
            getUnderlineColorMode() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
            }
            isUnderlineColorRGB() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
            }
            isUnderlineColorPalette() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
            }
            isUnderlineColorDefault() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
            }
            getUnderlineStyle() {
              return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
            }
          }
          t2.AttributeData = i2;
          class s2 {
            get ext() {
              return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
            }
            set ext(e3) {
              this._ext = e3;
            }
            get underlineStyle() {
              return this._urlId ? 5 : (469762048 & this._ext) >> 26;
            }
            set underlineStyle(e3) {
              this._ext &= -469762049, this._ext |= e3 << 26 & 469762048;
            }
            get underlineColor() {
              return 67108863 & this._ext;
            }
            set underlineColor(e3) {
              this._ext &= -67108864, this._ext |= 67108863 & e3;
            }
            get urlId() {
              return this._urlId;
            }
            set urlId(e3) {
              this._urlId = e3;
            }
            constructor(e3 = 0, t3 = 0) {
              this._ext = 0, this._urlId = 0, this._ext = e3, this._urlId = t3;
            }
            clone() {
              return new s2(this._ext, this._urlId);
            }
            isEmpty() {
              return 0 === this.underlineStyle && 0 === this._urlId;
            }
          }
          t2.ExtendedAttrs = s2;
        }, 9092: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Buffer = t2.MAX_BUFFER_SIZE = void 0;
          const s2 = i2(6349), r = i2(7226), n = i2(3734), o = i2(8437), a = i2(4634), h = i2(511), c = i2(643), l = i2(4863), d = i2(7116);
          t2.MAX_BUFFER_SIZE = 4294967295, t2.Buffer = class {
            constructor(e3, t3, i3) {
              this._hasScrollback = e3, this._optionsService = t3, this._bufferService = i3, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = o.DEFAULT_ATTR_DATA.clone(), this.savedCharset = d.DEFAULT_CHARSET, this.markers = [], this._nullCell = h.CellData.fromCharData([0, c.NULL_CELL_CHAR, c.NULL_CELL_WIDTH, c.NULL_CELL_CODE]), this._whitespaceCell = h.CellData.fromCharData([0, c.WHITESPACE_CELL_CHAR, c.WHITESPACE_CELL_WIDTH, c.WHITESPACE_CELL_CODE]), this._isClearing = false, this._memoryCleanupQueue = new r.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
            }
            getNullCell(e3) {
              return e3 ? (this._nullCell.fg = e3.fg, this._nullCell.bg = e3.bg, this._nullCell.extended = e3.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs()), this._nullCell;
            }
            getWhitespaceCell(e3) {
              return e3 ? (this._whitespaceCell.fg = e3.fg, this._whitespaceCell.bg = e3.bg, this._whitespaceCell.extended = e3.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs()), this._whitespaceCell;
            }
            getBlankLine(e3, t3) {
              return new o.BufferLine(this._bufferService.cols, this.getNullCell(e3), t3);
            }
            get hasScrollback() {
              return this._hasScrollback && this.lines.maxLength > this._rows;
            }
            get isCursorInViewport() {
              const e3 = this.ybase + this.y - this.ydisp;
              return e3 >= 0 && e3 < this._rows;
            }
            _getCorrectBufferLength(e3) {
              if (!this._hasScrollback)
                return e3;
              const i3 = e3 + this._optionsService.rawOptions.scrollback;
              return i3 > t2.MAX_BUFFER_SIZE ? t2.MAX_BUFFER_SIZE : i3;
            }
            fillViewportRows(e3) {
              if (0 === this.lines.length) {
                void 0 === e3 && (e3 = o.DEFAULT_ATTR_DATA);
                let t3 = this._rows;
                for (; t3--; )
                  this.lines.push(this.getBlankLine(e3));
              }
            }
            clear() {
              this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
            }
            resize(e3, t3) {
              const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
              let s3 = 0;
              const r2 = this._getCorrectBufferLength(t3);
              if (r2 > this.lines.maxLength && (this.lines.maxLength = r2), this.lines.length > 0) {
                if (this._cols < e3)
                  for (let t4 = 0; t4 < this.lines.length; t4++)
                    s3 += +this.lines.get(t4).resize(e3, i3);
                let n2 = 0;
                if (this._rows < t3)
                  for (let s4 = this._rows; s4 < t3; s4++)
                    this.lines.length < t3 + this.ybase && (this._optionsService.rawOptions.windowsMode || void 0 !== this._optionsService.rawOptions.windowsPty.backend || void 0 !== this._optionsService.rawOptions.windowsPty.buildNumber ? this.lines.push(new o.BufferLine(e3, i3)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + n2 + 1 ? (this.ybase--, n2++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new o.BufferLine(e3, i3)));
                else
                  for (let e4 = this._rows; e4 > t3; e4--)
                    this.lines.length > t3 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
                if (r2 < this.lines.maxLength) {
                  const e4 = this.lines.length - r2;
                  e4 > 0 && (this.lines.trimStart(e4), this.ybase = Math.max(this.ybase - e4, 0), this.ydisp = Math.max(this.ydisp - e4, 0), this.savedY = Math.max(this.savedY - e4, 0)), this.lines.maxLength = r2;
                }
                this.x = Math.min(this.x, e3 - 1), this.y = Math.min(this.y, t3 - 1), n2 && (this.y += n2), this.savedX = Math.min(this.savedX, e3 - 1), this.scrollTop = 0;
              }
              if (this.scrollBottom = t3 - 1, this._isReflowEnabled && (this._reflow(e3, t3), this._cols > e3))
                for (let t4 = 0; t4 < this.lines.length; t4++)
                  s3 += +this.lines.get(t4).resize(e3, i3);
              this._cols = e3, this._rows = t3, this._memoryCleanupQueue.clear(), s3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
            }
            _batchedMemoryCleanup() {
              let e3 = true;
              this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e3 = false);
              let t3 = 0;
              for (; this._memoryCleanupPosition < this.lines.length; )
                if (t3 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t3 > 100)
                  return true;
              return e3;
            }
            get _isReflowEnabled() {
              const e3 = this._optionsService.rawOptions.windowsPty;
              return e3 && e3.buildNumber ? this._hasScrollback && "conpty" === e3.backend && e3.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
            }
            _reflow(e3, t3) {
              this._cols !== e3 && (e3 > this._cols ? this._reflowLarger(e3, t3) : this._reflowSmaller(e3, t3));
            }
            _reflowLarger(e3, t3) {
              const i3 = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e3, this.ybase + this.y, this.getNullCell(o.DEFAULT_ATTR_DATA));
              if (i3.length > 0) {
                const s3 = (0, a.reflowLargerCreateNewLayout)(this.lines, i3);
                (0, a.reflowLargerApplyNewLayout)(this.lines, s3.layout), this._reflowLargerAdjustViewport(e3, t3, s3.countRemoved);
              }
            }
            _reflowLargerAdjustViewport(e3, t3, i3) {
              const s3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
              let r2 = i3;
              for (; r2-- > 0; )
                0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t3 && this.lines.push(new o.BufferLine(e3, s3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
              this.savedY = Math.max(this.savedY - i3, 0);
            }
            _reflowSmaller(e3, t3) {
              const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA), s3 = [];
              let r2 = 0;
              for (let n2 = this.lines.length - 1; n2 >= 0; n2--) {
                let h2 = this.lines.get(n2);
                if (!h2 || !h2.isWrapped && h2.getTrimmedLength() <= e3)
                  continue;
                const c2 = [h2];
                for (; h2.isWrapped && n2 > 0; )
                  h2 = this.lines.get(--n2), c2.unshift(h2);
                const l2 = this.ybase + this.y;
                if (l2 >= n2 && l2 < n2 + c2.length)
                  continue;
                const d2 = c2[c2.length - 1].getTrimmedLength(), _ = (0, a.reflowSmallerGetNewLineLengths)(c2, this._cols, e3), u = _.length - c2.length;
                let f;
                f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
                const v = [];
                for (let e4 = 0; e4 < u; e4++) {
                  const e5 = this.getBlankLine(o.DEFAULT_ATTR_DATA, true);
                  v.push(e5);
                }
                v.length > 0 && (s3.push({ start: n2 + c2.length + r2, newLines: v }), r2 += v.length), c2.push(...v);
                let p = _.length - 1, g = _[p];
                0 === g && (p--, g = _[p]);
                let m = c2.length - u - 1, S = d2;
                for (; m >= 0; ) {
                  const e4 = Math.min(S, g);
                  if (void 0 === c2[p])
                    break;
                  if (c2[p].copyCellsFrom(c2[m], S - e4, g - e4, e4, true), g -= e4, 0 === g && (p--, g = _[p]), S -= e4, 0 === S) {
                    m--;
                    const e5 = Math.max(m, 0);
                    S = (0, a.getWrappedLineTrimmedLength)(c2, e5, this._cols);
                  }
                }
                for (let t4 = 0; t4 < c2.length; t4++)
                  _[t4] < e3 && c2[t4].setCell(_[t4], i3);
                let C = u - f;
                for (; C-- > 0; )
                  0 === this.ybase ? this.y < t3 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + r2) - t3 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
                this.savedY = Math.min(this.savedY + u, this.ybase + t3 - 1);
              }
              if (s3.length > 0) {
                const e4 = [], t4 = [];
                for (let e5 = 0; e5 < this.lines.length; e5++)
                  t4.push(this.lines.get(e5));
                const i4 = this.lines.length;
                let n2 = i4 - 1, o2 = 0, a2 = s3[o2];
                this.lines.length = Math.min(this.lines.maxLength, this.lines.length + r2);
                let h2 = 0;
                for (let c3 = Math.min(this.lines.maxLength - 1, i4 + r2 - 1); c3 >= 0; c3--)
                  if (a2 && a2.start > n2 + h2) {
                    for (let e5 = a2.newLines.length - 1; e5 >= 0; e5--)
                      this.lines.set(c3--, a2.newLines[e5]);
                    c3++, e4.push({ index: n2 + 1, amount: a2.newLines.length }), h2 += a2.newLines.length, a2 = s3[++o2];
                  } else
                    this.lines.set(c3, t4[n2--]);
                let c2 = 0;
                for (let t5 = e4.length - 1; t5 >= 0; t5--)
                  e4[t5].index += c2, this.lines.onInsertEmitter.fire(e4[t5]), c2 += e4[t5].amount;
                const l2 = Math.max(0, i4 + r2 - this.lines.maxLength);
                l2 > 0 && this.lines.onTrimEmitter.fire(l2);
              }
            }
            translateBufferLineToString(e3, t3, i3 = 0, s3) {
              const r2 = this.lines.get(e3);
              return r2 ? r2.translateToString(t3, i3, s3) : "";
            }
            getWrappedRangeForLine(e3) {
              let t3 = e3, i3 = e3;
              for (; t3 > 0 && this.lines.get(t3).isWrapped; )
                t3--;
              for (; i3 + 1 < this.lines.length && this.lines.get(i3 + 1).isWrapped; )
                i3++;
              return { first: t3, last: i3 };
            }
            setupTabStops(e3) {
              for (null != e3 ? this.tabs[e3] || (e3 = this.prevStop(e3)) : (this.tabs = {}, e3 = 0); e3 < this._cols; e3 += this._optionsService.rawOptions.tabStopWidth)
                this.tabs[e3] = true;
            }
            prevStop(e3) {
              for (null == e3 && (e3 = this.x); !this.tabs[--e3] && e3 > 0; )
                ;
              return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
            }
            nextStop(e3) {
              for (null == e3 && (e3 = this.x); !this.tabs[++e3] && e3 < this._cols; )
                ;
              return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
            }
            clearMarkers(e3) {
              this._isClearing = true;
              for (let t3 = 0; t3 < this.markers.length; t3++)
                this.markers[t3].line === e3 && (this.markers[t3].dispose(), this.markers.splice(t3--, 1));
              this._isClearing = false;
            }
            clearAllMarkers() {
              this._isClearing = true;
              for (let e3 = 0; e3 < this.markers.length; e3++)
                this.markers[e3].dispose(), this.markers.splice(e3--, 1);
              this._isClearing = false;
            }
            addMarker(e3) {
              const t3 = new l.Marker(e3);
              return this.markers.push(t3), t3.register(this.lines.onTrim((e4) => {
                t3.line -= e4, t3.line < 0 && t3.dispose();
              })), t3.register(this.lines.onInsert((e4) => {
                t3.line >= e4.index && (t3.line += e4.amount);
              })), t3.register(this.lines.onDelete((e4) => {
                t3.line >= e4.index && t3.line < e4.index + e4.amount && t3.dispose(), t3.line > e4.index && (t3.line -= e4.amount);
              })), t3.register(t3.onDispose(() => this._removeMarker(t3))), t3;
            }
            _removeMarker(e3) {
              this._isClearing || this.markers.splice(this.markers.indexOf(e3), 1);
            }
          };
        }, 8437: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLine = t2.DEFAULT_ATTR_DATA = void 0;
          const s2 = i2(3734), r = i2(511), n = i2(643), o = i2(482);
          t2.DEFAULT_ATTR_DATA = Object.freeze(new s2.AttributeData());
          let a = 0;
          class h {
            constructor(e3, t3, i3 = false) {
              this.isWrapped = i3, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e3);
              const s3 = t3 || r.CellData.fromCharData([0, n.NULL_CELL_CHAR, n.NULL_CELL_WIDTH, n.NULL_CELL_CODE]);
              for (let t4 = 0; t4 < e3; ++t4)
                this.setCell(t4, s3);
              this.length = e3;
            }
            get(e3) {
              const t3 = this._data[3 * e3 + 0], i3 = 2097151 & t3;
              return [this._data[3 * e3 + 1], 2097152 & t3 ? this._combined[e3] : i3 ? (0, o.stringFromCodePoint)(i3) : "", t3 >> 22, 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : i3];
            }
            set(e3, t3) {
              this._data[3 * e3 + 1] = t3[n.CHAR_DATA_ATTR_INDEX], t3[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e3] = t3[1], this._data[3 * e3 + 0] = 2097152 | e3 | t3[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e3 + 0] = t3[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t3[n.CHAR_DATA_WIDTH_INDEX] << 22;
            }
            getWidth(e3) {
              return this._data[3 * e3 + 0] >> 22;
            }
            hasWidth(e3) {
              return 12582912 & this._data[3 * e3 + 0];
            }
            getFg(e3) {
              return this._data[3 * e3 + 1];
            }
            getBg(e3) {
              return this._data[3 * e3 + 2];
            }
            hasContent(e3) {
              return 4194303 & this._data[3 * e3 + 0];
            }
            getCodePoint(e3) {
              const t3 = this._data[3 * e3 + 0];
              return 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : 2097151 & t3;
            }
            isCombined(e3) {
              return 2097152 & this._data[3 * e3 + 0];
            }
            getString(e3) {
              const t3 = this._data[3 * e3 + 0];
              return 2097152 & t3 ? this._combined[e3] : 2097151 & t3 ? (0, o.stringFromCodePoint)(2097151 & t3) : "";
            }
            isProtected(e3) {
              return 536870912 & this._data[3 * e3 + 2];
            }
            loadCell(e3, t3) {
              return a = 3 * e3, t3.content = this._data[a + 0], t3.fg = this._data[a + 1], t3.bg = this._data[a + 2], 2097152 & t3.content && (t3.combinedData = this._combined[e3]), 268435456 & t3.bg && (t3.extended = this._extendedAttrs[e3]), t3;
            }
            setCell(e3, t3) {
              2097152 & t3.content && (this._combined[e3] = t3.combinedData), 268435456 & t3.bg && (this._extendedAttrs[e3] = t3.extended), this._data[3 * e3 + 0] = t3.content, this._data[3 * e3 + 1] = t3.fg, this._data[3 * e3 + 2] = t3.bg;
            }
            setCellFromCodePoint(e3, t3, i3, s3, r2, n2) {
              268435456 & r2 && (this._extendedAttrs[e3] = n2), this._data[3 * e3 + 0] = t3 | i3 << 22, this._data[3 * e3 + 1] = s3, this._data[3 * e3 + 2] = r2;
            }
            addCodepointToCell(e3, t3) {
              let i3 = this._data[3 * e3 + 0];
              2097152 & i3 ? this._combined[e3] += (0, o.stringFromCodePoint)(t3) : (2097151 & i3 ? (this._combined[e3] = (0, o.stringFromCodePoint)(2097151 & i3) + (0, o.stringFromCodePoint)(t3), i3 &= -2097152, i3 |= 2097152) : i3 = t3 | 1 << 22, this._data[3 * e3 + 0] = i3);
            }
            insertCells(e3, t3, i3, n2) {
              if ((e3 %= this.length) && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == n2 ? void 0 : n2.fg) || 0, (null == n2 ? void 0 : n2.bg) || 0, (null == n2 ? void 0 : n2.extended) || new s2.ExtendedAttrs()), t3 < this.length - e3) {
                const s3 = new r.CellData();
                for (let i4 = this.length - e3 - t3 - 1; i4 >= 0; --i4)
                  this.setCell(e3 + t3 + i4, this.loadCell(e3 + i4, s3));
                for (let s4 = 0; s4 < t3; ++s4)
                  this.setCell(e3 + s4, i3);
              } else
                for (let t4 = e3; t4 < this.length; ++t4)
                  this.setCell(t4, i3);
              2 === this.getWidth(this.length - 1) && this.setCellFromCodePoint(this.length - 1, 0, 1, (null == n2 ? void 0 : n2.fg) || 0, (null == n2 ? void 0 : n2.bg) || 0, (null == n2 ? void 0 : n2.extended) || new s2.ExtendedAttrs());
            }
            deleteCells(e3, t3, i3, n2) {
              if (e3 %= this.length, t3 < this.length - e3) {
                const s3 = new r.CellData();
                for (let i4 = 0; i4 < this.length - e3 - t3; ++i4)
                  this.setCell(e3 + i4, this.loadCell(e3 + t3 + i4, s3));
                for (let e4 = this.length - t3; e4 < this.length; ++e4)
                  this.setCell(e4, i3);
              } else
                for (let t4 = e3; t4 < this.length; ++t4)
                  this.setCell(t4, i3);
              e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == n2 ? void 0 : n2.fg) || 0, (null == n2 ? void 0 : n2.bg) || 0, (null == n2 ? void 0 : n2.extended) || new s2.ExtendedAttrs()), 0 !== this.getWidth(e3) || this.hasContent(e3) || this.setCellFromCodePoint(e3, 0, 1, (null == n2 ? void 0 : n2.fg) || 0, (null == n2 ? void 0 : n2.bg) || 0, (null == n2 ? void 0 : n2.extended) || new s2.ExtendedAttrs());
            }
            replaceCells(e3, t3, i3, r2, n2 = false) {
              if (n2)
                for (e3 && 2 === this.getWidth(e3 - 1) && !this.isProtected(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == r2 ? void 0 : r2.fg) || 0, (null == r2 ? void 0 : r2.bg) || 0, (null == r2 ? void 0 : r2.extended) || new s2.ExtendedAttrs()), t3 < this.length && 2 === this.getWidth(t3 - 1) && !this.isProtected(t3) && this.setCellFromCodePoint(t3, 0, 1, (null == r2 ? void 0 : r2.fg) || 0, (null == r2 ? void 0 : r2.bg) || 0, (null == r2 ? void 0 : r2.extended) || new s2.ExtendedAttrs()); e3 < t3 && e3 < this.length; )
                  this.isProtected(e3) || this.setCell(e3, i3), e3++;
              else
                for (e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == r2 ? void 0 : r2.fg) || 0, (null == r2 ? void 0 : r2.bg) || 0, (null == r2 ? void 0 : r2.extended) || new s2.ExtendedAttrs()), t3 < this.length && 2 === this.getWidth(t3 - 1) && this.setCellFromCodePoint(t3, 0, 1, (null == r2 ? void 0 : r2.fg) || 0, (null == r2 ? void 0 : r2.bg) || 0, (null == r2 ? void 0 : r2.extended) || new s2.ExtendedAttrs()); e3 < t3 && e3 < this.length; )
                  this.setCell(e3++, i3);
            }
            resize(e3, t3) {
              if (e3 === this.length)
                return 4 * this._data.length * 2 < this._data.buffer.byteLength;
              const i3 = 3 * e3;
              if (e3 > this.length) {
                if (this._data.buffer.byteLength >= 4 * i3)
                  this._data = new Uint32Array(this._data.buffer, 0, i3);
                else {
                  const e4 = new Uint32Array(i3);
                  e4.set(this._data), this._data = e4;
                }
                for (let i4 = this.length; i4 < e3; ++i4)
                  this.setCell(i4, t3);
              } else {
                this._data = this._data.subarray(0, i3);
                const t4 = Object.keys(this._combined);
                for (let i4 = 0; i4 < t4.length; i4++) {
                  const s4 = parseInt(t4[i4], 10);
                  s4 >= e3 && delete this._combined[s4];
                }
                const s3 = Object.keys(this._extendedAttrs);
                for (let t5 = 0; t5 < s3.length; t5++) {
                  const i4 = parseInt(s3[t5], 10);
                  i4 >= e3 && delete this._extendedAttrs[i4];
                }
              }
              return this.length = e3, 4 * i3 * 2 < this._data.buffer.byteLength;
            }
            cleanupMemory() {
              if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
                const e3 = new Uint32Array(this._data.length);
                return e3.set(this._data), this._data = e3, 1;
              }
              return 0;
            }
            fill(e3, t3 = false) {
              if (t3)
                for (let t4 = 0; t4 < this.length; ++t4)
                  this.isProtected(t4) || this.setCell(t4, e3);
              else {
                this._combined = {}, this._extendedAttrs = {};
                for (let t4 = 0; t4 < this.length; ++t4)
                  this.setCell(t4, e3);
              }
            }
            copyFrom(e3) {
              this.length !== e3.length ? this._data = new Uint32Array(e3._data) : this._data.set(e3._data), this.length = e3.length, this._combined = {};
              for (const t3 in e3._combined)
                this._combined[t3] = e3._combined[t3];
              this._extendedAttrs = {};
              for (const t3 in e3._extendedAttrs)
                this._extendedAttrs[t3] = e3._extendedAttrs[t3];
              this.isWrapped = e3.isWrapped;
            }
            clone() {
              const e3 = new h(0);
              e3._data = new Uint32Array(this._data), e3.length = this.length;
              for (const t3 in this._combined)
                e3._combined[t3] = this._combined[t3];
              for (const t3 in this._extendedAttrs)
                e3._extendedAttrs[t3] = this._extendedAttrs[t3];
              return e3.isWrapped = this.isWrapped, e3;
            }
            getTrimmedLength() {
              for (let e3 = this.length - 1; e3 >= 0; --e3)
                if (4194303 & this._data[3 * e3 + 0])
                  return e3 + (this._data[3 * e3 + 0] >> 22);
              return 0;
            }
            getNoBgTrimmedLength() {
              for (let e3 = this.length - 1; e3 >= 0; --e3)
                if (4194303 & this._data[3 * e3 + 0] || 50331648 & this._data[3 * e3 + 2])
                  return e3 + (this._data[3 * e3 + 0] >> 22);
              return 0;
            }
            copyCellsFrom(e3, t3, i3, s3, r2) {
              const n2 = e3._data;
              if (r2)
                for (let r3 = s3 - 1; r3 >= 0; r3--) {
                  for (let e4 = 0; e4 < 3; e4++)
                    this._data[3 * (i3 + r3) + e4] = n2[3 * (t3 + r3) + e4];
                  268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
                }
              else
                for (let r3 = 0; r3 < s3; r3++) {
                  for (let e4 = 0; e4 < 3; e4++)
                    this._data[3 * (i3 + r3) + e4] = n2[3 * (t3 + r3) + e4];
                  268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
                }
              const o2 = Object.keys(e3._combined);
              for (let s4 = 0; s4 < o2.length; s4++) {
                const r3 = parseInt(o2[s4], 10);
                r3 >= t3 && (this._combined[r3 - t3 + i3] = e3._combined[r3]);
              }
            }
            translateToString(e3 = false, t3 = 0, i3 = this.length) {
              e3 && (i3 = Math.min(i3, this.getTrimmedLength()));
              let s3 = "";
              for (; t3 < i3; ) {
                const e4 = this._data[3 * t3 + 0], i4 = 2097151 & e4;
                s3 += 2097152 & e4 ? this._combined[t3] : i4 ? (0, o.stringFromCodePoint)(i4) : n.WHITESPACE_CELL_CHAR, t3 += e4 >> 22 || 1;
              }
              return s3;
            }
          }
          t2.BufferLine = h;
        }, 4841: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getRangeLength = void 0, t2.getRangeLength = function(e3, t3) {
            if (e3.start.y > e3.end.y)
              throw new Error(`Buffer range end (${e3.end.x}, ${e3.end.y}) cannot be before start (${e3.start.x}, ${e3.start.y})`);
            return t3 * (e3.end.y - e3.start.y) + (e3.end.x - e3.start.x + 1);
          };
        }, 4634: (e2, t2) => {
          function i2(e3, t3, i3) {
            if (t3 === e3.length - 1)
              return e3[t3].getTrimmedLength();
            const s2 = !e3[t3].hasContent(i3 - 1) && 1 === e3[t3].getWidth(i3 - 1), r = 2 === e3[t3 + 1].getWidth(0);
            return s2 && r ? i3 - 1 : i3;
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getWrappedLineTrimmedLength = t2.reflowSmallerGetNewLineLengths = t2.reflowLargerApplyNewLayout = t2.reflowLargerCreateNewLayout = t2.reflowLargerGetLinesToRemove = void 0, t2.reflowLargerGetLinesToRemove = function(e3, t3, s2, r, n) {
            const o = [];
            for (let a = 0; a < e3.length - 1; a++) {
              let h = a, c = e3.get(++h);
              if (!c.isWrapped)
                continue;
              const l = [e3.get(a)];
              for (; h < e3.length && c.isWrapped; )
                l.push(c), c = e3.get(++h);
              if (r >= a && r < h) {
                a += l.length - 1;
                continue;
              }
              let d = 0, _ = i2(l, d, t3), u = 1, f = 0;
              for (; u < l.length; ) {
                const e4 = i2(l, u, t3), r2 = e4 - f, o2 = s2 - _, a2 = Math.min(r2, o2);
                l[d].copyCellsFrom(l[u], f, _, a2, false), _ += a2, _ === s2 && (d++, _ = 0), f += a2, f === e4 && (u++, f = 0), 0 === _ && 0 !== d && 2 === l[d - 1].getWidth(s2 - 1) && (l[d].copyCellsFrom(l[d - 1], s2 - 1, _++, 1, false), l[d - 1].setCell(s2 - 1, n));
              }
              l[d].replaceCells(_, s2, n);
              let v = 0;
              for (let e4 = l.length - 1; e4 > 0 && (e4 > d || 0 === l[e4].getTrimmedLength()); e4--)
                v++;
              v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;
            }
            return o;
          }, t2.reflowLargerCreateNewLayout = function(e3, t3) {
            const i3 = [];
            let s2 = 0, r = t3[s2], n = 0;
            for (let o = 0; o < e3.length; o++)
              if (r === o) {
                const i4 = t3[++s2];
                e3.onDeleteEmitter.fire({ index: o - n, amount: i4 }), o += i4 - 1, n += i4, r = t3[++s2];
              } else
                i3.push(o);
            return { layout: i3, countRemoved: n };
          }, t2.reflowLargerApplyNewLayout = function(e3, t3) {
            const i3 = [];
            for (let s2 = 0; s2 < t3.length; s2++)
              i3.push(e3.get(t3[s2]));
            for (let t4 = 0; t4 < i3.length; t4++)
              e3.set(t4, i3[t4]);
            e3.length = t3.length;
          }, t2.reflowSmallerGetNewLineLengths = function(e3, t3, s2) {
            const r = [], n = e3.map((s3, r2) => i2(e3, r2, t3)).reduce((e4, t4) => e4 + t4);
            let o = 0, a = 0, h = 0;
            for (; h < n; ) {
              if (n - h < s2) {
                r.push(n - h);
                break;
              }
              o += s2;
              const c = i2(e3, a, t3);
              o > c && (o -= c, a++);
              const l = 2 === e3[a].getWidth(o - 1);
              l && o--;
              const d = l ? s2 - 1 : s2;
              r.push(d), h += d;
            }
            return r;
          }, t2.getWrappedLineTrimmedLength = i2;
        }, 5295: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferSet = void 0;
          const s2 = i2(8460), r = i2(844), n = i2(9092);
          class o extends r.Disposable {
            constructor(e3, t3) {
              super(), this._optionsService = e3, this._bufferService = t3, this._onBufferActivate = this.register(new s2.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
            }
            reset() {
              this._normal = new n.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
            }
            get alt() {
              return this._alt;
            }
            get active() {
              return this._activeBuffer;
            }
            get normal() {
              return this._normal;
            }
            activateNormalBuffer() {
              this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
            }
            activateAltBuffer(e3) {
              this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e3), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
            }
            resize(e3, t3) {
              this._normal.resize(e3, t3), this._alt.resize(e3, t3), this.setupTabStops(e3);
            }
            setupTabStops(e3) {
              this._normal.setupTabStops(e3), this._alt.setupTabStops(e3);
            }
          }
          t2.BufferSet = o;
        }, 511: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CellData = void 0;
          const s2 = i2(482), r = i2(643), n = i2(3734);
          class o extends n.AttributeData {
            constructor() {
              super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs(), this.combinedData = "";
            }
            static fromCharData(e3) {
              const t3 = new o();
              return t3.setFromCharData(e3), t3;
            }
            isCombined() {
              return 2097152 & this.content;
            }
            getWidth() {
              return this.content >> 22;
            }
            getChars() {
              return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
            }
            getCode() {
              return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
            }
            setFromCharData(e3) {
              this.fg = e3[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
              let t3 = false;
              if (e3[r.CHAR_DATA_CHAR_INDEX].length > 2)
                t3 = true;
              else if (2 === e3[r.CHAR_DATA_CHAR_INDEX].length) {
                const i3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
                if (55296 <= i3 && i3 <= 56319) {
                  const s3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                  56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i3 - 55296) + s3 - 56320 + 65536 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22 : t3 = true;
                } else
                  t3 = true;
              } else
                this.content = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e3[r.CHAR_DATA_WIDTH_INDEX] << 22;
              t3 && (this.combinedData = e3[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22);
            }
            getAsCharData() {
              return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
            }
          }
          t2.CellData = o;
        }, 643: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.WHITESPACE_CELL_CODE = t2.WHITESPACE_CELL_WIDTH = t2.WHITESPACE_CELL_CHAR = t2.NULL_CELL_CODE = t2.NULL_CELL_WIDTH = t2.NULL_CELL_CHAR = t2.CHAR_DATA_CODE_INDEX = t2.CHAR_DATA_WIDTH_INDEX = t2.CHAR_DATA_CHAR_INDEX = t2.CHAR_DATA_ATTR_INDEX = t2.DEFAULT_EXT = t2.DEFAULT_ATTR = t2.DEFAULT_COLOR = void 0, t2.DEFAULT_COLOR = 0, t2.DEFAULT_ATTR = 256 | t2.DEFAULT_COLOR << 9, t2.DEFAULT_EXT = 0, t2.CHAR_DATA_ATTR_INDEX = 0, t2.CHAR_DATA_CHAR_INDEX = 1, t2.CHAR_DATA_WIDTH_INDEX = 2, t2.CHAR_DATA_CODE_INDEX = 3, t2.NULL_CELL_CHAR = "", t2.NULL_CELL_WIDTH = 1, t2.NULL_CELL_CODE = 0, t2.WHITESPACE_CELL_CHAR = " ", t2.WHITESPACE_CELL_WIDTH = 1, t2.WHITESPACE_CELL_CODE = 32;
        }, 4863: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Marker = void 0;
          const s2 = i2(8460), r = i2(844);
          class n {
            get id() {
              return this._id;
            }
            constructor(e3) {
              this.line = e3, this.isDisposed = false, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new s2.EventEmitter()), this.onDispose = this._onDispose.event;
            }
            dispose() {
              this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
            }
            register(e3) {
              return this._disposables.push(e3), e3;
            }
          }
          t2.Marker = n, n._nextId = 1;
        }, 7116: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_CHARSET = t2.CHARSETS = void 0, t2.CHARSETS = {}, t2.DEFAULT_CHARSET = t2.CHARSETS.B, t2.CHARSETS[0] = { "`": "\u25C6", a: "\u2592", b: "\u2409", c: "\u240C", d: "\u240D", e: "\u240A", f: "\xB0", g: "\xB1", h: "\u2424", i: "\u240B", j: "\u2518", k: "\u2510", l: "\u250C", m: "\u2514", n: "\u253C", o: "\u23BA", p: "\u23BB", q: "\u2500", r: "\u23BC", s: "\u23BD", t: "\u251C", u: "\u2524", v: "\u2534", w: "\u252C", x: "\u2502", y: "\u2264", z: "\u2265", "{": "\u03C0", "|": "\u2260", "}": "\xA3", "~": "\xB7" }, t2.CHARSETS.A = { "#": "\xA3" }, t2.CHARSETS.B = void 0, t2.CHARSETS[4] = { "#": "\xA3", "@": "\xBE", "[": "ij", "\\": "\xBD", "]": "|", "{": "\xA8", "|": "f", "}": "\xBC", "~": "\xB4" }, t2.CHARSETS.C = t2.CHARSETS[5] = { "[": "\xC4", "\\": "\xD6", "]": "\xC5", "^": "\xDC", "`": "\xE9", "{": "\xE4", "|": "\xF6", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS.R = { "#": "\xA3", "@": "\xE0", "[": "\xB0", "\\": "\xE7", "]": "\xA7", "{": "\xE9", "|": "\xF9", "}": "\xE8", "~": "\xA8" }, t2.CHARSETS.Q = { "@": "\xE0", "[": "\xE2", "\\": "\xE7", "]": "\xEA", "^": "\xEE", "`": "\xF4", "{": "\xE9", "|": "\xF9", "}": "\xE8", "~": "\xFB" }, t2.CHARSETS.K = { "@": "\xA7", "[": "\xC4", "\\": "\xD6", "]": "\xDC", "{": "\xE4", "|": "\xF6", "}": "\xFC", "~": "\xDF" }, t2.CHARSETS.Y = { "#": "\xA3", "@": "\xA7", "[": "\xB0", "\\": "\xE7", "]": "\xE9", "`": "\xF9", "{": "\xE0", "|": "\xF2", "}": "\xE8", "~": "\xEC" }, t2.CHARSETS.E = t2.CHARSETS[6] = { "@": "\xC4", "[": "\xC6", "\\": "\xD8", "]": "\xC5", "^": "\xDC", "`": "\xE4", "{": "\xE6", "|": "\xF8", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS.Z = { "#": "\xA3", "@": "\xA7", "[": "\xA1", "\\": "\xD1", "]": "\xBF", "{": "\xB0", "|": "\xF1", "}": "\xE7" }, t2.CHARSETS.H = t2.CHARSETS[7] = { "@": "\xC9", "[": "\xC4", "\\": "\xD6", "]": "\xC5", "^": "\xDC", "`": "\xE9", "{": "\xE4", "|": "\xF6", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS["="] = { "#": "\xF9", "@": "\xE0", "[": "\xE9", "\\": "\xE7", "]": "\xEA", "^": "\xEE", _: "\xE8", "`": "\xF4", "{": "\xE4", "|": "\xF6", "}": "\xFC", "~": "\xFB" };
        }, 2584: (e2, t2) => {
          var i2, s2, r;
          Object.defineProperty(t2, "__esModule", { value: true }), t2.C1_ESCAPED = t2.C1 = t2.C0 = void 0, function(e3) {
            e3.NUL = "\0", e3.SOH = "", e3.STX = "", e3.ETX = "", e3.EOT = "", e3.ENQ = "", e3.ACK = "", e3.BEL = "\x07", e3.BS = "\b", e3.HT = "	", e3.LF = "\n", e3.VT = "\v", e3.FF = "\f", e3.CR = "\r", e3.SO = "", e3.SI = "", e3.DLE = "", e3.DC1 = "", e3.DC2 = "", e3.DC3 = "", e3.DC4 = "", e3.NAK = "", e3.SYN = "", e3.ETB = "", e3.CAN = "", e3.EM = "", e3.SUB = "", e3.ESC = "\x1B", e3.FS = "", e3.GS = "", e3.RS = "", e3.US = "", e3.SP = " ", e3.DEL = "\x7F";
          }(i2 || (t2.C0 = i2 = {})), function(e3) {
            e3.PAD = "\x80", e3.HOP = "\x81", e3.BPH = "\x82", e3.NBH = "\x83", e3.IND = "\x84", e3.NEL = "\x85", e3.SSA = "\x86", e3.ESA = "\x87", e3.HTS = "\x88", e3.HTJ = "\x89", e3.VTS = "\x8A", e3.PLD = "\x8B", e3.PLU = "\x8C", e3.RI = "\x8D", e3.SS2 = "\x8E", e3.SS3 = "\x8F", e3.DCS = "\x90", e3.PU1 = "\x91", e3.PU2 = "\x92", e3.STS = "\x93", e3.CCH = "\x94", e3.MW = "\x95", e3.SPA = "\x96", e3.EPA = "\x97", e3.SOS = "\x98", e3.SGCI = "\x99", e3.SCI = "\x9A", e3.CSI = "\x9B", e3.ST = "\x9C", e3.OSC = "\x9D", e3.PM = "\x9E", e3.APC = "\x9F";
          }(s2 || (t2.C1 = s2 = {})), function(e3) {
            e3.ST = `${i2.ESC}\\`;
          }(r || (t2.C1_ESCAPED = r = {}));
        }, 7399: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluateKeyboardEvent = void 0;
          const s2 = i2(2584), r = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
          t2.evaluateKeyboardEvent = function(e3, t3, i3, n) {
            const o = { type: 0, cancel: false, key: void 0 }, a = (e3.shiftKey ? 1 : 0) | (e3.altKey ? 2 : 0) | (e3.ctrlKey ? 4 : 0) | (e3.metaKey ? 8 : 0);
            switch (e3.keyCode) {
              case 0:
                "UIKeyInputUpArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A" : "UIKeyInputLeftArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D" : "UIKeyInputRightArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C" : "UIKeyInputDownArrow" === e3.key && (o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B");
                break;
              case 8:
                if (e3.altKey) {
                  o.key = s2.C0.ESC + s2.C0.DEL;
                  break;
                }
                o.key = s2.C0.DEL;
                break;
              case 9:
                if (e3.shiftKey) {
                  o.key = s2.C0.ESC + "[Z";
                  break;
                }
                o.key = s2.C0.HT, o.cancel = true;
                break;
              case 13:
                o.key = e3.altKey ? s2.C0.ESC + s2.C0.CR : s2.C0.CR, o.cancel = true;
                break;
              case 27:
                o.key = s2.C0.ESC, e3.altKey && (o.key = s2.C0.ESC + s2.C0.ESC), o.cancel = true;
                break;
              case 37:
                if (e3.metaKey)
                  break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "D", o.key === s2.C0.ESC + "[1;3D" && (o.key = s2.C0.ESC + (i3 ? "b" : "[1;5D"))) : o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D";
                break;
              case 39:
                if (e3.metaKey)
                  break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "C", o.key === s2.C0.ESC + "[1;3C" && (o.key = s2.C0.ESC + (i3 ? "f" : "[1;5C"))) : o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C";
                break;
              case 38:
                if (e3.metaKey)
                  break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "A", i3 || o.key !== s2.C0.ESC + "[1;3A" || (o.key = s2.C0.ESC + "[1;5A")) : o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A";
                break;
              case 40:
                if (e3.metaKey)
                  break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "B", i3 || o.key !== s2.C0.ESC + "[1;3B" || (o.key = s2.C0.ESC + "[1;5B")) : o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B";
                break;
              case 45:
                e3.shiftKey || e3.ctrlKey || (o.key = s2.C0.ESC + "[2~");
                break;
              case 46:
                o.key = a ? s2.C0.ESC + "[3;" + (a + 1) + "~" : s2.C0.ESC + "[3~";
                break;
              case 36:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "H" : t3 ? s2.C0.ESC + "OH" : s2.C0.ESC + "[H";
                break;
              case 35:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "F" : t3 ? s2.C0.ESC + "OF" : s2.C0.ESC + "[F";
                break;
              case 33:
                e3.shiftKey ? o.type = 2 : e3.ctrlKey ? o.key = s2.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[5~";
                break;
              case 34:
                e3.shiftKey ? o.type = 3 : e3.ctrlKey ? o.key = s2.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[6~";
                break;
              case 112:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "P" : s2.C0.ESC + "OP";
                break;
              case 113:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "Q" : s2.C0.ESC + "OQ";
                break;
              case 114:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "R" : s2.C0.ESC + "OR";
                break;
              case 115:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "S" : s2.C0.ESC + "OS";
                break;
              case 116:
                o.key = a ? s2.C0.ESC + "[15;" + (a + 1) + "~" : s2.C0.ESC + "[15~";
                break;
              case 117:
                o.key = a ? s2.C0.ESC + "[17;" + (a + 1) + "~" : s2.C0.ESC + "[17~";
                break;
              case 118:
                o.key = a ? s2.C0.ESC + "[18;" + (a + 1) + "~" : s2.C0.ESC + "[18~";
                break;
              case 119:
                o.key = a ? s2.C0.ESC + "[19;" + (a + 1) + "~" : s2.C0.ESC + "[19~";
                break;
              case 120:
                o.key = a ? s2.C0.ESC + "[20;" + (a + 1) + "~" : s2.C0.ESC + "[20~";
                break;
              case 121:
                o.key = a ? s2.C0.ESC + "[21;" + (a + 1) + "~" : s2.C0.ESC + "[21~";
                break;
              case 122:
                o.key = a ? s2.C0.ESC + "[23;" + (a + 1) + "~" : s2.C0.ESC + "[23~";
                break;
              case 123:
                o.key = a ? s2.C0.ESC + "[24;" + (a + 1) + "~" : s2.C0.ESC + "[24~";
                break;
              default:
                if (!e3.ctrlKey || e3.shiftKey || e3.altKey || e3.metaKey)
                  if (i3 && !n || !e3.altKey || e3.metaKey)
                    !i3 || e3.altKey || e3.ctrlKey || e3.shiftKey || !e3.metaKey ? e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && e3.keyCode >= 48 && 1 === e3.key.length ? o.key = e3.key : e3.key && e3.ctrlKey && ("_" === e3.key && (o.key = s2.C0.US), "@" === e3.key && (o.key = s2.C0.NUL)) : 65 === e3.keyCode && (o.type = 1);
                  else {
                    const t4 = r[e3.keyCode], i4 = null == t4 ? void 0 : t4[e3.shiftKey ? 1 : 0];
                    if (i4)
                      o.key = s2.C0.ESC + i4;
                    else if (e3.keyCode >= 65 && e3.keyCode <= 90) {
                      const t5 = e3.ctrlKey ? e3.keyCode - 64 : e3.keyCode + 32;
                      let i5 = String.fromCharCode(t5);
                      e3.shiftKey && (i5 = i5.toUpperCase()), o.key = s2.C0.ESC + i5;
                    } else if (32 === e3.keyCode)
                      o.key = s2.C0.ESC + (e3.ctrlKey ? s2.C0.NUL : " ");
                    else if ("Dead" === e3.key && e3.code.startsWith("Key")) {
                      let t5 = e3.code.slice(3, 4);
                      e3.shiftKey || (t5 = t5.toLowerCase()), o.key = s2.C0.ESC + t5, o.cancel = true;
                    }
                  }
                else
                  e3.keyCode >= 65 && e3.keyCode <= 90 ? o.key = String.fromCharCode(e3.keyCode - 64) : 32 === e3.keyCode ? o.key = s2.C0.NUL : e3.keyCode >= 51 && e3.keyCode <= 55 ? o.key = String.fromCharCode(e3.keyCode - 51 + 27) : 56 === e3.keyCode ? o.key = s2.C0.DEL : 219 === e3.keyCode ? o.key = s2.C0.ESC : 220 === e3.keyCode ? o.key = s2.C0.FS : 221 === e3.keyCode && (o.key = s2.C0.GS);
            }
            return o;
          };
        }, 482: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Utf8ToUtf32 = t2.StringToUtf32 = t2.utf32ToString = t2.stringFromCodePoint = void 0, t2.stringFromCodePoint = function(e3) {
            return e3 > 65535 ? (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10)) + String.fromCharCode(e3 % 1024 + 56320)) : String.fromCharCode(e3);
          }, t2.utf32ToString = function(e3, t3 = 0, i2 = e3.length) {
            let s2 = "";
            for (let r = t3; r < i2; ++r) {
              let t4 = e3[r];
              t4 > 65535 ? (t4 -= 65536, s2 += String.fromCharCode(55296 + (t4 >> 10)) + String.fromCharCode(t4 % 1024 + 56320)) : s2 += String.fromCharCode(t4);
            }
            return s2;
          }, t2.StringToUtf32 = class {
            constructor() {
              this._interim = 0;
            }
            clear() {
              this._interim = 0;
            }
            decode(e3, t3) {
              const i2 = e3.length;
              if (!i2)
                return 0;
              let s2 = 0, r = 0;
              if (this._interim) {
                const i3 = e3.charCodeAt(r++);
                56320 <= i3 && i3 <= 57343 ? t3[s2++] = 1024 * (this._interim - 55296) + i3 - 56320 + 65536 : (t3[s2++] = this._interim, t3[s2++] = i3), this._interim = 0;
              }
              for (let n = r; n < i2; ++n) {
                const r2 = e3.charCodeAt(n);
                if (55296 <= r2 && r2 <= 56319) {
                  if (++n >= i2)
                    return this._interim = r2, s2;
                  const o = e3.charCodeAt(n);
                  56320 <= o && o <= 57343 ? t3[s2++] = 1024 * (r2 - 55296) + o - 56320 + 65536 : (t3[s2++] = r2, t3[s2++] = o);
                } else
                  65279 !== r2 && (t3[s2++] = r2);
              }
              return s2;
            }
          }, t2.Utf8ToUtf32 = class {
            constructor() {
              this.interim = new Uint8Array(3);
            }
            clear() {
              this.interim.fill(0);
            }
            decode(e3, t3) {
              const i2 = e3.length;
              if (!i2)
                return 0;
              let s2, r, n, o, a = 0, h = 0, c = 0;
              if (this.interim[0]) {
                let s3 = false, r2 = this.interim[0];
                r2 &= 192 == (224 & r2) ? 31 : 224 == (240 & r2) ? 15 : 7;
                let n2, o2 = 0;
                for (; (n2 = 63 & this.interim[++o2]) && o2 < 4; )
                  r2 <<= 6, r2 |= n2;
                const h2 = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, l2 = h2 - o2;
                for (; c < l2; ) {
                  if (c >= i2)
                    return 0;
                  if (n2 = e3[c++], 128 != (192 & n2)) {
                    c--, s3 = true;
                    break;
                  }
                  this.interim[o2++] = n2, r2 <<= 6, r2 |= 63 & n2;
                }
                s3 || (2 === h2 ? r2 < 128 ? c-- : t3[a++] = r2 : 3 === h2 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || 65279 === r2 || (t3[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t3[a++] = r2)), this.interim.fill(0);
              }
              const l = i2 - 4;
              let d = c;
              for (; d < i2; ) {
                for (; !(!(d < l) || 128 & (s2 = e3[d]) || 128 & (r = e3[d + 1]) || 128 & (n = e3[d + 2]) || 128 & (o = e3[d + 3])); )
                  t3[a++] = s2, t3[a++] = r, t3[a++] = n, t3[a++] = o, d += 4;
                if (s2 = e3[d++], s2 < 128)
                  t3[a++] = s2;
                else if (192 == (224 & s2)) {
                  if (d >= i2)
                    return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (h = (31 & s2) << 6 | 63 & r, h < 128) {
                    d--;
                    continue;
                  }
                  t3[a++] = h;
                } else if (224 == (240 & s2)) {
                  if (d >= i2)
                    return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (d >= i2)
                    return this.interim[0] = s2, this.interim[1] = r, a;
                  if (n = e3[d++], 128 != (192 & n)) {
                    d--;
                    continue;
                  }
                  if (h = (15 & s2) << 12 | (63 & r) << 6 | 63 & n, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h)
                    continue;
                  t3[a++] = h;
                } else if (240 == (248 & s2)) {
                  if (d >= i2)
                    return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (d >= i2)
                    return this.interim[0] = s2, this.interim[1] = r, a;
                  if (n = e3[d++], 128 != (192 & n)) {
                    d--;
                    continue;
                  }
                  if (d >= i2)
                    return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = n, a;
                  if (o = e3[d++], 128 != (192 & o)) {
                    d--;
                    continue;
                  }
                  if (h = (7 & s2) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h < 65536 || h > 1114111)
                    continue;
                  t3[a++] = h;
                }
              }
              return a;
            }
          };
        }, 225: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeV6 = void 0;
          const i2 = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], s2 = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
          let r;
          t2.UnicodeV6 = class {
            constructor() {
              if (this.version = "6", !r) {
                r = new Uint8Array(65536), r.fill(1), r[0] = 0, r.fill(0, 1, 32), r.fill(0, 127, 160), r.fill(2, 4352, 4448), r[9001] = 2, r[9002] = 2, r.fill(2, 11904, 42192), r[12351] = 1, r.fill(2, 44032, 55204), r.fill(2, 63744, 64256), r.fill(2, 65040, 65050), r.fill(2, 65072, 65136), r.fill(2, 65280, 65377), r.fill(2, 65504, 65511);
                for (let e3 = 0; e3 < i2.length; ++e3)
                  r.fill(0, i2[e3][0], i2[e3][1] + 1);
              }
            }
            wcwidth(e3) {
              return e3 < 32 ? 0 : e3 < 127 ? 1 : e3 < 65536 ? r[e3] : function(e4, t3) {
                let i3, s3 = 0, r2 = t3.length - 1;
                if (e4 < t3[0][0] || e4 > t3[r2][1])
                  return false;
                for (; r2 >= s3; )
                  if (i3 = s3 + r2 >> 1, e4 > t3[i3][1])
                    s3 = i3 + 1;
                  else {
                    if (!(e4 < t3[i3][0]))
                      return true;
                    r2 = i3 - 1;
                  }
                return false;
              }(e3, s2) ? 0 : e3 >= 131072 && e3 <= 196605 || e3 >= 196608 && e3 <= 262141 ? 2 : 1;
            }
          };
        }, 5981: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.WriteBuffer = void 0;
          const s2 = i2(8460), r = i2(844);
          class n extends r.Disposable {
            constructor(e3) {
              super(), this._action = e3, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new s2.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
            }
            handleUserInput() {
              this._didUserInput = true;
            }
            writeSync(e3, t3) {
              if (void 0 !== t3 && this._syncCalls > t3)
                return void (this._syncCalls = 0);
              if (this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting)
                return;
              let i3;
              for (this._isSyncWriting = true; i3 = this._writeBuffer.shift(); ) {
                this._action(i3);
                const e4 = this._callbacks.shift();
                e4 && e4();
              }
              this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
            }
            write(e3, t3) {
              if (this._pendingData > 5e7)
                throw new Error("write data discarded, use flow control to avoid losing data");
              if (!this._writeBuffer.length) {
                if (this._bufferOffset = 0, this._didUserInput)
                  return this._didUserInput = false, this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3), void this._innerWrite();
                setTimeout(() => this._innerWrite());
              }
              this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3);
            }
            _innerWrite(e3 = 0, t3 = true) {
              const i3 = e3 || Date.now();
              for (; this._writeBuffer.length > this._bufferOffset; ) {
                const e4 = this._writeBuffer[this._bufferOffset], s3 = this._action(e4, t3);
                if (s3) {
                  const e5 = (e6) => Date.now() - i3 >= 12 ? setTimeout(() => this._innerWrite(0, e6)) : this._innerWrite(i3, e6);
                  return void s3.catch((e6) => (queueMicrotask(() => {
                    throw e6;
                  }), Promise.resolve(false))).then(e5);
                }
                const r2 = this._callbacks[this._bufferOffset];
                if (r2 && r2(), this._bufferOffset++, this._pendingData -= e4.length, Date.now() - i3 >= 12)
                  break;
              }
              this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
            }
          }
          t2.WriteBuffer = n;
        }, 5941: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.toRgbString = t2.parseColor = void 0;
          const i2 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s2 = /^[\da-f]+$/;
          function r(e3, t3) {
            const i3 = e3.toString(16), s3 = i3.length < 2 ? "0" + i3 : i3;
            switch (t3) {
              case 4:
                return i3[0];
              case 8:
                return s3;
              case 12:
                return (s3 + s3).slice(0, 3);
              default:
                return s3 + s3;
            }
          }
          t2.parseColor = function(e3) {
            if (!e3)
              return;
            let t3 = e3.toLowerCase();
            if (0 === t3.indexOf("rgb:")) {
              t3 = t3.slice(4);
              const e4 = i2.exec(t3);
              if (e4) {
                const t4 = e4[1] ? 15 : e4[4] ? 255 : e4[7] ? 4095 : 65535;
                return [Math.round(parseInt(e4[1] || e4[4] || e4[7] || e4[10], 16) / t4 * 255), Math.round(parseInt(e4[2] || e4[5] || e4[8] || e4[11], 16) / t4 * 255), Math.round(parseInt(e4[3] || e4[6] || e4[9] || e4[12], 16) / t4 * 255)];
              }
            } else if (0 === t3.indexOf("#") && (t3 = t3.slice(1), s2.exec(t3) && [3, 6, 9, 12].includes(t3.length))) {
              const e4 = t3.length / 3, i3 = [0, 0, 0];
              for (let s3 = 0; s3 < 3; ++s3) {
                const r2 = parseInt(t3.slice(e4 * s3, e4 * s3 + e4), 16);
                i3[s3] = 1 === e4 ? r2 << 4 : 2 === e4 ? r2 : 3 === e4 ? r2 >> 4 : r2 >> 8;
              }
              return i3;
            }
          }, t2.toRgbString = function(e3, t3 = 16) {
            const [i3, s3, n] = e3;
            return `rgb:${r(i3, t3)}/${r(s3, t3)}/${r(n, t3)}`;
          };
        }, 5770: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.PAYLOAD_LIMIT = void 0, t2.PAYLOAD_LIMIT = 1e7;
        }, 6351: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DcsHandler = t2.DcsParser = void 0;
          const s2 = i2(482), r = i2(8742), n = i2(5770), o = [];
          t2.DcsParser = class {
            constructor() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {
              }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
            }
            dispose() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._active = o;
            }
            registerHandler(e3, t3) {
              void 0 === this._handlers[e3] && (this._handlers[e3] = []);
              const i3 = this._handlers[e3];
              return i3.push(t3), { dispose: () => {
                const e4 = i3.indexOf(t3);
                -1 !== e4 && i3.splice(e4, 1);
              } };
            }
            clearHandler(e3) {
              this._handlers[e3] && delete this._handlers[e3];
            }
            setHandlerFallback(e3) {
              this._handlerFb = e3;
            }
            reset() {
              if (this._active.length)
                for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3)
                  this._active[e3].unhook(false);
              this._stack.paused = false, this._active = o, this._ident = 0;
            }
            hook(e3, t3) {
              if (this.reset(), this._ident = e3, this._active = this._handlers[e3] || o, this._active.length)
                for (let e4 = this._active.length - 1; e4 >= 0; e4--)
                  this._active[e4].hook(t3);
              else
                this._handlerFb(this._ident, "HOOK", t3);
            }
            put(e3, t3, i3) {
              if (this._active.length)
                for (let s3 = this._active.length - 1; s3 >= 0; s3--)
                  this._active[s3].put(e3, t3, i3);
              else
                this._handlerFb(this._ident, "PUT", (0, s2.utf32ToString)(e3, t3, i3));
            }
            unhook(e3, t3 = true) {
              if (this._active.length) {
                let i3 = false, s3 = this._active.length - 1, r2 = false;
                if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                  for (; s3 >= 0 && (i3 = this._active[s3].unhook(e3), true !== i3); s3--)
                    if (i3 instanceof Promise)
                      return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                  s3--;
                }
                for (; s3 >= 0; s3--)
                  if (i3 = this._active[s3].unhook(false), i3 instanceof Promise)
                    return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
              } else
                this._handlerFb(this._ident, "UNHOOK", e3);
              this._active = o, this._ident = 0;
            }
          };
          const a = new r.Params();
          a.addParam(0), t2.DcsHandler = class {
            constructor(e3) {
              this._handler = e3, this._data = "", this._params = a, this._hitLimit = false;
            }
            hook(e3) {
              this._params = e3.length > 1 || e3.params[0] ? e3.clone() : a, this._data = "", this._hitLimit = false;
            }
            put(e3, t3, i3) {
              this._hitLimit || (this._data += (0, s2.utf32ToString)(e3, t3, i3), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
            }
            unhook(e3) {
              let t3 = false;
              if (this._hitLimit)
                t3 = false;
              else if (e3 && (t3 = this._handler(this._data, this._params), t3 instanceof Promise))
                return t3.then((e4) => (this._params = a, this._data = "", this._hitLimit = false, e4));
              return this._params = a, this._data = "", this._hitLimit = false, t3;
            }
          };
        }, 2015: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.EscapeSequenceParser = t2.VT500_TRANSITION_TABLE = t2.TransitionTable = void 0;
          const s2 = i2(844), r = i2(8742), n = i2(6242), o = i2(6351);
          class a {
            constructor(e3) {
              this.table = new Uint8Array(e3);
            }
            setDefault(e3, t3) {
              this.table.fill(e3 << 4 | t3);
            }
            add(e3, t3, i3, s3) {
              this.table[t3 << 8 | e3] = i3 << 4 | s3;
            }
            addMany(e3, t3, i3, s3) {
              for (let r2 = 0; r2 < e3.length; r2++)
                this.table[t3 << 8 | e3[r2]] = i3 << 4 | s3;
            }
          }
          t2.TransitionTable = a;
          const h = 160;
          t2.VT500_TRANSITION_TABLE = function() {
            const e3 = new a(4095), t3 = Array.apply(null, Array(256)).map((e4, t4) => t4), i3 = (e4, i4) => t3.slice(e4, i4), s3 = i3(32, 127), r2 = i3(0, 24);
            r2.push(25), r2.push.apply(r2, i3(28, 32));
            const n2 = i3(0, 14);
            let o2;
            for (o2 in e3.setDefault(1, 0), e3.addMany(s3, 0, 2, 0), n2)
              e3.addMany([24, 26, 153, 154], o2, 3, 0), e3.addMany(i3(128, 144), o2, 3, 0), e3.addMany(i3(144, 152), o2, 3, 0), e3.add(156, o2, 0, 0), e3.add(27, o2, 11, 1), e3.add(157, o2, 4, 8), e3.addMany([152, 158, 159], o2, 0, 7), e3.add(155, o2, 11, 3), e3.add(144, o2, 11, 9);
            return e3.addMany(r2, 0, 3, 0), e3.addMany(r2, 1, 3, 1), e3.add(127, 1, 0, 1), e3.addMany(r2, 8, 0, 8), e3.addMany(r2, 3, 3, 3), e3.add(127, 3, 0, 3), e3.addMany(r2, 4, 3, 4), e3.add(127, 4, 0, 4), e3.addMany(r2, 6, 3, 6), e3.addMany(r2, 5, 3, 5), e3.add(127, 5, 0, 5), e3.addMany(r2, 2, 3, 2), e3.add(127, 2, 0, 2), e3.add(93, 1, 4, 8), e3.addMany(s3, 8, 5, 8), e3.add(127, 8, 5, 8), e3.addMany([156, 27, 24, 26, 7], 8, 6, 0), e3.addMany(i3(28, 32), 8, 0, 8), e3.addMany([88, 94, 95], 1, 0, 7), e3.addMany(s3, 7, 0, 7), e3.addMany(r2, 7, 0, 7), e3.add(156, 7, 0, 0), e3.add(127, 7, 0, 7), e3.add(91, 1, 11, 3), e3.addMany(i3(64, 127), 3, 7, 0), e3.addMany(i3(48, 60), 3, 8, 4), e3.addMany([60, 61, 62, 63], 3, 9, 4), e3.addMany(i3(48, 60), 4, 8, 4), e3.addMany(i3(64, 127), 4, 7, 0), e3.addMany([60, 61, 62, 63], 4, 0, 6), e3.addMany(i3(32, 64), 6, 0, 6), e3.add(127, 6, 0, 6), e3.addMany(i3(64, 127), 6, 0, 0), e3.addMany(i3(32, 48), 3, 9, 5), e3.addMany(i3(32, 48), 5, 9, 5), e3.addMany(i3(48, 64), 5, 0, 6), e3.addMany(i3(64, 127), 5, 7, 0), e3.addMany(i3(32, 48), 4, 9, 5), e3.addMany(i3(32, 48), 1, 9, 2), e3.addMany(i3(32, 48), 2, 9, 2), e3.addMany(i3(48, 127), 2, 10, 0), e3.addMany(i3(48, 80), 1, 10, 0), e3.addMany(i3(81, 88), 1, 10, 0), e3.addMany([89, 90, 92], 1, 10, 0), e3.addMany(i3(96, 127), 1, 10, 0), e3.add(80, 1, 11, 9), e3.addMany(r2, 9, 0, 9), e3.add(127, 9, 0, 9), e3.addMany(i3(28, 32), 9, 0, 9), e3.addMany(i3(32, 48), 9, 9, 12), e3.addMany(i3(48, 60), 9, 8, 10), e3.addMany([60, 61, 62, 63], 9, 9, 10), e3.addMany(r2, 11, 0, 11), e3.addMany(i3(32, 128), 11, 0, 11), e3.addMany(i3(28, 32), 11, 0, 11), e3.addMany(r2, 10, 0, 10), e3.add(127, 10, 0, 10), e3.addMany(i3(28, 32), 10, 0, 10), e3.addMany(i3(48, 60), 10, 8, 10), e3.addMany([60, 61, 62, 63], 10, 0, 11), e3.addMany(i3(32, 48), 10, 9, 12), e3.addMany(r2, 12, 0, 12), e3.add(127, 12, 0, 12), e3.addMany(i3(28, 32), 12, 0, 12), e3.addMany(i3(32, 48), 12, 9, 12), e3.addMany(i3(48, 64), 12, 0, 11), e3.addMany(i3(64, 127), 12, 12, 13), e3.addMany(i3(64, 127), 10, 12, 13), e3.addMany(i3(64, 127), 9, 12, 13), e3.addMany(r2, 13, 13, 13), e3.addMany(s3, 13, 13, 13), e3.add(127, 13, 0, 13), e3.addMany([27, 156, 24, 26], 13, 14, 0), e3.add(h, 0, 2, 0), e3.add(h, 8, 5, 8), e3.add(h, 6, 0, 6), e3.add(h, 11, 0, 11), e3.add(h, 13, 13, 13), e3;
          }();
          class c extends s2.Disposable {
            constructor(e3 = t2.VT500_TRANSITION_TABLE) {
              super(), this._transitions = e3, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (e4, t3, i3) => {
              }, this._executeHandlerFb = (e4) => {
              }, this._csiHandlerFb = (e4, t3) => {
              }, this._escHandlerFb = (e4) => {
              }, this._errorHandlerFb = (e4) => e4, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, s2.toDisposable)(() => {
                this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
              })), this._oscParser = this.register(new n.OscParser()), this._dcsParser = this.register(new o.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => true);
            }
            _identifier(e3, t3 = [64, 126]) {
              let i3 = 0;
              if (e3.prefix) {
                if (e3.prefix.length > 1)
                  throw new Error("only one byte as prefix supported");
                if (i3 = e3.prefix.charCodeAt(0), i3 && 60 > i3 || i3 > 63)
                  throw new Error("prefix must be in range 0x3c .. 0x3f");
              }
              if (e3.intermediates) {
                if (e3.intermediates.length > 2)
                  throw new Error("only two bytes as intermediates are supported");
                for (let t4 = 0; t4 < e3.intermediates.length; ++t4) {
                  const s4 = e3.intermediates.charCodeAt(t4);
                  if (32 > s4 || s4 > 47)
                    throw new Error("intermediate must be in range 0x20 .. 0x2f");
                  i3 <<= 8, i3 |= s4;
                }
              }
              if (1 !== e3.final.length)
                throw new Error("final must be a single byte");
              const s3 = e3.final.charCodeAt(0);
              if (t3[0] > s3 || s3 > t3[1])
                throw new Error(`final must be in range ${t3[0]} .. ${t3[1]}`);
              return i3 <<= 8, i3 |= s3, i3;
            }
            identToString(e3) {
              const t3 = [];
              for (; e3; )
                t3.push(String.fromCharCode(255 & e3)), e3 >>= 8;
              return t3.reverse().join("");
            }
            setPrintHandler(e3) {
              this._printHandler = e3;
            }
            clearPrintHandler() {
              this._printHandler = this._printHandlerFb;
            }
            registerEscHandler(e3, t3) {
              const i3 = this._identifier(e3, [48, 126]);
              void 0 === this._escHandlers[i3] && (this._escHandlers[i3] = []);
              const s3 = this._escHandlers[i3];
              return s3.push(t3), { dispose: () => {
                const e4 = s3.indexOf(t3);
                -1 !== e4 && s3.splice(e4, 1);
              } };
            }
            clearEscHandler(e3) {
              this._escHandlers[this._identifier(e3, [48, 126])] && delete this._escHandlers[this._identifier(e3, [48, 126])];
            }
            setEscHandlerFallback(e3) {
              this._escHandlerFb = e3;
            }
            setExecuteHandler(e3, t3) {
              this._executeHandlers[e3.charCodeAt(0)] = t3;
            }
            clearExecuteHandler(e3) {
              this._executeHandlers[e3.charCodeAt(0)] && delete this._executeHandlers[e3.charCodeAt(0)];
            }
            setExecuteHandlerFallback(e3) {
              this._executeHandlerFb = e3;
            }
            registerCsiHandler(e3, t3) {
              const i3 = this._identifier(e3);
              void 0 === this._csiHandlers[i3] && (this._csiHandlers[i3] = []);
              const s3 = this._csiHandlers[i3];
              return s3.push(t3), { dispose: () => {
                const e4 = s3.indexOf(t3);
                -1 !== e4 && s3.splice(e4, 1);
              } };
            }
            clearCsiHandler(e3) {
              this._csiHandlers[this._identifier(e3)] && delete this._csiHandlers[this._identifier(e3)];
            }
            setCsiHandlerFallback(e3) {
              this._csiHandlerFb = e3;
            }
            registerDcsHandler(e3, t3) {
              return this._dcsParser.registerHandler(this._identifier(e3), t3);
            }
            clearDcsHandler(e3) {
              this._dcsParser.clearHandler(this._identifier(e3));
            }
            setDcsHandlerFallback(e3) {
              this._dcsParser.setHandlerFallback(e3);
            }
            registerOscHandler(e3, t3) {
              return this._oscParser.registerHandler(e3, t3);
            }
            clearOscHandler(e3) {
              this._oscParser.clearHandler(e3);
            }
            setOscHandlerFallback(e3) {
              this._oscParser.setHandlerFallback(e3);
            }
            setErrorHandler(e3) {
              this._errorHandler = e3;
            }
            clearErrorHandler() {
              this._errorHandler = this._errorHandlerFb;
            }
            reset() {
              this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);
            }
            _preserveStack(e3, t3, i3, s3, r2) {
              this._parseStack.state = e3, this._parseStack.handlers = t3, this._parseStack.handlerPos = i3, this._parseStack.transition = s3, this._parseStack.chunkPos = r2;
            }
            parse(e3, t3, i3) {
              let s3, r2 = 0, n2 = 0, o2 = 0;
              if (this._parseStack.state)
                if (2 === this._parseStack.state)
                  this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1;
                else {
                  if (void 0 === i3 || 1 === this._parseStack.state)
                    throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
                  const t4 = this._parseStack.handlers;
                  let n3 = this._parseStack.handlerPos - 1;
                  switch (this._parseStack.state) {
                    case 3:
                      if (false === i3 && n3 > -1) {
                        for (; n3 >= 0 && (s3 = t4[n3](this._params), true !== s3); n3--)
                          if (s3 instanceof Promise)
                            return this._parseStack.handlerPos = n3, s3;
                      }
                      this._parseStack.handlers = [];
                      break;
                    case 4:
                      if (false === i3 && n3 > -1) {
                        for (; n3 >= 0 && (s3 = t4[n3](), true !== s3); n3--)
                          if (s3 instanceof Promise)
                            return this._parseStack.handlerPos = n3, s3;
                      }
                      this._parseStack.handlers = [];
                      break;
                    case 6:
                      if (r2 = e3[this._parseStack.chunkPos], s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2, i3), s3)
                        return s3;
                      27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                      break;
                    case 5:
                      if (r2 = e3[this._parseStack.chunkPos], s3 = this._oscParser.end(24 !== r2 && 26 !== r2, i3), s3)
                        return s3;
                      27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  }
                  this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
                }
              for (let i4 = o2; i4 < t3; ++i4) {
                switch (r2 = e3[i4], n2 = this._transitions.table[this.currentState << 8 | (r2 < 160 ? r2 : h)], n2 >> 4) {
                  case 2:
                    for (let s4 = i4 + 1; ; ++s4) {
                      if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                    }
                    break;
                  case 3:
                    this._executeHandlers[r2] ? this._executeHandlers[r2]() : this._executeHandlerFb(r2), this.precedingCodepoint = 0;
                    break;
                  case 0:
                    break;
                  case 1:
                    if (this._errorHandler({ position: i4, code: r2, currentState: this.currentState, collect: this._collect, params: this._params, abort: false }).abort)
                      return;
                    break;
                  case 7:
                    const o3 = this._csiHandlers[this._collect << 8 | r2];
                    let a2 = o3 ? o3.length - 1 : -1;
                    for (; a2 >= 0 && (s3 = o3[a2](this._params), true !== s3); a2--)
                      if (s3 instanceof Promise)
                        return this._preserveStack(3, o3, a2, n2, i4), s3;
                    a2 < 0 && this._csiHandlerFb(this._collect << 8 | r2, this._params), this.precedingCodepoint = 0;
                    break;
                  case 8:
                    do {
                      switch (r2) {
                        case 59:
                          this._params.addParam(0);
                          break;
                        case 58:
                          this._params.addSubParam(-1);
                          break;
                        default:
                          this._params.addDigit(r2 - 48);
                      }
                    } while (++i4 < t3 && (r2 = e3[i4]) > 47 && r2 < 60);
                    i4--;
                    break;
                  case 9:
                    this._collect <<= 8, this._collect |= r2;
                    break;
                  case 10:
                    const c2 = this._escHandlers[this._collect << 8 | r2];
                    let l = c2 ? c2.length - 1 : -1;
                    for (; l >= 0 && (s3 = c2[l](), true !== s3); l--)
                      if (s3 instanceof Promise)
                        return this._preserveStack(4, c2, l, n2, i4), s3;
                    l < 0 && this._escHandlerFb(this._collect << 8 | r2), this.precedingCodepoint = 0;
                    break;
                  case 11:
                    this._params.reset(), this._params.addParam(0), this._collect = 0;
                    break;
                  case 12:
                    this._dcsParser.hook(this._collect << 8 | r2, this._params);
                    break;
                  case 13:
                    for (let s4 = i4 + 1; ; ++s4)
                      if (s4 >= t3 || 24 === (r2 = e3[s4]) || 26 === r2 || 27 === r2 || r2 > 127 && r2 < h) {
                        this._dcsParser.put(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                    break;
                  case 14:
                    if (s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2), s3)
                      return this._preserveStack(6, [], 0, n2, i4), s3;
                    27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                    break;
                  case 4:
                    this._oscParser.start();
                    break;
                  case 5:
                    for (let s4 = i4 + 1; ; s4++)
                      if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 127 && r2 < h) {
                        this._oscParser.put(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                    break;
                  case 6:
                    if (s3 = this._oscParser.end(24 !== r2 && 26 !== r2), s3)
                      return this._preserveStack(5, [], 0, n2, i4), s3;
                    27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                }
                this.currentState = 15 & n2;
              }
            }
          }
          t2.EscapeSequenceParser = c;
        }, 6242: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OscHandler = t2.OscParser = void 0;
          const s2 = i2(5770), r = i2(482), n = [];
          t2.OscParser = class {
            constructor() {
              this._state = 0, this._active = n, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
            }
            registerHandler(e3, t3) {
              void 0 === this._handlers[e3] && (this._handlers[e3] = []);
              const i3 = this._handlers[e3];
              return i3.push(t3), { dispose: () => {
                const e4 = i3.indexOf(t3);
                -1 !== e4 && i3.splice(e4, 1);
              } };
            }
            clearHandler(e3) {
              this._handlers[e3] && delete this._handlers[e3];
            }
            setHandlerFallback(e3) {
              this._handlerFb = e3;
            }
            dispose() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._active = n;
            }
            reset() {
              if (2 === this._state)
                for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3)
                  this._active[e3].end(false);
              this._stack.paused = false, this._active = n, this._id = -1, this._state = 0;
            }
            _start() {
              if (this._active = this._handlers[this._id] || n, this._active.length)
                for (let e3 = this._active.length - 1; e3 >= 0; e3--)
                  this._active[e3].start();
              else
                this._handlerFb(this._id, "START");
            }
            _put(e3, t3, i3) {
              if (this._active.length)
                for (let s3 = this._active.length - 1; s3 >= 0; s3--)
                  this._active[s3].put(e3, t3, i3);
              else
                this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e3, t3, i3));
            }
            start() {
              this.reset(), this._state = 1;
            }
            put(e3, t3, i3) {
              if (3 !== this._state) {
                if (1 === this._state)
                  for (; t3 < i3; ) {
                    const i4 = e3[t3++];
                    if (59 === i4) {
                      this._state = 2, this._start();
                      break;
                    }
                    if (i4 < 48 || 57 < i4)
                      return void (this._state = 3);
                    -1 === this._id && (this._id = 0), this._id = 10 * this._id + i4 - 48;
                  }
                2 === this._state && i3 - t3 > 0 && this._put(e3, t3, i3);
              }
            }
            end(e3, t3 = true) {
              if (0 !== this._state) {
                if (3 !== this._state)
                  if (1 === this._state && this._start(), this._active.length) {
                    let i3 = false, s3 = this._active.length - 1, r2 = false;
                    if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                      for (; s3 >= 0 && (i3 = this._active[s3].end(e3), true !== i3); s3--)
                        if (i3 instanceof Promise)
                          return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                      s3--;
                    }
                    for (; s3 >= 0; s3--)
                      if (i3 = this._active[s3].end(false), i3 instanceof Promise)
                        return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
                  } else
                    this._handlerFb(this._id, "END", e3);
                this._active = n, this._id = -1, this._state = 0;
              }
            }
          }, t2.OscHandler = class {
            constructor(e3) {
              this._handler = e3, this._data = "", this._hitLimit = false;
            }
            start() {
              this._data = "", this._hitLimit = false;
            }
            put(e3, t3, i3) {
              this._hitLimit || (this._data += (0, r.utf32ToString)(e3, t3, i3), this._data.length > s2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
            }
            end(e3) {
              let t3 = false;
              if (this._hitLimit)
                t3 = false;
              else if (e3 && (t3 = this._handler(this._data), t3 instanceof Promise))
                return t3.then((e4) => (this._data = "", this._hitLimit = false, e4));
              return this._data = "", this._hitLimit = false, t3;
            }
          };
        }, 8742: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Params = void 0;
          const i2 = 2147483647;
          class s2 {
            static fromArray(e3) {
              const t3 = new s2();
              if (!e3.length)
                return t3;
              for (let i3 = Array.isArray(e3[0]) ? 1 : 0; i3 < e3.length; ++i3) {
                const s3 = e3[i3];
                if (Array.isArray(s3))
                  for (let e4 = 0; e4 < s3.length; ++e4)
                    t3.addSubParam(s3[e4]);
                else
                  t3.addParam(s3);
              }
              return t3;
            }
            constructor(e3 = 32, t3 = 32) {
              if (this.maxLength = e3, this.maxSubParamsLength = t3, t3 > 256)
                throw new Error("maxSubParamsLength must not be greater than 256");
              this.params = new Int32Array(e3), this.length = 0, this._subParams = new Int32Array(t3), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e3), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
            }
            clone() {
              const e3 = new s2(this.maxLength, this.maxSubParamsLength);
              return e3.params.set(this.params), e3.length = this.length, e3._subParams.set(this._subParams), e3._subParamsLength = this._subParamsLength, e3._subParamsIdx.set(this._subParamsIdx), e3._rejectDigits = this._rejectDigits, e3._rejectSubDigits = this._rejectSubDigits, e3._digitIsSub = this._digitIsSub, e3;
            }
            toArray() {
              const e3 = [];
              for (let t3 = 0; t3 < this.length; ++t3) {
                e3.push(this.params[t3]);
                const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
                s3 - i3 > 0 && e3.push(Array.prototype.slice.call(this._subParams, i3, s3));
              }
              return e3;
            }
            reset() {
              this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
            }
            addParam(e3) {
              if (this._digitIsSub = false, this.length >= this.maxLength)
                this._rejectDigits = true;
              else {
                if (e3 < -1)
                  throw new Error("values lesser than -1 are not allowed");
                this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e3 > i2 ? i2 : e3;
              }
            }
            addSubParam(e3) {
              if (this._digitIsSub = true, this.length)
                if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength)
                  this._rejectSubDigits = true;
                else {
                  if (e3 < -1)
                    throw new Error("values lesser than -1 are not allowed");
                  this._subParams[this._subParamsLength++] = e3 > i2 ? i2 : e3, this._subParamsIdx[this.length - 1]++;
                }
            }
            hasSubParams(e3) {
              return (255 & this._subParamsIdx[e3]) - (this._subParamsIdx[e3] >> 8) > 0;
            }
            getSubParams(e3) {
              const t3 = this._subParamsIdx[e3] >> 8, i3 = 255 & this._subParamsIdx[e3];
              return i3 - t3 > 0 ? this._subParams.subarray(t3, i3) : null;
            }
            getSubParamsAll() {
              const e3 = {};
              for (let t3 = 0; t3 < this.length; ++t3) {
                const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
                s3 - i3 > 0 && (e3[t3] = this._subParams.slice(i3, s3));
              }
              return e3;
            }
            addDigit(e3) {
              let t3;
              if (this._rejectDigits || !(t3 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits)
                return;
              const s3 = this._digitIsSub ? this._subParams : this.params, r = s3[t3 - 1];
              s3[t3 - 1] = ~r ? Math.min(10 * r + e3, i2) : e3;
            }
          }
          t2.Params = s2;
        }, 5741: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.AddonManager = void 0, t2.AddonManager = class {
            constructor() {
              this._addons = [];
            }
            dispose() {
              for (let e3 = this._addons.length - 1; e3 >= 0; e3--)
                this._addons[e3].instance.dispose();
            }
            loadAddon(e3, t3) {
              const i2 = { instance: t3, dispose: t3.dispose, isDisposed: false };
              this._addons.push(i2), t3.dispose = () => this._wrappedAddonDispose(i2), t3.activate(e3);
            }
            _wrappedAddonDispose(e3) {
              if (e3.isDisposed)
                return;
              let t3 = -1;
              for (let i2 = 0; i2 < this._addons.length; i2++)
                if (this._addons[i2] === e3) {
                  t3 = i2;
                  break;
                }
              if (-1 === t3)
                throw new Error("Could not dispose an addon that has not been loaded");
              e3.isDisposed = true, e3.dispose.apply(e3.instance), this._addons.splice(t3, 1);
            }
          };
        }, 8771: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferApiView = void 0;
          const s2 = i2(3785), r = i2(511);
          t2.BufferApiView = class {
            constructor(e3, t3) {
              this._buffer = e3, this.type = t3;
            }
            init(e3) {
              return this._buffer = e3, this;
            }
            get cursorY() {
              return this._buffer.y;
            }
            get cursorX() {
              return this._buffer.x;
            }
            get viewportY() {
              return this._buffer.ydisp;
            }
            get baseY() {
              return this._buffer.ybase;
            }
            get length() {
              return this._buffer.lines.length;
            }
            getLine(e3) {
              const t3 = this._buffer.lines.get(e3);
              if (t3)
                return new s2.BufferLineApiView(t3);
            }
            getNullCell() {
              return new r.CellData();
            }
          };
        }, 3785: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLineApiView = void 0;
          const s2 = i2(511);
          t2.BufferLineApiView = class {
            constructor(e3) {
              this._line = e3;
            }
            get isWrapped() {
              return this._line.isWrapped;
            }
            get length() {
              return this._line.length;
            }
            getCell(e3, t3) {
              if (!(e3 < 0 || e3 >= this._line.length))
                return t3 ? (this._line.loadCell(e3, t3), t3) : this._line.loadCell(e3, new s2.CellData());
            }
            translateToString(e3, t3, i3) {
              return this._line.translateToString(e3, t3, i3);
            }
          };
        }, 8285: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferNamespaceApi = void 0;
          const s2 = i2(8771), r = i2(8460), n = i2(844);
          class o extends n.Disposable {
            constructor(e3) {
              super(), this._core = e3, this._onBufferChange = this.register(new r.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new s2.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s2.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
            }
            get active() {
              if (this._core.buffers.active === this._core.buffers.normal)
                return this.normal;
              if (this._core.buffers.active === this._core.buffers.alt)
                return this.alternate;
              throw new Error("Active buffer is neither normal nor alternate");
            }
            get normal() {
              return this._normal.init(this._core.buffers.normal);
            }
            get alternate() {
              return this._alternate.init(this._core.buffers.alt);
            }
          }
          t2.BufferNamespaceApi = o;
        }, 7975: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ParserApi = void 0, t2.ParserApi = class {
            constructor(e3) {
              this._core = e3;
            }
            registerCsiHandler(e3, t3) {
              return this._core.registerCsiHandler(e3, (e4) => t3(e4.toArray()));
            }
            addCsiHandler(e3, t3) {
              return this.registerCsiHandler(e3, t3);
            }
            registerDcsHandler(e3, t3) {
              return this._core.registerDcsHandler(e3, (e4, i2) => t3(e4, i2.toArray()));
            }
            addDcsHandler(e3, t3) {
              return this.registerDcsHandler(e3, t3);
            }
            registerEscHandler(e3, t3) {
              return this._core.registerEscHandler(e3, t3);
            }
            addEscHandler(e3, t3) {
              return this.registerEscHandler(e3, t3);
            }
            registerOscHandler(e3, t3) {
              return this._core.registerOscHandler(e3, t3);
            }
            addOscHandler(e3, t3) {
              return this.registerOscHandler(e3, t3);
            }
          };
        }, 7090: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeApi = void 0, t2.UnicodeApi = class {
            constructor(e3) {
              this._core = e3;
            }
            register(e3) {
              this._core.unicodeService.register(e3);
            }
            get versions() {
              return this._core.unicodeService.versions;
            }
            get activeVersion() {
              return this._core.unicodeService.activeVersion;
            }
            set activeVersion(e3) {
              this._core.unicodeService.activeVersion = e3;
            }
          };
        }, 744: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferService = t2.MINIMUM_ROWS = t2.MINIMUM_COLS = void 0;
          const n = i2(8460), o = i2(844), a = i2(5295), h = i2(2585);
          t2.MINIMUM_COLS = 2, t2.MINIMUM_ROWS = 1;
          let c = t2.BufferService = class extends o.Disposable {
            get buffer() {
              return this.buffers.active;
            }
            constructor(e3) {
              super(), this.isUserScrolling = false, this._onResize = this.register(new n.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e3.rawOptions.cols || 0, t2.MINIMUM_COLS), this.rows = Math.max(e3.rawOptions.rows || 0, t2.MINIMUM_ROWS), this.buffers = this.register(new a.BufferSet(e3, this));
            }
            resize(e3, t3) {
              this.cols = e3, this.rows = t3, this.buffers.resize(e3, t3), this._onResize.fire({ cols: e3, rows: t3 });
            }
            reset() {
              this.buffers.reset(), this.isUserScrolling = false;
            }
            scroll(e3, t3 = false) {
              const i3 = this.buffer;
              let s3;
              s3 = this._cachedBlankLine, s3 && s3.length === this.cols && s3.getFg(0) === e3.fg && s3.getBg(0) === e3.bg || (s3 = i3.getBlankLine(e3, t3), this._cachedBlankLine = s3), s3.isWrapped = t3;
              const r2 = i3.ybase + i3.scrollTop, n2 = i3.ybase + i3.scrollBottom;
              if (0 === i3.scrollTop) {
                const e4 = i3.lines.isFull;
                n2 === i3.lines.length - 1 ? e4 ? i3.lines.recycle().copyFrom(s3) : i3.lines.push(s3.clone()) : i3.lines.splice(n2 + 1, 0, s3.clone()), e4 ? this.isUserScrolling && (i3.ydisp = Math.max(i3.ydisp - 1, 0)) : (i3.ybase++, this.isUserScrolling || i3.ydisp++);
              } else {
                const e4 = n2 - r2 + 1;
                i3.lines.shiftElements(r2 + 1, e4 - 1, -1), i3.lines.set(n2, s3.clone());
              }
              this.isUserScrolling || (i3.ydisp = i3.ybase), this._onScroll.fire(i3.ydisp);
            }
            scrollLines(e3, t3, i3) {
              const s3 = this.buffer;
              if (e3 < 0) {
                if (0 === s3.ydisp)
                  return;
                this.isUserScrolling = true;
              } else
                e3 + s3.ydisp >= s3.ybase && (this.isUserScrolling = false);
              const r2 = s3.ydisp;
              s3.ydisp = Math.max(Math.min(s3.ydisp + e3, s3.ybase), 0), r2 !== s3.ydisp && (t3 || this._onScroll.fire(s3.ydisp));
            }
          };
          t2.BufferService = c = s2([r(0, h.IOptionsService)], c);
        }, 7994: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CharsetService = void 0, t2.CharsetService = class {
            constructor() {
              this.glevel = 0, this._charsets = [];
            }
            reset() {
              this.charset = void 0, this._charsets = [], this.glevel = 0;
            }
            setgLevel(e3) {
              this.glevel = e3, this.charset = this._charsets[e3];
            }
            setgCharset(e3, t3) {
              this._charsets[e3] = t3, this.glevel === e3 && (this.charset = t3);
            }
          };
        }, 1753: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreMouseService = void 0;
          const n = i2(2585), o = i2(8460), a = i2(844), h = { NONE: { events: 0, restrict: () => false }, X10: { events: 1, restrict: (e3) => 4 !== e3.button && 1 === e3.action && (e3.ctrl = false, e3.alt = false, e3.shift = false, true) }, VT200: { events: 19, restrict: (e3) => 32 !== e3.action }, DRAG: { events: 23, restrict: (e3) => 32 !== e3.action || 3 !== e3.button }, ANY: { events: 31, restrict: (e3) => true } };
          function c(e3, t3) {
            let i3 = (e3.ctrl ? 16 : 0) | (e3.shift ? 4 : 0) | (e3.alt ? 8 : 0);
            return 4 === e3.button ? (i3 |= 64, i3 |= e3.action) : (i3 |= 3 & e3.button, 4 & e3.button && (i3 |= 64), 8 & e3.button && (i3 |= 128), 32 === e3.action ? i3 |= 32 : 0 !== e3.action || t3 || (i3 |= 3)), i3;
          }
          const l = String.fromCharCode, d = { DEFAULT: (e3) => {
            const t3 = [c(e3, false) + 32, e3.col + 32, e3.row + 32];
            return t3[0] > 255 || t3[1] > 255 || t3[2] > 255 ? "" : `\x1B[M${l(t3[0])}${l(t3[1])}${l(t3[2])}`;
          }, SGR: (e3) => {
            const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
            return `\x1B[<${c(e3, true)};${e3.col};${e3.row}${t3}`;
          }, SGR_PIXELS: (e3) => {
            const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
            return `\x1B[<${c(e3, true)};${e3.x};${e3.y}${t3}`;
          } };
          let _ = t2.CoreMouseService = class extends a.Disposable {
            constructor(e3, t3) {
              super(), this._bufferService = e3, this._coreService = t3, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
              for (const e4 of Object.keys(h))
                this.addProtocol(e4, h[e4]);
              for (const e4 of Object.keys(d))
                this.addEncoding(e4, d[e4]);
              this.reset();
            }
            addProtocol(e3, t3) {
              this._protocols[e3] = t3;
            }
            addEncoding(e3, t3) {
              this._encodings[e3] = t3;
            }
            get activeProtocol() {
              return this._activeProtocol;
            }
            get areMouseEventsActive() {
              return 0 !== this._protocols[this._activeProtocol].events;
            }
            set activeProtocol(e3) {
              if (!this._protocols[e3])
                throw new Error(`unknown protocol "${e3}"`);
              this._activeProtocol = e3, this._onProtocolChange.fire(this._protocols[e3].events);
            }
            get activeEncoding() {
              return this._activeEncoding;
            }
            set activeEncoding(e3) {
              if (!this._encodings[e3])
                throw new Error(`unknown encoding "${e3}"`);
              this._activeEncoding = e3;
            }
            reset() {
              this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
            }
            triggerMouseEvent(e3) {
              if (e3.col < 0 || e3.col >= this._bufferService.cols || e3.row < 0 || e3.row >= this._bufferService.rows)
                return false;
              if (4 === e3.button && 32 === e3.action)
                return false;
              if (3 === e3.button && 32 !== e3.action)
                return false;
              if (4 !== e3.button && (2 === e3.action || 3 === e3.action))
                return false;
              if (e3.col++, e3.row++, 32 === e3.action && this._lastEvent && this._equalEvents(this._lastEvent, e3, "SGR_PIXELS" === this._activeEncoding))
                return false;
              if (!this._protocols[this._activeProtocol].restrict(e3))
                return false;
              const t3 = this._encodings[this._activeEncoding](e3);
              return t3 && ("DEFAULT" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t3) : this._coreService.triggerDataEvent(t3, true)), this._lastEvent = e3, true;
            }
            explainEvents(e3) {
              return { down: !!(1 & e3), up: !!(2 & e3), drag: !!(4 & e3), move: !!(8 & e3), wheel: !!(16 & e3) };
            }
            _equalEvents(e3, t3, i3) {
              if (i3) {
                if (e3.x !== t3.x)
                  return false;
                if (e3.y !== t3.y)
                  return false;
              } else {
                if (e3.col !== t3.col)
                  return false;
                if (e3.row !== t3.row)
                  return false;
              }
              return e3.button === t3.button && e3.action === t3.action && e3.ctrl === t3.ctrl && e3.alt === t3.alt && e3.shift === t3.shift;
            }
          };
          t2.CoreMouseService = _ = s2([r(0, n.IBufferService), r(1, n.ICoreService)], _);
        }, 6975: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreService = void 0;
          const n = i2(1439), o = i2(8460), a = i2(844), h = i2(2585), c = Object.freeze({ insertMode: false }), l = Object.freeze({ applicationCursorKeys: false, applicationKeypad: false, bracketedPasteMode: false, origin: false, reverseWraparound: false, sendFocus: false, wraparound: true });
          let d = t2.CoreService = class extends a.Disposable {
            constructor(e3, t3, i3) {
              super(), this._bufferService = e3, this._logService = t3, this._optionsService = i3, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new o.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
            }
            reset() {
              this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
            }
            triggerDataEvent(e3, t3 = false) {
              if (this._optionsService.rawOptions.disableStdin)
                return;
              const i3 = this._bufferService.buffer;
              t3 && this._optionsService.rawOptions.scrollOnUserInput && i3.ybase !== i3.ydisp && this._onRequestScrollToBottom.fire(), t3 && this._onUserInput.fire(), this._logService.debug(`sending data "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onData.fire(e3);
            }
            triggerBinaryEvent(e3) {
              this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onBinary.fire(e3));
            }
          };
          t2.CoreService = d = s2([r(0, h.IBufferService), r(1, h.ILogService), r(2, h.IOptionsService)], d);
        }, 9074: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DecorationService = void 0;
          const s2 = i2(8055), r = i2(8460), n = i2(844), o = i2(6106);
          let a = 0, h = 0;
          class c extends n.Disposable {
            get decorations() {
              return this._decorations.values();
            }
            constructor() {
              super(), this._decorations = new o.SortedList((e3) => null == e3 ? void 0 : e3.marker.line), this._onDecorationRegistered = this.register(new r.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)(() => this.reset()));
            }
            registerDecoration(e3) {
              if (e3.marker.isDisposed)
                return;
              const t3 = new l(e3);
              if (t3) {
                const e4 = t3.marker.onDispose(() => t3.dispose());
                t3.onDispose(() => {
                  t3 && (this._decorations.delete(t3) && this._onDecorationRemoved.fire(t3), e4.dispose());
                }), this._decorations.insert(t3), this._onDecorationRegistered.fire(t3);
              }
              return t3;
            }
            reset() {
              for (const e3 of this._decorations.values())
                e3.dispose();
              this._decorations.clear();
            }
            *getDecorationsAtCell(e3, t3, i3) {
              var s3, r2, n2;
              let o2 = 0, a2 = 0;
              for (const h2 of this._decorations.getKeyIterator(t3))
                o2 = null !== (s3 = h2.options.x) && void 0 !== s3 ? s3 : 0, a2 = o2 + (null !== (r2 = h2.options.width) && void 0 !== r2 ? r2 : 1), e3 >= o2 && e3 < a2 && (!i3 || (null !== (n2 = h2.options.layer) && void 0 !== n2 ? n2 : "bottom") === i3) && (yield h2);
            }
            forEachDecorationAtCell(e3, t3, i3, s3) {
              this._decorations.forEachByKey(t3, (t4) => {
                var r2, n2, o2;
                a = null !== (r2 = t4.options.x) && void 0 !== r2 ? r2 : 0, h = a + (null !== (n2 = t4.options.width) && void 0 !== n2 ? n2 : 1), e3 >= a && e3 < h && (!i3 || (null !== (o2 = t4.options.layer) && void 0 !== o2 ? o2 : "bottom") === i3) && s3(t4);
              });
            }
          }
          t2.DecorationService = c;
          class l extends n.Disposable {
            get isDisposed() {
              return this._isDisposed;
            }
            get backgroundColorRGB() {
              return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s2.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
            }
            get foregroundColorRGB() {
              return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s2.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
            }
            constructor(e3) {
              super(), this.options = e3, this.onRenderEmitter = this.register(new r.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e3.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
            }
            dispose() {
              this._onDispose.fire(), super.dispose();
            }
          }
        }, 4348: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.InstantiationService = t2.ServiceCollection = void 0;
          const s2 = i2(2585), r = i2(8343);
          class n {
            constructor(...e3) {
              this._entries = /* @__PURE__ */ new Map();
              for (const [t3, i3] of e3)
                this.set(t3, i3);
            }
            set(e3, t3) {
              const i3 = this._entries.get(e3);
              return this._entries.set(e3, t3), i3;
            }
            forEach(e3) {
              for (const [t3, i3] of this._entries.entries())
                e3(t3, i3);
            }
            has(e3) {
              return this._entries.has(e3);
            }
            get(e3) {
              return this._entries.get(e3);
            }
          }
          t2.ServiceCollection = n, t2.InstantiationService = class {
            constructor() {
              this._services = new n(), this._services.set(s2.IInstantiationService, this);
            }
            setService(e3, t3) {
              this._services.set(e3, t3);
            }
            getService(e3) {
              return this._services.get(e3);
            }
            createInstance(e3, ...t3) {
              const i3 = (0, r.getServiceDependencies)(e3).sort((e4, t4) => e4.index - t4.index), s3 = [];
              for (const t4 of i3) {
                const i4 = this._services.get(t4.id);
                if (!i4)
                  throw new Error(`[createInstance] ${e3.name} depends on UNKNOWN service ${t4.id}.`);
                s3.push(i4);
              }
              const n2 = i3.length > 0 ? i3[0].index : t3.length;
              if (t3.length !== n2)
                throw new Error(`[createInstance] First service dependency of ${e3.name} at position ${n2 + 1} conflicts with ${t3.length} static arguments`);
              return new e3(...[...t3, ...s3]);
            }
          };
        }, 7866: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.traceCall = t2.setTraceLogger = t2.LogService = void 0;
          const n = i2(844), o = i2(2585), a = { trace: o.LogLevelEnum.TRACE, debug: o.LogLevelEnum.DEBUG, info: o.LogLevelEnum.INFO, warn: o.LogLevelEnum.WARN, error: o.LogLevelEnum.ERROR, off: o.LogLevelEnum.OFF };
          let h, c = t2.LogService = class extends n.Disposable {
            get logLevel() {
              return this._logLevel;
            }
            constructor(e3) {
              super(), this._optionsService = e3, this._logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), h = this;
            }
            _updateLogLevel() {
              this._logLevel = a[this._optionsService.rawOptions.logLevel];
            }
            _evalLazyOptionalParams(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                "function" == typeof e3[t3] && (e3[t3] = e3[t3]());
            }
            _log(e3, t3, i3) {
              this._evalLazyOptionalParams(i3), e3.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + t3, ...i3);
            }
            trace(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.TRACE && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.trace.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.log, e3, t3);
            }
            debug(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.DEBUG && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.debug.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.log, e3, t3);
            }
            info(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.INFO && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.info.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.info, e3, t3);
            }
            warn(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.WARN && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.warn.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.warn, e3, t3);
            }
            error(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.ERROR && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.error.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.error, e3, t3);
            }
          };
          t2.LogService = c = s2([r(0, o.IOptionsService)], c), t2.setTraceLogger = function(e3) {
            h = e3;
          }, t2.traceCall = function(e3, t3, i3) {
            if ("function" != typeof i3.value)
              throw new Error("not supported");
            const s3 = i3.value;
            i3.value = function(...e4) {
              if (h.logLevel !== o.LogLevelEnum.TRACE)
                return s3.apply(this, e4);
              h.trace(`GlyphRenderer#${s3.name}(${e4.map((e5) => JSON.stringify(e5)).join(", ")})`);
              const t4 = s3.apply(this, e4);
              return h.trace(`GlyphRenderer#${s3.name} return`, t4), t4;
            };
          };
        }, 7302: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionsService = t2.DEFAULT_OPTIONS = void 0;
          const s2 = i2(8460), r = i2(844), n = i2(6114);
          t2.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: false, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: true, drawBoldTextInBrightColors: true, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: false, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: true, scrollSensitivity: 1, screenReaderMode: false, smoothScrollDuration: 0, macOptionIsMeta: false, macOptionClickForcesSelection: false, minimumContrastRatio: 1, disableStdin: false, allowProposedApi: false, allowTransparency: false, tabStopWidth: 8, theme: {}, rightClickSelectsWord: n.isMac, windowOptions: {}, windowsMode: false, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: true, convertEol: false, termName: "xterm", cancelEvents: false, overviewRulerWidth: 0 };
          const o = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
          class a extends r.Disposable {
            constructor(e3) {
              super(), this._onOptionChange = this.register(new s2.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
              const i3 = Object.assign({}, t2.DEFAULT_OPTIONS);
              for (const t3 in e3)
                if (t3 in i3)
                  try {
                    const s3 = e3[t3];
                    i3[t3] = this._sanitizeAndValidateOption(t3, s3);
                  } catch (e4) {
                    console.error(e4);
                  }
              this.rawOptions = i3, this.options = Object.assign({}, i3), this._setupOptions();
            }
            onSpecificOptionChange(e3, t3) {
              return this.onOptionChange((i3) => {
                i3 === e3 && t3(this.rawOptions[e3]);
              });
            }
            onMultipleOptionChange(e3, t3) {
              return this.onOptionChange((i3) => {
                -1 !== e3.indexOf(i3) && t3();
              });
            }
            _setupOptions() {
              const e3 = (e4) => {
                if (!(e4 in t2.DEFAULT_OPTIONS))
                  throw new Error(`No option with key "${e4}"`);
                return this.rawOptions[e4];
              }, i3 = (e4, i4) => {
                if (!(e4 in t2.DEFAULT_OPTIONS))
                  throw new Error(`No option with key "${e4}"`);
                i4 = this._sanitizeAndValidateOption(e4, i4), this.rawOptions[e4] !== i4 && (this.rawOptions[e4] = i4, this._onOptionChange.fire(e4));
              };
              for (const t3 in this.rawOptions) {
                const s3 = { get: e3.bind(this, t3), set: i3.bind(this, t3) };
                Object.defineProperty(this.options, t3, s3);
              }
            }
            _sanitizeAndValidateOption(e3, i3) {
              switch (e3) {
                case "cursorStyle":
                  if (i3 || (i3 = t2.DEFAULT_OPTIONS[e3]), !/* @__PURE__ */ function(e4) {
                    return "block" === e4 || "underline" === e4 || "bar" === e4;
                  }(i3))
                    throw new Error(`"${i3}" is not a valid value for ${e3}`);
                  break;
                case "wordSeparator":
                  i3 || (i3 = t2.DEFAULT_OPTIONS[e3]);
                  break;
                case "fontWeight":
                case "fontWeightBold":
                  if ("number" == typeof i3 && 1 <= i3 && i3 <= 1e3)
                    break;
                  i3 = o.includes(i3) ? i3 : t2.DEFAULT_OPTIONS[e3];
                  break;
                case "cursorWidth":
                  i3 = Math.floor(i3);
                case "lineHeight":
                case "tabStopWidth":
                  if (i3 < 1)
                    throw new Error(`${e3} cannot be less than 1, value: ${i3}`);
                  break;
                case "minimumContrastRatio":
                  i3 = Math.max(1, Math.min(21, Math.round(10 * i3) / 10));
                  break;
                case "scrollback":
                  if ((i3 = Math.min(i3, 4294967295)) < 0)
                    throw new Error(`${e3} cannot be less than 0, value: ${i3}`);
                  break;
                case "fastScrollSensitivity":
                case "scrollSensitivity":
                  if (i3 <= 0)
                    throw new Error(`${e3} cannot be less than or equal to 0, value: ${i3}`);
                  break;
                case "rows":
                case "cols":
                  if (!i3 && 0 !== i3)
                    throw new Error(`${e3} must be numeric, value: ${i3}`);
                  break;
                case "windowsPty":
                  i3 = null != i3 ? i3 : {};
              }
              return i3;
            }
          }
          t2.OptionsService = a;
        }, 2660: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a = e3.length - 1; a >= 0; a--)
                (r2 = e3[a]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkService = void 0;
          const n = i2(2585);
          let o = t2.OscLinkService = class {
            constructor(e3) {
              this._bufferService = e3, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
            }
            registerLink(e3) {
              const t3 = this._bufferService.buffer;
              if (void 0 === e3.id) {
                const i4 = t3.addMarker(t3.ybase + t3.y), s4 = { data: e3, id: this._nextId++, lines: [i4] };
                return i4.onDispose(() => this._removeMarkerFromLink(s4, i4)), this._dataByLinkId.set(s4.id, s4), s4.id;
              }
              const i3 = e3, s3 = this._getEntryIdKey(i3), r2 = this._entriesWithId.get(s3);
              if (r2)
                return this.addLineToLink(r2.id, t3.ybase + t3.y), r2.id;
              const n2 = t3.addMarker(t3.ybase + t3.y), o2 = { id: this._nextId++, key: this._getEntryIdKey(i3), data: i3, lines: [n2] };
              return n2.onDispose(() => this._removeMarkerFromLink(o2, n2)), this._entriesWithId.set(o2.key, o2), this._dataByLinkId.set(o2.id, o2), o2.id;
            }
            addLineToLink(e3, t3) {
              const i3 = this._dataByLinkId.get(e3);
              if (i3 && i3.lines.every((e4) => e4.line !== t3)) {
                const e4 = this._bufferService.buffer.addMarker(t3);
                i3.lines.push(e4), e4.onDispose(() => this._removeMarkerFromLink(i3, e4));
              }
            }
            getLinkData(e3) {
              var t3;
              return null === (t3 = this._dataByLinkId.get(e3)) || void 0 === t3 ? void 0 : t3.data;
            }
            _getEntryIdKey(e3) {
              return `${e3.id};;${e3.uri}`;
            }
            _removeMarkerFromLink(e3, t3) {
              const i3 = e3.lines.indexOf(t3);
              -1 !== i3 && (e3.lines.splice(i3, 1), 0 === e3.lines.length && (void 0 !== e3.data.id && this._entriesWithId.delete(e3.key), this._dataByLinkId.delete(e3.id)));
            }
          };
          t2.OscLinkService = o = s2([r(0, n.IBufferService)], o);
        }, 8343: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.createDecorator = t2.getServiceDependencies = t2.serviceRegistry = void 0;
          const i2 = "di$target", s2 = "di$dependencies";
          t2.serviceRegistry = /* @__PURE__ */ new Map(), t2.getServiceDependencies = function(e3) {
            return e3[s2] || [];
          }, t2.createDecorator = function(e3) {
            if (t2.serviceRegistry.has(e3))
              return t2.serviceRegistry.get(e3);
            const r = function(e4, t3, n) {
              if (3 !== arguments.length)
                throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
              !function(e5, t4, r2) {
                t4[i2] === t4 ? t4[s2].push({ id: e5, index: r2 }) : (t4[s2] = [{ id: e5, index: r2 }], t4[i2] = t4);
              }(r, e4, n);
            };
            return r.toString = () => e3, t2.serviceRegistry.set(e3, r), r;
          };
        }, 2585: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.IDecorationService = t2.IUnicodeService = t2.IOscLinkService = t2.IOptionsService = t2.ILogService = t2.LogLevelEnum = t2.IInstantiationService = t2.ICharsetService = t2.ICoreService = t2.ICoreMouseService = t2.IBufferService = void 0;
          const s2 = i2(8343);
          var r;
          t2.IBufferService = (0, s2.createDecorator)("BufferService"), t2.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t2.ICoreService = (0, s2.createDecorator)("CoreService"), t2.ICharsetService = (0, s2.createDecorator)("CharsetService"), t2.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), function(e3) {
            e3[e3.TRACE = 0] = "TRACE", e3[e3.DEBUG = 1] = "DEBUG", e3[e3.INFO = 2] = "INFO", e3[e3.WARN = 3] = "WARN", e3[e3.ERROR = 4] = "ERROR", e3[e3.OFF = 5] = "OFF";
          }(r || (t2.LogLevelEnum = r = {})), t2.ILogService = (0, s2.createDecorator)("LogService"), t2.IOptionsService = (0, s2.createDecorator)("OptionsService"), t2.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t2.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t2.IDecorationService = (0, s2.createDecorator)("DecorationService");
        }, 1480: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeService = void 0;
          const s2 = i2(8460), r = i2(225);
          t2.UnicodeService = class {
            constructor() {
              this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new s2.EventEmitter(), this.onChange = this._onChange.event;
              const e3 = new r.UnicodeV6();
              this.register(e3), this._active = e3.version, this._activeProvider = e3;
            }
            dispose() {
              this._onChange.dispose();
            }
            get versions() {
              return Object.keys(this._providers);
            }
            get activeVersion() {
              return this._active;
            }
            set activeVersion(e3) {
              if (!this._providers[e3])
                throw new Error(`unknown Unicode version "${e3}"`);
              this._active = e3, this._activeProvider = this._providers[e3], this._onChange.fire(e3);
            }
            register(e3) {
              this._providers[e3.version] = e3;
            }
            wcwidth(e3) {
              return this._activeProvider.wcwidth(e3);
            }
            getStringCellWidth(e3) {
              let t3 = 0;
              const i3 = e3.length;
              for (let s3 = 0; s3 < i3; ++s3) {
                let r2 = e3.charCodeAt(s3);
                if (55296 <= r2 && r2 <= 56319) {
                  if (++s3 >= i3)
                    return t3 + this.wcwidth(r2);
                  const n = e3.charCodeAt(s3);
                  56320 <= n && n <= 57343 ? r2 = 1024 * (r2 - 55296) + n - 56320 + 65536 : t3 += this.wcwidth(n);
                }
                t3 += this.wcwidth(r2);
              }
              return t3;
            }
          };
        } }, t = {};
        function i(s2) {
          var r = t[s2];
          if (void 0 !== r)
            return r.exports;
          var n = t[s2] = { exports: {} };
          return e[s2].call(n.exports, n, n.exports, i), n.exports;
        }
        var s = {};
        return (() => {
          var e2 = s;
          Object.defineProperty(e2, "__esModule", { value: true }), e2.Terminal = void 0;
          const t2 = i(9042), r = i(3236), n = i(844), o = i(5741), a = i(8285), h = i(7975), c = i(7090), l = ["cols", "rows"];
          class d extends n.Disposable {
            constructor(e3) {
              super(), this._core = this.register(new r.Terminal(e3)), this._addonManager = this.register(new o.AddonManager()), this._publicOptions = Object.assign({}, this._core.options);
              const t3 = (e4) => this._core.options[e4], i2 = (e4, t4) => {
                this._checkReadonlyOptions(e4), this._core.options[e4] = t4;
              };
              for (const e4 in this._core.options) {
                const s2 = { get: t3.bind(this, e4), set: i2.bind(this, e4) };
                Object.defineProperty(this._publicOptions, e4, s2);
              }
            }
            _checkReadonlyOptions(e3) {
              if (l.includes(e3))
                throw new Error(`Option "${e3}" can only be set in the constructor`);
            }
            _checkProposedApi() {
              if (!this._core.optionsService.rawOptions.allowProposedApi)
                throw new Error("You must set the allowProposedApi option to true to use proposed API");
            }
            get onBell() {
              return this._core.onBell;
            }
            get onBinary() {
              return this._core.onBinary;
            }
            get onCursorMove() {
              return this._core.onCursorMove;
            }
            get onData() {
              return this._core.onData;
            }
            get onKey() {
              return this._core.onKey;
            }
            get onLineFeed() {
              return this._core.onLineFeed;
            }
            get onRender() {
              return this._core.onRender;
            }
            get onResize() {
              return this._core.onResize;
            }
            get onScroll() {
              return this._core.onScroll;
            }
            get onSelectionChange() {
              return this._core.onSelectionChange;
            }
            get onTitleChange() {
              return this._core.onTitleChange;
            }
            get onWriteParsed() {
              return this._core.onWriteParsed;
            }
            get element() {
              return this._core.element;
            }
            get parser() {
              return this._parser || (this._parser = new h.ParserApi(this._core)), this._parser;
            }
            get unicode() {
              return this._checkProposedApi(), new c.UnicodeApi(this._core);
            }
            get textarea() {
              return this._core.textarea;
            }
            get rows() {
              return this._core.rows;
            }
            get cols() {
              return this._core.cols;
            }
            get buffer() {
              return this._buffer || (this._buffer = this.register(new a.BufferNamespaceApi(this._core))), this._buffer;
            }
            get markers() {
              return this._checkProposedApi(), this._core.markers;
            }
            get modes() {
              const e3 = this._core.coreService.decPrivateModes;
              let t3 = "none";
              switch (this._core.coreMouseService.activeProtocol) {
                case "X10":
                  t3 = "x10";
                  break;
                case "VT200":
                  t3 = "vt200";
                  break;
                case "DRAG":
                  t3 = "drag";
                  break;
                case "ANY":
                  t3 = "any";
              }
              return { applicationCursorKeysMode: e3.applicationCursorKeys, applicationKeypadMode: e3.applicationKeypad, bracketedPasteMode: e3.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: t3, originMode: e3.origin, reverseWraparoundMode: e3.reverseWraparound, sendFocusMode: e3.sendFocus, wraparoundMode: e3.wraparound };
            }
            get options() {
              return this._publicOptions;
            }
            set options(e3) {
              for (const t3 in e3)
                this._publicOptions[t3] = e3[t3];
            }
            blur() {
              this._core.blur();
            }
            focus() {
              this._core.focus();
            }
            resize(e3, t3) {
              this._verifyIntegers(e3, t3), this._core.resize(e3, t3);
            }
            open(e3) {
              this._core.open(e3);
            }
            attachCustomKeyEventHandler(e3) {
              this._core.attachCustomKeyEventHandler(e3);
            }
            registerLinkProvider(e3) {
              return this._core.registerLinkProvider(e3);
            }
            registerCharacterJoiner(e3) {
              return this._checkProposedApi(), this._core.registerCharacterJoiner(e3);
            }
            deregisterCharacterJoiner(e3) {
              this._checkProposedApi(), this._core.deregisterCharacterJoiner(e3);
            }
            registerMarker(e3 = 0) {
              return this._verifyIntegers(e3), this._core.registerMarker(e3);
            }
            registerDecoration(e3) {
              var t3, i2, s2;
              return this._checkProposedApi(), this._verifyPositiveIntegers(null !== (t3 = e3.x) && void 0 !== t3 ? t3 : 0, null !== (i2 = e3.width) && void 0 !== i2 ? i2 : 0, null !== (s2 = e3.height) && void 0 !== s2 ? s2 : 0), this._core.registerDecoration(e3);
            }
            hasSelection() {
              return this._core.hasSelection();
            }
            select(e3, t3, i2) {
              this._verifyIntegers(e3, t3, i2), this._core.select(e3, t3, i2);
            }
            getSelection() {
              return this._core.getSelection();
            }
            getSelectionPosition() {
              return this._core.getSelectionPosition();
            }
            clearSelection() {
              this._core.clearSelection();
            }
            selectAll() {
              this._core.selectAll();
            }
            selectLines(e3, t3) {
              this._verifyIntegers(e3, t3), this._core.selectLines(e3, t3);
            }
            dispose() {
              super.dispose();
            }
            scrollLines(e3) {
              this._verifyIntegers(e3), this._core.scrollLines(e3);
            }
            scrollPages(e3) {
              this._verifyIntegers(e3), this._core.scrollPages(e3);
            }
            scrollToTop() {
              this._core.scrollToTop();
            }
            scrollToBottom() {
              this._core.scrollToBottom();
            }
            scrollToLine(e3) {
              this._verifyIntegers(e3), this._core.scrollToLine(e3);
            }
            clear() {
              this._core.clear();
            }
            write(e3, t3) {
              this._core.write(e3, t3);
            }
            writeln(e3, t3) {
              this._core.write(e3), this._core.write("\r\n", t3);
            }
            paste(e3) {
              this._core.paste(e3);
            }
            refresh(e3, t3) {
              this._verifyIntegers(e3, t3), this._core.refresh(e3, t3);
            }
            reset() {
              this._core.reset();
            }
            clearTextureAtlas() {
              this._core.clearTextureAtlas();
            }
            loadAddon(e3) {
              this._addonManager.loadAddon(this, e3);
            }
            static get strings() {
              return t2;
            }
            _verifyIntegers(...e3) {
              for (const t3 of e3)
                if (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0)
                  throw new Error("This API only accepts integers");
            }
            _verifyPositiveIntegers(...e3) {
              for (const t3 of e3)
                if (t3 && (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0 || t3 < 0))
                  throw new Error("This API only accepts positive integers");
            }
          }
          e2.Terminal = d;
        })(), s;
      })());
    }
  });

  // node_modules/@xterm/addon-fit/lib/addon-fit.js
  var require_addon_fit = __commonJS({
    "node_modules/@xterm/addon-fit/lib/addon-fit.js"(exports, module) {
      !function(e, t) {
        "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.FitAddon = t() : e.FitAddon = t();
      }(self, () => (() => {
        "use strict";
        var e = {};
        return (() => {
          var t = e;
          Object.defineProperty(t, "__esModule", { value: true }), t.FitAddon = void 0, t.FitAddon = class {
            activate(e2) {
              this._terminal = e2;
            }
            dispose() {
            }
            fit() {
              const e2 = this.proposeDimensions();
              if (!e2 || !this._terminal || isNaN(e2.cols) || isNaN(e2.rows))
                return;
              const t2 = this._terminal._core;
              this._terminal.rows === e2.rows && this._terminal.cols === e2.cols || (t2._renderService.clear(), this._terminal.resize(e2.cols, e2.rows));
            }
            proposeDimensions() {
              if (!this._terminal)
                return;
              if (!this._terminal.element || !this._terminal.element.parentElement)
                return;
              const e2 = this._terminal._core, t2 = e2._renderService.dimensions;
              if (0 === t2.css.cell.width || 0 === t2.css.cell.height)
                return;
              const r = 0 === this._terminal.options.scrollback ? 0 : e2.viewport.scrollBarWidth, i = window.getComputedStyle(this._terminal.element.parentElement), o = parseInt(i.getPropertyValue("height")), s = Math.max(0, parseInt(i.getPropertyValue("width"))), n = window.getComputedStyle(this._terminal.element), l = o - (parseInt(n.getPropertyValue("padding-top")) + parseInt(n.getPropertyValue("padding-bottom"))), a = s - (parseInt(n.getPropertyValue("padding-right")) + parseInt(n.getPropertyValue("padding-left"))) - r;
              return { cols: Math.max(2, Math.floor(a / t2.css.cell.width)), rows: Math.max(1, Math.floor(l / t2.css.cell.height)) };
            }
          };
        })(), e;
      })());
    }
  });

  // lib/index.js
  var import_api2 = __toESM(require_dist());
  var import_repo = __toESM(require_dist2());
  var import_xterm2 = __toESM(require_xterm());
  var import_addon_fit2 = __toESM(require_addon_fit());

  // lib/init-xterm.js
  var import_addon_fit = __toESM(require_addon_fit());
  var import_xterm = __toESM(require_xterm());
  function initXTerminal() {
    const termContainer = document.createElement("div");
    termContainer.className = "terminalContainer";
    termContainer.style.cssText = `
  position: absolute;
  left: 0; top: 0;
  width: 100%; height: 100%;
  border: solid 1em transparent;
  box-sizing: border-box;
  `;
    const termHost = document.createElement("div");
    termHost.className = "terminalHost";
    termHost.style.cssText = `
  position: relative;
  width: 100%; height: 100%;
  box-sizing: border-box;
  `;
    document.body.appendChild(termContainer);
    termContainer.appendChild(termHost);
    const measure = document.createElement("div");
    measure.style.cssText = `
  font-size: 2vh;
  z-index: -1;
  position: absolute;
  opacity: 0;
  `;
    measure.textContent = "M";
    document.body.appendChild(measure);
    const sz = measure.getBoundingClientRect();
    document.body.removeChild(measure);
    const terminal = new import_xterm.Terminal({
      allowTransparency: true,
      cursorBlink: true,
      cursorStyle: "underline",
      disableStdin: false,
      fontSize: Math.round(sz.height),
      theme: {
        background: "#00000000"
      }
    });
    const fitAddon = new import_addon_fit.FitAddon();
    terminal.loadAddon(fitAddon);
    terminal.open(termHost);
    fitAddon.fit();
    var debounce;
    window.addEventListener("resize", () => {
      clearTimeout(debounce);
      debounce = setTimeout(() => fitAddon.fit(), 150);
    });
    return { read, write, terminal, fitAddon };
    function write(text) {
      return terminal.write(text);
    }
    function read(silent) {
      return new Promise((resolve) => {
        let buf = "";
        const dataSub = terminal.onData((data) => {
          buf += data = [...data].filter(
            (ch) => ch.length > 1 || ch.charCodeAt(0) >= 32 && ch.charCodeAt(0) !== 127
          ).join("");
          terminal.write(!silent ? data : data.replace(/./g, "*"));
        });
        const keySub = terminal.onKey((e) => {
          if (e.key === "\r") {
            dataSub.dispose();
            keySub.dispose();
            terminal.write("\r\n");
            resolve(buf);
          }
          if (e.key === "\x7F") {
            if (buf) {
              const newBuf = buf.slice(0, buf.length - 1);
              buf = newBuf;
              terminal.write("\b \b");
            }
          }
        });
      });
    }
  }

  // lib/init-at-client.js
  var import_api = __toESM(require_dist());
  function initAtClient(_0) {
    return __async(this, arguments, function* ({ identifier, password }) {
      var _a, _b, _c;
      const oldXrpc = "https://bsky.social/xrpc";
      const newXrpc = "https://bsky.network/xrpc";
      const oldAtClient = new import_api.BskyAgent({ service: oldXrpc });
      const res = yield oldAtClient.login(
        { identifier, password }
      );
      const didDoc = (_a = res == null ? void 0 : res.data) == null ? void 0 : _a.didDoc;
      const serviceURL = (_c = (_b = didDoc == null ? void 0 : didDoc.service) == null ? void 0 : _b.find((svc) => /pds/i.test((svc == null ? void 0 : svc.id) || ""))) == null ? void 0 : _c.serviceEndpoint;
      const authenticatedAtClient = new import_api.BskyAgent({ service: serviceURL });
      patchBskyAgentWithCORSProxy(authenticatedAtClient);
      yield authenticatedAtClient.login({ identifier, password });
      const unaunthenticatedAtClient = new import_api.BskyAgent({ service: newXrpc });
      patchBskyAgentWithCORSProxy(unaunthenticatedAtClient);
      return { oldAtClient, authenticatedAtClient, unaunthenticatedAtClient };
      function patchBskyAgentWithCORSProxy(atClient) {
        atClient.com.atproto.sync._service.xrpc.baseClient.lex.assertValidXrpcOutput = function(lexUri, value, ...rest) {
          return true;
        };
        if (typeof window !== "undefined" && window) {
          const baseFetch = atClient.com.atproto.sync._service.xrpc.baseClient.fetch;
          atClient.com.atproto.sync._service.xrpc.baseClient.fetch = function(reqUri, ...args) {
            if (/(com.atproto.sync.listRepos)|(com.atproto.server.createSession)/.test(reqUri))
              reqUri = "https://corsproxy.io/?" + reqUri;
            return baseFetch.call(
              atClient.com.atproto.sync._service.xrpc.baseClient,
              reqUri,
              ...args
            );
          };
        }
      }
    });
  }

  // lib/index.js
  function exportToGlobal(exports) {
    exports.atproto = import_api2.default;
    exports.atproto_repo = import_repo.default;
    exports.xterm = import_xterm2.default;
    exports.xterm_fit = import_addon_fit2.default;
    exports.initXTerminal = initXTerminal;
    exports.initAtClient = initAtClient;
  }
  if (typeof window !== "undefined" && window) {
    exportToGlobal(window);
    ;
  }
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@atproto/repo/dist/index.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=libs.js.map
