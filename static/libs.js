(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __knownSymbol = (name, symbol) => {
    return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  };
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target2 = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target2[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target2[prop] = source[prop];
      }
    return target2;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target2, all) => {
    for (var name in all)
      __defProp(target2, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from5, except, desc) => {
    if (from5 && typeof from5 === "object" || typeof from5 === "function") {
      for (let key of __getOwnPropNames(from5))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc(from5, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __asyncGenerator = (__this, __arguments, generator) => {
    var resume = (k, v, yes, no) => {
      try {
        var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
        Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
      } catch (e) {
        no(e);
      }
    };
    var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));
    var it = {};
    return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
  };
  var __yieldStar = (value) => {
    var obj = value[__knownSymbol("asyncIterator")];
    var isAwait = false;
    var method;
    var it = {};
    if (obj == null) {
      obj = value[__knownSymbol("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw")
            throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object))
              throw TypeError("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };
  var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

  // node_modules/@atproto/api/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@atproto/api/dist/index.js"(exports, module2) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require2() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export2 = (target2, all) => {
        for (var name2 in all)
          __defProp2(target2, name2, { get: all[name2], enumerable: true });
      };
      var __copyProps2 = (to, from32, except, desc) => {
        if (from32 && typeof from32 === "object" || typeof from32 === "function") {
          for (let key of __getOwnPropNames2(from32))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from32[key], enumerable: !(desc = __getOwnPropDesc2(from32, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target2) => (target2 = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target2, "default", { value: mod, enumerable: true }) : target2, mod));
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var require_boundaries = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/boundaries.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.EXTENDED_PICTOGRAPHIC = exports2.CLUSTER_BREAK = void 0;
          var CLUSTER_BREAK;
          (function(CLUSTER_BREAK2) {
            CLUSTER_BREAK2[CLUSTER_BREAK2["CR"] = 0] = "CR";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LF"] = 1] = "LF";
            CLUSTER_BREAK2[CLUSTER_BREAK2["CONTROL"] = 2] = "CONTROL";
            CLUSTER_BREAK2[CLUSTER_BREAK2["EXTEND"] = 3] = "EXTEND";
            CLUSTER_BREAK2[CLUSTER_BREAK2["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
            CLUSTER_BREAK2[CLUSTER_BREAK2["SPACINGMARK"] = 5] = "SPACINGMARK";
            CLUSTER_BREAK2[CLUSTER_BREAK2["L"] = 6] = "L";
            CLUSTER_BREAK2[CLUSTER_BREAK2["V"] = 7] = "V";
            CLUSTER_BREAK2[CLUSTER_BREAK2["T"] = 8] = "T";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LV"] = 9] = "LV";
            CLUSTER_BREAK2[CLUSTER_BREAK2["LVT"] = 10] = "LVT";
            CLUSTER_BREAK2[CLUSTER_BREAK2["OTHER"] = 11] = "OTHER";
            CLUSTER_BREAK2[CLUSTER_BREAK2["PREPEND"] = 12] = "PREPEND";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE"] = 13] = "E_BASE";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_MODIFIER"] = 14] = "E_MODIFIER";
            CLUSTER_BREAK2[CLUSTER_BREAK2["ZWJ"] = 15] = "ZWJ";
            CLUSTER_BREAK2[CLUSTER_BREAK2["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
            CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
          })(CLUSTER_BREAK = exports2.CLUSTER_BREAK || (exports2.CLUSTER_BREAK = {}));
          exports2.EXTENDED_PICTOGRAPHIC = 101;
        }
      });
      var require_GraphemerHelper = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerHelper.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var boundaries_1 = require_boundaries();
          var NotBreak = 0;
          var BreakStart = 1;
          var Break = 2;
          var BreakLastRegional = 3;
          var BreakPenultimateRegional = 4;
          var GraphemerHelper = class {
            static isSurrogate(str, pos) {
              return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
            }
            static codePointAt(str, idx) {
              if (idx === void 0) {
                idx = 0;
              }
              const code2 = str.charCodeAt(idx);
              if (55296 <= code2 && code2 <= 56319 && idx < str.length - 1) {
                const hi = code2;
                const low = str.charCodeAt(idx + 1);
                if (56320 <= low && low <= 57343) {
                  return (hi - 55296) * 1024 + (low - 56320) + 65536;
                }
                return hi;
              }
              if (56320 <= code2 && code2 <= 57343 && idx >= 1) {
                const hi = str.charCodeAt(idx - 1);
                const low = code2;
                if (55296 <= hi && hi <= 56319) {
                  return (hi - 55296) * 1024 + (low - 56320) + 65536;
                }
                return low;
              }
              return code2;
            }
            static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
              const all = [start].concat(mid).concat([end]);
              const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
              const previous = all[all.length - 2];
              const next = end;
              const nextEmoji = endEmoji;
              const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
              if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
              }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
                if (all.filter(function(c) {
                  return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                }).length % 2 === 1) {
                  return BreakLastRegional;
                } else {
                  return BreakPenultimateRegional;
                }
              }
              if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
                return NotBreak;
              } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
                return BreakStart;
              } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
                return BreakStart;
              } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
                return NotBreak;
              } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
                return NotBreak;
              } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
                return NotBreak;
              } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
                return NotBreak;
              } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
                return NotBreak;
              } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
                return NotBreak;
              }
              const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
              if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.EXTEND;
              }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
                return NotBreak;
              }
              if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
                return Break;
              }
              if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
                return NotBreak;
              }
              return BreakStart;
            }
          };
          exports2.default = GraphemerHelper;
        }
      });
      var require_GraphemerIterator = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerIterator.js"(exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var GraphemerIterator = class {
            constructor(str, nextBreak) {
              this._index = 0;
              this._str = str;
              this._nextBreak = nextBreak;
            }
            [Symbol.iterator]() {
              return this;
            }
            next() {
              let brk;
              if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
                const value = this._str.slice(this._index, brk);
                this._index = brk;
                return { value, done: false };
              }
              if (this._index < this._str.length) {
                const value = this._str.slice(this._index);
                this._index = this._str.length;
                return { value, done: false };
              }
              return { value: void 0, done: true };
            }
          };
          exports2.default = GraphemerIterator;
        }
      });
      var require_Graphemer = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/Graphemer.js"(exports2) {
          "use strict";
          var __importDefault = exports2 && exports2.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var boundaries_1 = require_boundaries();
          var GraphemerHelper_1 = __importDefault(require_GraphemerHelper());
          var GraphemerIterator_1 = __importDefault(require_GraphemerIterator());
          var Graphemer2 = class {
            static nextBreak(string3, index) {
              if (index === void 0) {
                index = 0;
              }
              if (index < 0) {
                return 0;
              }
              if (index >= string3.length - 1) {
                return string3.length;
              }
              const prevCP = GraphemerHelper_1.default.codePointAt(string3, index);
              const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
              const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
              const mid = [];
              const midEmoji = [];
              for (let i = index + 1; i < string3.length; i++) {
                if (GraphemerHelper_1.default.isSurrogate(string3, i - 1)) {
                  continue;
                }
                const nextCP = GraphemerHelper_1.default.codePointAt(string3, i);
                const next = Graphemer2.getGraphemeBreakProperty(nextCP);
                const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
                if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
                  return i;
                }
                mid.push(next);
                midEmoji.push(nextEmoji);
              }
              return string3.length;
            }
            splitGraphemes(str) {
              const res = [];
              let index = 0;
              let brk;
              while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
                res.push(str.slice(index, brk));
                index = brk;
              }
              if (index < str.length) {
                res.push(str.slice(index));
              }
              return res;
            }
            iterateGraphemes(str) {
              return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
            }
            countGraphemes(str) {
              let count = 0;
              let index = 0;
              let brk;
              while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
                index = brk;
                count++;
              }
              if (index < str.length) {
                count++;
              }
              return count;
            }
            static getGraphemeBreakProperty(code2) {
              if (code2 < 48905) {
                if (code2 < 44116) {
                  if (code2 < 4141) {
                    if (code2 < 2818) {
                      if (code2 < 2363) {
                        if (code2 < 1759) {
                          if (code2 < 1471) {
                            if (code2 < 127) {
                              if (code2 < 11) {
                                if (code2 < 10) {
                                  if (0 <= code2 && code2 <= 9) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 === 10) {
                                    return boundaries_1.CLUSTER_BREAK.LF;
                                  }
                                }
                              } else {
                                if (code2 < 13) {
                                  if (11 <= code2 && code2 <= 12) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 14) {
                                    if (code2 === 13) {
                                      return boundaries_1.CLUSTER_BREAK.CR;
                                    }
                                  } else {
                                    if (14 <= code2 && code2 <= 31) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 768) {
                                if (code2 < 173) {
                                  if (127 <= code2 && code2 <= 159) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 === 173) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              } else {
                                if (code2 < 1155) {
                                  if (768 <= code2 && code2 <= 879) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1425) {
                                    if (1155 <= code2 && code2 <= 1161) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (1425 <= code2 && code2 <= 1469) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 1552) {
                              if (code2 < 1476) {
                                if (code2 < 1473) {
                                  if (code2 === 1471) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1473 <= code2 && code2 <= 1474) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 1479) {
                                  if (1476 <= code2 && code2 <= 1477) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1536) {
                                    if (code2 === 1479) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (1536 <= code2 && code2 <= 1541) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 1648) {
                                if (code2 < 1564) {
                                  if (1552 <= code2 && code2 <= 1562) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1611) {
                                    if (code2 === 1564) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (1611 <= code2 && code2 <= 1631) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 1750) {
                                  if (code2 === 1648) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 1757) {
                                    if (1750 <= code2 && code2 <= 1756) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 1757) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2075) {
                            if (code2 < 1840) {
                              if (code2 < 1770) {
                                if (code2 < 1767) {
                                  if (1759 <= code2 && code2 <= 1764) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1767 <= code2 && code2 <= 1768) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 1807) {
                                  if (1770 <= code2 && code2 <= 1773) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 1807) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                  if (code2 === 1809) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2027) {
                                if (code2 < 1958) {
                                  if (1840 <= code2 && code2 <= 1866) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1958 <= code2 && code2 <= 1968) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2045) {
                                  if (2027 <= code2 && code2 <= 2035) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2070) {
                                    if (code2 === 2045) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2070 <= code2 && code2 <= 2073) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2200) {
                              if (code2 < 2089) {
                                if (code2 < 2085) {
                                  if (2075 <= code2 && code2 <= 2083) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2085 <= code2 && code2 <= 2087) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2137) {
                                  if (2089 <= code2 && code2 <= 2093) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2192) {
                                    if (2137 <= code2 && code2 <= 2139) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2192 <= code2 && code2 <= 2193) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2275) {
                                if (code2 < 2250) {
                                  if (2200 <= code2 && code2 <= 2207) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2274) {
                                    if (2250 <= code2 && code2 <= 2273) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2274) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2307) {
                                  if (2275 <= code2 && code2 <= 2306) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2307) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 2362) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 2561) {
                          if (code2 < 2434) {
                            if (code2 < 2381) {
                              if (code2 < 2366) {
                                if (code2 === 2363) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 2364) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2369) {
                                  if (2366 <= code2 && code2 <= 2368) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2377) {
                                    if (2369 <= code2 && code2 <= 2376) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2377 <= code2 && code2 <= 2380) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2385) {
                                if (code2 < 2382) {
                                  if (code2 === 2381) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2382 <= code2 && code2 <= 2383) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2402) {
                                  if (2385 <= code2 && code2 <= 2391) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2433) {
                                    if (2402 <= code2 && code2 <= 2403) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2433) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2503) {
                              if (code2 < 2494) {
                                if (code2 < 2492) {
                                  if (2434 <= code2 && code2 <= 2435) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 2492) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2495) {
                                  if (code2 === 2494) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2497) {
                                    if (2495 <= code2 && code2 <= 2496) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2497 <= code2 && code2 <= 2500) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2519) {
                                if (code2 < 2507) {
                                  if (2503 <= code2 && code2 <= 2504) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2509) {
                                    if (2507 <= code2 && code2 <= 2508) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 2509) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2530) {
                                  if (code2 === 2519) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2558) {
                                    if (2530 <= code2 && code2 <= 2531) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2558) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 2691) {
                            if (code2 < 2631) {
                              if (code2 < 2620) {
                                if (code2 < 2563) {
                                  if (2561 <= code2 && code2 <= 2562) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 2563) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2622) {
                                  if (code2 === 2620) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2625) {
                                    if (2622 <= code2 && code2 <= 2624) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2625 <= code2 && code2 <= 2626) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2672) {
                                if (code2 < 2635) {
                                  if (2631 <= code2 && code2 <= 2632) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2641) {
                                    if (2635 <= code2 && code2 <= 2637) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2641) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2677) {
                                  if (2672 <= code2 && code2 <= 2673) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2689) {
                                    if (code2 === 2677) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2689 <= code2 && code2 <= 2690) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 2761) {
                              if (code2 < 2750) {
                                if (code2 === 2691) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 2748) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 2753) {
                                  if (2750 <= code2 && code2 <= 2752) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2759) {
                                    if (2753 <= code2 && code2 <= 2757) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2759 <= code2 && code2 <= 2760) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2786) {
                                if (code2 < 2763) {
                                  if (code2 === 2761) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 2765) {
                                    if (2763 <= code2 && code2 <= 2764) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 2765) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 2810) {
                                  if (2786 <= code2 && code2 <= 2787) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2817) {
                                    if (2810 <= code2 && code2 <= 2815) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 2817) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 3315) {
                        if (code2 < 3076) {
                          if (code2 < 2946) {
                            if (code2 < 2887) {
                              if (code2 < 2878) {
                                if (code2 < 2876) {
                                  if (2818 <= code2 && code2 <= 2819) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 2876) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 2880) {
                                  if (2878 <= code2 && code2 <= 2879) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2881) {
                                    if (code2 === 2880) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (2881 <= code2 && code2 <= 2884) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 2893) {
                                if (code2 < 2891) {
                                  if (2887 <= code2 && code2 <= 2888) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2891 <= code2 && code2 <= 2892) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 2901) {
                                  if (code2 === 2893) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 2914) {
                                    if (2901 <= code2 && code2 <= 2903) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (2914 <= code2 && code2 <= 2915) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3014) {
                              if (code2 < 3007) {
                                if (code2 === 2946) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3006) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3008) {
                                  if (code2 === 3007) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3009) {
                                    if (code2 === 3008) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3009 <= code2 && code2 <= 3010) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3031) {
                                if (code2 < 3018) {
                                  if (3014 <= code2 && code2 <= 3016) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3021) {
                                    if (3018 <= code2 && code2 <= 3020) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3021) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3072) {
                                  if (code2 === 3031) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3073) {
                                    if (code2 === 3072) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3073 <= code2 && code2 <= 3075) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3262) {
                            if (code2 < 3146) {
                              if (code2 < 3134) {
                                if (code2 === 3076) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3132) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3137) {
                                  if (3134 <= code2 && code2 <= 3136) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3142) {
                                    if (3137 <= code2 && code2 <= 3140) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3142 <= code2 && code2 <= 3144) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3201) {
                                if (code2 < 3157) {
                                  if (3146 <= code2 && code2 <= 3149) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3170) {
                                    if (3157 <= code2 && code2 <= 3158) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3170 <= code2 && code2 <= 3171) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3202) {
                                  if (code2 === 3201) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3260) {
                                    if (3202 <= code2 && code2 <= 3203) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3260) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3270) {
                              if (code2 < 3264) {
                                if (code2 === 3262) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 3263) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3266) {
                                  if (3264 <= code2 && code2 <= 3265) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3267) {
                                    if (code2 === 3266) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3267 <= code2 && code2 <= 3268) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3276) {
                                if (code2 < 3271) {
                                  if (code2 === 3270) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3274) {
                                    if (3271 <= code2 && code2 <= 3272) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3274 <= code2 && code2 <= 3275) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3285) {
                                  if (3276 <= code2 && code2 <= 3277) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3298) {
                                    if (3285 <= code2 && code2 <= 3286) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3298 <= code2 && code2 <= 3299) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 3551) {
                          if (code2 < 3406) {
                            if (code2 < 3391) {
                              if (code2 < 3330) {
                                if (code2 < 3328) {
                                  if (code2 === 3315) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3328 <= code2 && code2 <= 3329) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 3387) {
                                  if (3330 <= code2 && code2 <= 3331) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3390) {
                                    if (3387 <= code2 && code2 <= 3388) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 3390) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3398) {
                                if (code2 < 3393) {
                                  if (3391 <= code2 && code2 <= 3392) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3393 <= code2 && code2 <= 3396) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 3402) {
                                  if (3398 <= code2 && code2 <= 3400) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3405) {
                                    if (3402 <= code2 && code2 <= 3404) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 3405) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3530) {
                              if (code2 < 3426) {
                                if (code2 === 3406) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code2 === 3415) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3457) {
                                  if (3426 <= code2 && code2 <= 3427) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3458) {
                                    if (code2 === 3457) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3458 <= code2 && code2 <= 3459) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3538) {
                                if (code2 < 3535) {
                                  if (code2 === 3530) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3536) {
                                    if (code2 === 3535) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3536 <= code2 && code2 <= 3537) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3542) {
                                  if (3538 <= code2 && code2 <= 3540) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3544) {
                                    if (code2 === 3542) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3544 <= code2 && code2 <= 3550) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 3893) {
                            if (code2 < 3655) {
                              if (code2 < 3633) {
                                if (code2 < 3570) {
                                  if (code2 === 3551) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3570 <= code2 && code2 <= 3571) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 3635) {
                                  if (code2 === 3633) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3636) {
                                    if (code2 === 3635) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3636 <= code2 && code2 <= 3642) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3764) {
                                if (code2 < 3761) {
                                  if (3655 <= code2 && code2 <= 3662) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 3761) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 3763) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 3784) {
                                  if (3764 <= code2 && code2 <= 3772) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3864) {
                                    if (3784 <= code2 && code2 <= 3790) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3864 <= code2 && code2 <= 3865) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 3967) {
                              if (code2 < 3897) {
                                if (code2 === 3893) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 3895) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 3902) {
                                  if (code2 === 3897) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 3953) {
                                    if (3902 <= code2 && code2 <= 3903) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (3953 <= code2 && code2 <= 3966) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 3981) {
                                if (code2 < 3968) {
                                  if (code2 === 3967) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 3974) {
                                    if (3968 <= code2 && code2 <= 3972) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (3974 <= code2 && code2 <= 3975) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 3993) {
                                  if (3981 <= code2 && code2 <= 3991) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4038) {
                                    if (3993 <= code2 && code2 <= 4028) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 4038) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 7204) {
                      if (code2 < 6448) {
                        if (code2 < 5938) {
                          if (code2 < 4226) {
                            if (code2 < 4157) {
                              if (code2 < 4146) {
                                if (code2 < 4145) {
                                  if (4141 <= code2 && code2 <= 4144) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 4145) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 4153) {
                                  if (4146 <= code2 && code2 <= 4151) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4155) {
                                    if (4153 <= code2 && code2 <= 4154) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (4155 <= code2 && code2 <= 4156) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 4184) {
                                if (code2 < 4182) {
                                  if (4157 <= code2 && code2 <= 4158) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4182 <= code2 && code2 <= 4183) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 4190) {
                                  if (4184 <= code2 && code2 <= 4185) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 4209) {
                                    if (4190 <= code2 && code2 <= 4192) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (4209 <= code2 && code2 <= 4212) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 4352) {
                              if (code2 < 4229) {
                                if (code2 === 4226) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 4228) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 4237) {
                                  if (4229 <= code2 && code2 <= 4230) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 4237) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 4253) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 4957) {
                                if (code2 < 4448) {
                                  if (4352 <= code2 && code2 <= 4447) {
                                    return boundaries_1.CLUSTER_BREAK.L;
                                  }
                                } else {
                                  if (code2 < 4520) {
                                    if (4448 <= code2 && code2 <= 4519) {
                                      return boundaries_1.CLUSTER_BREAK.V;
                                    }
                                  } else {
                                    if (4520 <= code2 && code2 <= 4607) {
                                      return boundaries_1.CLUSTER_BREAK.T;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 5906) {
                                  if (4957 <= code2 && code2 <= 4959) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 5909) {
                                    if (5906 <= code2 && code2 <= 5908) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 5909) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 6089) {
                            if (code2 < 6070) {
                              if (code2 < 5970) {
                                if (code2 < 5940) {
                                  if (5938 <= code2 && code2 <= 5939) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 5940) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 6002) {
                                  if (5970 <= code2 && code2 <= 5971) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6068) {
                                    if (6002 <= code2 && code2 <= 6003) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6068 <= code2 && code2 <= 6069) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6078) {
                                if (code2 < 6071) {
                                  if (code2 === 6070) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (6071 <= code2 && code2 <= 6077) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6086) {
                                  if (6078 <= code2 && code2 <= 6085) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6087) {
                                    if (code2 === 6086) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6087 <= code2 && code2 <= 6088) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6277) {
                              if (code2 < 6155) {
                                if (code2 < 6109) {
                                  if (6089 <= code2 && code2 <= 6099) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6109) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6158) {
                                  if (6155 <= code2 && code2 <= 6157) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6158) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                  if (code2 === 6159) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6435) {
                                if (code2 < 6313) {
                                  if (6277 <= code2 && code2 <= 6278) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6432) {
                                    if (code2 === 6313) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6432 <= code2 && code2 <= 6434) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 6439) {
                                  if (6435 <= code2 && code2 <= 6438) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6441) {
                                    if (6439 <= code2 && code2 <= 6440) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6441 <= code2 && code2 <= 6443) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 6971) {
                          if (code2 < 6744) {
                            if (code2 < 6681) {
                              if (code2 < 6451) {
                                if (code2 < 6450) {
                                  if (6448 <= code2 && code2 <= 6449) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6450) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6457) {
                                  if (6451 <= code2 && code2 <= 6456) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6679) {
                                    if (6457 <= code2 && code2 <= 6459) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6679 <= code2 && code2 <= 6680) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6741) {
                                if (code2 < 6683) {
                                  if (6681 <= code2 && code2 <= 6682) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6683) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6742) {
                                  if (code2 === 6741) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 6742) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 6743) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 6771) {
                              if (code2 < 6754) {
                                if (code2 < 6752) {
                                  if (6744 <= code2 && code2 <= 6750) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 6752) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 6757) {
                                  if (code2 === 6754) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6765) {
                                    if (6757 <= code2 && code2 <= 6764) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6765 <= code2 && code2 <= 6770) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 6912) {
                                if (code2 < 6783) {
                                  if (6771 <= code2 && code2 <= 6780) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6832) {
                                    if (code2 === 6783) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6832 <= code2 && code2 <= 6862) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 6916) {
                                  if (6912 <= code2 && code2 <= 6915) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 6964) {
                                    if (code2 === 6916) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (6964 <= code2 && code2 <= 6970) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 7080) {
                            if (code2 < 7019) {
                              if (code2 < 6973) {
                                if (code2 === 6971) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 6972) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 6978) {
                                  if (6973 <= code2 && code2 <= 6977) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 6979) {
                                    if (code2 === 6978) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (6979 <= code2 && code2 <= 6980) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7073) {
                                if (code2 < 7040) {
                                  if (7019 <= code2 && code2 <= 7027) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 7042) {
                                    if (7040 <= code2 && code2 <= 7041) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 7042) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 7074) {
                                  if (code2 === 7073) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7078) {
                                    if (7074 <= code2 && code2 <= 7077) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7078 <= code2 && code2 <= 7079) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 7144) {
                              if (code2 < 7083) {
                                if (code2 < 7082) {
                                  if (7080 <= code2 && code2 <= 7081) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7082) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 7142) {
                                  if (7083 <= code2 && code2 <= 7085) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7142) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 7143) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7150) {
                                if (code2 < 7146) {
                                  if (7144 <= code2 && code2 <= 7145) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 7149) {
                                    if (7146 <= code2 && code2 <= 7148) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 7149) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 7151) {
                                  if (code2 === 7150) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7154) {
                                    if (7151 <= code2 && code2 <= 7153) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7154 <= code2 && code2 <= 7155) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 43346) {
                        if (code2 < 11647) {
                          if (code2 < 7415) {
                            if (code2 < 7380) {
                              if (code2 < 7220) {
                                if (code2 < 7212) {
                                  if (7204 <= code2 && code2 <= 7211) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7212 <= code2 && code2 <= 7219) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 7222) {
                                  if (7220 <= code2 && code2 <= 7221) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 7376) {
                                    if (7222 <= code2 && code2 <= 7223) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (7376 <= code2 && code2 <= 7378) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 7394) {
                                if (code2 < 7393) {
                                  if (7380 <= code2 && code2 <= 7392) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7393) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 7405) {
                                  if (7394 <= code2 && code2 <= 7400) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 7405) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 7412) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 8205) {
                              if (code2 < 7616) {
                                if (code2 < 7416) {
                                  if (code2 === 7415) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7416 <= code2 && code2 <= 7417) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 8203) {
                                  if (7616 <= code2 && code2 <= 7679) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 8203) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                  if (code2 === 8204) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 8288) {
                                if (code2 < 8206) {
                                  if (code2 === 8205) {
                                    return boundaries_1.CLUSTER_BREAK.ZWJ;
                                  }
                                } else {
                                  if (code2 < 8232) {
                                    if (8206 <= code2 && code2 <= 8207) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (8232 <= code2 && code2 <= 8238) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 8400) {
                                  if (8288 <= code2 && code2 <= 8303) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 11503) {
                                    if (8400 <= code2 && code2 <= 8432) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (11503 <= code2 && code2 <= 11505) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 43043) {
                            if (code2 < 42612) {
                              if (code2 < 12330) {
                                if (code2 < 11744) {
                                  if (code2 === 11647) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (11744 <= code2 && code2 <= 11775) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 12441) {
                                  if (12330 <= code2 && code2 <= 12335) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 42607) {
                                    if (12441 <= code2 && code2 <= 12442) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (42607 <= code2 && code2 <= 42610) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43010) {
                                if (code2 < 42654) {
                                  if (42612 <= code2 && code2 <= 42621) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 42736) {
                                    if (42654 <= code2 && code2 <= 42655) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (42736 <= code2 && code2 <= 42737) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 43014) {
                                  if (code2 === 43010) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43014) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43019) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43188) {
                              if (code2 < 43047) {
                                if (code2 < 43045) {
                                  if (43043 <= code2 && code2 <= 43044) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43045 <= code2 && code2 <= 43046) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43052) {
                                  if (code2 === 43047) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43136) {
                                    if (code2 === 43052) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43136 <= code2 && code2 <= 43137) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43263) {
                                if (code2 < 43204) {
                                  if (43188 <= code2 && code2 <= 43203) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43232) {
                                    if (43204 <= code2 && code2 <= 43205) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43232 <= code2 && code2 <= 43249) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 43302) {
                                  if (code2 === 43263) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 43335) {
                                    if (43302 <= code2 && code2 <= 43309) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43335 <= code2 && code2 <= 43345) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 43698) {
                          if (code2 < 43493) {
                            if (code2 < 43444) {
                              if (code2 < 43392) {
                                if (code2 < 43360) {
                                  if (43346 <= code2 && code2 <= 43347) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43360 <= code2 && code2 <= 43388) {
                                    return boundaries_1.CLUSTER_BREAK.L;
                                  }
                                }
                              } else {
                                if (code2 < 43395) {
                                  if (43392 <= code2 && code2 <= 43394) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43395) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 43443) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43450) {
                                if (code2 < 43446) {
                                  if (43444 <= code2 && code2 <= 43445) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43446 <= code2 && code2 <= 43449) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43452) {
                                  if (43450 <= code2 && code2 <= 43451) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43454) {
                                    if (43452 <= code2 && code2 <= 43453) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43454 <= code2 && code2 <= 43456) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 43573) {
                              if (code2 < 43567) {
                                if (code2 < 43561) {
                                  if (code2 === 43493) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43561 <= code2 && code2 <= 43566) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43569) {
                                  if (43567 <= code2 && code2 <= 43568) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 43571) {
                                    if (43569 <= code2 && code2 <= 43570) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (43571 <= code2 && code2 <= 43572) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43597) {
                                if (code2 < 43587) {
                                  if (43573 <= code2 && code2 <= 43574) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43587) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43596) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43644) {
                                  if (code2 === 43597) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 43644) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43696) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44006) {
                            if (code2 < 43756) {
                              if (code2 < 43710) {
                                if (code2 < 43703) {
                                  if (43698 <= code2 && code2 <= 43700) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43703 <= code2 && code2 <= 43704) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 43713) {
                                  if (43710 <= code2 && code2 <= 43711) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 43713) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 43755) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 43766) {
                                if (code2 < 43758) {
                                  if (43756 <= code2 && code2 <= 43757) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 43765) {
                                    if (43758 <= code2 && code2 <= 43759) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 43765) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44003) {
                                  if (code2 === 43766) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 44005) {
                                    if (44003 <= code2 && code2 <= 44004) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 44005) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44032) {
                              if (code2 < 44009) {
                                if (code2 < 44008) {
                                  if (44006 <= code2 && code2 <= 44007) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 44008) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 44012) {
                                  if (44009 <= code2 && code2 <= 44010) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 44012) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 44013) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44061) {
                                if (code2 < 44033) {
                                  if (code2 === 44032) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44060) {
                                    if (44033 <= code2 && code2 <= 44059) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44060) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44088) {
                                  if (44061 <= code2 && code2 <= 44087) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44089) {
                                    if (code2 === 44088) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44089 <= code2 && code2 <= 44115) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 46497) {
                    if (code2 < 45293) {
                      if (code2 < 44704) {
                        if (code2 < 44397) {
                          if (code2 < 44256) {
                            if (code2 < 44173) {
                              if (code2 < 44144) {
                                if (code2 < 44117) {
                                  if (code2 === 44116) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44117 <= code2 && code2 <= 44143) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44145) {
                                  if (code2 === 44144) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44172) {
                                    if (44145 <= code2 && code2 <= 44171) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44172) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44201) {
                                if (code2 < 44200) {
                                  if (44173 <= code2 && code2 <= 44199) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44200) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44228) {
                                  if (44201 <= code2 && code2 <= 44227) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44229) {
                                    if (code2 === 44228) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44229 <= code2 && code2 <= 44255) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44313) {
                              if (code2 < 44284) {
                                if (code2 < 44257) {
                                  if (code2 === 44256) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44257 <= code2 && code2 <= 44283) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44285) {
                                  if (code2 === 44284) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44312) {
                                    if (44285 <= code2 && code2 <= 44311) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44312) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44368) {
                                if (code2 < 44340) {
                                  if (44313 <= code2 && code2 <= 44339) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44341) {
                                    if (code2 === 44340) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44341 <= code2 && code2 <= 44367) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44369) {
                                  if (code2 === 44368) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44396) {
                                    if (44369 <= code2 && code2 <= 44395) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44396) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 44537) {
                            if (code2 < 44480) {
                              if (code2 < 44425) {
                                if (code2 < 44424) {
                                  if (44397 <= code2 && code2 <= 44423) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44424) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44452) {
                                  if (44425 <= code2 && code2 <= 44451) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44453) {
                                    if (code2 === 44452) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44453 <= code2 && code2 <= 44479) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44508) {
                                if (code2 < 44481) {
                                  if (code2 === 44480) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44481 <= code2 && code2 <= 44507) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44509) {
                                  if (code2 === 44508) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44536) {
                                    if (44509 <= code2 && code2 <= 44535) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44536) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44620) {
                              if (code2 < 44565) {
                                if (code2 < 44564) {
                                  if (44537 <= code2 && code2 <= 44563) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44564) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44592) {
                                  if (44565 <= code2 && code2 <= 44591) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44593) {
                                    if (code2 === 44592) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44593 <= code2 && code2 <= 44619) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44649) {
                                if (code2 < 44621) {
                                  if (code2 === 44620) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44648) {
                                    if (44621 <= code2 && code2 <= 44647) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44648) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44676) {
                                  if (44649 <= code2 && code2 <= 44675) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44677) {
                                    if (code2 === 44676) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44677 <= code2 && code2 <= 44703) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 44985) {
                          if (code2 < 44844) {
                            if (code2 < 44761) {
                              if (code2 < 44732) {
                                if (code2 < 44705) {
                                  if (code2 === 44704) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44705 <= code2 && code2 <= 44731) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44733) {
                                  if (code2 === 44732) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44760) {
                                    if (44733 <= code2 && code2 <= 44759) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44760) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44789) {
                                if (code2 < 44788) {
                                  if (44761 <= code2 && code2 <= 44787) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 44788) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 44816) {
                                  if (44789 <= code2 && code2 <= 44815) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44817) {
                                    if (code2 === 44816) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44817 <= code2 && code2 <= 44843) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 44901) {
                              if (code2 < 44872) {
                                if (code2 < 44845) {
                                  if (code2 === 44844) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44845 <= code2 && code2 <= 44871) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 44873) {
                                  if (code2 === 44872) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44900) {
                                    if (44873 <= code2 && code2 <= 44899) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44900) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 44956) {
                                if (code2 < 44928) {
                                  if (44901 <= code2 && code2 <= 44927) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 44929) {
                                    if (code2 === 44928) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (44929 <= code2 && code2 <= 44955) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 44957) {
                                  if (code2 === 44956) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 44984) {
                                    if (44957 <= code2 && code2 <= 44983) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 44984) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45152) {
                            if (code2 < 45068) {
                              if (code2 < 45013) {
                                if (code2 < 45012) {
                                  if (44985 <= code2 && code2 <= 45011) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45012) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45040) {
                                  if (45013 <= code2 && code2 <= 45039) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45041) {
                                    if (code2 === 45040) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45041 <= code2 && code2 <= 45067) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45097) {
                                if (code2 < 45069) {
                                  if (code2 === 45068) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45096) {
                                    if (45069 <= code2 && code2 <= 45095) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45096) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45124) {
                                  if (45097 <= code2 && code2 <= 45123) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45125) {
                                    if (code2 === 45124) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45125 <= code2 && code2 <= 45151) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45209) {
                              if (code2 < 45180) {
                                if (code2 < 45153) {
                                  if (code2 === 45152) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45153 <= code2 && code2 <= 45179) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45181) {
                                  if (code2 === 45180) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45208) {
                                    if (45181 <= code2 && code2 <= 45207) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45208) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45264) {
                                if (code2 < 45236) {
                                  if (45209 <= code2 && code2 <= 45235) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45237) {
                                    if (code2 === 45236) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45237 <= code2 && code2 <= 45263) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45265) {
                                  if (code2 === 45264) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45292) {
                                    if (45265 <= code2 && code2 <= 45291) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45292) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 45908) {
                        if (code2 < 45600) {
                          if (code2 < 45433) {
                            if (code2 < 45376) {
                              if (code2 < 45321) {
                                if (code2 < 45320) {
                                  if (45293 <= code2 && code2 <= 45319) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45320) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45348) {
                                  if (45321 <= code2 && code2 <= 45347) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45349) {
                                    if (code2 === 45348) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45349 <= code2 && code2 <= 45375) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45404) {
                                if (code2 < 45377) {
                                  if (code2 === 45376) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45377 <= code2 && code2 <= 45403) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45405) {
                                  if (code2 === 45404) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45432) {
                                    if (45405 <= code2 && code2 <= 45431) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45432) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45516) {
                              if (code2 < 45461) {
                                if (code2 < 45460) {
                                  if (45433 <= code2 && code2 <= 45459) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45460) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45488) {
                                  if (45461 <= code2 && code2 <= 45487) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45489) {
                                    if (code2 === 45488) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45489 <= code2 && code2 <= 45515) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45545) {
                                if (code2 < 45517) {
                                  if (code2 === 45516) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45544) {
                                    if (45517 <= code2 && code2 <= 45543) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45544) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45572) {
                                  if (45545 <= code2 && code2 <= 45571) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45573) {
                                    if (code2 === 45572) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45573 <= code2 && code2 <= 45599) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 45741) {
                            if (code2 < 45657) {
                              if (code2 < 45628) {
                                if (code2 < 45601) {
                                  if (code2 === 45600) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45601 <= code2 && code2 <= 45627) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45629) {
                                  if (code2 === 45628) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45656) {
                                    if (45629 <= code2 && code2 <= 45655) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45656) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45712) {
                                if (code2 < 45684) {
                                  if (45657 <= code2 && code2 <= 45683) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45685) {
                                    if (code2 === 45684) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45685 <= code2 && code2 <= 45711) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45713) {
                                  if (code2 === 45712) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45740) {
                                    if (45713 <= code2 && code2 <= 45739) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45740) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 45824) {
                              if (code2 < 45769) {
                                if (code2 < 45768) {
                                  if (45741 <= code2 && code2 <= 45767) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45768) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 45796) {
                                  if (45769 <= code2 && code2 <= 45795) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45797) {
                                    if (code2 === 45796) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45797 <= code2 && code2 <= 45823) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45853) {
                                if (code2 < 45825) {
                                  if (code2 === 45824) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45852) {
                                    if (45825 <= code2 && code2 <= 45851) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45852) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 45880) {
                                  if (45853 <= code2 && code2 <= 45879) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 45881) {
                                    if (code2 === 45880) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (45881 <= code2 && code2 <= 45907) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 46189) {
                          if (code2 < 46048) {
                            if (code2 < 45965) {
                              if (code2 < 45936) {
                                if (code2 < 45909) {
                                  if (code2 === 45908) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45909 <= code2 && code2 <= 45935) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 45937) {
                                  if (code2 === 45936) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 45964) {
                                    if (45937 <= code2 && code2 <= 45963) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 45964) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 45993) {
                                if (code2 < 45992) {
                                  if (45965 <= code2 && code2 <= 45991) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 45992) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46020) {
                                  if (45993 <= code2 && code2 <= 46019) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46021) {
                                    if (code2 === 46020) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46021 <= code2 && code2 <= 46047) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46105) {
                              if (code2 < 46076) {
                                if (code2 < 46049) {
                                  if (code2 === 46048) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46049 <= code2 && code2 <= 46075) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46077) {
                                  if (code2 === 46076) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46104) {
                                    if (46077 <= code2 && code2 <= 46103) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46104) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46160) {
                                if (code2 < 46132) {
                                  if (46105 <= code2 && code2 <= 46131) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46133) {
                                    if (code2 === 46132) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46133 <= code2 && code2 <= 46159) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46161) {
                                  if (code2 === 46160) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46188) {
                                    if (46161 <= code2 && code2 <= 46187) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46188) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46356) {
                            if (code2 < 46272) {
                              if (code2 < 46217) {
                                if (code2 < 46216) {
                                  if (46189 <= code2 && code2 <= 46215) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46216) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46244) {
                                  if (46217 <= code2 && code2 <= 46243) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46245) {
                                    if (code2 === 46244) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46245 <= code2 && code2 <= 46271) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46301) {
                                if (code2 < 46273) {
                                  if (code2 === 46272) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46300) {
                                    if (46273 <= code2 && code2 <= 46299) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46300) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46328) {
                                  if (46301 <= code2 && code2 <= 46327) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46329) {
                                    if (code2 === 46328) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46329 <= code2 && code2 <= 46355) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46413) {
                              if (code2 < 46384) {
                                if (code2 < 46357) {
                                  if (code2 === 46356) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46357 <= code2 && code2 <= 46383) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46385) {
                                  if (code2 === 46384) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46412) {
                                    if (46385 <= code2 && code2 <= 46411) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46412) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46468) {
                                if (code2 < 46440) {
                                  if (46413 <= code2 && code2 <= 46439) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46441) {
                                    if (code2 === 46440) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46441 <= code2 && code2 <= 46467) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46469) {
                                  if (code2 === 46468) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46496) {
                                    if (46469 <= code2 && code2 <= 46495) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46496) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 47701) {
                      if (code2 < 47112) {
                        if (code2 < 46804) {
                          if (code2 < 46637) {
                            if (code2 < 46580) {
                              if (code2 < 46525) {
                                if (code2 < 46524) {
                                  if (46497 <= code2 && code2 <= 46523) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46524) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46552) {
                                  if (46525 <= code2 && code2 <= 46551) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46553) {
                                    if (code2 === 46552) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46553 <= code2 && code2 <= 46579) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46608) {
                                if (code2 < 46581) {
                                  if (code2 === 46580) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46581 <= code2 && code2 <= 46607) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46609) {
                                  if (code2 === 46608) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46636) {
                                    if (46609 <= code2 && code2 <= 46635) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46636) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 46720) {
                              if (code2 < 46665) {
                                if (code2 < 46664) {
                                  if (46637 <= code2 && code2 <= 46663) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46664) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 46692) {
                                  if (46665 <= code2 && code2 <= 46691) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46693) {
                                    if (code2 === 46692) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46693 <= code2 && code2 <= 46719) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46749) {
                                if (code2 < 46721) {
                                  if (code2 === 46720) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46748) {
                                    if (46721 <= code2 && code2 <= 46747) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46748) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46776) {
                                  if (46749 <= code2 && code2 <= 46775) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46777) {
                                    if (code2 === 46776) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46777 <= code2 && code2 <= 46803) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 46945) {
                            if (code2 < 46861) {
                              if (code2 < 46832) {
                                if (code2 < 46805) {
                                  if (code2 === 46804) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46805 <= code2 && code2 <= 46831) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 46833) {
                                  if (code2 === 46832) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46860) {
                                    if (46833 <= code2 && code2 <= 46859) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46860) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 46916) {
                                if (code2 < 46888) {
                                  if (46861 <= code2 && code2 <= 46887) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 46889) {
                                    if (code2 === 46888) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (46889 <= code2 && code2 <= 46915) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 46917) {
                                  if (code2 === 46916) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 46944) {
                                    if (46917 <= code2 && code2 <= 46943) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 46944) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47028) {
                              if (code2 < 46973) {
                                if (code2 < 46972) {
                                  if (46945 <= code2 && code2 <= 46971) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 46972) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47e3) {
                                  if (46973 <= code2 && code2 <= 46999) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47001) {
                                    if (code2 === 47e3) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47001 <= code2 && code2 <= 47027) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47057) {
                                if (code2 < 47029) {
                                  if (code2 === 47028) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47056) {
                                    if (47029 <= code2 && code2 <= 47055) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47056) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47084) {
                                  if (47057 <= code2 && code2 <= 47083) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47085) {
                                    if (code2 === 47084) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47085 <= code2 && code2 <= 47111) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 47393) {
                          if (code2 < 47252) {
                            if (code2 < 47169) {
                              if (code2 < 47140) {
                                if (code2 < 47113) {
                                  if (code2 === 47112) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47113 <= code2 && code2 <= 47139) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47141) {
                                  if (code2 === 47140) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47168) {
                                    if (47141 <= code2 && code2 <= 47167) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47168) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47197) {
                                if (code2 < 47196) {
                                  if (47169 <= code2 && code2 <= 47195) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47196) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47224) {
                                  if (47197 <= code2 && code2 <= 47223) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47225) {
                                    if (code2 === 47224) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47225 <= code2 && code2 <= 47251) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47309) {
                              if (code2 < 47280) {
                                if (code2 < 47253) {
                                  if (code2 === 47252) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47253 <= code2 && code2 <= 47279) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47281) {
                                  if (code2 === 47280) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47308) {
                                    if (47281 <= code2 && code2 <= 47307) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47308) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47364) {
                                if (code2 < 47336) {
                                  if (47309 <= code2 && code2 <= 47335) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47337) {
                                    if (code2 === 47336) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47337 <= code2 && code2 <= 47363) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47365) {
                                  if (code2 === 47364) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47392) {
                                    if (47365 <= code2 && code2 <= 47391) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47392) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 47560) {
                            if (code2 < 47476) {
                              if (code2 < 47421) {
                                if (code2 < 47420) {
                                  if (47393 <= code2 && code2 <= 47419) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47420) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47448) {
                                  if (47421 <= code2 && code2 <= 47447) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47449) {
                                    if (code2 === 47448) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47449 <= code2 && code2 <= 47475) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47505) {
                                if (code2 < 47477) {
                                  if (code2 === 47476) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47504) {
                                    if (47477 <= code2 && code2 <= 47503) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47504) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47532) {
                                  if (47505 <= code2 && code2 <= 47531) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47533) {
                                    if (code2 === 47532) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47533 <= code2 && code2 <= 47559) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47617) {
                              if (code2 < 47588) {
                                if (code2 < 47561) {
                                  if (code2 === 47560) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47561 <= code2 && code2 <= 47587) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47589) {
                                  if (code2 === 47588) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47616) {
                                    if (47589 <= code2 && code2 <= 47615) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47616) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47672) {
                                if (code2 < 47644) {
                                  if (47617 <= code2 && code2 <= 47643) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47645) {
                                    if (code2 === 47644) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47645 <= code2 && code2 <= 47671) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47673) {
                                  if (code2 === 47672) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47700) {
                                    if (47673 <= code2 && code2 <= 47699) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47700) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 48316) {
                        if (code2 < 48008) {
                          if (code2 < 47841) {
                            if (code2 < 47784) {
                              if (code2 < 47729) {
                                if (code2 < 47728) {
                                  if (47701 <= code2 && code2 <= 47727) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47728) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47756) {
                                  if (47729 <= code2 && code2 <= 47755) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47757) {
                                    if (code2 === 47756) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47757 <= code2 && code2 <= 47783) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47812) {
                                if (code2 < 47785) {
                                  if (code2 === 47784) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47785 <= code2 && code2 <= 47811) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 47813) {
                                  if (code2 === 47812) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47840) {
                                    if (47813 <= code2 && code2 <= 47839) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47840) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 47924) {
                              if (code2 < 47869) {
                                if (code2 < 47868) {
                                  if (47841 <= code2 && code2 <= 47867) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 47868) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 47896) {
                                  if (47869 <= code2 && code2 <= 47895) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47897) {
                                    if (code2 === 47896) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47897 <= code2 && code2 <= 47923) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 47953) {
                                if (code2 < 47925) {
                                  if (code2 === 47924) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 47952) {
                                    if (47925 <= code2 && code2 <= 47951) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 47952) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 47980) {
                                  if (47953 <= code2 && code2 <= 47979) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 47981) {
                                    if (code2 === 47980) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (47981 <= code2 && code2 <= 48007) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48149) {
                            if (code2 < 48065) {
                              if (code2 < 48036) {
                                if (code2 < 48009) {
                                  if (code2 === 48008) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48009 <= code2 && code2 <= 48035) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48037) {
                                  if (code2 === 48036) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48064) {
                                    if (48037 <= code2 && code2 <= 48063) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48064) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48120) {
                                if (code2 < 48092) {
                                  if (48065 <= code2 && code2 <= 48091) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48093) {
                                    if (code2 === 48092) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48093 <= code2 && code2 <= 48119) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48121) {
                                  if (code2 === 48120) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48148) {
                                    if (48121 <= code2 && code2 <= 48147) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48148) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48232) {
                              if (code2 < 48177) {
                                if (code2 < 48176) {
                                  if (48149 <= code2 && code2 <= 48175) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48176) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48204) {
                                  if (48177 <= code2 && code2 <= 48203) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48205) {
                                    if (code2 === 48204) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48205 <= code2 && code2 <= 48231) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48261) {
                                if (code2 < 48233) {
                                  if (code2 === 48232) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48260) {
                                    if (48233 <= code2 && code2 <= 48259) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48260) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48288) {
                                  if (48261 <= code2 && code2 <= 48287) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48289) {
                                    if (code2 === 48288) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48289 <= code2 && code2 <= 48315) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 48597) {
                          if (code2 < 48456) {
                            if (code2 < 48373) {
                              if (code2 < 48344) {
                                if (code2 < 48317) {
                                  if (code2 === 48316) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48317 <= code2 && code2 <= 48343) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48345) {
                                  if (code2 === 48344) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48372) {
                                    if (48345 <= code2 && code2 <= 48371) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48372) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48401) {
                                if (code2 < 48400) {
                                  if (48373 <= code2 && code2 <= 48399) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48400) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48428) {
                                  if (48401 <= code2 && code2 <= 48427) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48429) {
                                    if (code2 === 48428) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48429 <= code2 && code2 <= 48455) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48513) {
                              if (code2 < 48484) {
                                if (code2 < 48457) {
                                  if (code2 === 48456) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48457 <= code2 && code2 <= 48483) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48485) {
                                  if (code2 === 48484) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48512) {
                                    if (48485 <= code2 && code2 <= 48511) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48512) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48568) {
                                if (code2 < 48540) {
                                  if (48513 <= code2 && code2 <= 48539) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48541) {
                                    if (code2 === 48540) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48541 <= code2 && code2 <= 48567) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48569) {
                                  if (code2 === 48568) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48596) {
                                    if (48569 <= code2 && code2 <= 48595) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48596) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 48764) {
                            if (code2 < 48680) {
                              if (code2 < 48625) {
                                if (code2 < 48624) {
                                  if (48597 <= code2 && code2 <= 48623) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48624) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48652) {
                                  if (48625 <= code2 && code2 <= 48651) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48653) {
                                    if (code2 === 48652) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48653 <= code2 && code2 <= 48679) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48709) {
                                if (code2 < 48681) {
                                  if (code2 === 48680) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48708) {
                                    if (48681 <= code2 && code2 <= 48707) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48708) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48736) {
                                  if (48709 <= code2 && code2 <= 48735) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48737) {
                                    if (code2 === 48736) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48737 <= code2 && code2 <= 48763) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 48821) {
                              if (code2 < 48792) {
                                if (code2 < 48765) {
                                  if (code2 === 48764) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48765 <= code2 && code2 <= 48791) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 48793) {
                                  if (code2 === 48792) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48820) {
                                    if (48793 <= code2 && code2 <= 48819) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48820) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 48876) {
                                if (code2 < 48848) {
                                  if (48821 <= code2 && code2 <= 48847) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48849) {
                                    if (code2 === 48848) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48849 <= code2 && code2 <= 48875) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 48877) {
                                  if (code2 === 48876) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 48904) {
                                    if (48877 <= code2 && code2 <= 48903) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 48904) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 53720) {
                  if (code2 < 51312) {
                    if (code2 < 50108) {
                      if (code2 < 49493) {
                        if (code2 < 49212) {
                          if (code2 < 49045) {
                            if (code2 < 48988) {
                              if (code2 < 48933) {
                                if (code2 < 48932) {
                                  if (48905 <= code2 && code2 <= 48931) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 48932) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 48960) {
                                  if (48933 <= code2 && code2 <= 48959) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 48961) {
                                    if (code2 === 48960) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (48961 <= code2 && code2 <= 48987) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49016) {
                                if (code2 < 48989) {
                                  if (code2 === 48988) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48989 <= code2 && code2 <= 49015) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49017) {
                                  if (code2 === 49016) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49044) {
                                    if (49017 <= code2 && code2 <= 49043) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49044) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49128) {
                              if (code2 < 49073) {
                                if (code2 < 49072) {
                                  if (49045 <= code2 && code2 <= 49071) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49072) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49100) {
                                  if (49073 <= code2 && code2 <= 49099) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49101) {
                                    if (code2 === 49100) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49101 <= code2 && code2 <= 49127) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49157) {
                                if (code2 < 49129) {
                                  if (code2 === 49128) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49156) {
                                    if (49129 <= code2 && code2 <= 49155) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49156) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49184) {
                                  if (49157 <= code2 && code2 <= 49183) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49185) {
                                    if (code2 === 49184) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49185 <= code2 && code2 <= 49211) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49352) {
                            if (code2 < 49269) {
                              if (code2 < 49240) {
                                if (code2 < 49213) {
                                  if (code2 === 49212) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49213 <= code2 && code2 <= 49239) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49241) {
                                  if (code2 === 49240) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49268) {
                                    if (49241 <= code2 && code2 <= 49267) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49268) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49297) {
                                if (code2 < 49296) {
                                  if (49269 <= code2 && code2 <= 49295) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49296) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49324) {
                                  if (49297 <= code2 && code2 <= 49323) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49325) {
                                    if (code2 === 49324) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49325 <= code2 && code2 <= 49351) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49409) {
                              if (code2 < 49380) {
                                if (code2 < 49353) {
                                  if (code2 === 49352) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49353 <= code2 && code2 <= 49379) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49381) {
                                  if (code2 === 49380) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49408) {
                                    if (49381 <= code2 && code2 <= 49407) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49408) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49464) {
                                if (code2 < 49436) {
                                  if (49409 <= code2 && code2 <= 49435) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49437) {
                                    if (code2 === 49436) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49437 <= code2 && code2 <= 49463) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49465) {
                                  if (code2 === 49464) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49492) {
                                    if (49465 <= code2 && code2 <= 49491) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49492) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 49800) {
                          if (code2 < 49633) {
                            if (code2 < 49576) {
                              if (code2 < 49521) {
                                if (code2 < 49520) {
                                  if (49493 <= code2 && code2 <= 49519) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49520) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49548) {
                                  if (49521 <= code2 && code2 <= 49547) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49549) {
                                    if (code2 === 49548) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49549 <= code2 && code2 <= 49575) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49604) {
                                if (code2 < 49577) {
                                  if (code2 === 49576) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49577 <= code2 && code2 <= 49603) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49605) {
                                  if (code2 === 49604) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49632) {
                                    if (49605 <= code2 && code2 <= 49631) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49632) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 49716) {
                              if (code2 < 49661) {
                                if (code2 < 49660) {
                                  if (49633 <= code2 && code2 <= 49659) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49660) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49688) {
                                  if (49661 <= code2 && code2 <= 49687) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49689) {
                                    if (code2 === 49688) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49689 <= code2 && code2 <= 49715) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49745) {
                                if (code2 < 49717) {
                                  if (code2 === 49716) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49744) {
                                    if (49717 <= code2 && code2 <= 49743) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49744) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49772) {
                                  if (49745 <= code2 && code2 <= 49771) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49773) {
                                    if (code2 === 49772) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49773 <= code2 && code2 <= 49799) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 49941) {
                            if (code2 < 49857) {
                              if (code2 < 49828) {
                                if (code2 < 49801) {
                                  if (code2 === 49800) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49801 <= code2 && code2 <= 49827) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 49829) {
                                  if (code2 === 49828) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49856) {
                                    if (49829 <= code2 && code2 <= 49855) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49856) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 49912) {
                                if (code2 < 49884) {
                                  if (49857 <= code2 && code2 <= 49883) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49885) {
                                    if (code2 === 49884) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49885 <= code2 && code2 <= 49911) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 49913) {
                                  if (code2 === 49912) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 49940) {
                                    if (49913 <= code2 && code2 <= 49939) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 49940) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50024) {
                              if (code2 < 49969) {
                                if (code2 < 49968) {
                                  if (49941 <= code2 && code2 <= 49967) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 49968) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 49996) {
                                  if (49969 <= code2 && code2 <= 49995) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 49997) {
                                    if (code2 === 49996) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (49997 <= code2 && code2 <= 50023) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50053) {
                                if (code2 < 50025) {
                                  if (code2 === 50024) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50052) {
                                    if (50025 <= code2 && code2 <= 50051) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50052) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50080) {
                                  if (50053 <= code2 && code2 <= 50079) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50081) {
                                    if (code2 === 50080) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50081 <= code2 && code2 <= 50107) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 50697) {
                        if (code2 < 50389) {
                          if (code2 < 50248) {
                            if (code2 < 50165) {
                              if (code2 < 50136) {
                                if (code2 < 50109) {
                                  if (code2 === 50108) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50109 <= code2 && code2 <= 50135) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50137) {
                                  if (code2 === 50136) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50164) {
                                    if (50137 <= code2 && code2 <= 50163) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50164) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50193) {
                                if (code2 < 50192) {
                                  if (50165 <= code2 && code2 <= 50191) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50192) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50220) {
                                  if (50193 <= code2 && code2 <= 50219) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50221) {
                                    if (code2 === 50220) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50221 <= code2 && code2 <= 50247) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50305) {
                              if (code2 < 50276) {
                                if (code2 < 50249) {
                                  if (code2 === 50248) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50249 <= code2 && code2 <= 50275) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50277) {
                                  if (code2 === 50276) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50304) {
                                    if (50277 <= code2 && code2 <= 50303) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50304) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50360) {
                                if (code2 < 50332) {
                                  if (50305 <= code2 && code2 <= 50331) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50333) {
                                    if (code2 === 50332) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50333 <= code2 && code2 <= 50359) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50361) {
                                  if (code2 === 50360) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50388) {
                                    if (50361 <= code2 && code2 <= 50387) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50388) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 50556) {
                            if (code2 < 50472) {
                              if (code2 < 50417) {
                                if (code2 < 50416) {
                                  if (50389 <= code2 && code2 <= 50415) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50416) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50444) {
                                  if (50417 <= code2 && code2 <= 50443) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50445) {
                                    if (code2 === 50444) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50445 <= code2 && code2 <= 50471) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50501) {
                                if (code2 < 50473) {
                                  if (code2 === 50472) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50500) {
                                    if (50473 <= code2 && code2 <= 50499) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50500) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50528) {
                                  if (50501 <= code2 && code2 <= 50527) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50529) {
                                    if (code2 === 50528) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50529 <= code2 && code2 <= 50555) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50613) {
                              if (code2 < 50584) {
                                if (code2 < 50557) {
                                  if (code2 === 50556) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50557 <= code2 && code2 <= 50583) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50585) {
                                  if (code2 === 50584) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50612) {
                                    if (50585 <= code2 && code2 <= 50611) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50612) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50668) {
                                if (code2 < 50640) {
                                  if (50613 <= code2 && code2 <= 50639) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50641) {
                                    if (code2 === 50640) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50641 <= code2 && code2 <= 50667) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50669) {
                                  if (code2 === 50668) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50696) {
                                    if (50669 <= code2 && code2 <= 50695) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50696) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 51004) {
                          if (code2 < 50837) {
                            if (code2 < 50780) {
                              if (code2 < 50725) {
                                if (code2 < 50724) {
                                  if (50697 <= code2 && code2 <= 50723) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50724) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50752) {
                                  if (50725 <= code2 && code2 <= 50751) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50753) {
                                    if (code2 === 50752) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50753 <= code2 && code2 <= 50779) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50808) {
                                if (code2 < 50781) {
                                  if (code2 === 50780) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50781 <= code2 && code2 <= 50807) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 50809) {
                                  if (code2 === 50808) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50836) {
                                    if (50809 <= code2 && code2 <= 50835) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50836) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 50920) {
                              if (code2 < 50865) {
                                if (code2 < 50864) {
                                  if (50837 <= code2 && code2 <= 50863) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 50864) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 50892) {
                                  if (50865 <= code2 && code2 <= 50891) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50893) {
                                    if (code2 === 50892) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50893 <= code2 && code2 <= 50919) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 50949) {
                                if (code2 < 50921) {
                                  if (code2 === 50920) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 50948) {
                                    if (50921 <= code2 && code2 <= 50947) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 50948) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 50976) {
                                  if (50949 <= code2 && code2 <= 50975) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 50977) {
                                    if (code2 === 50976) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (50977 <= code2 && code2 <= 51003) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51145) {
                            if (code2 < 51061) {
                              if (code2 < 51032) {
                                if (code2 < 51005) {
                                  if (code2 === 51004) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51005 <= code2 && code2 <= 51031) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51033) {
                                  if (code2 === 51032) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51060) {
                                    if (51033 <= code2 && code2 <= 51059) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51060) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51116) {
                                if (code2 < 51088) {
                                  if (51061 <= code2 && code2 <= 51087) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51089) {
                                    if (code2 === 51088) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51089 <= code2 && code2 <= 51115) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51117) {
                                  if (code2 === 51116) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51144) {
                                    if (51117 <= code2 && code2 <= 51143) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51144) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51228) {
                              if (code2 < 51173) {
                                if (code2 < 51172) {
                                  if (51145 <= code2 && code2 <= 51171) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51172) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51200) {
                                  if (51173 <= code2 && code2 <= 51199) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51201) {
                                    if (code2 === 51200) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51201 <= code2 && code2 <= 51227) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51257) {
                                if (code2 < 51229) {
                                  if (code2 === 51228) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51256) {
                                    if (51229 <= code2 && code2 <= 51255) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51256) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51284) {
                                  if (51257 <= code2 && code2 <= 51283) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51285) {
                                    if (code2 === 51284) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51285 <= code2 && code2 <= 51311) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 52516) {
                      if (code2 < 51901) {
                        if (code2 < 51593) {
                          if (code2 < 51452) {
                            if (code2 < 51369) {
                              if (code2 < 51340) {
                                if (code2 < 51313) {
                                  if (code2 === 51312) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51313 <= code2 && code2 <= 51339) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51341) {
                                  if (code2 === 51340) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51368) {
                                    if (51341 <= code2 && code2 <= 51367) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51368) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51397) {
                                if (code2 < 51396) {
                                  if (51369 <= code2 && code2 <= 51395) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51396) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51424) {
                                  if (51397 <= code2 && code2 <= 51423) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51425) {
                                    if (code2 === 51424) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51425 <= code2 && code2 <= 51451) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51509) {
                              if (code2 < 51480) {
                                if (code2 < 51453) {
                                  if (code2 === 51452) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51453 <= code2 && code2 <= 51479) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51481) {
                                  if (code2 === 51480) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51508) {
                                    if (51481 <= code2 && code2 <= 51507) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51508) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51564) {
                                if (code2 < 51536) {
                                  if (51509 <= code2 && code2 <= 51535) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51537) {
                                    if (code2 === 51536) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51537 <= code2 && code2 <= 51563) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51565) {
                                  if (code2 === 51564) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51592) {
                                    if (51565 <= code2 && code2 <= 51591) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51592) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 51760) {
                            if (code2 < 51676) {
                              if (code2 < 51621) {
                                if (code2 < 51620) {
                                  if (51593 <= code2 && code2 <= 51619) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51620) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51648) {
                                  if (51621 <= code2 && code2 <= 51647) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51649) {
                                    if (code2 === 51648) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51649 <= code2 && code2 <= 51675) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51705) {
                                if (code2 < 51677) {
                                  if (code2 === 51676) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51704) {
                                    if (51677 <= code2 && code2 <= 51703) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51704) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51732) {
                                  if (51705 <= code2 && code2 <= 51731) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51733) {
                                    if (code2 === 51732) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51733 <= code2 && code2 <= 51759) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 51817) {
                              if (code2 < 51788) {
                                if (code2 < 51761) {
                                  if (code2 === 51760) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51761 <= code2 && code2 <= 51787) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 51789) {
                                  if (code2 === 51788) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51816) {
                                    if (51789 <= code2 && code2 <= 51815) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51816) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 51872) {
                                if (code2 < 51844) {
                                  if (51817 <= code2 && code2 <= 51843) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51845) {
                                    if (code2 === 51844) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51845 <= code2 && code2 <= 51871) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 51873) {
                                  if (code2 === 51872) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 51900) {
                                    if (51873 <= code2 && code2 <= 51899) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 51900) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 52208) {
                          if (code2 < 52041) {
                            if (code2 < 51984) {
                              if (code2 < 51929) {
                                if (code2 < 51928) {
                                  if (51901 <= code2 && code2 <= 51927) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 51928) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 51956) {
                                  if (51929 <= code2 && code2 <= 51955) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 51957) {
                                    if (code2 === 51956) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (51957 <= code2 && code2 <= 51983) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52012) {
                                if (code2 < 51985) {
                                  if (code2 === 51984) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51985 <= code2 && code2 <= 52011) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52013) {
                                  if (code2 === 52012) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52040) {
                                    if (52013 <= code2 && code2 <= 52039) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52040) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52124) {
                              if (code2 < 52069) {
                                if (code2 < 52068) {
                                  if (52041 <= code2 && code2 <= 52067) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52068) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52096) {
                                  if (52069 <= code2 && code2 <= 52095) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52097) {
                                    if (code2 === 52096) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52097 <= code2 && code2 <= 52123) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52153) {
                                if (code2 < 52125) {
                                  if (code2 === 52124) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52152) {
                                    if (52125 <= code2 && code2 <= 52151) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52152) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52180) {
                                  if (52153 <= code2 && code2 <= 52179) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52181) {
                                    if (code2 === 52180) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52181 <= code2 && code2 <= 52207) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52349) {
                            if (code2 < 52265) {
                              if (code2 < 52236) {
                                if (code2 < 52209) {
                                  if (code2 === 52208) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52209 <= code2 && code2 <= 52235) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52237) {
                                  if (code2 === 52236) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52264) {
                                    if (52237 <= code2 && code2 <= 52263) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52264) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52320) {
                                if (code2 < 52292) {
                                  if (52265 <= code2 && code2 <= 52291) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52293) {
                                    if (code2 === 52292) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52293 <= code2 && code2 <= 52319) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52321) {
                                  if (code2 === 52320) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52348) {
                                    if (52321 <= code2 && code2 <= 52347) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52348) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52432) {
                              if (code2 < 52377) {
                                if (code2 < 52376) {
                                  if (52349 <= code2 && code2 <= 52375) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52376) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52404) {
                                  if (52377 <= code2 && code2 <= 52403) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52405) {
                                    if (code2 === 52404) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52405 <= code2 && code2 <= 52431) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52461) {
                                if (code2 < 52433) {
                                  if (code2 === 52432) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52460) {
                                    if (52433 <= code2 && code2 <= 52459) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52460) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52488) {
                                  if (52461 <= code2 && code2 <= 52487) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52489) {
                                    if (code2 === 52488) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52489 <= code2 && code2 <= 52515) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 53105) {
                        if (code2 < 52797) {
                          if (code2 < 52656) {
                            if (code2 < 52573) {
                              if (code2 < 52544) {
                                if (code2 < 52517) {
                                  if (code2 === 52516) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52517 <= code2 && code2 <= 52543) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52545) {
                                  if (code2 === 52544) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52572) {
                                    if (52545 <= code2 && code2 <= 52571) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52572) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52601) {
                                if (code2 < 52600) {
                                  if (52573 <= code2 && code2 <= 52599) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52600) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52628) {
                                  if (52601 <= code2 && code2 <= 52627) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52629) {
                                    if (code2 === 52628) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52629 <= code2 && code2 <= 52655) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 52713) {
                              if (code2 < 52684) {
                                if (code2 < 52657) {
                                  if (code2 === 52656) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52657 <= code2 && code2 <= 52683) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52685) {
                                  if (code2 === 52684) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52712) {
                                    if (52685 <= code2 && code2 <= 52711) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52712) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52768) {
                                if (code2 < 52740) {
                                  if (52713 <= code2 && code2 <= 52739) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52741) {
                                    if (code2 === 52740) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52741 <= code2 && code2 <= 52767) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52769) {
                                  if (code2 === 52768) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52796) {
                                    if (52769 <= code2 && code2 <= 52795) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52796) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 52964) {
                            if (code2 < 52880) {
                              if (code2 < 52825) {
                                if (code2 < 52824) {
                                  if (52797 <= code2 && code2 <= 52823) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 52824) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 52852) {
                                  if (52825 <= code2 && code2 <= 52851) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52853) {
                                    if (code2 === 52852) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52853 <= code2 && code2 <= 52879) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 52909) {
                                if (code2 < 52881) {
                                  if (code2 === 52880) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 52908) {
                                    if (52881 <= code2 && code2 <= 52907) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 52908) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 52936) {
                                  if (52909 <= code2 && code2 <= 52935) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 52937) {
                                    if (code2 === 52936) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (52937 <= code2 && code2 <= 52963) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53021) {
                              if (code2 < 52992) {
                                if (code2 < 52965) {
                                  if (code2 === 52964) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52965 <= code2 && code2 <= 52991) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 52993) {
                                  if (code2 === 52992) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53020) {
                                    if (52993 <= code2 && code2 <= 53019) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53020) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53076) {
                                if (code2 < 53048) {
                                  if (53021 <= code2 && code2 <= 53047) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53049) {
                                    if (code2 === 53048) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53049 <= code2 && code2 <= 53075) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53077) {
                                  if (code2 === 53076) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53104) {
                                    if (53077 <= code2 && code2 <= 53103) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53104) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 53412) {
                          if (code2 < 53245) {
                            if (code2 < 53188) {
                              if (code2 < 53133) {
                                if (code2 < 53132) {
                                  if (53105 <= code2 && code2 <= 53131) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53132) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53160) {
                                  if (53133 <= code2 && code2 <= 53159) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53161) {
                                    if (code2 === 53160) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53161 <= code2 && code2 <= 53187) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53216) {
                                if (code2 < 53189) {
                                  if (code2 === 53188) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53189 <= code2 && code2 <= 53215) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53217) {
                                  if (code2 === 53216) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53244) {
                                    if (53217 <= code2 && code2 <= 53243) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53244) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53328) {
                              if (code2 < 53273) {
                                if (code2 < 53272) {
                                  if (53245 <= code2 && code2 <= 53271) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53272) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53300) {
                                  if (53273 <= code2 && code2 <= 53299) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53301) {
                                    if (code2 === 53300) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53301 <= code2 && code2 <= 53327) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53357) {
                                if (code2 < 53329) {
                                  if (code2 === 53328) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53356) {
                                    if (53329 <= code2 && code2 <= 53355) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53356) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53384) {
                                  if (53357 <= code2 && code2 <= 53383) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53385) {
                                    if (code2 === 53384) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53385 <= code2 && code2 <= 53411) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 53553) {
                            if (code2 < 53469) {
                              if (code2 < 53440) {
                                if (code2 < 53413) {
                                  if (code2 === 53412) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53413 <= code2 && code2 <= 53439) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53441) {
                                  if (code2 === 53440) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53468) {
                                    if (53441 <= code2 && code2 <= 53467) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53468) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53524) {
                                if (code2 < 53496) {
                                  if (53469 <= code2 && code2 <= 53495) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53497) {
                                    if (code2 === 53496) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53497 <= code2 && code2 <= 53523) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53525) {
                                  if (code2 === 53524) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53552) {
                                    if (53525 <= code2 && code2 <= 53551) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53552) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53636) {
                              if (code2 < 53581) {
                                if (code2 < 53580) {
                                  if (53553 <= code2 && code2 <= 53579) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53580) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53608) {
                                  if (53581 <= code2 && code2 <= 53607) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53609) {
                                    if (code2 === 53608) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53609 <= code2 && code2 <= 53635) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53665) {
                                if (code2 < 53637) {
                                  if (code2 === 53636) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53664) {
                                    if (53637 <= code2 && code2 <= 53663) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53664) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53692) {
                                  if (53665 <= code2 && code2 <= 53691) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53693) {
                                    if (code2 === 53692) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53693 <= code2 && code2 <= 53719) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 70459) {
                    if (code2 < 54897) {
                      if (code2 < 54308) {
                        if (code2 < 54001) {
                          if (code2 < 53860) {
                            if (code2 < 53777) {
                              if (code2 < 53748) {
                                if (code2 < 53721) {
                                  if (code2 === 53720) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53721 <= code2 && code2 <= 53747) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53749) {
                                  if (code2 === 53748) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53776) {
                                    if (53749 <= code2 && code2 <= 53775) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53776) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53805) {
                                if (code2 < 53804) {
                                  if (53777 <= code2 && code2 <= 53803) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 53804) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 53832) {
                                  if (53805 <= code2 && code2 <= 53831) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53833) {
                                    if (code2 === 53832) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53833 <= code2 && code2 <= 53859) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 53917) {
                              if (code2 < 53888) {
                                if (code2 < 53861) {
                                  if (code2 === 53860) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53861 <= code2 && code2 <= 53887) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 53889) {
                                  if (code2 === 53888) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 53916) {
                                    if (53889 <= code2 && code2 <= 53915) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 53916) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 53972) {
                                if (code2 < 53944) {
                                  if (53917 <= code2 && code2 <= 53943) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 53945) {
                                    if (code2 === 53944) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (53945 <= code2 && code2 <= 53971) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 53973) {
                                  if (code2 === 53972) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54e3) {
                                    if (53973 <= code2 && code2 <= 53999) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54e3) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54141) {
                            if (code2 < 54084) {
                              if (code2 < 54029) {
                                if (code2 < 54028) {
                                  if (54001 <= code2 && code2 <= 54027) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54028) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54056) {
                                  if (54029 <= code2 && code2 <= 54055) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54057) {
                                    if (code2 === 54056) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54057 <= code2 && code2 <= 54083) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54112) {
                                if (code2 < 54085) {
                                  if (code2 === 54084) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54085 <= code2 && code2 <= 54111) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54113) {
                                  if (code2 === 54112) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54140) {
                                    if (54113 <= code2 && code2 <= 54139) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54140) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54224) {
                              if (code2 < 54169) {
                                if (code2 < 54168) {
                                  if (54141 <= code2 && code2 <= 54167) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54168) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54196) {
                                  if (54169 <= code2 && code2 <= 54195) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54197) {
                                    if (code2 === 54196) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54197 <= code2 && code2 <= 54223) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54253) {
                                if (code2 < 54225) {
                                  if (code2 === 54224) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54252) {
                                    if (54225 <= code2 && code2 <= 54251) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54252) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54280) {
                                  if (54253 <= code2 && code2 <= 54279) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54281) {
                                    if (code2 === 54280) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54281 <= code2 && code2 <= 54307) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 54589) {
                          if (code2 < 54448) {
                            if (code2 < 54365) {
                              if (code2 < 54336) {
                                if (code2 < 54309) {
                                  if (code2 === 54308) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54309 <= code2 && code2 <= 54335) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54337) {
                                  if (code2 === 54336) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54364) {
                                    if (54337 <= code2 && code2 <= 54363) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54364) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54393) {
                                if (code2 < 54392) {
                                  if (54365 <= code2 && code2 <= 54391) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54392) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54420) {
                                  if (54393 <= code2 && code2 <= 54419) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54421) {
                                    if (code2 === 54420) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54421 <= code2 && code2 <= 54447) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54505) {
                              if (code2 < 54476) {
                                if (code2 < 54449) {
                                  if (code2 === 54448) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54449 <= code2 && code2 <= 54475) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54477) {
                                  if (code2 === 54476) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54504) {
                                    if (54477 <= code2 && code2 <= 54503) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54504) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54560) {
                                if (code2 < 54532) {
                                  if (54505 <= code2 && code2 <= 54531) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54533) {
                                    if (code2 === 54532) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54533 <= code2 && code2 <= 54559) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54561) {
                                  if (code2 === 54560) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54588) {
                                    if (54561 <= code2 && code2 <= 54587) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54588) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 54756) {
                            if (code2 < 54672) {
                              if (code2 < 54617) {
                                if (code2 < 54616) {
                                  if (54589 <= code2 && code2 <= 54615) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54616) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54644) {
                                  if (54617 <= code2 && code2 <= 54643) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54645) {
                                    if (code2 === 54644) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54645 <= code2 && code2 <= 54671) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54701) {
                                if (code2 < 54673) {
                                  if (code2 === 54672) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54700) {
                                    if (54673 <= code2 && code2 <= 54699) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54700) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54728) {
                                  if (54701 <= code2 && code2 <= 54727) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54729) {
                                    if (code2 === 54728) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54729 <= code2 && code2 <= 54755) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 54813) {
                              if (code2 < 54784) {
                                if (code2 < 54757) {
                                  if (code2 === 54756) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54757 <= code2 && code2 <= 54783) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 54785) {
                                  if (code2 === 54784) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54812) {
                                    if (54785 <= code2 && code2 <= 54811) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54812) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 54868) {
                                if (code2 < 54840) {
                                  if (54813 <= code2 && code2 <= 54839) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54841) {
                                    if (code2 === 54840) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54841 <= code2 && code2 <= 54867) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 54869) {
                                  if (code2 === 54868) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 54896) {
                                    if (54869 <= code2 && code2 <= 54895) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 54896) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 69632) {
                        if (code2 < 55216) {
                          if (code2 < 55037) {
                            if (code2 < 54980) {
                              if (code2 < 54925) {
                                if (code2 < 54924) {
                                  if (54897 <= code2 && code2 <= 54923) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 54924) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 54952) {
                                  if (54925 <= code2 && code2 <= 54951) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 54953) {
                                    if (code2 === 54952) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (54953 <= code2 && code2 <= 54979) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 55008) {
                                if (code2 < 54981) {
                                  if (code2 === 54980) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54981 <= code2 && code2 <= 55007) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              } else {
                                if (code2 < 55009) {
                                  if (code2 === 55008) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 55036) {
                                    if (55009 <= code2 && code2 <= 55035) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 55036) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 55120) {
                              if (code2 < 55065) {
                                if (code2 < 55064) {
                                  if (55037 <= code2 && code2 <= 55063) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 === 55064) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              } else {
                                if (code2 < 55092) {
                                  if (55065 <= code2 && code2 <= 55091) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 55093) {
                                    if (code2 === 55092) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (55093 <= code2 && code2 <= 55119) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 55149) {
                                if (code2 < 55121) {
                                  if (code2 === 55120) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (code2 < 55148) {
                                    if (55121 <= code2 && code2 <= 55147) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  } else {
                                    if (code2 === 55148) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 55176) {
                                  if (55149 <= code2 && code2 <= 55175) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (code2 < 55177) {
                                    if (code2 === 55176) {
                                      return boundaries_1.CLUSTER_BREAK.LV;
                                    }
                                  } else {
                                    if (55177 <= code2 && code2 <= 55203) {
                                      return boundaries_1.CLUSTER_BREAK.LVT;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 68097) {
                            if (code2 < 65279) {
                              if (code2 < 64286) {
                                if (code2 < 55243) {
                                  if (55216 <= code2 && code2 <= 55238) {
                                    return boundaries_1.CLUSTER_BREAK.V;
                                  }
                                } else {
                                  if (55243 <= code2 && code2 <= 55291) {
                                    return boundaries_1.CLUSTER_BREAK.T;
                                  }
                                }
                              } else {
                                if (code2 < 65024) {
                                  if (code2 === 64286) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 65056) {
                                    if (65024 <= code2 && code2 <= 65039) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (65056 <= code2 && code2 <= 65071) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 66045) {
                                if (code2 < 65438) {
                                  if (code2 === 65279) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 65520) {
                                    if (65438 <= code2 && code2 <= 65439) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (65520 <= code2 && code2 <= 65531) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 66272) {
                                  if (code2 === 66045) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 66422) {
                                    if (code2 === 66272) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (66422 <= code2 && code2 <= 66426) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 68325) {
                              if (code2 < 68108) {
                                if (code2 < 68101) {
                                  if (68097 <= code2 && code2 <= 68099) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (68101 <= code2 && code2 <= 68102) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 68152) {
                                  if (68108 <= code2 && code2 <= 68111) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 68159) {
                                    if (68152 <= code2 && code2 <= 68154) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 68159) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69373) {
                                if (code2 < 68900) {
                                  if (68325 <= code2 && code2 <= 68326) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69291) {
                                    if (68900 <= code2 && code2 <= 68903) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (69291 <= code2 && code2 <= 69292) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 69446) {
                                  if (69373 <= code2 && code2 <= 69375) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69506) {
                                    if (69446 <= code2 && code2 <= 69456) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (69506 <= code2 && code2 <= 69509) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 70016) {
                          if (code2 < 69815) {
                            if (code2 < 69747) {
                              if (code2 < 69634) {
                                if (code2 === 69632) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 69633) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 69688) {
                                  if (code2 === 69634) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 69744) {
                                    if (69688 <= code2 && code2 <= 69702) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 69744) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69762) {
                                if (code2 < 69759) {
                                  if (69747 <= code2 && code2 <= 69748) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69759 <= code2 && code2 <= 69761) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 69808) {
                                  if (code2 === 69762) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 69811) {
                                    if (69808 <= code2 && code2 <= 69810) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (69811 <= code2 && code2 <= 69814) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 69888) {
                              if (code2 < 69821) {
                                if (code2 < 69817) {
                                  if (69815 <= code2 && code2 <= 69816) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (69817 <= code2 && code2 <= 69818) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 69826) {
                                  if (code2 === 69821) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 === 69826) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 69837) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 69933) {
                                if (code2 < 69927) {
                                  if (69888 <= code2 && code2 <= 69890) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 69932) {
                                    if (69927 <= code2 && code2 <= 69931) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 69932) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 69957) {
                                  if (69933 <= code2 && code2 <= 69940) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70003) {
                                    if (69957 <= code2 && code2 <= 69958) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (code2 === 70003) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 70194) {
                            if (code2 < 70082) {
                              if (code2 < 70067) {
                                if (code2 < 70018) {
                                  if (70016 <= code2 && code2 <= 70017) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 70018) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70070) {
                                  if (70067 <= code2 && code2 <= 70069) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70079) {
                                    if (70070 <= code2 && code2 <= 70078) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70079 <= code2 && code2 <= 70080) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70095) {
                                if (code2 < 70089) {
                                  if (70082 <= code2 && code2 <= 70083) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 70094) {
                                    if (70089 <= code2 && code2 <= 70092) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 70094) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 70188) {
                                  if (code2 === 70095) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70191) {
                                    if (70188 <= code2 && code2 <= 70190) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70191 <= code2 && code2 <= 70193) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70209) {
                              if (code2 < 70197) {
                                if (code2 < 70196) {
                                  if (70194 <= code2 && code2 <= 70195) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70196) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70198) {
                                  if (code2 === 70197) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70206) {
                                    if (70198 <= code2 && code2 <= 70199) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 70206) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70371) {
                                if (code2 < 70367) {
                                  if (code2 === 70209) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70368) {
                                    if (code2 === 70367) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70368 <= code2 && code2 <= 70370) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 70400) {
                                  if (70371 <= code2 && code2 <= 70378) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70402) {
                                    if (70400 <= code2 && code2 <= 70401) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70402 <= code2 && code2 <= 70403) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 72343) {
                      if (code2 < 71339) {
                        if (code2 < 70841) {
                          if (code2 < 70512) {
                            if (code2 < 70471) {
                              if (code2 < 70463) {
                                if (code2 < 70462) {
                                  if (70459 <= code2 && code2 <= 70460) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 70462) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70464) {
                                  if (code2 === 70463) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 70465) {
                                    if (code2 === 70464) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (70465 <= code2 && code2 <= 70468) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70487) {
                                if (code2 < 70475) {
                                  if (70471 <= code2 && code2 <= 70472) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70475 <= code2 && code2 <= 70477) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70498) {
                                  if (code2 === 70487) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70502) {
                                    if (70498 <= code2 && code2 <= 70499) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70502 <= code2 && code2 <= 70508) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 70725) {
                              if (code2 < 70712) {
                                if (code2 < 70709) {
                                  if (70512 <= code2 && code2 <= 70516) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70709 <= code2 && code2 <= 70711) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 70720) {
                                  if (70712 <= code2 && code2 <= 70719) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70722) {
                                    if (70720 <= code2 && code2 <= 70721) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70722 <= code2 && code2 <= 70724) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 70832) {
                                if (code2 < 70726) {
                                  if (code2 === 70725) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70726) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 70750) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 70833) {
                                  if (code2 === 70832) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70835) {
                                    if (70833 <= code2 && code2 <= 70834) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70835 <= code2 && code2 <= 70840) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 71096) {
                            if (code2 < 70847) {
                              if (code2 < 70843) {
                                if (code2 === 70841) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 70842) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 70845) {
                                  if (70843 <= code2 && code2 <= 70844) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 70845) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 70846) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71087) {
                                if (code2 < 70849) {
                                  if (70847 <= code2 && code2 <= 70848) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 70850) {
                                    if (code2 === 70849) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (70850 <= code2 && code2 <= 70851) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71088) {
                                  if (code2 === 71087) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71090) {
                                    if (71088 <= code2 && code2 <= 71089) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71090 <= code2 && code2 <= 71093) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71216) {
                              if (code2 < 71102) {
                                if (code2 < 71100) {
                                  if (71096 <= code2 && code2 <= 71099) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71100 <= code2 && code2 <= 71101) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 71103) {
                                  if (code2 === 71102) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 71132) {
                                    if (71103 <= code2 && code2 <= 71104) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (71132 <= code2 && code2 <= 71133) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71229) {
                                if (code2 < 71219) {
                                  if (71216 <= code2 && code2 <= 71218) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 71227) {
                                    if (71219 <= code2 && code2 <= 71226) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (71227 <= code2 && code2 <= 71228) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71230) {
                                  if (code2 === 71229) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71231) {
                                    if (code2 === 71230) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71231 <= code2 && code2 <= 71232) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 71999) {
                          if (code2 < 71463) {
                            if (code2 < 71350) {
                              if (code2 < 71341) {
                                if (code2 === 71339) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (code2 === 71340) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 71342) {
                                  if (code2 === 71341) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71344) {
                                    if (71342 <= code2 && code2 <= 71343) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71344 <= code2 && code2 <= 71349) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71453) {
                                if (code2 === 71350) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 71351) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 71458) {
                                  if (71453 <= code2 && code2 <= 71455) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71462) {
                                    if (71458 <= code2 && code2 <= 71461) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 71462) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 71984) {
                              if (code2 < 71727) {
                                if (code2 < 71724) {
                                  if (71463 <= code2 && code2 <= 71467) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71724 <= code2 && code2 <= 71726) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 71736) {
                                  if (71727 <= code2 && code2 <= 71735) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71737) {
                                    if (code2 === 71736) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71737 <= code2 && code2 <= 71738) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 71995) {
                                if (code2 < 71985) {
                                  if (code2 === 71984) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 71991) {
                                    if (71985 <= code2 && code2 <= 71989) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (71991 <= code2 && code2 <= 71992) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 71997) {
                                  if (71995 <= code2 && code2 <= 71996) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 71997) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 71998) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 72193) {
                            if (code2 < 72145) {
                              if (code2 < 72001) {
                                if (code2 === 71999) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (code2 === 72e3) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code2 < 72002) {
                                  if (code2 === 72001) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 === 72002) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 72003) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72156) {
                                if (code2 < 72148) {
                                  if (72145 <= code2 && code2 <= 72147) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72154) {
                                    if (72148 <= code2 && code2 <= 72151) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72154 <= code2 && code2 <= 72155) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 72160) {
                                  if (72156 <= code2 && code2 <= 72159) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 === 72160) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 72164) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 72263) {
                              if (code2 < 72249) {
                                if (code2 < 72243) {
                                  if (72193 <= code2 && code2 <= 72202) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72243 <= code2 && code2 <= 72248) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72250) {
                                  if (code2 === 72249) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72251) {
                                    if (code2 === 72250) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  } else {
                                    if (72251 <= code2 && code2 <= 72254) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72281) {
                                if (code2 < 72273) {
                                  if (code2 === 72263) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72279) {
                                    if (72273 <= code2 && code2 <= 72278) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72279 <= code2 && code2 <= 72280) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 72324) {
                                  if (72281 <= code2 && code2 <= 72283) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72330) {
                                    if (72324 <= code2 && code2 <= 72329) {
                                      return boundaries_1.CLUSTER_BREAK.PREPEND;
                                    }
                                  } else {
                                    if (72330 <= code2 && code2 <= 72342) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 94033) {
                        if (code2 < 73104) {
                          if (code2 < 72881) {
                            if (code2 < 72766) {
                              if (code2 < 72751) {
                                if (code2 < 72344) {
                                  if (code2 === 72343) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72344 <= code2 && code2 <= 72345) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72752) {
                                  if (code2 === 72751) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 72760) {
                                    if (72752 <= code2 && code2 <= 72758) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (72760 <= code2 && code2 <= 72765) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 72850) {
                                if (code2 === 72766) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (code2 === 72767) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code2 < 72873) {
                                  if (72850 <= code2 && code2 <= 72871) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 72874) {
                                    if (code2 === 72873) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (72874 <= code2 && code2 <= 72880) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 73018) {
                              if (code2 < 72884) {
                                if (code2 < 72882) {
                                  if (code2 === 72881) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72882 <= code2 && code2 <= 72883) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 72885) {
                                  if (code2 === 72884) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (code2 < 73009) {
                                    if (72885 <= code2 && code2 <= 72886) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73009 <= code2 && code2 <= 73014) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 73030) {
                                if (code2 < 73020) {
                                  if (code2 === 73018) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 73023) {
                                    if (73020 <= code2 && code2 <= 73021) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73023 <= code2 && code2 <= 73029) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 73031) {
                                  if (code2 === 73030) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 73098) {
                                    if (code2 === 73031) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (73098 <= code2 && code2 <= 73102) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 73526) {
                            if (code2 < 73459) {
                              if (code2 < 73109) {
                                if (code2 < 73107) {
                                  if (73104 <= code2 && code2 <= 73105) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73107 <= code2 && code2 <= 73108) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 73110) {
                                  if (code2 === 73109) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 73110) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 73111) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 73474) {
                                if (code2 < 73461) {
                                  if (73459 <= code2 && code2 <= 73460) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 73472) {
                                    if (73461 <= code2 && code2 <= 73462) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (73472 <= code2 && code2 <= 73473) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 73475) {
                                  if (code2 === 73474) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (code2 < 73524) {
                                    if (code2 === 73475) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (73524 <= code2 && code2 <= 73525) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 78896) {
                              if (code2 < 73536) {
                                if (code2 < 73534) {
                                  if (73526 <= code2 && code2 <= 73530) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73534 <= code2 && code2 <= 73535) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 73537) {
                                  if (code2 === 73536) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 73537) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                  if (code2 === 73538) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code2 < 92912) {
                                if (code2 < 78912) {
                                  if (78896 <= code2 && code2 <= 78911) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 78919) {
                                    if (code2 === 78912) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (78919 <= code2 && code2 <= 78933) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 92976) {
                                  if (92912 <= code2 && code2 <= 92916) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 94031) {
                                    if (92976 <= code2 && code2 <= 92982) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 94031) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code2 < 121476) {
                          if (code2 < 119143) {
                            if (code2 < 113824) {
                              if (code2 < 94180) {
                                if (code2 < 94095) {
                                  if (94033 <= code2 && code2 <= 94087) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (94095 <= code2 && code2 <= 94098) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 94192) {
                                  if (code2 === 94180) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 113821) {
                                    if (94192 <= code2 && code2 <= 94193) {
                                      return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                    }
                                  } else {
                                    if (113821 <= code2 && code2 <= 113822) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 118576) {
                                if (code2 < 118528) {
                                  if (113824 <= code2 && code2 <= 113827) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (118528 <= code2 && code2 <= 118573) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 119141) {
                                  if (118576 <= code2 && code2 <= 118598) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 119141) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                  if (code2 === 119142) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 119173) {
                              if (code2 < 119150) {
                                if (code2 < 119149) {
                                  if (119143 <= code2 && code2 <= 119145) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 === 119149) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              } else {
                                if (code2 < 119155) {
                                  if (119150 <= code2 && code2 <= 119154) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 119163) {
                                    if (119155 <= code2 && code2 <= 119162) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (119163 <= code2 && code2 <= 119170) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 121344) {
                                if (code2 < 119210) {
                                  if (119173 <= code2 && code2 <= 119179) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 119362) {
                                    if (119210 <= code2 && code2 <= 119213) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (119362 <= code2 && code2 <= 119364) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 121403) {
                                  if (121344 <= code2 && code2 <= 121398) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 121461) {
                                    if (121403 <= code2 && code2 <= 121452) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 121461) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code2 < 123628) {
                            if (code2 < 122907) {
                              if (code2 < 121505) {
                                if (code2 < 121499) {
                                  if (code2 === 121476) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (121499 <= code2 && code2 <= 121503) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 122880) {
                                  if (121505 <= code2 && code2 <= 121519) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 122888) {
                                    if (122880 <= code2 && code2 <= 122886) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (122888 <= code2 && code2 <= 122904) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 123023) {
                                if (code2 < 122915) {
                                  if (122907 <= code2 && code2 <= 122913) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 122918) {
                                    if (122915 <= code2 && code2 <= 122916) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (122918 <= code2 && code2 <= 122922) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 123184) {
                                  if (code2 === 123023) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 123566) {
                                    if (123184 <= code2 && code2 <= 123190) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (code2 === 123566) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            if (code2 < 127995) {
                              if (code2 < 125136) {
                                if (code2 < 124140) {
                                  if (123628 <= code2 && code2 <= 123631) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (124140 <= code2 && code2 <= 124143) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              } else {
                                if (code2 < 125252) {
                                  if (125136 <= code2 && code2 <= 125142) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 127462) {
                                    if (125252 <= code2 && code2 <= 125258) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (127462 <= code2 && code2 <= 127487) {
                                      return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                                    }
                                  }
                                }
                              }
                            } else {
                              if (code2 < 917632) {
                                if (code2 < 917504) {
                                  if (127995 <= code2 && code2 <= 127999) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (code2 < 917536) {
                                    if (917504 <= code2 && code2 <= 917535) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  } else {
                                    if (917536 <= code2 && code2 <= 917631) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  }
                                }
                              } else {
                                if (code2 < 917760) {
                                  if (917632 <= code2 && code2 <= 917759) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (code2 < 918e3) {
                                    if (917760 <= code2 && code2 <= 917999) {
                                      return boundaries_1.CLUSTER_BREAK.EXTEND;
                                    }
                                  } else {
                                    if (918e3 <= code2 && code2 <= 921599) {
                                      return boundaries_1.CLUSTER_BREAK.CONTROL;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return boundaries_1.CLUSTER_BREAK.OTHER;
            }
            static getEmojiProperty(code2) {
              if (code2 < 10160) {
                if (code2 < 9728) {
                  if (code2 < 9e3) {
                    if (code2 < 8482) {
                      if (code2 < 8252) {
                        if (code2 === 169) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 174) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 === 8252) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 8265) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code2 < 8596) {
                        if (code2 === 8482) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 8505) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 8617) {
                          if (8596 <= code2 && code2 <= 8601) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 8986) {
                            if (8617 <= code2 && code2 <= 8618) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (8986 <= code2 && code2 <= 8987) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 9410) {
                      if (code2 < 9167) {
                        if (code2 === 9e3) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 9096) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 9193) {
                          if (code2 === 9167) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9208) {
                            if (9193 <= code2 && code2 <= 9203) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9208 <= code2 && code2 <= 9210) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 9654) {
                        if (code2 < 9642) {
                          if (code2 === 9410) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9642 <= code2 && code2 <= 9643) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 9664) {
                          if (code2 === 9654) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9723) {
                            if (code2 === 9664) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9723 <= code2 && code2 <= 9726) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 10035) {
                    if (code2 < 10004) {
                      if (code2 < 9748) {
                        if (code2 < 9735) {
                          if (9728 <= code2 && code2 <= 9733) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9735 <= code2 && code2 <= 9746) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 9872) {
                          if (9748 <= code2 && code2 <= 9861) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 9992) {
                            if (9872 <= code2 && code2 <= 9989) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (9992 <= code2 && code2 <= 10002) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 10013) {
                        if (code2 === 10004) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 10006) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 10017) {
                          if (code2 === 10013) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10017) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 10024) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 10067) {
                      if (code2 < 10055) {
                        if (code2 < 10052) {
                          if (10035 <= code2 && code2 <= 10036) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10052) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 10060) {
                          if (code2 === 10055) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10060) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 10062) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    } else {
                      if (code2 < 10083) {
                        if (code2 < 10071) {
                          if (10067 <= code2 && code2 <= 10069) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 10071) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 10133) {
                          if (10083 <= code2 && code2 <= 10087) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 10145) {
                            if (10133 <= code2 && code2 <= 10135) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (code2 === 10145) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code2 < 127489) {
                  if (code2 < 12951) {
                    if (code2 < 11035) {
                      if (code2 < 10548) {
                        if (code2 === 10160) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 10175) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 11013) {
                          if (10548 <= code2 && code2 <= 10549) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (11013 <= code2 && code2 <= 11015) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    } else {
                      if (code2 < 11093) {
                        if (code2 < 11088) {
                          if (11035 <= code2 && code2 <= 11036) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 11088) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 12336) {
                          if (code2 === 11093) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 12336) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                          if (code2 === 12349) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 127340) {
                      if (code2 < 126976) {
                        if (code2 === 12951) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (code2 === 12953) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code2 < 127245) {
                          if (126976 <= code2 && code2 <= 127231) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127279) {
                            if (127245 <= code2 && code2 <= 127247) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (code2 === 127279) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 127374) {
                        if (code2 < 127358) {
                          if (127340 <= code2 && code2 <= 127345) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127358 <= code2 && code2 <= 127359) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 127377) {
                          if (code2 === 127374) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127405) {
                            if (127377 <= code2 && code2 <= 127386) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (127405 <= code2 && code2 <= 127461) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code2 < 128981) {
                    if (code2 < 127561) {
                      if (code2 < 127535) {
                        if (code2 < 127514) {
                          if (127489 <= code2 && code2 <= 127503) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 === 127514) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 127538) {
                          if (code2 === 127535) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 127548) {
                            if (127538 <= code2 && code2 <= 127546) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (127548 <= code2 && code2 <= 127551) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 128326) {
                        if (code2 < 128e3) {
                          if (127561 <= code2 && code2 <= 127994) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (128e3 <= code2 && code2 <= 128317) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 128640) {
                          if (128326 <= code2 && code2 <= 128591) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 128884) {
                            if (128640 <= code2 && code2 <= 128767) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (128884 <= code2 && code2 <= 128895) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code2 < 129198) {
                      if (code2 < 129096) {
                        if (code2 < 129036) {
                          if (128981 <= code2 && code2 <= 129023) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129036 <= code2 && code2 <= 129039) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 129114) {
                          if (129096 <= code2 && code2 <= 129103) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 129160) {
                            if (129114 <= code2 && code2 <= 129119) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (129160 <= code2 && code2 <= 129167) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    } else {
                      if (code2 < 129340) {
                        if (code2 < 129292) {
                          if (129198 <= code2 && code2 <= 129279) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129292 <= code2 && code2 <= 129338) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      } else {
                        if (code2 < 129351) {
                          if (129340 <= code2 && code2 <= 129349) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (code2 < 130048) {
                            if (129351 <= code2 && code2 <= 129791) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          } else {
                            if (130048 <= code2 && code2 <= 131069) {
                              return boundaries_1.EXTENDED_PICTOGRAPHIC;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return boundaries_1.CLUSTER_BREAK.OTHER;
            }
          };
          exports2.default = Graphemer2;
        }
      });
      var require_lib = __commonJS2({
        "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/index.js"(exports2) {
          "use strict";
          var __importDefault = exports2 && exports2.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          var Graphemer_1 = __importDefault(require_Graphemer());
          exports2.default = Graphemer_1.default;
        }
      });
      var require_dist2 = __commonJS2({
        "../../node_modules/.pnpm/iso-datestring-validator@2.2.2/node_modules/iso-datestring-validator/dist/index.js"(exports2) {
          (() => {
            "use strict";
            var e = { d: (t2, r2) => {
              for (var n2 in r2)
                e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
            }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
              typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
            } }, t = {};
            function r(e2, t2) {
              return t2 === void 0 && (t2 = "-"), new RegExp("^(?!0{4}" + t2 + "0{2}" + t2 + "0{2})((?=[0-9]{4}" + t2 + "(((0[^2])|1[0-2])|02(?=" + t2 + "(([0-1][0-9])|2[0-8])))" + t2 + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t2 + "02" + t2 + "29))([0-9]{4})" + t2 + "(?!((0[469])|11)" + t2 + "31)((0[1,3-9]|1[0-2])|(02(?!" + t2 + "3)))" + t2 + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e2);
            }
            function n(e2) {
              var t2 = /\D/.exec(e2);
              return t2 ? t2[0] : "";
            }
            function i(e2, t2, r2) {
              t2 === void 0 && (t2 = ":"), r2 === void 0 && (r2 = false);
              var i2 = new RegExp("^([0-1]|2(?=([0-3])|4" + t2 + "00))[0-9]" + t2 + "[0-5][0-9](" + t2 + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
              if (!r2 || !/[Z+\-]/.test(e2))
                return i2.test(e2);
              if (/Z$/.test(e2))
                return i2.test(e2.replace("Z", ""));
              var o2 = e2.includes("+"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];
              return i2.test(u2) && function(e3, t3, r3) {
                return r3 === void 0 && (r3 = ":"), new RegExp(t3 ? "^(0(?!(2" + r3 + "4)|0" + r3 + "3)|1(?=([0-1]|2(?=" + r3 + "[04])|[34](?=" + r3 + "0))))([03469](?=" + r3 + "[03])|[17](?=" + r3 + "0)|2(?=" + r3 + "[04])|5(?=" + r3 + "[034])|8(?=" + r3 + "[04]))" + r3 + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r3 + "[03])|[0-24-8](?=" + r3 + "00))" + r3 + "[03]0$").test(e3);
              }(d2, o2, n(d2));
            }
            function o(e2) {
              var t2 = e2.split("T"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));
              if (!a2)
                return false;
              var d2, s = (d2 = a2.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d2) ? d2[0] : "");
              return u2 && i(a2, s, true);
            }
            function a(e2, t2) {
              return t2 === void 0 && (t2 = "-"), new RegExp("^[0-9]{4}" + t2 + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e2);
            }
            e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });
            var u = exports2;
            for (var d in t)
              u[d] = t[d];
            t.__esModule && Object.defineProperty(u, "__esModule", { value: true });
          })();
        }
      });
      var src_exports22 = {};
      __export2(src_exports22, {
        APP_BSKY_GRAPH: () => APP_BSKY_GRAPH,
        ActorNS: () => ActorNS,
        AdminNS: () => AdminNS,
        AppBskyActorDefs: () => defs_exports5,
        AppBskyActorGetPreferences: () => getPreferences_exports,
        AppBskyActorGetProfile: () => getProfile_exports,
        AppBskyActorGetProfiles: () => getProfiles_exports,
        AppBskyActorGetSuggestions: () => getSuggestions_exports,
        AppBskyActorProfile: () => profile_exports,
        AppBskyActorPutPreferences: () => putPreferences_exports,
        AppBskyActorSearchActors: () => searchActors_exports,
        AppBskyActorSearchActorsTypeahead: () => searchActorsTypeahead_exports,
        AppBskyEmbedExternal: () => external_exports,
        AppBskyEmbedImages: () => images_exports,
        AppBskyEmbedRecord: () => record_exports,
        AppBskyEmbedRecordWithMedia: () => recordWithMedia_exports,
        AppBskyFeedDefs: () => defs_exports6,
        AppBskyFeedDescribeFeedGenerator: () => describeFeedGenerator_exports,
        AppBskyFeedGenerator: () => generator_exports,
        AppBskyFeedGetActorFeeds: () => getActorFeeds_exports,
        AppBskyFeedGetActorLikes: () => getActorLikes_exports,
        AppBskyFeedGetAuthorFeed: () => getAuthorFeed_exports,
        AppBskyFeedGetFeed: () => getFeed_exports,
        AppBskyFeedGetFeedGenerator: () => getFeedGenerator_exports,
        AppBskyFeedGetFeedGenerators: () => getFeedGenerators_exports,
        AppBskyFeedGetFeedSkeleton: () => getFeedSkeleton_exports,
        AppBskyFeedGetLikes: () => getLikes_exports,
        AppBskyFeedGetListFeed: () => getListFeed_exports,
        AppBskyFeedGetPostThread: () => getPostThread_exports,
        AppBskyFeedGetPosts: () => getPosts_exports,
        AppBskyFeedGetRepostedBy: () => getRepostedBy_exports,
        AppBskyFeedGetSuggestedFeeds: () => getSuggestedFeeds_exports,
        AppBskyFeedGetTimeline: () => getTimeline_exports,
        AppBskyFeedLike: () => like_exports,
        AppBskyFeedPost: () => post_exports,
        AppBskyFeedRepost: () => repost_exports,
        AppBskyFeedSearchPosts: () => searchPosts_exports,
        AppBskyFeedThreadgate: () => threadgate_exports,
        AppBskyGraphBlock: () => block_exports,
        AppBskyGraphDefs: () => defs_exports7,
        AppBskyGraphFollow: () => follow_exports,
        AppBskyGraphGetBlocks: () => getBlocks_exports2,
        AppBskyGraphGetFollowers: () => getFollowers_exports,
        AppBskyGraphGetFollows: () => getFollows_exports,
        AppBskyGraphGetList: () => getList_exports,
        AppBskyGraphGetListBlocks: () => getListBlocks_exports,
        AppBskyGraphGetListMutes: () => getListMutes_exports,
        AppBskyGraphGetLists: () => getLists_exports,
        AppBskyGraphGetMutes: () => getMutes_exports,
        AppBskyGraphGetSuggestedFollowsByActor: () => getSuggestedFollowsByActor_exports,
        AppBskyGraphList: () => list_exports,
        AppBskyGraphListblock: () => listblock_exports,
        AppBskyGraphListitem: () => listitem_exports,
        AppBskyGraphMuteActor: () => muteActor_exports,
        AppBskyGraphMuteActorList: () => muteActorList_exports,
        AppBskyGraphUnmuteActor: () => unmuteActor_exports,
        AppBskyGraphUnmuteActorList: () => unmuteActorList_exports,
        AppBskyNotificationGetUnreadCount: () => getUnreadCount_exports,
        AppBskyNotificationListNotifications: () => listNotifications_exports,
        AppBskyNotificationRegisterPush: () => registerPush_exports,
        AppBskyNotificationUpdateSeen: () => updateSeen_exports,
        AppBskyRichtextFacet: () => facet_exports,
        AppBskyUnspeccedDefs: () => defs_exports8,
        AppBskyUnspeccedGetPopular: () => getPopular_exports,
        AppBskyUnspeccedGetPopularFeedGenerators: () => getPopularFeedGenerators_exports,
        AppBskyUnspeccedGetTimelineSkeleton: () => getTimelineSkeleton_exports,
        AppBskyUnspeccedSearchActorsSkeleton: () => searchActorsSkeleton_exports,
        AppBskyUnspeccedSearchPostsSkeleton: () => searchPostsSkeleton_exports,
        AppNS: () => AppNS,
        AtUri: () => AtUri,
        AtpAgent: () => AtpAgent,
        AtpBaseClient: () => AtpBaseClient,
        AtpServiceClient: () => AtpServiceClient,
        AtprotoNS: () => AtprotoNS,
        BlobRef: () => BlobRef,
        BlockRecord: () => BlockRecord,
        BskyAgent: () => BskyAgent2,
        BskyNS: () => BskyNS,
        COM_ATPROTO_ADMIN: () => COM_ATPROTO_ADMIN,
        COM_ATPROTO_MODERATION: () => COM_ATPROTO_MODERATION,
        ComAtprotoAdminDefs: () => defs_exports,
        ComAtprotoAdminDeleteAccount: () => deleteAccount_exports,
        ComAtprotoAdminDisableAccountInvites: () => disableAccountInvites_exports,
        ComAtprotoAdminDisableInviteCodes: () => disableInviteCodes_exports,
        ComAtprotoAdminEmitModerationEvent: () => emitModerationEvent_exports,
        ComAtprotoAdminEnableAccountInvites: () => enableAccountInvites_exports,
        ComAtprotoAdminGetAccountInfo: () => getAccountInfo_exports,
        ComAtprotoAdminGetInviteCodes: () => getInviteCodes_exports,
        ComAtprotoAdminGetModerationEvent: () => getModerationEvent_exports,
        ComAtprotoAdminGetRecord: () => getRecord_exports,
        ComAtprotoAdminGetRepo: () => getRepo_exports,
        ComAtprotoAdminGetSubjectStatus: () => getSubjectStatus_exports,
        ComAtprotoAdminQueryModerationEvents: () => queryModerationEvents_exports,
        ComAtprotoAdminQueryModerationStatuses: () => queryModerationStatuses_exports,
        ComAtprotoAdminSearchRepos: () => searchRepos_exports,
        ComAtprotoAdminSendEmail: () => sendEmail_exports,
        ComAtprotoAdminUpdateAccountEmail: () => updateAccountEmail_exports,
        ComAtprotoAdminUpdateAccountHandle: () => updateAccountHandle_exports,
        ComAtprotoAdminUpdateSubjectStatus: () => updateSubjectStatus_exports,
        ComAtprotoIdentityResolveHandle: () => resolveHandle_exports,
        ComAtprotoIdentityUpdateHandle: () => updateHandle_exports,
        ComAtprotoLabelDefs: () => defs_exports2,
        ComAtprotoLabelQueryLabels: () => queryLabels_exports,
        ComAtprotoLabelSubscribeLabels: () => subscribeLabels_exports,
        ComAtprotoModerationCreateReport: () => createReport_exports,
        ComAtprotoModerationDefs: () => defs_exports3,
        ComAtprotoRepoApplyWrites: () => applyWrites_exports,
        ComAtprotoRepoCreateRecord: () => createRecord_exports,
        ComAtprotoRepoDeleteRecord: () => deleteRecord_exports,
        ComAtprotoRepoDescribeRepo: () => describeRepo_exports,
        ComAtprotoRepoGetRecord: () => getRecord_exports2,
        ComAtprotoRepoListRecords: () => listRecords_exports,
        ComAtprotoRepoPutRecord: () => putRecord_exports,
        ComAtprotoRepoStrongRef: () => strongRef_exports,
        ComAtprotoRepoUploadBlob: () => uploadBlob_exports,
        ComAtprotoServerConfirmEmail: () => confirmEmail_exports,
        ComAtprotoServerCreateAccount: () => createAccount_exports,
        ComAtprotoServerCreateAppPassword: () => createAppPassword_exports,
        ComAtprotoServerCreateInviteCode: () => createInviteCode_exports,
        ComAtprotoServerCreateInviteCodes: () => createInviteCodes_exports,
        ComAtprotoServerCreateSession: () => createSession_exports,
        ComAtprotoServerDefs: () => defs_exports4,
        ComAtprotoServerDeleteAccount: () => deleteAccount_exports2,
        ComAtprotoServerDeleteSession: () => deleteSession_exports,
        ComAtprotoServerDescribeServer: () => describeServer_exports,
        ComAtprotoServerGetAccountInviteCodes: () => getAccountInviteCodes_exports,
        ComAtprotoServerGetSession: () => getSession_exports,
        ComAtprotoServerListAppPasswords: () => listAppPasswords_exports,
        ComAtprotoServerRefreshSession: () => refreshSession_exports,
        ComAtprotoServerRequestAccountDelete: () => requestAccountDelete_exports,
        ComAtprotoServerRequestEmailConfirmation: () => requestEmailConfirmation_exports,
        ComAtprotoServerRequestEmailUpdate: () => requestEmailUpdate_exports,
        ComAtprotoServerRequestPasswordReset: () => requestPasswordReset_exports,
        ComAtprotoServerReserveSigningKey: () => reserveSigningKey_exports,
        ComAtprotoServerResetPassword: () => resetPassword_exports,
        ComAtprotoServerRevokeAppPassword: () => revokeAppPassword_exports,
        ComAtprotoServerUpdateEmail: () => updateEmail_exports,
        ComAtprotoSyncGetBlob: () => getBlob_exports,
        ComAtprotoSyncGetBlocks: () => getBlocks_exports,
        ComAtprotoSyncGetCheckout: () => getCheckout_exports,
        ComAtprotoSyncGetHead: () => getHead_exports,
        ComAtprotoSyncGetLatestCommit: () => getLatestCommit_exports,
        ComAtprotoSyncGetRecord: () => getRecord_exports3,
        ComAtprotoSyncGetRepo: () => getRepo_exports2,
        ComAtprotoSyncListBlobs: () => listBlobs_exports,
        ComAtprotoSyncListRepos: () => listRepos_exports,
        ComAtprotoSyncNotifyOfUpdate: () => notifyOfUpdate_exports,
        ComAtprotoSyncRequestCrawl: () => requestCrawl_exports,
        ComAtprotoSyncSubscribeRepos: () => subscribeRepos_exports,
        ComAtprotoTempFetchLabels: () => fetchLabels_exports,
        ComAtprotoTempImportRepo: () => importRepo_exports,
        ComAtprotoTempPushBlob: () => pushBlob_exports,
        ComAtprotoTempTransferAccount: () => transferAccount_exports,
        ComNS: () => ComNS,
        EmbedNS: () => EmbedNS,
        FeedNS: () => FeedNS,
        FollowRecord: () => FollowRecord,
        GeneratorRecord: () => GeneratorRecord,
        GraphNS: () => GraphNS,
        IdentityNS: () => IdentityNS,
        LABELS: () => LABELS,
        LABEL_GROUPS: () => LABEL_GROUPS,
        LabelNS: () => LabelNS,
        LikeRecord: () => LikeRecord,
        ListRecord: () => ListRecord,
        ListblockRecord: () => ListblockRecord,
        ListitemRecord: () => ListitemRecord,
        ModerationDecision: () => ModerationDecision,
        ModerationNS: () => ModerationNS,
        NotificationNS: () => NotificationNS,
        PostRecord: () => PostRecord,
        ProfileRecord: () => ProfileRecord,
        RepoNS: () => RepoNS,
        RepostRecord: () => RepostRecord,
        RichText: () => RichText,
        RichTextSegment: () => RichTextSegment,
        RichtextNS: () => RichtextNS,
        ServerNS: () => ServerNS,
        SyncNS: () => SyncNS,
        TempNS: () => TempNS,
        ThreadgateRecord: () => ThreadgateRecord,
        UnicodeString: () => UnicodeString,
        UnspeccedNS: () => UnspeccedNS,
        default: () => AtpAgent,
        jsonStringToLex: () => jsonStringToLex,
        jsonToLex: () => jsonToLex,
        lexToJson: () => lexToJson,
        moderateFeedGenerator: () => moderateFeedGenerator,
        moderatePost: () => moderatePost,
        moderateProfile: () => moderateProfile,
        moderateUserList: () => moderateUserList,
        parseLanguage: () => parseLanguage,
        sanitizeRichText: () => sanitizeRichText,
        stringifyLex: () => stringifyLex
      });
      module2.exports = __toCommonJS(src_exports22);
      var ensureValidHandle = (handle2) => {
        if (!/^[a-zA-Z0-9.-]*$/.test(handle2)) {
          throw new InvalidHandleError("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
        }
        if (handle2.length > 253) {
          throw new InvalidHandleError("Handle is too long (253 chars max)");
        }
        const labels = handle2.split(".");
        if (labels.length < 2) {
          throw new InvalidHandleError("Handle domain needs at least two parts");
        }
        for (let i = 0; i < labels.length; i++) {
          const l = labels[i];
          if (l.length < 1) {
            throw new InvalidHandleError("Handle parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidHandleError("Handle part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidHandleError("Handle parts can not start or end with hyphens");
          }
          if (i + 1 == labels.length && !/^[a-zA-Z]/.test(l)) {
            throw new InvalidHandleError("Handle final component (TLD) must start with ASCII letter");
          }
        }
      };
      var InvalidHandleError = class extends Error {
      };
      var ensureValidDid = (did2) => {
        if (!/^[a-zA-Z0-9._:%-]*$/.test(did2)) {
          throw new InvalidDidError("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
        }
        const parts = did2.split(":");
        if (parts.length < 3) {
          throw new InvalidDidError("DID requires prefix, method, and method-specific content");
        }
        if (parts[0] != "did") {
          throw new InvalidDidError('DID requires "did:" prefix');
        }
        if (!/^[a-z]+$/.test(parts[1])) {
          throw new InvalidDidError("DID method must be lower-case letters");
        }
        if (did2.endsWith(":") || did2.endsWith("%")) {
          throw new InvalidDidError('DID can not end with ":" or "%"');
        }
        if (did2.length > 2 * 1024) {
          throw new InvalidDidError("DID is too long (2048 chars max)");
        }
      };
      var InvalidDidError = class extends Error {
      };
      var NSID = class {
        constructor(nsid2) {
          this.segments = [];
          ensureValidNsid(nsid2);
          this.segments = nsid2.split(".");
        }
        static parse(nsid2) {
          return new NSID(nsid2);
        }
        static create(authority, name2) {
          const segments = [...authority.split(".").reverse(), name2].join(".");
          return new NSID(segments);
        }
        static isValid(nsid2) {
          try {
            NSID.parse(nsid2);
            return true;
          } catch (e) {
            return false;
          }
        }
        get authority() {
          return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
        }
        get name() {
          return this.segments.at(this.segments.length - 1);
        }
        toString() {
          return this.segments.join(".");
        }
      };
      var ensureValidNsid = (nsid2) => {
        const toCheck = nsid2;
        if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
          throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
        }
        if (toCheck.length > 253 + 1 + 63) {
          throw new InvalidNsidError("NSID is too long (317 chars max)");
        }
        const labels = toCheck.split(".");
        if (labels.length < 3) {
          throw new InvalidNsidError("NSID needs at least three parts");
        }
        for (let i = 0; i < labels.length; i++) {
          const l = labels[i];
          if (l.length < 1) {
            throw new InvalidNsidError("NSID parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidNsidError("NSID part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidNsidError("NSID parts can not start or end with hyphen");
          }
          if (/^[0-9]/.test(l) && i == 0) {
            throw new InvalidNsidError("NSID first part may not start with a digit");
          }
          if (!/^[a-zA-Z]+$/.test(l) && i + 1 == labels.length) {
            throw new InvalidNsidError("NSID name part must be only letters");
          }
        }
      };
      var InvalidNsidError = class extends Error {
      };
      var ensureValidAtUri = (uri2) => {
        const uriParts = uri2.split("#");
        if (uriParts.length > 2) {
          throw new Error('ATURI can have at most one "#", separating fragment out');
        }
        const fragmentPart = uriParts[1] || null;
        uri2 = uriParts[0];
        if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri2)) {
          throw new Error("Disallowed characters in ATURI (ASCII)");
        }
        const parts = uri2.split("/");
        if (parts.length >= 3 && (parts[0] != "at:" || parts[1].length != 0)) {
          throw new Error('ATURI must start with "at://"');
        }
        if (parts.length < 3) {
          throw new Error("ATURI requires at least method and authority sections");
        }
        try {
          if (parts[2].startsWith("did:")) {
            ensureValidDid(parts[2]);
          } else {
            ensureValidHandle(parts[2]);
          }
        } catch (e) {
          throw new Error("ATURI authority must be a valid handle or DID");
        }
        if (parts.length >= 4) {
          if (parts[3].length == 0) {
            throw new Error("ATURI can not have a slash after authority without a path segment");
          }
          try {
            ensureValidNsid(parts[3]);
          } catch (e) {
            throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
          }
        }
        if (parts.length >= 5) {
          if (parts[4].length == 0) {
            throw new Error("ATURI can not have a slash after collection, unless record key is provided");
          }
        }
        if (parts.length >= 6) {
          throw new Error("ATURI path can have at most two parts, and no trailing slash");
        }
        if (uriParts.length >= 2 && fragmentPart == null) {
          throw new Error("ATURI fragment must be non-empty and start with slash");
        }
        if (fragmentPart != null) {
          if (fragmentPart.length == 0 || fragmentPart[0] != "/") {
            throw new Error("ATURI fragment must be non-empty and start with slash");
          }
          if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
            throw new Error("Disallowed characters in ATURI fragment (ASCII)");
          }
        }
        if (uri2.length > 8 * 1024) {
          throw new Error("ATURI is far too long");
        }
      };
      var ATP_URI_REGEX = /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      var RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      var AtUri = class {
        constructor(uri2, base33) {
          let parsed;
          if (base33) {
            parsed = parse(base33);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${base33}`);
            }
            const relativep = parseRelative(uri2);
            if (!relativep) {
              throw new Error(`Invalid path: ${uri2}`);
            }
            Object.assign(parsed, relativep);
          } else {
            parsed = parse(uri2);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${uri2}`);
            }
          }
          this.hash = parsed.hash;
          this.host = parsed.host;
          this.pathname = parsed.pathname;
          this.searchParams = parsed.searchParams;
        }
        static make(handleOrDid, collection, rkey) {
          let str = handleOrDid;
          if (collection)
            str += "/" + collection;
          if (rkey)
            str += "/" + rkey;
          return new AtUri(str);
        }
        get protocol() {
          return "at:";
        }
        get origin() {
          return `at://${this.host}`;
        }
        get hostname() {
          return this.host;
        }
        set hostname(v) {
          this.host = v;
        }
        get search() {
          return this.searchParams.toString();
        }
        set search(v) {
          this.searchParams = new URLSearchParams(v);
        }
        get collection() {
          return this.pathname.split("/").filter(Boolean)[0] || "";
        }
        set collection(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          parts[0] = v;
          this.pathname = parts.join("/");
        }
        get rkey() {
          return this.pathname.split("/").filter(Boolean)[1] || "";
        }
        set rkey(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          if (!parts[0])
            parts[0] = "undefined";
          parts[1] = v;
          this.pathname = parts.join("/");
        }
        get href() {
          return this.toString();
        }
        toString() {
          let path = this.pathname || "/";
          if (!path.startsWith("/")) {
            path = `/${path}`;
          }
          let qs = this.searchParams.toString();
          if (qs && !qs.startsWith("?")) {
            qs = `?${qs}`;
          }
          let hash = this.hash;
          if (hash && !hash.startsWith("#")) {
            hash = `#${hash}`;
          }
          return `at://${this.host}${path}${qs}${hash}`;
        }
      };
      function parse(str) {
        const match = ATP_URI_REGEX.exec(str);
        if (match) {
          return {
            hash: match[5] || "",
            host: match[2] || "",
            pathname: match[3] || "",
            searchParams: new URLSearchParams(match[4] || "")
          };
        }
        return void 0;
      }
      function parseRelative(str) {
        const match = RELATIVE_REGEX.exec(str);
        if (match) {
          return {
            hash: match[3] || "",
            pathname: match[1] || "",
            searchParams: new URLSearchParams(match[2] || "")
          };
        }
        return void 0;
      }
      var util;
      (function(util2) {
        util2.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util2.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util2.assertNever = assertNever;
        util2.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util2.getValidEnumValues = (obj) => {
          const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
          const filtered = {};
          for (const k of validKeys) {
            filtered[k] = obj[k];
          }
          return util2.objectValues(filtered);
        };
        util2.objectValues = (obj) => {
          return util2.objectKeys(obj).map(function(e) {
            return obj[e];
          });
        };
        util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
          const keys = [];
          for (const key in object2) {
            if (Object.prototype.hasOwnProperty.call(object2, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        util2.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array2, separator = " | ") {
          return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util2.joinValues = joinValues;
        util2.jsonStringifyReplacer = (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util || (util = {}));
      var objectUtil;
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return __spreadValues(__spreadValues({}, first), second);
        };
      })(objectUtil || (objectUtil = {}));
      var ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      var getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "undefined":
            return ZodParsedType.undefined;
          case "string":
            return ZodParsedType.string;
          case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
          case "boolean":
            return ZodParsedType.boolean;
          case "function":
            return ZodParsedType.function;
          case "bigint":
            return ZodParsedType.bigint;
          case "symbol":
            return ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return ZodParsedType.array;
            }
            if (data === null) {
              return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return ZodParsedType.date;
            }
            return ZodParsedType.object;
          default:
            return ZodParsedType.unknown;
        }
      };
      var ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
      ]);
      var quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
      };
      var ZodError = class extends Error {
        constructor(issues) {
          super();
          this.issues = [];
          this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
          };
          this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
          };
          const actualProto = new.target.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
          } else {
            this.__proto__ = actualProto;
          }
          this.name = "ZodError";
          this.issues = issues;
        }
        get errors() {
          return this.issues;
        }
        format(_mapper) {
          const mapper = _mapper || function(issue) {
            return issue.message;
          };
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union") {
                issue.unionErrors.map(processError);
              } else if (issue.code === "invalid_return_type") {
                processError(issue.returnTypeError);
              } else if (issue.code === "invalid_arguments") {
                processError(issue.argumentsError);
              } else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              } else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                  const el = issue.path[i];
                  const terminal = i === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  } else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i++;
                }
              }
            }
          };
          processError(this);
          return fieldErrors;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub of this.issues) {
            if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
              formErrors.push(mapper(sub));
            }
          }
          return { formErrors, fieldErrors };
        }
        get formErrors() {
          return this.flatten();
        }
      };
      ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
      };
      var errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
          case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
              message = "Required";
            } else {
              message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
          case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
          case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
          case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
          case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
          case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
          case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
          case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
          case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
              if ("includes" in issue.validation) {
                message = `Invalid input: must include "${issue.validation.includes}"`;
                if (typeof issue.validation.position === "number") {
                  message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                }
              } else if ("startsWith" in issue.validation) {
                message = `Invalid input: must start with "${issue.validation.startsWith}"`;
              } else if ("endsWith" in issue.validation) {
                message = `Invalid input: must end with "${issue.validation.endsWith}"`;
              } else {
                util.assertNever(issue.validation);
              }
            } else if (issue.validation !== "regex") {
              message = `Invalid ${issue.validation}`;
            } else {
              message = "Invalid";
            }
            break;
          case ZodIssueCode.too_small:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.too_big:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
              message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
          case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
          case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
          default:
            message = _ctx.defaultError;
            util.assertNever(issue);
        }
        return { message };
      };
      var overrideErrorMap = errorMap;
      function setErrorMap(map) {
        overrideErrorMap = map;
      }
      function getErrorMap() {
        return overrideErrorMap;
      }
      var makeIssue = (params2) => {
        const { data, path, errorMaps, issueData } = params2;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = __spreadProps(__spreadValues({}, issueData), {
          path: fullPath
        });
        let errorMessage = "";
        const maps = errorMaps.filter((m) => !!m).slice().reverse();
        for (const map of maps) {
          errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return __spreadProps(__spreadValues({}, issueData), {
          path: fullPath,
          message: issueData.message || errorMessage
        });
      };
      var EMPTY_PATH = [];
      function addIssueToContext(ctx, issueData) {
        const issue = makeIssue({
          issueData,
          data: ctx.data,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x)
        });
        ctx.common.issues.push(issue);
      }
      var ParseStatus = class {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s of results) {
            if (s.status === "aborted")
              return INVALID;
            if (s.status === "dirty")
              status.dirty();
            arrayValue.push(s.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static mergeObjectAsync(status, pairs) {
          return __async(this, null, function* () {
            const syncPairs = [];
            for (const pair of pairs) {
              syncPairs.push({
                key: yield pair.key,
                value: yield pair.value
              });
            }
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return INVALID;
            if (value.status === "aborted")
              return INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      };
      var INVALID = Object.freeze({
        status: "aborted"
      });
      var DIRTY = (value) => ({ status: "dirty", value });
      var OK = (value) => ({ status: "valid", value });
      var isAborted = (x) => x.status === "aborted";
      var isDirty = (x) => x.status === "dirty";
      var isValid = (x) => x.status === "valid";
      var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
      var errorUtil;
      (function(errorUtil2) {
        errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
      })(errorUtil || (errorUtil = {}));
      var ParseInputLazyPath = class {
        constructor(parent, value, path, key) {
          this._cachedPath = [];
          this.parent = parent;
          this.data = value;
          this._path = path;
          this._key = key;
        }
        get path() {
          if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
              this._cachedPath.push(...this._path, ...this._key);
            } else {
              this._cachedPath.push(...this._path, this._key);
            }
          }
          return this._cachedPath;
        }
      };
      var handleResult = (ctx, result) => {
        if (isValid(result)) {
          return { success: true, data: result.value };
        } else {
          if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
          }
          return {
            success: false,
            get error() {
              if (this._error)
                return this._error;
              const error = new ZodError(ctx.common.issues);
              this._error = error;
              return this._error;
            }
          };
        }
      };
      function processCreateParams(params2) {
        if (!params2)
          return {};
        const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
        if (errorMap2 && (invalid_type_error || required_error)) {
          throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        }
        if (errorMap2)
          return { errorMap: errorMap2, description };
        const customMap = (iss, ctx) => {
          if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
          if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
          }
          return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
        };
        return { errorMap: customMap, description };
      }
      var ZodType = class {
        constructor(def2) {
          this.spa = this.safeParseAsync;
          this._def = def2;
          this.parse = this.parse.bind(this);
          this.safeParse = this.safeParse.bind(this);
          this.parseAsync = this.parseAsync.bind(this);
          this.safeParseAsync = this.safeParseAsync.bind(this);
          this.spa = this.spa.bind(this);
          this.refine = this.refine.bind(this);
          this.refinement = this.refinement.bind(this);
          this.superRefine = this.superRefine.bind(this);
          this.optional = this.optional.bind(this);
          this.nullable = this.nullable.bind(this);
          this.nullish = this.nullish.bind(this);
          this.array = this.array.bind(this);
          this.promise = this.promise.bind(this);
          this.or = this.or.bind(this);
          this.and = this.and.bind(this);
          this.transform = this.transform.bind(this);
          this.brand = this.brand.bind(this);
          this.default = this.default.bind(this);
          this.catch = this.catch.bind(this);
          this.describe = this.describe.bind(this);
          this.pipe = this.pipe.bind(this);
          this.isNullable = this.isNullable.bind(this);
          this.isOptional = this.isOptional.bind(this);
        }
        get description() {
          return this._def.description;
        }
        _getType(input) {
          return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
          return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          };
        }
        _processInputParams(input) {
          return {
            status: new ParseStatus(),
            ctx: {
              common: input.parent.common,
              data: input.data,
              parsedType: getParsedType(input.data),
              schemaErrorMap: this._def.errorMap,
              path: input.path,
              parent: input.parent
            }
          };
        }
        _parseSync(input) {
          const result = this._parse(input);
          if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
          }
          return result;
        }
        _parseAsync(input) {
          const result = this._parse(input);
          return Promise.resolve(result);
        }
        parse(data, params2) {
          const result = this.safeParse(data, params2);
          if (result.success)
            return result.data;
          throw result.error;
        }
        safeParse(data, params2) {
          var _a3;
          const ctx = {
            common: {
              issues: [],
              async: (_a3 = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a3 !== void 0 ? _a3 : false,
              contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
            },
            path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const result = this._parseSync({ data, path: ctx.path, parent: ctx });
          return handleResult(ctx, result);
        }
        parseAsync(data, params2) {
          return __async(this, null, function* () {
            const result = yield this.safeParseAsync(data, params2);
            if (result.success)
              return result.data;
            throw result.error;
          });
        }
        safeParseAsync(data, params2) {
          return __async(this, null, function* () {
            const ctx = {
              common: {
                issues: [],
                contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
                async: true
              },
              path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data,
              parsedType: getParsedType(data)
            };
            const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
            const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
            return handleResult(ctx, result);
          });
        }
        refine(check, message) {
          const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
              return { message };
            } else if (typeof message === "function") {
              return message(val);
            } else {
              return message;
            }
          };
          return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue(__spreadValues({
              code: ZodIssueCode.custom
            }, getIssueProperties(val)));
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then((data) => {
                if (!data) {
                  setError();
                  return false;
                } else {
                  return true;
                }
              });
            }
            if (!result) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        refinement(check, refinementData) {
          return this._refinement((val, ctx) => {
            if (!check(val)) {
              ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
              return false;
            } else {
              return true;
            }
          });
        }
        _refinement(refinement) {
          return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement }
          });
        }
        superRefine(refinement) {
          return this._refinement(refinement);
        }
        optional() {
          return ZodOptional.create(this, this._def);
        }
        nullable() {
          return ZodNullable.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return ZodArray.create(this, this._def);
        }
        promise() {
          return ZodPromise.create(this, this._def);
        }
        or(option) {
          return ZodUnion.create([this, option], this._def);
        }
        and(incoming) {
          return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
          return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform }
          }));
        }
        default(def2) {
          const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
          return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
          }));
        }
        brand() {
          return new ZodBranded(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this
          }, processCreateParams(this._def)));
        }
        catch(def2) {
          const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
          return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
          }));
        }
        describe(description) {
          const This = this.constructor;
          return new This(__spreadProps(__spreadValues({}, this._def), {
            description
          }));
        }
        pipe(target2) {
          return ZodPipeline.create(this, target2);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      };
      var cuidRegex = /^c[^\s-]{8,}$/i;
      var cuid2Regex = /^[a-z][a-z0-9]*$/;
      var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
      var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
      var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
      var emojiRegex = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
      var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
      var datetimeRegex = (args) => {
        if (args.precision) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
          }
        } else if (args.precision === 0) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
          }
        } else {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
          }
        }
      };
      function isValidIP(ip, version22) {
        if ((version22 === "v4" || !version22) && ipv4Regex.test(ip)) {
          return true;
        }
        if ((version22 === "v6" || !version22) && ipv6Regex.test(ip)) {
          return true;
        }
        return false;
      }
      var ZodString = class extends ZodType {
        constructor() {
          super(...arguments);
          this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), __spreadValues({
            validation,
            code: ZodIssueCode.invalid_string
          }, errorUtil.errToObj(message)));
          this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
          this.trim = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "trim" }]
          }));
          this.toLowerCase = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toLowerCase" }]
          }));
          this.toUpperCase = () => new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toUpperCase" }]
          }));
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = String(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.length < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.length > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "length") {
              const tooBig = input.data.length > check.value;
              const tooSmall = input.data.length < check.value;
              if (tooBig || tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                if (tooBig) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                } else if (tooSmall) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                }
                status.dirty();
              }
            } else if (check.kind === "email") {
              if (!emailRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "email",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "emoji") {
              if (!emojiRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "emoji",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "uuid") {
              if (!uuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "uuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid") {
              if (!cuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid2") {
              if (!cuid2Regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid2",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ulid") {
              if (!ulidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ulid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "url") {
              try {
                new URL(input.data);
              } catch (_a3) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "url",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "regex") {
              check.regex.lastIndex = 0;
              const testResult = check.regex.test(input.data);
              if (!testResult) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "regex",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "trim") {
              input.data = input.data.trim();
            } else if (check.kind === "includes") {
              if (!input.data.includes(check.value, check.position)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { includes: check.value, position: check.position },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "toLowerCase") {
              input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
              input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
              if (!input.data.startsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { startsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "endsWith") {
              if (!input.data.endsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { endsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "datetime") {
              const regex = datetimeRegex(check);
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: "datetime",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ip") {
              if (!isValidIP(input.data, check.version)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ip",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        _addCheck(check) {
          return new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        email(message) {
          return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
        }
        url(message) {
          return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
        }
        emoji(message) {
          return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
        }
        uuid(message) {
          return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
        }
        cuid(message) {
          return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
        }
        cuid2(message) {
          return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
        }
        ulid(message) {
          return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
        }
        ip(options) {
          return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
        }
        datetime(options) {
          var _a3;
          if (typeof options === "string") {
            return this._addCheck({
              kind: "datetime",
              precision: null,
              offset: false,
              message: options
            });
          }
          return this._addCheck(__spreadValues({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a3 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a3 !== void 0 ? _a3 : false
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        regex(regex, message) {
          return this._addCheck(__spreadValues({
            kind: "regex",
            regex
          }, errorUtil.errToObj(message)));
        }
        includes(value, options) {
          return this._addCheck(__spreadValues({
            kind: "includes",
            value,
            position: options === null || options === void 0 ? void 0 : options.position
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        startsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "startsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        endsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "endsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        min(minLength, message) {
          return this._addCheck(__spreadValues({
            kind: "min",
            value: minLength
          }, errorUtil.errToObj(message)));
        }
        max(maxLength, message) {
          return this._addCheck(__spreadValues({
            kind: "max",
            value: maxLength
          }, errorUtil.errToObj(message)));
        }
        length(len, message) {
          return this._addCheck(__spreadValues({
            kind: "length",
            value: len
          }, errorUtil.errToObj(message)));
        }
        get isDatetime() {
          return !!this._def.checks.find((ch) => ch.kind === "datetime");
        }
        get isEmail() {
          return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
          return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isEmoji() {
          return !!this._def.checks.find((ch) => ch.kind === "emoji");
        }
        get isUUID() {
          return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get isCUID2() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid2");
        }
        get isULID() {
          return !!this._def.checks.find((ch) => ch.kind === "ulid");
        }
        get isIP() {
          return !!this._def.checks.find((ch) => ch.kind === "ip");
        }
        get minLength() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxLength() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodString.create = (params2) => {
        var _a3;
        return new ZodString(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodString,
          coerce: (_a3 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a3 !== void 0 ? _a3 : false
        }, processCreateParams(params2)));
      };
      function floatSafeRemainder(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
        return valInt % stepInt / Math.pow(10, decCount);
      }
      var ZodNumber = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
          this.step = this.multipleOf;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = Number(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.number,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "int") {
              if (!util.isInteger(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (floatSafeRemainder(input.data, check.value) !== 0) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "finite") {
              if (!Number.isFinite(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_finite,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        int(message) {
          return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        finite(message) {
          return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message)
          });
        }
        safe(message) {
          return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message)
          })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
        get isInt() {
          return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
        }
        get isFinite() {
          let max = null, min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
              return true;
            } else if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            } else if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return Number.isFinite(min) && Number.isFinite(max);
        }
      };
      ZodNumber.create = (params2) => {
        return new ZodNumber(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodNumber,
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false
        }, processCreateParams(params2)));
      };
      var ZodBigInt = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = BigInt(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.bigint) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.bigint,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  type: "bigint",
                  minimum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  type: "bigint",
                  maximum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (input.data % check.value !== BigInt(0)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min;
        }
        get maxValue() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max;
        }
      };
      ZodBigInt.create = (params2) => {
        var _a3;
        return new ZodBigInt(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodBigInt,
          coerce: (_a3 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a3 !== void 0 ? _a3 : false
        }, processCreateParams(params2)));
      };
      var ZodBoolean = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = Boolean(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.boolean,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodBoolean.create = (params2) => {
        return new ZodBoolean(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodBoolean,
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false
        }, processCreateParams(params2)));
      };
      var ZodDate = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = new Date(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.date,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          if (isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_date
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.getTime() < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  minimum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.getTime() > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  maximum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return {
            status: status.value,
            value: new Date(input.data.getTime())
          };
        }
        _addCheck(check) {
          return new ZodDate(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        min(minDate, message) {
          return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        max(maxDate, message) {
          return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        get minDate() {
          let min = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min === null || ch.value > min)
                min = ch.value;
            }
          }
          return min != null ? new Date(min) : null;
        }
        get maxDate() {
          let max = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max === null || ch.value < max)
                max = ch.value;
            }
          }
          return max != null ? new Date(max) : null;
        }
      };
      ZodDate.create = (params2) => {
        return new ZodDate(__spreadValues({
          checks: [],
          coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
          typeName: ZodFirstPartyTypeKind.ZodDate
        }, processCreateParams(params2)));
      };
      var ZodSymbol = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.symbol,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodSymbol.create = (params2) => {
        return new ZodSymbol(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodSymbol
        }, processCreateParams(params2)));
      };
      var ZodUndefined = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.undefined,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodUndefined.create = (params2) => {
        return new ZodUndefined(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUndefined
        }, processCreateParams(params2)));
      };
      var ZodNull = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.null,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodNull.create = (params2) => {
        return new ZodNull(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNull
        }, processCreateParams(params2)));
      };
      var ZodAny = class extends ZodType {
        constructor() {
          super(...arguments);
          this._any = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodAny.create = (params2) => {
        return new ZodAny(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodAny
        }, processCreateParams(params2)));
      };
      var ZodUnknown = class extends ZodType {
        constructor() {
          super(...arguments);
          this._unknown = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodUnknown.create = (params2) => {
        return new ZodUnknown(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUnknown
        }, processCreateParams(params2)));
      };
      var ZodNever = class extends ZodType {
        _parse(input) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
          });
          return INVALID;
        }
      };
      ZodNever.create = (params2) => {
        return new ZodNever(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNever
        }, processCreateParams(params2)));
      };
      var ZodVoid = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.void,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodVoid.create = (params2) => {
        return new ZodVoid(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodVoid
        }, processCreateParams(params2)));
      };
      var ZodArray = class extends ZodType {
        _parse(input) {
          const { ctx, status } = this._processInputParams(input);
          const def2 = this._def;
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (def2.exactLength !== null) {
            const tooBig = ctx.data.length > def2.exactLength.value;
            const tooSmall = ctx.data.length < def2.exactLength.value;
            if (tooBig || tooSmall) {
              addIssueToContext(ctx, {
                code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                minimum: tooSmall ? def2.exactLength.value : void 0,
                maximum: tooBig ? def2.exactLength.value : void 0,
                type: "array",
                inclusive: true,
                exact: true,
                message: def2.exactLength.message
              });
              status.dirty();
            }
          }
          if (def2.minLength !== null) {
            if (ctx.data.length < def2.minLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def2.minLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def2.minLength.message
              });
              status.dirty();
            }
          }
          if (def2.maxLength !== null) {
            if (ctx.data.length > def2.maxLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def2.maxLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def2.maxLength.message
              });
              status.dirty();
            }
          }
          if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
              return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result2) => {
              return ParseStatus.mergeArray(status, result2);
            });
          }
          const result = [...ctx.data].map((item, i) => {
            return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          });
          return ParseStatus.mergeArray(status, result);
        }
        get element() {
          return this._def.type;
        }
        min(minLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            minLength: { value: minLength, message: errorUtil.toString(message) }
          }));
        }
        max(maxLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            maxLength: { value: maxLength, message: errorUtil.toString(message) }
          }));
        }
        length(len, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            exactLength: { value: len, message: errorUtil.toString(message) }
          }));
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodArray.create = (schema2, params2) => {
        return new ZodArray(__spreadValues({
          type: schema2,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: ZodFirstPartyTypeKind.ZodArray
        }, processCreateParams(params2)));
      };
      function deepPartialify(schema2) {
        if (schema2 instanceof ZodObject) {
          const newShape = {};
          for (const key in schema2.shape) {
            const fieldSchema = schema2.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
          }
          return new ZodObject(__spreadProps(__spreadValues({}, schema2._def), {
            shape: () => newShape
          }));
        } else if (schema2 instanceof ZodArray) {
          return new ZodArray(__spreadProps(__spreadValues({}, schema2._def), {
            type: deepPartialify(schema2.element)
          }));
        } else if (schema2 instanceof ZodOptional) {
          return ZodOptional.create(deepPartialify(schema2.unwrap()));
        } else if (schema2 instanceof ZodNullable) {
          return ZodNullable.create(deepPartialify(schema2.unwrap()));
        } else if (schema2 instanceof ZodTuple) {
          return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
        } else {
          return schema2;
        }
      }
      var ZodObject = class extends ZodType {
        constructor() {
          super(...arguments);
          this._cached = null;
          this.nonstrict = this.passthrough;
          this.augment = this.extend;
        }
        _getCached() {
          if (this._cached !== null)
            return this._cached;
          const shape = this._def.shape();
          const keys = util.objectKeys(shape);
          return this._cached = { shape, keys };
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const { status, ctx } = this._processInputParams(input);
          const { shape, keys: shapeKeys } = this._getCached();
          const extraKeys = [];
          if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
              if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
              }
            }
          }
          const pairs = [];
          for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
              for (const key of extraKeys) {
                pairs.push({
                  key: { status: "valid", value: key },
                  value: { status: "valid", value: ctx.data[key] }
                });
              }
            } else if (unknownKeys === "strict") {
              if (extraKeys.length > 0) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.unrecognized_keys,
                  keys: extraKeys
                });
                status.dirty();
              }
            } else if (unknownKeys === "strip")
              ;
            else {
              throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
          } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
              const value = ctx.data[key];
              pairs.push({
                key: { status: "valid", value: key },
                value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
              });
            }
          }
          if (ctx.common.async) {
            return Promise.resolve().then(() => __async(this, null, function* () {
              const syncPairs = [];
              for (const pair of pairs) {
                const key = yield pair.key;
                syncPairs.push({
                  key,
                  value: yield pair.value,
                  alwaysSet: pair.alwaysSet
                });
              }
              return syncPairs;
            })).then((syncPairs) => {
              return ParseStatus.mergeObjectSync(status, syncPairs);
            });
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get shape() {
          return this._def.shape();
        }
        strict(message) {
          errorUtil.errToObj;
          return new ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strict"
          }), message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a3, _b, _c, _d;
              const defaultError = (_c = (_b = (_a3 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a3, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}));
        }
        strip() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strip"
          }));
        }
        passthrough() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "passthrough"
          }));
        }
        extend(augmentation) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
          }));
        }
        merge(merging) {
          const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject
          });
          return merged;
        }
        setKey(key, schema2) {
          return this.augment({ [key]: schema2 });
        }
        catchall(index) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            catchall: index
          }));
        }
        pick(mask) {
          const shape = {};
          util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        omit(mask) {
          const shape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        deepPartial() {
          return deepPartialify(this);
        }
        partial(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
              newShape[key] = fieldSchema;
            } else {
              newShape[key] = fieldSchema.optional();
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        required(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        keyof() {
          return createZodEnum(util.objectKeys(this.shape));
        }
      };
      ZodObject.create = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      ZodObject.strictCreate = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strict",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      ZodObject.lazycreate = (shape, params2) => {
        return new ZodObject(__spreadValues({
          shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params2)));
      };
      var ZodUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const options = this._def.options;
          function handleResults(results) {
            for (const result of results) {
              if (result.result.status === "valid") {
                return result.result;
              }
            }
            for (const result of results) {
              if (result.result.status === "dirty") {
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
              }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return Promise.all(options.map((option) => __async(this, null, function* () {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              return {
                result: yield option._parseAsync({
                  data: ctx.data,
                  path: ctx.path,
                  parent: childCtx
                }),
                ctx: childCtx
              };
            }))).then(handleResults);
          } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              const result = option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              });
              if (result.status === "valid") {
                return result;
              } else if (result.status === "dirty" && !dirty) {
                dirty = { result, ctx: childCtx };
              }
              if (childCtx.common.issues.length) {
                issues.push(childCtx.common.issues);
              }
            }
            if (dirty) {
              ctx.common.issues.push(...dirty.ctx.common.issues);
              return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError(issues2));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      ZodUnion.create = (types, params2) => {
        return new ZodUnion(__spreadValues({
          options: types,
          typeName: ZodFirstPartyTypeKind.ZodUnion
        }, processCreateParams(params2)));
      };
      var getDiscriminator = (type) => {
        if (type instanceof ZodLazy) {
          return getDiscriminator(type.schema);
        } else if (type instanceof ZodEffects) {
          return getDiscriminator(type.innerType());
        } else if (type instanceof ZodLiteral) {
          return [type.value];
        } else if (type instanceof ZodEnum) {
          return type.options;
        } else if (type instanceof ZodNativeEnum) {
          return Object.keys(type.enum);
        } else if (type instanceof ZodDefault) {
          return getDiscriminator(type._def.innerType);
        } else if (type instanceof ZodUndefined) {
          return [void 0];
        } else if (type instanceof ZodNull) {
          return [null];
        } else {
          return null;
        }
      };
      var ZodDiscriminatedUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const discriminator = this.discriminator;
          const discriminatorValue = ctx.data[discriminator];
          const option = this.optionsMap.get(discriminatorValue);
          if (!option) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [discriminator]
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          } else {
            return option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(discriminator, options, params2) {
          const optionsMap = /* @__PURE__ */ new Map();
          for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
              throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
              if (optionsMap.has(value)) {
                throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
              }
              optionsMap.set(value, type);
            }
          }
          return new ZodDiscriminatedUnion(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap
          }, processCreateParams(params2)));
        }
      };
      function mergeValues(a, b) {
        const aType = getParsedType(a);
        const bType = getParsedType(b);
        if (a === b) {
          return { valid: true, data: a };
        } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
          const bKeys = util.objectKeys(b);
          const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
          const newObj = __spreadValues(__spreadValues({}, a), b);
          for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newObj[key] = sharedValue.data;
          }
          return { valid: true, data: newObj };
        } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
          if (a.length !== b.length) {
            return { valid: false };
          }
          const newArray = [];
          for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
              return { valid: false };
            }
            newArray.push(sharedValue.data);
          }
          return { valid: true, data: newArray };
        } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
          return { valid: true, data: a };
        } else {
          return { valid: false };
        }
      }
      var ZodIntersection = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
              return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_intersection_types
              });
              return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
              status.dirty();
            }
            return { status: status.value, value: merged.data };
          };
          if (ctx.common.async) {
            return Promise.all([
              this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              }),
              this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              })
            ]).then(([left, right]) => handleParsed(left, right));
          } else {
            return handleParsed(this._def.left._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }), this._def.right._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }));
          }
        }
      };
      ZodIntersection.create = (left, right, params2) => {
        return new ZodIntersection(__spreadValues({
          left,
          right,
          typeName: ZodFirstPartyTypeKind.ZodIntersection
        }, processCreateParams(params2)));
      };
      var ZodTuple = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            return INVALID;
          }
          const rest = this._def.rest;
          if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            status.dirty();
          }
          const items = [...ctx.data].map((item, itemIndex) => {
            const schema2 = this._def.items[itemIndex] || this._def.rest;
            if (!schema2)
              return null;
            return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
          }).filter((x) => !!x);
          if (ctx.common.async) {
            return Promise.all(items).then((results) => {
              return ParseStatus.mergeArray(status, results);
            });
          } else {
            return ParseStatus.mergeArray(status, items);
          }
        }
        get items() {
          return this._def.items;
        }
        rest(rest) {
          return new ZodTuple(__spreadProps(__spreadValues({}, this._def), {
            rest
          }));
        }
      };
      ZodTuple.create = (schemas2, params2) => {
        if (!Array.isArray(schemas2)) {
          throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple(__spreadValues({
          items: schemas2,
          typeName: ZodFirstPartyTypeKind.ZodTuple,
          rest: null
        }, processCreateParams(params2)));
      };
      var ZodRecord = class extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const pairs = [];
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          for (const key in ctx.data) {
            pairs.push({
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
              value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
            });
          }
          if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get element() {
          return this._def.valueType;
        }
        static create(first, second, third) {
          if (second instanceof ZodType) {
            return new ZodRecord(__spreadValues({
              keyType: first,
              valueType: second,
              typeName: ZodFirstPartyTypeKind.ZodRecord
            }, processCreateParams(third)));
          }
          return new ZodRecord(__spreadValues({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord
          }, processCreateParams(second)));
        }
      };
      var ZodMap = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.map,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
              value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
            };
          });
          if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(() => __async(this, null, function* () {
              for (const pair of pairs) {
                const key = yield pair.key;
                const value = yield pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                  return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                  status.dirty();
                }
                finalMap.set(key.value, value.value);
              }
              return { status: status.value, value: finalMap };
            }));
          } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
              const key = pair.key;
              const value = pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          }
        }
      };
      ZodMap.create = (keyType, valueType, params2) => {
        return new ZodMap(__spreadValues({
          valueType,
          keyType,
          typeName: ZodFirstPartyTypeKind.ZodMap
        }, processCreateParams(params2)));
      };
      var ZodSet = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.set,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const def2 = this._def;
          if (def2.minSize !== null) {
            if (ctx.data.size < def2.minSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def2.minSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def2.minSize.message
              });
              status.dirty();
            }
          }
          if (def2.maxSize !== null) {
            if (ctx.data.size > def2.maxSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def2.maxSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def2.maxSize.message
              });
              status.dirty();
            }
          }
          const valueType = this._def.valueType;
          function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
              if (element.status === "aborted")
                return INVALID;
              if (element.status === "dirty")
                status.dirty();
              parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
          }
          const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
          if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
          } else {
            return finalizeSet(elements);
          }
        }
        min(minSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            minSize: { value: minSize, message: errorUtil.toString(message) }
          }));
        }
        max(maxSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            maxSize: { value: maxSize, message: errorUtil.toString(message) }
          }));
        }
        size(size, message) {
          return this.min(size, message).max(size, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodSet.create = (valueType, params2) => {
        return new ZodSet(__spreadValues({
          valueType,
          minSize: null,
          maxSize: null,
          typeName: ZodFirstPartyTypeKind.ZodSet
        }, processCreateParams(params2)));
      };
      var ZodFunction = class extends ZodType {
        constructor() {
          super(...arguments);
          this.validate = this.implement;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.function,
              received: ctx.parsedType
            });
            return INVALID;
          }
          function makeArgsIssue(args, error) {
            return makeIssue({
              data: args,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_arguments,
                argumentsError: error
              }
            });
          }
          function makeReturnsIssue(returns, error) {
            return makeIssue({
              data: returns,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x) => !!x),
              issueData: {
                code: ZodIssueCode.invalid_return_type,
                returnTypeError: error
              }
            });
          }
          const params2 = { errorMap: ctx.common.contextualErrorMap };
          const fn = ctx.data;
          if (this._def.returns instanceof ZodPromise) {
            return OK((...args) => __async(this, null, function* () {
              const error = new ZodError([]);
              const parsedArgs = yield this._def.args.parseAsync(args, params2).catch((e) => {
                error.addIssue(makeArgsIssue(args, e));
                throw error;
              });
              const result = yield fn(...parsedArgs);
              const parsedReturns = yield this._def.returns._def.type.parseAsync(result, params2).catch((e) => {
                error.addIssue(makeReturnsIssue(result, e));
                throw error;
              });
              return parsedReturns;
            }));
          } else {
            return OK((...args) => {
              const parsedArgs = this._def.args.safeParse(args, params2);
              if (!parsedArgs.success) {
                throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
              }
              const result = fn(...parsedArgs.data);
              const parsedReturns = this._def.returns.safeParse(result, params2);
              if (!parsedReturns.success) {
                throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
              }
              return parsedReturns.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...items) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            args: ZodTuple.create(items).rest(ZodUnknown.create())
          }));
        }
        returns(returnType) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            returns: returnType
          }));
        }
        implement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        strictImplement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        static create(args, returns, params2) {
          return new ZodFunction(__spreadValues({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction
          }, processCreateParams(params2)));
        }
      };
      var ZodLazy = class extends ZodType {
        get schema() {
          return this._def.getter();
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const lazySchema = this._def.getter();
          return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
      };
      ZodLazy.create = (getter, params2) => {
        return new ZodLazy(__spreadValues({
          getter,
          typeName: ZodFirstPartyTypeKind.ZodLazy
        }, processCreateParams(params2)));
      };
      var ZodLiteral = class extends ZodType {
        _parse(input) {
          if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_literal,
              expected: this._def.value
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
        get value() {
          return this._def.value;
        }
      };
      ZodLiteral.create = (value, params2) => {
        return new ZodLiteral(__spreadValues({
          value,
          typeName: ZodFirstPartyTypeKind.ZodLiteral
        }, processCreateParams(params2)));
      };
      function createZodEnum(values, params2) {
        return new ZodEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodEnum
        }, processCreateParams(params2)));
      }
      var ZodEnum = class extends ZodType {
        _parse(input) {
          if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Values() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        extract(values) {
          return ZodEnum.create(values);
        }
        exclude(values) {
          return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
        }
      };
      ZodEnum.create = createZodEnum;
      var ZodNativeEnum = class extends ZodType {
        _parse(input) {
          const nativeEnumValues = util.getValidEnumValues(this._def.values);
          const ctx = this._getOrReturnCtx(input);
          if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      ZodNativeEnum.create = (values, params2) => {
        return new ZodNativeEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodNativeEnum
        }, processCreateParams(params2)));
      };
      var ZodPromise = class extends ZodType {
        unwrap() {
          return this._def.type;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.promise,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
          return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
              path: ctx.path,
              errorMap: ctx.common.contextualErrorMap
            });
          }));
        }
      };
      ZodPromise.create = (schema2, params2) => {
        return new ZodPromise(__spreadValues({
          type: schema2,
          typeName: ZodFirstPartyTypeKind.ZodPromise
        }, processCreateParams(params2)));
      };
      var ZodEffects = class extends ZodType {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const effect = this._def.effect || null;
          if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
              return Promise.resolve(processed).then((processed2) => {
                return this._def.schema._parseAsync({
                  data: processed2,
                  path: ctx.path,
                  parent: ctx
                });
              });
            } else {
              return this._def.schema._parseSync({
                data: processed,
                path: ctx.path,
                parent: ctx
              });
            }
          }
          const checkCtx = {
            addIssue: (arg) => {
              addIssueToContext(ctx, arg);
              if (arg.fatal) {
                status.abort();
              } else {
                status.dirty();
              }
            },
            get path() {
              return ctx.path;
            }
          };
          checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
          if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
              const result = effect.refinement(acc, checkCtx);
              if (ctx.common.async) {
                return Promise.resolve(result);
              }
              if (result instanceof Promise) {
                throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
              }
              return acc;
            };
            if (ctx.common.async === false) {
              const inner = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              executeRefinement(inner.value);
              return { status: status.value, value: inner.value };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                if (inner.status === "aborted")
                  return INVALID;
                if (inner.status === "dirty")
                  status.dirty();
                return executeRefinement(inner.value).then(() => {
                  return { status: status.value, value: inner.value };
                });
              });
            }
          }
          if (effect.type === "transform") {
            if (ctx.common.async === false) {
              const base33 = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (!isValid(base33))
                return base33;
              const result = effect.transform(base33.value, checkCtx);
              if (result instanceof Promise) {
                throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
              }
              return { status: status.value, value: result };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base33) => {
                if (!isValid(base33))
                  return base33;
                return Promise.resolve(effect.transform(base33.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
              });
            }
          }
          util.assertNever(effect);
        }
      };
      ZodEffects.create = (schema2, effect, params2) => {
        return new ZodEffects(__spreadValues({
          schema: schema2,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect
        }, processCreateParams(params2)));
      };
      ZodEffects.createWithPreprocess = (preprocess, schema2, params2) => {
        return new ZodEffects(__spreadValues({
          schema: schema2,
          effect: { type: "preprocess", transform: preprocess },
          typeName: ZodFirstPartyTypeKind.ZodEffects
        }, processCreateParams(params2)));
      };
      var ZodOptional = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.undefined) {
            return OK(void 0);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodOptional.create = (type, params2) => {
        return new ZodOptional(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodOptional
        }, processCreateParams(params2)));
      };
      var ZodNullable = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.null) {
            return OK(null);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodNullable.create = (type, params2) => {
        return new ZodNullable(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodNullable
        }, processCreateParams(params2)));
      };
      var ZodDefault = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          let data = ctx.data;
          if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
          }
          return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      ZodDefault.create = (type, params2) => {
        return new ZodDefault(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodDefault,
          defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default
        }, processCreateParams(params2)));
      };
      var ZodCatch = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const newCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            })
          });
          const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: __spreadValues({}, newCtx)
          });
          if (isAsync(result)) {
            return result.then((result2) => {
              return {
                status: "valid",
                value: result2.status === "valid" ? result2.value : this._def.catchValue({
                  get error() {
                    return new ZodError(newCtx.common.issues);
                  },
                  input: newCtx.data
                })
              };
            });
          } else {
            return {
              status: "valid",
              value: result.status === "valid" ? result.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          }
        }
        removeCatch() {
          return this._def.innerType;
        }
      };
      ZodCatch.create = (type, params2) => {
        return new ZodCatch(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodCatch,
          catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch
        }, processCreateParams(params2)));
      };
      var ZodNaN = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.nan,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
      };
      ZodNaN.create = (params2) => {
        return new ZodNaN(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNaN
        }, processCreateParams(params2)));
      };
      var BRAND = Symbol("zod_brand");
      var ZodBranded = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const data = ctx.data;
          return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        unwrap() {
          return this._def.type;
        }
      };
      var ZodPipeline = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.common.async) {
            const handleAsync = () => __async(this, null, function* () {
              const inResult = yield this._def.in._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inResult.status === "aborted")
                return INVALID;
              if (inResult.status === "dirty") {
                status.dirty();
                return DIRTY(inResult.value);
              } else {
                return this._def.out._parseAsync({
                  data: inResult.value,
                  path: ctx.path,
                  parent: ctx
                });
              }
            });
            return handleAsync();
          } else {
            const inResult = this._def.in._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return {
                status: "dirty",
                value: inResult.value
              };
            } else {
              return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }
        }
        static create(a, b) {
          return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
          });
        }
      };
      var custom = (check, params2 = {}, fatal) => {
        if (check)
          return ZodAny.create().superRefine((data, ctx) => {
            var _a3, _b;
            if (!check(data)) {
              const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
              const _fatal = (_b = (_a3 = p.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b !== void 0 ? _b : true;
              const p2 = typeof p === "string" ? { message: p } : p;
              ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal: _fatal }));
            }
          });
        return ZodAny.create();
      };
      var late = {
        object: ZodObject.lazycreate
      };
      var ZodFirstPartyTypeKind;
      (function(ZodFirstPartyTypeKind2) {
        ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
      var instanceOfType = (cls, params2 = {
        message: `Input not instance of ${cls.name}`
      }) => custom((data) => data instanceof cls, params2);
      var stringType = ZodString.create;
      var numberType = ZodNumber.create;
      var nanType = ZodNaN.create;
      var bigIntType = ZodBigInt.create;
      var booleanType = ZodBoolean.create;
      var dateType = ZodDate.create;
      var symbolType = ZodSymbol.create;
      var undefinedType = ZodUndefined.create;
      var nullType = ZodNull.create;
      var anyType = ZodAny.create;
      var unknownType = ZodUnknown.create;
      var neverType = ZodNever.create;
      var voidType = ZodVoid.create;
      var arrayType = ZodArray.create;
      var objectType = ZodObject.create;
      var strictObjectType = ZodObject.strictCreate;
      var unionType = ZodUnion.create;
      var discriminatedUnionType = ZodDiscriminatedUnion.create;
      var intersectionType = ZodIntersection.create;
      var tupleType = ZodTuple.create;
      var recordType = ZodRecord.create;
      var mapType = ZodMap.create;
      var setType = ZodSet.create;
      var functionType = ZodFunction.create;
      var lazyType = ZodLazy.create;
      var literalType = ZodLiteral.create;
      var enumType = ZodEnum.create;
      var nativeEnumType = ZodNativeEnum.create;
      var promiseType = ZodPromise.create;
      var effectsType = ZodEffects.create;
      var optionalType = ZodOptional.create;
      var nullableType = ZodNullable.create;
      var preprocessType = ZodEffects.createWithPreprocess;
      var pipelineType = ZodPipeline.create;
      var ostring = () => stringType().optional();
      var onumber = () => numberType().optional();
      var oboolean = () => booleanType().optional();
      var coerce4 = {
        string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
          coerce: true
        })),
        bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
        date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true }))
      };
      var NEVER2 = INVALID;
      var z = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        defaultErrorMap: errorMap,
        setErrorMap,
        getErrorMap,
        makeIssue,
        EMPTY_PATH,
        addIssueToContext,
        ParseStatus,
        INVALID,
        DIRTY,
        OK,
        isAborted,
        isDirty,
        isValid,
        isAsync,
        get util() {
          return util;
        },
        get objectUtil() {
          return objectUtil;
        },
        ZodParsedType,
        getParsedType,
        ZodType,
        ZodString,
        ZodNumber,
        ZodBigInt,
        ZodBoolean,
        ZodDate,
        ZodSymbol,
        ZodUndefined,
        ZodNull,
        ZodAny,
        ZodUnknown,
        ZodNever,
        ZodVoid,
        ZodArray,
        ZodObject,
        ZodUnion,
        ZodDiscriminatedUnion,
        ZodIntersection,
        ZodTuple,
        ZodRecord,
        ZodMap,
        ZodSet,
        ZodFunction,
        ZodLazy,
        ZodLiteral,
        ZodEnum,
        ZodNativeEnum,
        ZodPromise,
        ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional,
        ZodNullable,
        ZodDefault,
        ZodCatch,
        ZodNaN,
        BRAND,
        ZodBranded,
        ZodPipeline,
        custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late,
        get ZodFirstPartyTypeKind() {
          return ZodFirstPartyTypeKind;
        },
        coerce: coerce4,
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        "enum": enumType,
        "function": functionType,
        "instanceof": instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        "null": nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean,
        onumber,
        optional: optionalType,
        ostring,
        pipeline: pipelineType,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        symbol: symbolType,
        transformer: effectsType,
        tuple: tupleType,
        "undefined": undefinedType,
        union: unionType,
        unknown: unknownType,
        "void": voidType,
        NEVER: NEVER2,
        ZodIssueCode,
        quotelessJson,
        ZodError
      });
      var check_exports = {};
      __export2(check_exports, {
        assure: () => assure,
        is: () => is2,
        isObject: () => isObject
      });
      var is2 = (obj, def2) => {
        return def2.safeParse(obj).success;
      };
      var assure = (def2, obj) => {
        return def2.parse(obj);
      };
      var isObject = (obj) => {
        return typeof obj === "object" && obj !== null;
      };
      var encode_14 = encode10;
      var MSB4 = 128;
      var REST4 = 127;
      var MSBALL4 = ~REST4;
      var INT4 = Math.pow(2, 31);
      function encode10(num, out, offset) {
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT4) {
          out[offset++] = num & 255 | MSB4;
          num /= 128;
        }
        while (num & MSBALL4) {
          out[offset++] = num & 255 | MSB4;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode10.bytes = offset - oldOffset + 1;
        return out;
      }
      var decode16 = read5;
      var MSB$14 = 128;
      var REST$14 = 127;
      function read5(buf2, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
        do {
          if (counter >= l) {
            read5.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf2[counter++];
          res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB$14);
        read5.bytes = counter - offset;
        return res;
      }
      var N14 = Math.pow(2, 7);
      var N24 = Math.pow(2, 14);
      var N34 = Math.pow(2, 21);
      var N44 = Math.pow(2, 28);
      var N54 = Math.pow(2, 35);
      var N64 = Math.pow(2, 42);
      var N74 = Math.pow(2, 49);
      var N84 = Math.pow(2, 56);
      var N94 = Math.pow(2, 63);
      var length4 = function(value) {
        return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
      };
      var varint7 = {
        encode: encode_14,
        decode: decode16,
        encodingLength: length4
      };
      var _brrp_varint4 = varint7;
      var varint_default4 = _brrp_varint4;
      var decode22 = (data, offset = 0) => {
        const code2 = varint_default4.decode(data, offset);
        return [
          code2,
          varint_default4.decode.bytes
        ];
      };
      var encodeTo4 = (int, target2, offset = 0) => {
        varint_default4.encode(int, target2, offset);
        return target2;
      };
      var encodingLength4 = (int) => {
        return varint_default4.encodingLength(int);
      };
      var empty4 = new Uint8Array(0);
      var equals7 = (aa, bb) => {
        if (aa === bb)
          return true;
        if (aa.byteLength !== bb.byteLength) {
          return false;
        }
        for (let ii = 0; ii < aa.byteLength; ii++) {
          if (aa[ii] !== bb[ii]) {
            return false;
          }
        }
        return true;
      };
      var coerce22 = (o) => {
        if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
          return o;
        if (o instanceof ArrayBuffer)
          return new Uint8Array(o);
        if (ArrayBuffer.isView(o)) {
          return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
        }
        throw new Error("Unknown type, must be binary type");
      };
      var fromString3 = (str) => new TextEncoder().encode(str);
      var toString3 = (b) => new TextDecoder().decode(b);
      var create5 = (code2, digest2) => {
        const size = digest2.byteLength;
        const sizeOffset = encodingLength4(code2);
        const digestOffset = sizeOffset + encodingLength4(size);
        const bytes2 = new Uint8Array(digestOffset + size);
        encodeTo4(code2, bytes2, 0);
        encodeTo4(size, bytes2, sizeOffset);
        bytes2.set(digest2, digestOffset);
        return new Digest4(code2, size, digest2, bytes2);
      };
      var decode32 = (multihash) => {
        const bytes2 = coerce22(multihash);
        const [code2, sizeOffset] = decode22(bytes2);
        const [size, digestOffset] = decode22(bytes2.subarray(sizeOffset));
        const digest2 = bytes2.subarray(sizeOffset + digestOffset);
        if (digest2.byteLength !== size) {
          throw new Error("Incorrect length");
        }
        return new Digest4(code2, size, digest2, bytes2);
      };
      var equals22 = (a, b) => {
        if (a === b) {
          return true;
        } else {
          return a.code === b.code && a.size === b.size && equals7(a.bytes, b.bytes);
        }
      };
      var Digest4 = class {
        constructor(code2, size, digest2, bytes2) {
          this.code = code2;
          this.size = size;
          this.digest = digest2;
          this.bytes = bytes2;
        }
      };
      var base58_exports = {};
      __export2(base58_exports, {
        base58btc: () => base58btc4,
        base58flickr: () => base58flickr4
      });
      function base4(ALPHABET, name2) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode52(source) {
          if (source instanceof Uint8Array)
            ;
          else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length22 = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length22) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length22 = i2;
            pbegin++;
          }
          var it2 = size - length22;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          var psz = 0;
          if (source[psz] === " ") {
            return;
          }
          var zeroes = 0;
          var length22 = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length22) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length22 = i2;
            psz++;
          }
          if (source[psz] === " ") {
            return;
          }
          var it4 = size - length22;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = new Uint8Array(zeroes + (size - it4));
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode62(string3) {
          var buffer2 = decodeUnsafe(string3);
          if (buffer2) {
            return buffer2;
          }
          throw new Error(`Non-${name2} character`);
        }
        return {
          encode: encode52,
          decodeUnsafe,
          decode: decode62
        };
      }
      var src5 = base4;
      var _brrp__multiformats_scope_baseX4 = src5;
      var base_x_default4 = _brrp__multiformats_scope_baseX4;
      var Encoder5 = class {
        constructor(name2, prefix, baseEncode) {
          this.name = name2;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes2) {
          if (bytes2 instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes2)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      var Decoder5 = class {
        constructor(name2, prefix, baseDecode) {
          this.name = name2;
          this.prefix = prefix;
          if (prefix.codePointAt(0) === void 0) {
            throw new Error("Invalid prefix character");
          }
          this.prefixCodePoint = prefix.codePointAt(0);
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder22) {
          return or4(this, decoder22);
        }
      };
      var ComposedDecoder4 = class {
        constructor(decoders) {
          this.decoders = decoders;
        }
        or(decoder22) {
          return or4(this, decoder22);
        }
        decode(input) {
          const prefix = input[0];
          const decoder22 = this.decoders[prefix];
          if (decoder22) {
            return decoder22.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      var or4 = (left, right) => new ComposedDecoder4(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
      var Codec4 = class {
        constructor(name2, prefix, baseEncode, baseDecode) {
          this.name = name2;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder5(name2, prefix, baseEncode);
          this.decoder = new Decoder5(name2, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
      var from5 = ({ name: name2, prefix, encode: encode52, decode: decode62 }) => new Codec4(name2, prefix, encode52, decode62);
      var baseX4 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
        const { encode: encode52, decode: decode62 } = base_x_default4(alphabet2, name2);
        return from5({
          prefix,
          name: name2,
          encode: encode52,
          decode: (text) => coerce22(decode62(text))
        });
      };
      var decode42 = (string3, alphabet2, bitsPerChar, name2) => {
        const codes = {};
        for (let i = 0; i < alphabet2.length; ++i) {
          codes[alphabet2[i]] = i;
        }
        let end = string3.length;
        while (string3[end - 1] === "=") {
          --end;
        }
        const out = new Uint8Array(end * bitsPerChar / 8 | 0);
        let bits = 0;
        let buffer2 = 0;
        let written = 0;
        for (let i = 0; i < end; ++i) {
          const value = codes[string3[i]];
          if (value === void 0) {
            throw new SyntaxError(`Non-${name2} character`);
          }
          buffer2 = buffer2 << bitsPerChar | value;
          bits += bitsPerChar;
          if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer2 >> bits;
          }
        }
        if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
          throw new SyntaxError("Unexpected end of data");
        }
        return out;
      };
      var encode22 = (data, alphabet2, bitsPerChar) => {
        const pad = alphabet2[alphabet2.length - 1] === "=";
        const mask = (1 << bitsPerChar) - 1;
        let out = "";
        let bits = 0;
        let buffer2 = 0;
        for (let i = 0; i < data.length; ++i) {
          buffer2 = buffer2 << 8 | data[i];
          bits += 8;
          while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet2[mask & buffer2 >> bits];
          }
        }
        if (bits) {
          out += alphabet2[mask & buffer2 << bitsPerChar - bits];
        }
        if (pad) {
          while (out.length * bitsPerChar & 7) {
            out += "=";
          }
        }
        return out;
      };
      var rfc46484 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
        return from5({
          prefix,
          name: name2,
          encode(input) {
            return encode22(input, alphabet2, bitsPerChar);
          },
          decode(input) {
            return decode42(input, alphabet2, bitsPerChar, name2);
          }
        });
      };
      var base58btc4 = baseX4({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      var base58flickr4 = baseX4({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
      var base32_exports = {};
      __export2(base32_exports, {
        base32: () => base324,
        base32hex: () => base32hex4,
        base32hexpad: () => base32hexpad4,
        base32hexpadupper: () => base32hexpadupper4,
        base32hexupper: () => base32hexupper4,
        base32pad: () => base32pad4,
        base32padupper: () => base32padupper4,
        base32upper: () => base32upper4,
        base32z: () => base32z4
      });
      var base324 = rfc46484({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      });
      var base32upper4 = rfc46484({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      });
      var base32pad4 = rfc46484({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      });
      var base32padupper4 = rfc46484({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      });
      var base32hex4 = rfc46484({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      });
      var base32hexupper4 = rfc46484({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      });
      var base32hexpad4 = rfc46484({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      });
      var base32hexpadupper4 = rfc46484({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      });
      var base32z4 = rfc46484({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
      var CID4 = class {
        constructor(version22, code2, multihash, bytes2) {
          this.code = code2;
          this.version = version22;
          this.multihash = multihash;
          this.bytes = bytes2;
          this.byteOffset = bytes2.byteOffset;
          this.byteLength = bytes2.byteLength;
          this.asCID = this;
          this._baseCache = /* @__PURE__ */ new Map();
          Object.defineProperties(this, {
            byteOffset: hidden2,
            byteLength: hidden2,
            code: readonly2,
            version: readonly2,
            multihash: readonly2,
            bytes: readonly2,
            _baseCache: hidden2,
            asCID: hidden2
          });
        }
        toV0() {
          switch (this.version) {
            case 0: {
              return this;
            }
            default: {
              const { code: code2, multihash } = this;
              if (code2 !== DAG_PB_CODE4) {
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              }
              if (multihash.code !== SHA_256_CODE4) {
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              }
              return CID4.createV0(multihash);
            }
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              const { code: code2, digest: digest2 } = this.multihash;
              const multihash = create5(code2, digest2);
              return CID4.createV1(this.code, multihash);
            }
            case 1: {
              return this;
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
          }
        }
        equals(other) {
          return other && this.code === other.code && this.version === other.version && equals22(this.multihash, other.multihash);
        }
        toString(base33) {
          const { bytes: bytes2, version: version22, _baseCache } = this;
          switch (version22) {
            case 0:
              return toStringV04(bytes2, _baseCache, base33 || base58btc4.encoder);
            default:
              return toStringV14(bytes2, _baseCache, base33 || base324.encoder);
          }
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(value) {
          deprecate2(/^0\.0/, IS_CID_DEPRECATION2);
          return !!(value && (value[cidSymbol4] || value.asCID === value));
        }
        get toBaseEncodedString() {
          throw new Error("Deprecated, use .toString()");
        }
        get codec() {
          throw new Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
        }
        get multibaseName() {
          throw new Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw new Error('"prefix" property is deprecated');
        }
        static asCID(value) {
          if (value instanceof CID4) {
            return value;
          } else if (value != null && value.asCID === value) {
            const { version: version22, code: code2, multihash, bytes: bytes2 } = value;
            return new CID4(version22, code2, multihash, bytes2 || encodeCID4(version22, code2, multihash.bytes));
          } else if (value != null && value[cidSymbol4] === true) {
            const { version: version22, multihash, code: code2 } = value;
            const digest2 = decode32(multihash);
            return CID4.create(version22, code2, digest2);
          } else {
            return null;
          }
        }
        static create(version22, code2, digest2) {
          if (typeof code2 !== "number") {
            throw new Error("String codecs are no longer supported");
          }
          switch (version22) {
            case 0: {
              if (code2 !== DAG_PB_CODE4) {
                throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`);
              } else {
                return new CID4(version22, code2, digest2, digest2.bytes);
              }
            }
            case 1: {
              const bytes2 = encodeCID4(version22, code2, digest2.bytes);
              return new CID4(version22, code2, digest2, bytes2);
            }
            default: {
              throw new Error("Invalid version");
            }
          }
        }
        static createV0(digest2) {
          return CID4.create(0, DAG_PB_CODE4, digest2);
        }
        static createV1(code2, digest2) {
          return CID4.create(1, code2, digest2);
        }
        static decode(bytes2) {
          const [cid2, remainder] = CID4.decodeFirst(bytes2);
          if (remainder.length) {
            throw new Error("Incorrect length");
          }
          return cid2;
        }
        static decodeFirst(bytes2) {
          const specs = CID4.inspectBytes(bytes2);
          const prefixSize = specs.size - specs.multihashSize;
          const multihashBytes = coerce22(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
          if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
          }
          const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
          const digest2 = new Digest4(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
          const cid2 = specs.version === 0 ? CID4.createV0(digest2) : CID4.createV1(specs.codec, digest2);
          return [
            cid2,
            bytes2.subarray(specs.size)
          ];
        }
        static inspectBytes(initialBytes) {
          let offset = 0;
          const next = () => {
            const [i, length22] = decode22(initialBytes.subarray(offset));
            offset += length22;
            return i;
          };
          let version22 = next();
          let codec = DAG_PB_CODE4;
          if (version22 === 18) {
            version22 = 0;
            offset = 0;
          } else if (version22 === 1) {
            codec = next();
          }
          if (version22 !== 0 && version22 !== 1) {
            throw new RangeError(`Invalid CID version ${version22}`);
          }
          const prefixSize = offset;
          const multihashCode = next();
          const digestSize = next();
          const size = offset + digestSize;
          const multihashSize = size - prefixSize;
          return {
            version: version22,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
          };
        }
        static parse(source, base33) {
          const [prefix, bytes2] = parseCIDtoBytes4(source, base33);
          const cid2 = CID4.decode(bytes2);
          cid2._baseCache.set(prefix, source);
          return cid2;
        }
      };
      var parseCIDtoBytes4 = (source, base33) => {
        switch (source[0]) {
          case "Q": {
            const decoder22 = base33 || base58btc4;
            return [
              base58btc4.prefix,
              decoder22.decode(`${base58btc4.prefix}${source}`)
            ];
          }
          case base58btc4.prefix: {
            const decoder22 = base33 || base58btc4;
            return [
              base58btc4.prefix,
              decoder22.decode(source)
            ];
          }
          case base324.prefix: {
            const decoder22 = base33 || base324;
            return [
              base324.prefix,
              decoder22.decode(source)
            ];
          }
          default: {
            if (base33 == null) {
              throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            }
            return [
              source[0],
              base33.decode(source)
            ];
          }
        }
      };
      var toStringV04 = (bytes2, cache3, base33) => {
        const { prefix } = base33;
        if (prefix !== base58btc4.prefix) {
          throw Error(`Cannot string encode V0 in ${base33.name} encoding`);
        }
        const cid2 = cache3.get(prefix);
        if (cid2 == null) {
          const cid3 = base33.encode(bytes2).slice(1);
          cache3.set(prefix, cid3);
          return cid3;
        } else {
          return cid2;
        }
      };
      var toStringV14 = (bytes2, cache3, base33) => {
        const { prefix } = base33;
        const cid2 = cache3.get(prefix);
        if (cid2 == null) {
          const cid3 = base33.encode(bytes2);
          cache3.set(prefix, cid3);
          return cid3;
        } else {
          return cid2;
        }
      };
      var DAG_PB_CODE4 = 112;
      var SHA_256_CODE4 = 18;
      var encodeCID4 = (version22, code2, multihash) => {
        const codeOffset = encodingLength4(version22);
        const hashOffset = codeOffset + encodingLength4(code2);
        const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
        encodeTo4(version22, bytes2, 0);
        encodeTo4(code2, bytes2, codeOffset);
        bytes2.set(multihash, hashOffset);
        return bytes2;
      };
      var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");
      var readonly2 = {
        writable: false,
        configurable: false,
        enumerable: true
      };
      var hidden2 = {
        writable: false,
        enumerable: false,
        configurable: false
      };
      var version2 = "0.0.0-dev";
      var deprecate2 = (range, message) => {
        if (range.test(version2)) {
          console.warn(message);
        } else {
          throw new Error(message);
        }
      };
      var IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
      var identity_exports = {};
      __export2(identity_exports, {
        identity: () => identity
      });
      var identity = from5({
        prefix: "\0",
        name: "identity",
        encode: (buf2) => toString3(buf2),
        decode: (str) => fromString3(str)
      });
      var base2_exports = {};
      __export2(base2_exports, {
        base2: () => base22
      });
      var base22 = rfc46484({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
      });
      var base8_exports = {};
      __export2(base8_exports, {
        base8: () => base8
      });
      var base8 = rfc46484({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
      });
      var base10_exports = {};
      __export2(base10_exports, {
        base10: () => base10
      });
      var base10 = baseX4({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
      });
      var base16_exports = {};
      __export2(base16_exports, {
        base16: () => base16,
        base16upper: () => base16upper
      });
      var base16 = rfc46484({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
      });
      var base16upper = rfc46484({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      });
      var base36_exports = {};
      __export2(base36_exports, {
        base36: () => base36,
        base36upper: () => base36upper
      });
      var base36 = baseX4({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
      });
      var base36upper = baseX4({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      });
      var base64_exports = {};
      __export2(base64_exports, {
        base64: () => base64,
        base64pad: () => base64pad,
        base64url: () => base64url,
        base64urlpad: () => base64urlpad
      });
      var base64 = rfc46484({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
      });
      var base64pad = rfc46484({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      });
      var base64url = rfc46484({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      });
      var base64urlpad = rfc46484({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      });
      var base256emoji_exports = {};
      __export2(base256emoji_exports, {
        base256emoji: () => base256emoji
      });
      var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
      var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
        p[i] = c;
        return p;
      }, []);
      var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
        p[c.codePointAt(0)] = i;
        return p;
      }, []);
      function encode32(data) {
        return data.reduce((p, c) => {
          p += alphabetBytesToChars[c];
          return p;
        }, "");
      }
      function decode52(str) {
        const byts = [];
        for (const char of str) {
          const byt = alphabetCharsToBytes[char.codePointAt(0)];
          if (byt === void 0) {
            throw new Error(`Non-base256emoji character: ${char}`);
          }
          byts.push(byt);
        }
        return new Uint8Array(byts);
      }
      var base256emoji = from5({
        prefix: "\u{1F680}",
        name: "base256emoji",
        encode: encode32,
        decode: decode52
      });
      var sha2_browser_exports = {};
      __export2(sha2_browser_exports, {
        sha256: () => sha256,
        sha512: () => sha512
      });
      var from22 = ({ name: name2, code: code2, encode: encode52 }) => new Hasher2(name2, code2, encode52);
      var Hasher2 = class {
        constructor(name2, code2, encode52) {
          this.name = name2;
          this.code = code2;
          this.encode = encode52;
        }
        digest(input) {
          if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? create5(this.code, result) : result.then((digest2) => create5(this.code, digest2));
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      var sha = (name2) => (data) => __async(exports, null, function* () {
        return new Uint8Array(yield crypto.subtle.digest(name2, data));
      });
      var sha256 = from22({
        name: "sha2-256",
        code: 18,
        encode: sha("SHA-256")
      });
      var sha512 = from22({
        name: "sha2-512",
        code: 19,
        encode: sha("SHA-512")
      });
      var identity_exports2 = {};
      __export2(identity_exports2, {
        identity: () => identity2
      });
      var code = 0;
      var name = "identity";
      var encode42 = coerce22;
      var digest = (input) => create5(code, encode42(input));
      var identity2 = {
        code,
        name,
        encode: encode42,
        digest
      };
      var textEncoder3 = new TextEncoder();
      var textDecoder2 = new TextDecoder();
      var bases = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity_exports), base2_exports), base8_exports), base10_exports), base16_exports), base32_exports), base36_exports), base58_exports), base64_exports), base256emoji_exports);
      var hashes = __spreadValues(__spreadValues({}, sha2_browser_exports), identity_exports2);
      function createCodec(name2, prefix, encode52, decode62) {
        return {
          name: name2,
          prefix,
          encoder: {
            name: name2,
            prefix,
            encode: encode52
          },
          decoder: { decode: decode62 }
        };
      }
      var string = createCodec("utf8", "u", (buf2) => {
        const decoder22 = new TextDecoder("utf8");
        return "u" + decoder22.decode(buf2);
      }, (str) => {
        const encoder2 = new TextEncoder();
        return encoder2.encode(str.substring(1));
      });
      var ascii = createCodec("ascii", "a", (buf2) => {
        let string3 = "a";
        for (let i = 0; i < buf2.length; i++) {
          string3 += String.fromCharCode(buf2[i]);
        }
        return string3;
      }, (str) => {
        str = str.substring(1);
        const buf2 = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          buf2[i] = str.charCodeAt(i);
        }
        return buf2;
      });
      var BASES = __spreadValues({
        utf8: string,
        "utf-8": string,
        hex: bases.base16,
        latin1: ascii,
        ascii,
        binary: ascii
      }, bases);
      var bases_default = BASES;
      function fromString22(string3, encoding = "utf8") {
        const base33 = bases_default[encoding];
        if (!base33) {
          throw new Error(`Unsupported encoding "${encoding}"`);
        }
        return base33.decoder.decode(`${base33.prefix}${string3}`);
      }
      function toString22(array2, encoding = "utf8") {
        const base33 = bases_default[encoding];
        if (!base33) {
          throw new Error(`Unsupported encoding "${encoding}"`);
        }
        return base33.encoder.encode(array2).substring(1);
      }
      var jsonToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => jsonToIpld(item));
        }
        if (val && typeof val === "object") {
          if (typeof val["$link"] === "string" && Object.keys(val).length === 1) {
            return CID4.parse(val["$link"]);
          }
          if (typeof val["$bytes"] === "string" && Object.keys(val).length === 1) {
            return fromString22(val["$bytes"], "base64");
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = jsonToIpld(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var ipldToJson = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => ipldToJson(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof Uint8Array) {
            return {
              $bytes: toString22(val, "base64")
            };
          }
          if (CID4.asCID(val)) {
            return {
              $link: val.toString()
            };
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = ipldToJson(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var cidSchema = z.any().refine((obj) => CID4.asCID(obj) !== null, {
        message: "Not a CID"
      }).transform((obj) => CID4.asCID(obj));
      var schema = {
        cid: cidSchema,
        bytes: z.instanceof(Uint8Array),
        string: z.string(),
        array: z.array(z.unknown()),
        map: z.record(z.string(), z.unknown()),
        unknown: z.unknown()
      };
      var def = {
        cid: {
          name: "cid",
          schema: schema.cid
        },
        bytes: {
          name: "bytes",
          schema: schema.bytes
        },
        string: {
          name: "string",
          schema: schema.string
        },
        map: {
          name: "map",
          schema: schema.map
        },
        unknown: {
          name: "unknown",
          schema: schema.unknown
        }
      };
      var SECOND = 1e3;
      var MINUTE = SECOND * 60;
      var HOUR = MINUTE * 60;
      var DAY = HOUR * 24;
      var import_graphemer = __toESM2(require_lib());
      var utf8Len = (str) => {
        return new TextEncoder().encode(str).byteLength;
      };
      var graphemeLen = (str) => {
        const splitter = new import_graphemer.default();
        return splitter.countGraphemes(str);
      };
      var parseLanguage = (langTag) => {
        const parsed = langTag.match(bcp47Regexp);
        if (!(parsed == null ? void 0 : parsed.groups))
          return null;
        const parts = parsed.groups;
        return {
          grandfathered: parts.grandfathered,
          language: parts.language,
          extlang: parts.extlang,
          script: parts.script,
          region: parts.region,
          variant: parts.variant,
          extension: parts.extension,
          privateUse: parts.privateUseA || parts.privateUseB
        };
      };
      var validateLanguage = (langTag) => {
        return bcp47Regexp.test(langTag);
      };
      var bcp47Regexp = new RegExp("^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$");
      var isValidDidDoc = (doc) => {
        return didDocument.safeParse(doc).success;
      };
      var getDid = (doc) => {
        const id = doc.id;
        if (typeof id !== "string") {
          throw new Error("No `id` on document");
        }
        return id;
      };
      var getPdsEndpoint = (doc) => {
        return getServiceEndpoint(doc, {
          id: "#atproto_pds",
          type: "AtprotoPersonalDataServer"
        });
      };
      var getServiceEndpoint = (doc, opts) => {
        const did2 = getDid(doc);
        let services = doc.service;
        if (!services)
          return void 0;
        if (typeof services !== "object")
          return void 0;
        if (!Array.isArray(services)) {
          services = [services];
        }
        const found = services.find((service2) => service2.id === opts.id || service2.id === `${did2}${opts.id}`);
        if (!found)
          return void 0;
        if (found.type !== opts.type) {
          return void 0;
        }
        if (typeof found.serviceEndpoint !== "string") {
          return void 0;
        }
        return validateUrl(found.serviceEndpoint);
      };
      var validateUrl = (urlStr) => {
        let url;
        try {
          url = new URL(urlStr);
        } catch (e) {
          return void 0;
        }
        if (!["http:", "https:"].includes(url.protocol)) {
          return void 0;
        } else if (!url.hostname) {
          return void 0;
        } else {
          return urlStr;
        }
      };
      var verificationMethod = z.object({
        id: z.string(),
        type: z.string(),
        controller: z.string(),
        publicKeyMultibase: z.string().optional()
      });
      var service = z.object({
        id: z.string(),
        type: z.string(),
        serviceEndpoint: z.union([z.string(), z.record(z.unknown())])
      });
      var didDocument = z.object({
        id: z.string(),
        alsoKnownAs: z.array(z.string()).optional(),
        verificationMethod: z.array(verificationMethod).optional(),
        service: z.array(service).optional()
      });
      var import_iso_datestring_validator = __toESM2(require_dist2());
      function datetime(path, value) {
        try {
          if (!(0, import_iso_datestring_validator.isValidISODateString)(value)) {
            throw new Error();
          }
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
          };
        }
        return { success: true, value };
      }
      function uri(path, value) {
        const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
        if (!isUri) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a uri`)
          };
        }
        return { success: true, value };
      }
      function atUri(path, value) {
        try {
          ensureValidAtUri(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid at-uri`)
          };
        }
        return { success: true, value };
      }
      function did(path, value) {
        try {
          ensureValidDid(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid did`)
          };
        }
        return { success: true, value };
      }
      function handle(path, value) {
        try {
          ensureValidHandle(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid handle`)
          };
        }
        return { success: true, value };
      }
      function atIdentifier(path, value) {
        const isDid = did(path, value);
        if (!isDid.success) {
          const isHandle2 = handle(path, value);
          if (!isHandle2.success) {
            return {
              success: false,
              error: new ValidationError(`${path} must be a valid did or a handle`)
            };
          }
        }
        return { success: true, value };
      }
      function nsid(path, value) {
        try {
          ensureValidNsid(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a valid nsid`)
          };
        }
        return { success: true, value };
      }
      function cid(path, value) {
        try {
          CID4.parse(value);
        } catch (e) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a cid string`)
          };
        }
        return { success: true, value };
      }
      function language(path, value) {
        if (validateLanguage(value)) {
          return { success: true, value };
        }
        return {
          success: false,
          error: new ValidationError(`${path} must be a well-formed BCP 47 language tag`)
        };
      }
      function validate(lexicons2, path, def2, value) {
        switch (def2.type) {
          case "boolean":
            return boolean(lexicons2, path, def2, value);
          case "integer":
            return integer(lexicons2, path, def2, value);
          case "string":
            return string2(lexicons2, path, def2, value);
          case "bytes":
            return bytes(lexicons2, path, def2, value);
          case "cid-link":
            return cidLink(lexicons2, path, def2, value);
          case "unknown":
            return unknown(lexicons2, path, def2, value);
          default:
            return {
              success: false,
              error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)
            };
        }
      }
      function boolean(lexicons2, path, def2, value) {
        def2 = def2;
        const type = typeof value;
        if (type === "undefined") {
          if (typeof def2.default === "boolean") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be a boolean`)
          };
        } else if (type !== "boolean") {
          return {
            success: false,
            error: new ValidationError(`${path} must be a boolean`)
          };
        }
        if (typeof def2.const === "boolean") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        return { success: true, value };
      }
      function integer(lexicons2, path, def2, value) {
        def2 = def2;
        const type = typeof value;
        if (type === "undefined") {
          if (typeof def2.default === "number") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be an integer`)
          };
        } else if (!Number.isInteger(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an integer`)
          };
        }
        if (typeof def2.const === "number") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        if (Array.isArray(def2.enum)) {
          if (!def2.enum.includes(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be one of (${def2.enum.join("|")})`)
            };
          }
        }
        if (typeof def2.maximum === "number") {
          if (value > def2.maximum) {
            return {
              success: false,
              error: new ValidationError(`${path} can not be greater than ${def2.maximum}`)
            };
          }
        }
        if (typeof def2.minimum === "number") {
          if (value < def2.minimum) {
            return {
              success: false,
              error: new ValidationError(`${path} can not be less than ${def2.minimum}`)
            };
          }
        }
        return { success: true, value };
      }
      function string2(lexicons2, path, def2, value) {
        def2 = def2;
        if (typeof value === "undefined") {
          if (typeof def2.default === "string") {
            return { success: true, value: def2.default };
          }
          return {
            success: false,
            error: new ValidationError(`${path} must be a string`)
          };
        } else if (typeof value !== "string") {
          return {
            success: false,
            error: new ValidationError(`${path} must be a string`)
          };
        }
        if (typeof def2.const === "string") {
          if (value !== def2.const) {
            return {
              success: false,
              error: new ValidationError(`${path} must be ${def2.const}`)
            };
          }
        }
        if (Array.isArray(def2.enum)) {
          if (!def2.enum.includes(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be one of (${def2.enum.join("|")})`)
            };
          }
        }
        if (typeof def2.maxLength === "number") {
          if (utf8Len(value) > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be longer than ${def2.maxLength} characters`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (utf8Len(value) < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be shorter than ${def2.minLength} characters`)
            };
          }
        }
        if (typeof def2.maxGraphemes === "number") {
          if (graphemeLen(value) > def2.maxGraphemes) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be longer than ${def2.maxGraphemes} graphemes`)
            };
          }
        }
        if (typeof def2.minGraphemes === "number") {
          if (graphemeLen(value) < def2.minGraphemes) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be shorter than ${def2.minGraphemes} graphemes`)
            };
          }
        }
        if (typeof def2.format === "string") {
          switch (def2.format) {
            case "datetime":
              return datetime(path, value);
            case "uri":
              return uri(path, value);
            case "at-uri":
              return atUri(path, value);
            case "did":
              return did(path, value);
            case "handle":
              return handle(path, value);
            case "at-identifier":
              return atIdentifier(path, value);
            case "nsid":
              return nsid(path, value);
            case "cid":
              return cid(path, value);
            case "language":
              return language(path, value);
          }
        }
        return { success: true, value };
      }
      function bytes(lexicons2, path, def2, value) {
        def2 = def2;
        if (!value || !(value instanceof Uint8Array)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a byte array`)
          };
        }
        if (typeof def2.maxLength === "number") {
          if (value.byteLength > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be larger than ${def2.maxLength} bytes`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (value.byteLength < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not be smaller than ${def2.minLength} bytes`)
            };
          }
        }
        return { success: true, value };
      }
      function cidLink(lexicons2, path, def2, value) {
        if (CID4.asCID(value) === null) {
          return {
            success: false,
            error: new ValidationError(`${path} must be a CID`)
          };
        }
        return { success: true, value };
      }
      function unknown(lexicons2, path, def2, value) {
        if (!value || typeof value !== "object") {
          return {
            success: false,
            error: new ValidationError(`${path} must be an object`)
          };
        }
        return { success: true, value };
      }
      var typedJsonBlobRef = z.object({
        $type: z.literal("blob"),
        ref: schema.cid,
        mimeType: z.string(),
        size: z.number()
      }).strict();
      var untypedJsonBlobRef = z.object({
        cid: z.string(),
        mimeType: z.string()
      }).strict();
      var jsonBlobRef = z.union([typedJsonBlobRef, untypedJsonBlobRef]);
      var BlobRef = class {
        constructor(ref, mimeType, size, original) {
          this.ref = ref;
          this.mimeType = mimeType;
          this.size = size;
          this.original = original != null ? original : {
            $type: "blob",
            ref,
            mimeType,
            size
          };
        }
        static asBlobRef(obj) {
          if (check_exports.is(obj, jsonBlobRef)) {
            return BlobRef.fromJsonRef(obj);
          }
          return null;
        }
        static fromJsonRef(json) {
          if (check_exports.is(json, typedJsonBlobRef)) {
            return new BlobRef(json.ref, json.mimeType, json.size);
          } else {
            return new BlobRef(CID4.parse(json.cid), json.mimeType, -1, json);
          }
        }
        ipld() {
          return {
            $type: "blob",
            ref: this.ref,
            mimeType: this.mimeType,
            size: this.size
          };
        }
        toJSON() {
          return ipldToJson(this.ipld());
        }
      };
      function blob(lexicons2, path, def2, value) {
        if (!value || !(value instanceof BlobRef)) {
          return {
            success: false,
            error: new ValidationError(`${path} should be a blob ref`)
          };
        }
        return { success: true, value };
      }
      function validate2(lexicons2, path, def2, value) {
        switch (def2.type) {
          case "boolean":
            return boolean(lexicons2, path, def2, value);
          case "integer":
            return integer(lexicons2, path, def2, value);
          case "string":
            return string2(lexicons2, path, def2, value);
          case "bytes":
            return bytes(lexicons2, path, def2, value);
          case "cid-link":
            return cidLink(lexicons2, path, def2, value);
          case "unknown":
            return unknown(lexicons2, path, def2, value);
          case "object":
            return object(lexicons2, path, def2, value);
          case "array":
            return array(lexicons2, path, def2, value);
          case "blob":
            return blob(lexicons2, path, def2, value);
          default:
            return {
              success: false,
              error: new ValidationError(`Unexpected lexicon type: ${def2.type}`)
            };
        }
      }
      function array(lexicons2, path, def2, value) {
        if (!Array.isArray(value)) {
          return {
            success: false,
            error: new ValidationError(`${path} must be an array`)
          };
        }
        if (typeof def2.maxLength === "number") {
          if (value.length > def2.maxLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not have more than ${def2.maxLength} elements`)
            };
          }
        }
        if (typeof def2.minLength === "number") {
          if (value.length < def2.minLength) {
            return {
              success: false,
              error: new ValidationError(`${path} must not have fewer than ${def2.minLength} elements`)
            };
          }
        }
        const itemsDef = def2.items;
        for (let i = 0; i < value.length; i++) {
          const itemValue = value[i];
          const itemPath = `${path}/${i}`;
          const res = validateOneOf(lexicons2, itemPath, itemsDef, itemValue);
          if (!res.success) {
            return res;
          }
        }
        return { success: true, value };
      }
      function object(lexicons2, path, def2, value) {
        def2 = def2;
        if (!value || typeof value !== "object") {
          return {
            success: false,
            error: new ValidationError(`${path} must be an object`)
          };
        }
        const requiredProps = new Set(def2.required);
        const nullableProps = new Set(def2.nullable);
        let resultValue = value;
        if (typeof def2.properties === "object") {
          for (const key in def2.properties) {
            if (value[key] === null && nullableProps.has(key)) {
              continue;
            }
            const propDef = def2.properties[key];
            const propPath = `${path}/${key}`;
            const validated = validateOneOf(lexicons2, propPath, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === "undefined";
            if (propIsUndefined && requiredProps.has(key)) {
              return {
                success: false,
                error: new ValidationError(`${path} must have the property "${key}"`)
              };
            } else if (!propIsUndefined && !validated.success) {
              return validated;
            }
            if (propValue !== value[key]) {
              if (resultValue === value) {
                resultValue = __spreadValues({}, value);
              }
              resultValue[key] = propValue;
            }
          }
        }
        return { success: true, value: resultValue };
      }
      function toLexUri(str, baseUri) {
        if (str.split("#").length > 2) {
          throw new Error("Uri can only have one hash segment");
        }
        if (str.startsWith("lex:")) {
          return str;
        }
        if (str.startsWith("#")) {
          if (!baseUri) {
            throw new Error(`Unable to resolve uri without anchor: ${str}`);
          }
          return `${baseUri}${str}`;
        }
        return `lex:${str}`;
      }
      function validateOneOf(lexicons2, path, def2, value, mustBeObj = false) {
        let error;
        let concreteDefs;
        if (def2.type === "union") {
          if (!isDiscriminatedObject(value)) {
            return {
              success: false,
              error: new ValidationError(`${path} must be an object which includes the "$type" property`)
            };
          }
          if (!refsContainType(def2.refs, value.$type)) {
            if (def2.closed) {
              return {
                success: false,
                error: new ValidationError(`${path} $type must be one of ${def2.refs.join(", ")}`)
              };
            }
            return { success: true, value };
          } else {
            concreteDefs = toConcreteTypes(lexicons2, {
              type: "ref",
              ref: value.$type
            });
          }
        } else {
          concreteDefs = toConcreteTypes(lexicons2, def2);
        }
        for (const concreteDef of concreteDefs) {
          const result = mustBeObj ? object(lexicons2, path, concreteDef, value) : validate2(lexicons2, path, concreteDef, value);
          if (result.success) {
            return result;
          }
          error != null ? error : error = result.error;
        }
        if (concreteDefs.length > 1) {
          return {
            success: false,
            error: new ValidationError(`${path} did not match any of the expected definitions`)
          };
        }
        return { success: false, error };
      }
      function assertValidOneOf(lexicons2, path, def2, value, mustBeObj = false) {
        const res = validateOneOf(lexicons2, path, def2, value, mustBeObj);
        if (!res.success)
          throw res.error;
        return res.value;
      }
      function toConcreteTypes(lexicons2, def2) {
        if (def2.type === "ref") {
          return [lexicons2.getDefOrThrow(def2.ref)];
        } else if (def2.type === "union") {
          return def2.refs.map((ref) => lexicons2.getDefOrThrow(ref)).flat();
        } else {
          return [def2];
        }
      }
      function requiredPropertiesRefinement(object2, ctx) {
        if (object2.required === void 0) {
          return;
        }
        if (!Array.isArray(object2.required)) {
          ctx.addIssue({
            code: z.ZodIssueCode.invalid_type,
            received: typeof object2.required,
            expected: "array"
          });
          return;
        }
        if (object2.properties === void 0) {
          if (object2.required.length > 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Required fields defined but no properties defined`
            });
          }
          return;
        }
        for (const field of object2.required) {
          if (object2.properties[field] === void 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Required field "${field}" not defined`
            });
          }
        }
      }
      var refsContainType = (refs, type) => {
        const lexUri = toLexUri(type);
        if (refs.includes(lexUri)) {
          return true;
        }
        if (lexUri.endsWith("#main")) {
          return refs.includes(lexUri.replace("#main", ""));
        } else {
          return refs.includes(lexUri + "#main");
        }
      };
      var lexBoolean = z.object({
        type: z.literal("boolean"),
        description: z.string().optional(),
        default: z.boolean().optional(),
        const: z.boolean().optional()
      }).strict();
      var lexInteger = z.object({
        type: z.literal("integer"),
        description: z.string().optional(),
        default: z.number().int().optional(),
        minimum: z.number().int().optional(),
        maximum: z.number().int().optional(),
        enum: z.number().int().array().optional(),
        const: z.number().int().optional()
      }).strict();
      var lexStringFormat = z.enum([
        "datetime",
        "uri",
        "at-uri",
        "did",
        "handle",
        "at-identifier",
        "nsid",
        "cid",
        "language"
      ]);
      var lexString = z.object({
        type: z.literal("string"),
        format: lexStringFormat.optional(),
        description: z.string().optional(),
        default: z.string().optional(),
        minLength: z.number().int().optional(),
        maxLength: z.number().int().optional(),
        minGraphemes: z.number().int().optional(),
        maxGraphemes: z.number().int().optional(),
        enum: z.string().array().optional(),
        const: z.string().optional(),
        knownValues: z.string().array().optional()
      }).strict();
      var lexUnknown = z.object({
        type: z.literal("unknown"),
        description: z.string().optional()
      }).strict();
      var lexPrimitive = z.discriminatedUnion("type", [
        lexBoolean,
        lexInteger,
        lexString,
        lexUnknown
      ]);
      var lexBytes = z.object({
        type: z.literal("bytes"),
        description: z.string().optional(),
        maxLength: z.number().optional(),
        minLength: z.number().optional()
      }).strict();
      var lexCidLink = z.object({
        type: z.literal("cid-link"),
        description: z.string().optional()
      }).strict();
      var lexIpldType = z.discriminatedUnion("type", [lexBytes, lexCidLink]);
      var lexRef = z.object({
        type: z.literal("ref"),
        description: z.string().optional(),
        ref: z.string()
      }).strict();
      var lexRefUnion = z.object({
        type: z.literal("union"),
        description: z.string().optional(),
        refs: z.string().array(),
        closed: z.boolean().optional()
      }).strict();
      var lexRefVariant = z.discriminatedUnion("type", [lexRef, lexRefUnion]);
      var lexBlob = z.object({
        type: z.literal("blob"),
        description: z.string().optional(),
        accept: z.string().array().optional(),
        maxSize: z.number().optional()
      }).strict();
      var lexArray = z.object({
        type: z.literal("array"),
        description: z.string().optional(),
        items: z.union([lexPrimitive, lexIpldType, lexBlob, lexRefVariant]),
        minLength: z.number().int().optional(),
        maxLength: z.number().int().optional()
      }).strict();
      var lexPrimitiveArray = lexArray.merge(z.object({
        items: lexPrimitive
      }).strict());
      var lexToken = z.object({
        type: z.literal("token"),
        description: z.string().optional()
      }).strict();
      var lexObject = z.object({
        type: z.literal("object"),
        description: z.string().optional(),
        required: z.string().array().optional(),
        nullable: z.string().array().optional(),
        properties: z.record(z.union([lexRefVariant, lexIpldType, lexArray, lexBlob, lexPrimitive]))
      }).strict().superRefine(requiredPropertiesRefinement);
      var lexXrpcParameters = z.object({
        type: z.literal("params"),
        description: z.string().optional(),
        required: z.string().array().optional(),
        properties: z.record(z.union([lexPrimitive, lexPrimitiveArray]))
      }).strict().superRefine(requiredPropertiesRefinement);
      var lexXrpcBody = z.object({
        description: z.string().optional(),
        encoding: z.string(),
        schema: z.union([lexRefVariant, lexObject]).optional()
      }).strict();
      var lexXrpcSubscriptionMessage = z.object({
        description: z.string().optional(),
        schema: z.union([lexRefVariant, lexObject]).optional()
      }).strict();
      var lexXrpcError = z.object({
        name: z.string(),
        description: z.string().optional()
      }).strict();
      var lexXrpcQuery = z.object({
        type: z.literal("query"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        output: lexXrpcBody.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexXrpcProcedure = z.object({
        type: z.literal("procedure"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        input: lexXrpcBody.optional(),
        output: lexXrpcBody.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexXrpcSubscription = z.object({
        type: z.literal("subscription"),
        description: z.string().optional(),
        parameters: lexXrpcParameters.optional(),
        message: lexXrpcSubscriptionMessage.optional(),
        errors: lexXrpcError.array().optional()
      }).strict();
      var lexRecord = z.object({
        type: z.literal("record"),
        description: z.string().optional(),
        key: z.string().optional(),
        record: lexObject
      }).strict();
      var lexUserType = z.custom((val) => {
        if (!val || typeof val !== "object") {
          return;
        }
        if (val["type"] === void 0) {
          return;
        }
        switch (val["type"]) {
          case "record":
            return lexRecord.parse(val);
          case "query":
            return lexXrpcQuery.parse(val);
          case "procedure":
            return lexXrpcProcedure.parse(val);
          case "subscription":
            return lexXrpcSubscription.parse(val);
          case "blob":
            return lexBlob.parse(val);
          case "array":
            return lexArray.parse(val);
          case "token":
            return lexToken.parse(val);
          case "object":
            return lexObject.parse(val);
          case "boolean":
            return lexBoolean.parse(val);
          case "integer":
            return lexInteger.parse(val);
          case "string":
            return lexString.parse(val);
          case "bytes":
            return lexBytes.parse(val);
          case "cid-link":
            return lexCidLink.parse(val);
          case "unknown":
            return lexUnknown.parse(val);
        }
      }, (val) => {
        if (!val || typeof val !== "object") {
          return {
            message: "Must be an object",
            fatal: true
          };
        }
        if (val["type"] === void 0) {
          return {
            message: "Must have a type",
            fatal: true
          };
        }
        return {
          message: `Invalid type: ${val["type"]} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
          fatal: true
        };
      });
      var lexiconDoc = z.object({
        lexicon: z.literal(1),
        id: z.string().refine((v) => NSID.isValid(v), {
          message: "Must be a valid NSID"
        }),
        revision: z.number().optional(),
        description: z.string().optional(),
        defs: z.record(lexUserType)
      }).strict().superRefine((doc, ctx) => {
        for (const defId in doc.defs) {
          const def2 = doc.defs[defId];
          if (defId !== "main" && (def2.type === "record" || def2.type === "procedure" || def2.type === "query" || def2.type === "subscription")) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              message: `Records, procedures, queries, and subscriptions must be the main definition.`
            });
          }
        }
      });
      function isObj(obj) {
        return obj !== null && typeof obj === "object";
      }
      function hasProp(data, prop) {
        return prop in data;
      }
      var discriminatedObject = z.object({ $type: z.string() });
      function isDiscriminatedObject(value) {
        return discriminatedObject.safeParse(value).success;
      }
      var ValidationError = class extends Error {
      };
      var InvalidLexiconError = class extends Error {
      };
      var LexiconDefNotFoundError = class extends Error {
      };
      function params(lexicons2, path, def2, val) {
        var _a3;
        const value = val && typeof val === "object" ? val : {};
        const requiredProps = new Set((_a3 = def2.required) != null ? _a3 : []);
        let resultValue = value;
        if (typeof def2.properties === "object") {
          for (const key in def2.properties) {
            const propDef = def2.properties[key];
            const validated = propDef.type === "array" ? array(lexicons2, key, propDef, value[key]) : validate(lexicons2, key, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === "undefined";
            if (propIsUndefined && requiredProps.has(key)) {
              return {
                success: false,
                error: new ValidationError(`${path} must have the property "${key}"`)
              };
            } else if (!propIsUndefined && !validated.success) {
              return validated;
            }
            if (propValue !== value[key]) {
              if (resultValue === value) {
                resultValue = __spreadValues({}, value);
              }
              resultValue[key] = propValue;
            }
          }
        }
        return { success: true, value: resultValue };
      }
      function assertValidRecord(lexicons2, def2, value) {
        const res = object(lexicons2, "Record", def2.record, value);
        if (!res.success)
          throw res.error;
        return res.value;
      }
      function assertValidXrpcParams(lexicons2, def2, value) {
        if (def2.parameters) {
          const res = params(lexicons2, "Params", def2.parameters, value);
          if (!res.success)
            throw res.error;
          return res.value;
        }
      }
      function assertValidXrpcInput(lexicons2, def2, value) {
        var _a3;
        if ((_a3 = def2.input) == null ? void 0 : _a3.schema) {
          return assertValidOneOf(lexicons2, "Input", def2.input.schema, value, true);
        }
      }
      function assertValidXrpcOutput(lexicons2, def2, value) {
        var _a3;
        if ((_a3 = def2.output) == null ? void 0 : _a3.schema) {
          return assertValidOneOf(lexicons2, "Output", def2.output.schema, value, true);
        }
      }
      function assertValidXrpcMessage(lexicons2, def2, value) {
        var _a3;
        if ((_a3 = def2.message) == null ? void 0 : _a3.schema) {
          return assertValidOneOf(lexicons2, "Message", def2.message.schema, value, true);
        }
      }
      var Lexicons = class {
        constructor(docs) {
          this.docs = /* @__PURE__ */ new Map();
          this.defs = /* @__PURE__ */ new Map();
          if (docs == null ? void 0 : docs.length) {
            for (const doc of docs) {
              this.add(doc);
            }
          }
        }
        add(doc) {
          const uri2 = toLexUri(doc.id);
          if (this.docs.has(uri2)) {
            throw new Error(`${uri2} has already been registered`);
          }
          resolveRefUris(doc, uri2);
          this.docs.set(uri2, doc);
          for (const [defUri, def2] of iterDefs(doc)) {
            this.defs.set(defUri, def2);
          }
        }
        remove(uri2) {
          uri2 = toLexUri(uri2);
          const doc = this.docs.get(uri2);
          if (!doc) {
            throw new Error(`Unable to remove "${uri2}": does not exist`);
          }
          for (const [defUri, _def] of iterDefs(doc)) {
            this.defs.delete(defUri);
          }
          this.docs.delete(uri2);
        }
        get(uri2) {
          uri2 = toLexUri(uri2);
          return this.docs.get(uri2);
        }
        getDef(uri2) {
          uri2 = toLexUri(uri2);
          return this.defs.get(uri2);
        }
        getDefOrThrow(uri2, types) {
          const def2 = this.getDef(uri2);
          if (!def2) {
            throw new LexiconDefNotFoundError(`Lexicon not found: ${uri2}`);
          }
          if (types && !types.includes(def2.type)) {
            throw new InvalidLexiconError(`Not a ${types.join(" or ")} lexicon: ${uri2}`);
          }
          return def2;
        }
        validate(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["record", "object"]);
          if (!isObj(value)) {
            throw new ValidationError(`Value must be an object`);
          }
          if (def2.type === "record") {
            return object(this, "Record", def2.record, value);
          } else if (def2.type === "object") {
            return object(this, "Object", def2, value);
          } else {
            throw new InvalidLexiconError("Definition must be a record or object");
          }
        }
        assertValidRecord(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["record"]);
          if (!isObj(value)) {
            throw new ValidationError(`Record must be an object`);
          }
          if (!hasProp(value, "$type") || typeof value.$type !== "string") {
            throw new ValidationError(`Record/$type must be a string`);
          }
          const $type = value.$type || "";
          if (toLexUri($type) !== lexUri) {
            throw new ValidationError(`Invalid $type: must be ${lexUri}, got ${$type}`);
          }
          return assertValidRecord(this, def2, value);
        }
        assertValidXrpcParams(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, [
            "query",
            "procedure",
            "subscription"
          ]);
          return assertValidXrpcParams(this, def2, value);
        }
        assertValidXrpcInput(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["procedure"]);
          return assertValidXrpcInput(this, def2, value);
        }
        assertValidXrpcOutput(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["query", "procedure"]);
          return assertValidXrpcOutput(this, def2, value);
        }
        assertValidXrpcMessage(lexUri, value) {
          lexUri = toLexUri(lexUri);
          const def2 = this.getDefOrThrow(lexUri, ["subscription"]);
          return assertValidXrpcMessage(this, def2, value);
        }
        resolveLexUri(lexUri, ref) {
          lexUri = toLexUri(lexUri);
          return toLexUri(ref, lexUri);
        }
      };
      function* iterDefs(doc) {
        for (const defId in doc.defs) {
          yield [`lex:${doc.id}#${defId}`, doc.defs[defId]];
          if (defId === "main") {
            yield [`lex:${doc.id}`, doc.defs[defId]];
          }
        }
      }
      function resolveRefUris(obj, baseUri) {
        for (const k in obj) {
          if (obj.type === "ref") {
            obj.ref = toLexUri(obj.ref, baseUri);
          } else if (obj.type === "union") {
            obj.refs = obj.refs.map((ref) => toLexUri(ref, baseUri));
          } else if (Array.isArray(obj[k])) {
            obj[k] = obj[k].map((item) => {
              if (typeof item === "string") {
                return item.startsWith("#") ? toLexUri(item, baseUri) : item;
              } else if (item && typeof item === "object") {
                return resolveRefUris(item, baseUri);
              }
              return item;
            });
          } else if (obj[k] && typeof obj[k] === "object") {
            obj[k] = resolveRefUris(obj[k], baseUri);
          }
        }
        return obj;
      }
      var lexToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => lexToIpld(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof BlobRef) {
            return val.original;
          }
          if (CID4.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = lexToIpld(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var ipldToLex = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => ipldToLex(item));
        }
        if (val && typeof val === "object") {
          if ((val["$type"] === "blob" || typeof val["cid"] === "string" && typeof val["mimeType"] === "string") && check_exports.is(val, jsonBlobRef)) {
            return BlobRef.fromJsonRef(val);
          }
          if (CID4.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = ipldToLex(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      var lexToJson = (val) => {
        return ipldToJson(lexToIpld(val));
      };
      var stringifyLex = (val) => {
        return JSON.stringify(lexToJson(val));
      };
      var jsonToLex = (val) => {
        return ipldToLex(jsonToIpld(val));
      };
      var jsonStringToLex = (val) => {
        return jsonToLex(JSON.parse(val));
      };
      var errorResponseBody = z.object({
        error: z.string().optional(),
        message: z.string().optional()
      });
      var ResponseType = /* @__PURE__ */ ((ResponseType2) => {
        ResponseType2[ResponseType2["Unknown"] = 1] = "Unknown";
        ResponseType2[ResponseType2["InvalidResponse"] = 2] = "InvalidResponse";
        ResponseType2[ResponseType2["Success"] = 200] = "Success";
        ResponseType2[ResponseType2["InvalidRequest"] = 400] = "InvalidRequest";
        ResponseType2[ResponseType2["AuthRequired"] = 401] = "AuthRequired";
        ResponseType2[ResponseType2["Forbidden"] = 403] = "Forbidden";
        ResponseType2[ResponseType2["XRPCNotSupported"] = 404] = "XRPCNotSupported";
        ResponseType2[ResponseType2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
        ResponseType2[ResponseType2["RateLimitExceeded"] = 429] = "RateLimitExceeded";
        ResponseType2[ResponseType2["InternalServerError"] = 500] = "InternalServerError";
        ResponseType2[ResponseType2["MethodNotImplemented"] = 501] = "MethodNotImplemented";
        ResponseType2[ResponseType2["UpstreamFailure"] = 502] = "UpstreamFailure";
        ResponseType2[ResponseType2["NotEnoughResources"] = 503] = "NotEnoughResources";
        ResponseType2[ResponseType2["UpstreamTimeout"] = 504] = "UpstreamTimeout";
        return ResponseType2;
      })(ResponseType || {});
      var ResponseTypeNames = {
        [
          2
          /* InvalidResponse */
        ]: "InvalidResponse",
        [
          200
          /* Success */
        ]: "Success",
        [
          400
          /* InvalidRequest */
        ]: "InvalidRequest",
        [
          401
          /* AuthRequired */
        ]: "AuthenticationRequired",
        [
          403
          /* Forbidden */
        ]: "Forbidden",
        [
          404
          /* XRPCNotSupported */
        ]: "XRPCNotSupported",
        [
          413
          /* PayloadTooLarge */
        ]: "PayloadTooLarge",
        [
          429
          /* RateLimitExceeded */
        ]: "RateLimitExceeded",
        [
          500
          /* InternalServerError */
        ]: "InternalServerError",
        [
          501
          /* MethodNotImplemented */
        ]: "MethodNotImplemented",
        [
          502
          /* UpstreamFailure */
        ]: "UpstreamFailure",
        [
          503
          /* NotEnoughResources */
        ]: "NotEnoughResources",
        [
          504
          /* UpstreamTimeout */
        ]: "UpstreamTimeout"
      };
      var ResponseTypeStrings = {
        [
          2
          /* InvalidResponse */
        ]: "Invalid Response",
        [
          200
          /* Success */
        ]: "Success",
        [
          400
          /* InvalidRequest */
        ]: "Invalid Request",
        [
          401
          /* AuthRequired */
        ]: "Authentication Required",
        [
          403
          /* Forbidden */
        ]: "Forbidden",
        [
          404
          /* XRPCNotSupported */
        ]: "XRPC Not Supported",
        [
          413
          /* PayloadTooLarge */
        ]: "Payload Too Large",
        [
          429
          /* RateLimitExceeded */
        ]: "Rate Limit Exceeded",
        [
          500
          /* InternalServerError */
        ]: "Internal Server Error",
        [
          501
          /* MethodNotImplemented */
        ]: "Method Not Implemented",
        [
          502
          /* UpstreamFailure */
        ]: "Upstream Failure",
        [
          503
          /* NotEnoughResources */
        ]: "Not Enough Resources",
        [
          504
          /* UpstreamTimeout */
        ]: "Upstream Timeout"
      };
      var XRPCResponse = class {
        constructor(data, headers) {
          this.data = data;
          this.headers = headers;
          this.success = true;
        }
      };
      var XRPCError = class extends Error {
        constructor(status, error, message, headers) {
          super(message || error || ResponseTypeStrings[status]);
          this.status = status;
          this.error = error;
          this.success = false;
          if (!this.error) {
            this.error = ResponseTypeNames[status];
          }
          this.headers = headers;
        }
      };
      var XRPCInvalidResponseError = class extends XRPCError {
        constructor(lexiconNsid, validationError, responseBody) {
          super(2, ResponseTypeStrings[
            2
            /* InvalidResponse */
          ], `The server gave an invalid response and may be out of date.`);
          this.lexiconNsid = lexiconNsid;
          this.validationError = validationError;
          this.responseBody = responseBody;
        }
      };
      function getMethodSchemaHTTPMethod(schema2) {
        if (schema2.type === "procedure") {
          return "post";
        }
        return "get";
      }
      function constructMethodCallUri(nsid2, schema2, serviceUri, params2) {
        var _a3, _b;
        const uri2 = new URL(serviceUri);
        uri2.pathname = `/xrpc/${nsid2}`;
        if (params2) {
          for (const [key, value] of Object.entries(params2)) {
            const paramSchema = (_b = (_a3 = schema2.parameters) == null ? void 0 : _a3.properties) == null ? void 0 : _b[key];
            if (!paramSchema) {
              throw new Error(`Invalid query parameter: ${key}`);
            }
            if (value !== void 0) {
              if (paramSchema.type === "array") {
                const vals = [];
                vals.concat(value).forEach((val) => {
                  uri2.searchParams.append(key, encodeQueryParam(paramSchema.items.type, val));
                });
              } else {
                uri2.searchParams.set(key, encodeQueryParam(paramSchema.type, value));
              }
            }
          }
        }
        return uri2.toString();
      }
      function encodeQueryParam(type, value) {
        if (type === "string" || type === "unknown") {
          return String(value);
        }
        if (type === "float") {
          return String(Number(value));
        } else if (type === "integer") {
          return String(Number(value) | 0);
        } else if (type === "boolean") {
          return value ? "true" : "false";
        } else if (type === "datetime") {
          if (value instanceof Date) {
            return value.toISOString();
          }
          return String(value);
        }
        throw new Error(`Unsupported query param type: ${type}`);
      }
      function normalizeHeaders(headers) {
        const normalized = {};
        for (const [header, value] of Object.entries(headers)) {
          normalized[header.toLowerCase()] = value;
        }
        return normalized;
      }
      function constructMethodCallHeaders(schema2, data, opts) {
        const headers = (opts == null ? void 0 : opts.headers) || {};
        if (schema2.type === "procedure") {
          if (opts == null ? void 0 : opts.encoding) {
            headers["Content-Type"] = opts.encoding;
          }
          if (data && typeof data === "object") {
            if (!headers["Content-Type"]) {
              headers["Content-Type"] = "application/json";
            }
          }
        }
        return headers;
      }
      function encodeMethodCallBody(headers, data) {
        if (!headers["content-type"] || typeof data === "undefined") {
          return void 0;
        }
        if (data instanceof ArrayBuffer) {
          return data;
        }
        if (headers["content-type"].startsWith("text/")) {
          return new TextEncoder().encode(data.toString());
        }
        if (headers["content-type"].startsWith("application/json")) {
          return new TextEncoder().encode(stringifyLex(data));
        }
        return data;
      }
      function httpResponseCodeToEnum(status) {
        let resCode;
        if (status in ResponseType) {
          resCode = status;
        } else if (status >= 100 && status < 200) {
          resCode = 404;
        } else if (status >= 200 && status < 300) {
          resCode = 200;
        } else if (status >= 300 && status < 400) {
          resCode = 404;
        } else if (status >= 400 && status < 500) {
          resCode = 400;
        } else {
          resCode = 500;
        }
        return resCode;
      }
      function httpResponseBodyParse(mimeType, data) {
        if (mimeType) {
          if (mimeType.includes("application/json") && (data == null ? void 0 : data.byteLength)) {
            try {
              const str = new TextDecoder().decode(data);
              return jsonStringToLex(str);
            } catch (e) {
              throw new XRPCError(2, `Failed to parse response body: ${String(e)}`);
            }
          }
          if (mimeType.startsWith("text/") && (data == null ? void 0 : data.byteLength)) {
            try {
              return new TextDecoder().decode(data);
            } catch (e) {
              throw new XRPCError(2, `Failed to parse response body: ${String(e)}`);
            }
          }
        }
        if (data instanceof ArrayBuffer) {
          return new Uint8Array(data);
        }
        return data;
      }
      var Client = class {
        constructor() {
          this.fetch = defaultFetchHandler;
          this.lex = new Lexicons();
        }
        call(serviceUri, methodNsid, params2, data, opts) {
          return __async(this, null, function* () {
            return this.service(serviceUri).call(methodNsid, params2, data, opts);
          });
        }
        service(serviceUri) {
          return new ServiceClient(this, serviceUri);
        }
        addLexicon(doc) {
          this.lex.add(doc);
        }
        addLexicons(docs) {
          for (const doc of docs) {
            this.addLexicon(doc);
          }
        }
        removeLexicon(uri2) {
          this.lex.remove(uri2);
        }
      };
      var ServiceClient = class {
        constructor(baseClient, serviceUri) {
          this.headers = {};
          this.baseClient = baseClient;
          this.uri = typeof serviceUri === "string" ? new URL(serviceUri) : serviceUri;
        }
        setHeader(key, value) {
          this.headers[key] = value;
        }
        unsetHeader(key) {
          delete this.headers[key];
        }
        call(methodNsid, params2, data, opts) {
          return __async(this, null, function* () {
            const def2 = this.baseClient.lex.getDefOrThrow(methodNsid);
            if (!def2 || def2.type !== "query" && def2.type !== "procedure") {
              throw new Error(`Invalid lexicon: ${methodNsid}. Must be a query or procedure.`);
            }
            const httpMethod = getMethodSchemaHTTPMethod(def2);
            const httpUri = constructMethodCallUri(methodNsid, def2, this.uri, params2);
            const httpHeaders = constructMethodCallHeaders(def2, data, {
              headers: __spreadValues(__spreadValues({}, this.headers), opts == null ? void 0 : opts.headers),
              encoding: opts == null ? void 0 : opts.encoding
            });
            const res = yield this.baseClient.fetch(httpUri, httpMethod, httpHeaders, data);
            const resCode = httpResponseCodeToEnum(res.status);
            if (resCode === 200) {
              try {
                this.baseClient.lex.assertValidXrpcOutput(methodNsid, res.body);
              } catch (e) {
                if (e instanceof ValidationError) {
                  throw new XRPCInvalidResponseError(methodNsid, e, res.body);
                } else {
                  throw e;
                }
              }
              return new XRPCResponse(res.body, res.headers);
            } else {
              if (res.body && isErrorResponseBody(res.body)) {
                throw new XRPCError(resCode, res.body.error, res.body.message, res.headers);
              } else {
                throw new XRPCError(resCode);
              }
            }
          });
        }
      };
      function defaultFetchHandler(httpUri, httpMethod, httpHeaders, httpReqBody) {
        return __async(this, null, function* () {
          try {
            const headers = normalizeHeaders(httpHeaders);
            const reqInit = {
              method: httpMethod,
              headers,
              body: encodeMethodCallBody(headers, httpReqBody),
              duplex: "half"
            };
            const res = yield fetch(httpUri, reqInit);
            const resBody = yield res.arrayBuffer();
            return {
              status: res.status,
              headers: Object.fromEntries(res.headers.entries()),
              body: httpResponseBodyParse(res.headers.get("content-type"), resBody)
            };
          } catch (e) {
            throw new XRPCError(1, String(e));
          }
        });
      }
      function isErrorResponseBody(v) {
        return errorResponseBody.safeParse(v).success;
      }
      var defaultInst = new Client();
      var schemaDict = {
        ComAtprotoAdminDefs: {
          lexicon: 1,
          id: "com.atproto.admin.defs",
          defs: {
            statusAttr: {
              type: "object",
              required: ["applied"],
              properties: {
                applied: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            },
            modEventView: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobCids",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#modEventTakedown",
                    "lex:com.atproto.admin.defs#modEventReverseTakedown",
                    "lex:com.atproto.admin.defs#modEventComment",
                    "lex:com.atproto.admin.defs#modEventReport",
                    "lex:com.atproto.admin.defs#modEventLabel",
                    "lex:com.atproto.admin.defs#modEventAcknowledge",
                    "lex:com.atproto.admin.defs#modEventEscalate",
                    "lex:com.atproto.admin.defs#modEventMute",
                    "lex:com.atproto.admin.defs#modEventEmail"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                creatorHandle: {
                  type: "string"
                },
                subjectHandle: {
                  type: "string"
                }
              }
            },
            modEventViewDetail: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobs",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#modEventTakedown",
                    "lex:com.atproto.admin.defs#modEventReverseTakedown",
                    "lex:com.atproto.admin.defs#modEventComment",
                    "lex:com.atproto.admin.defs#modEventReport",
                    "lex:com.atproto.admin.defs#modEventLabel",
                    "lex:com.atproto.admin.defs#modEventAcknowledge",
                    "lex:com.atproto.admin.defs#modEventEscalate",
                    "lex:com.atproto.admin.defs#modEventMute",
                    "lex:com.atproto.admin.defs#modEventResolveAppeal"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoView",
                    "lex:com.atproto.admin.defs#repoViewNotFound",
                    "lex:com.atproto.admin.defs#recordView",
                    "lex:com.atproto.admin.defs#recordViewNotFound"
                  ]
                },
                subjectBlobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#blobView"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            reportView: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt",
                "resolvedByActionIds"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                comment: {
                  type: "string"
                },
                subjectRepoHandle: {
                  type: "string"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                resolvedByActionIds: {
                  type: "array",
                  items: {
                    type: "integer"
                  }
                }
              }
            },
            subjectStatusView: {
              type: "object",
              required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
              properties: {
                id: {
                  type: "integer"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                subjectRepoHandle: {
                  type: "string"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the last update was made to the moderation status of the subject"
                },
                createdAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
                },
                reviewState: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectReviewState"
                },
                comment: {
                  type: "string",
                  description: "Sticky comment on the subject."
                },
                muteUntil: {
                  type: "string",
                  format: "datetime"
                },
                lastReviewedBy: {
                  type: "string",
                  format: "did"
                },
                lastReviewedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastReportedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastAppealedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the author of the subject appealed a moderation action"
                },
                takendown: {
                  type: "boolean"
                },
                appealed: {
                  type: "boolean",
                  description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
                },
                suspendUntil: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            reportViewDetail: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt",
                "resolvedByActions"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                comment: {
                  type: "string"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoView",
                    "lex:com.atproto.admin.defs#repoViewNotFound",
                    "lex:com.atproto.admin.defs#recordView",
                    "lex:com.atproto.admin.defs#recordViewNotFound"
                  ]
                },
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                resolvedByActions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#modEventView"
                  }
                }
              }
            },
            repoView: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                }
              }
            },
            repoViewDetail: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderationDetail"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            accountView: {
              type: "object",
              required: ["did", "handle", "indexedAt"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                },
                inviteNote: {
                  type: "string"
                }
              }
            },
            repoViewNotFound: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            repoRef: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            repoBlobRef: {
              type: "object",
              required: ["did", "cid"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                recordUri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            recordView: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobCids",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                },
                repo: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoView"
                }
              }
            },
            recordViewDetail: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobs",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#blobView"
                  }
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderationDetail"
                },
                repo: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoView"
                }
              }
            },
            recordViewNotFound: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            moderation: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                }
              }
            },
            moderationDetail: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#subjectStatusView"
                }
              }
            },
            blobView: {
              type: "object",
              required: ["cid", "mimeType", "size", "createdAt"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                mimeType: {
                  type: "string"
                },
                size: {
                  type: "integer"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                details: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#imageDetails",
                    "lex:com.atproto.admin.defs#videoDetails"
                  ]
                },
                moderation: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#moderation"
                }
              }
            },
            imageDetails: {
              type: "object",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                }
              }
            },
            videoDetails: {
              type: "object",
              required: ["width", "height", "length"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                },
                length: {
                  type: "integer"
                }
              }
            },
            subjectReviewState: {
              type: "string",
              knownValues: [
                "lex:com.atproto.admin.defs#reviewOpen",
                "lex:com.atproto.admin.defs#reviewEscalated",
                "lex:com.atproto.admin.defs#reviewClosed"
              ]
            },
            reviewOpen: {
              type: "token",
              description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
            },
            reviewEscalated: {
              type: "token",
              description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
            },
            reviewClosed: {
              type: "token",
              description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
            },
            modEventTakedown: {
              type: "object",
              description: "Take down a subject permanently or temporarily",
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the takedown should be in effect before automatically expiring."
                }
              }
            },
            modEventReverseTakedown: {
              type: "object",
              description: "Revert take down action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventResolveAppeal: {
              type: "object",
              description: "Resolve appeal on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe resolution."
                }
              }
            },
            modEventComment: {
              type: "object",
              description: "Add a comment to a subject",
              required: ["comment"],
              properties: {
                comment: {
                  type: "string"
                },
                sticky: {
                  type: "boolean",
                  description: "Make the comment persistent on the subject"
                }
              }
            },
            modEventReport: {
              type: "object",
              description: "Report a subject",
              required: ["reportType"],
              properties: {
                comment: {
                  type: "string"
                },
                reportType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                }
              }
            },
            modEventLabel: {
              type: "object",
              description: "Apply/Negate labels on a subject",
              required: ["createLabelVals", "negateLabelVals"],
              properties: {
                comment: {
                  type: "string"
                },
                createLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                negateLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            },
            modEventAcknowledge: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventEscalate: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventMute: {
              type: "object",
              description: "Mute incoming reports on a subject",
              required: ["durationInHours"],
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the subject should remain muted."
                }
              }
            },
            modEventUnmute: {
              type: "object",
              description: "Unmute action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventEmail: {
              type: "object",
              description: "Keep a log of outgoing email to a user",
              required: ["subjectLine"],
              properties: {
                subjectLine: {
                  type: "string",
                  description: "The subject line of the email sent to the user."
                },
                comment: {
                  type: "string",
                  description: "Additional comment about the outgoing comm."
                }
              }
            }
          }
        },
        ComAtprotoAdminDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.admin.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a user account as an administrator.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.disableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for disabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.disableInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Disable some set of codes and/or all codes associated with a set of users.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminEmitModerationEvent: {
          lexicon: 1,
          id: "com.atproto.admin.emitModerationEvent",
          defs: {
            main: {
              type: "procedure",
              description: "Take a moderation action on an actor.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["event", "subject", "createdBy"],
                  properties: {
                    event: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#modEventTakedown",
                        "lex:com.atproto.admin.defs#modEventAcknowledge",
                        "lex:com.atproto.admin.defs#modEventEscalate",
                        "lex:com.atproto.admin.defs#modEventComment",
                        "lex:com.atproto.admin.defs#modEventLabel",
                        "lex:com.atproto.admin.defs#modEventReport",
                        "lex:com.atproto.admin.defs#modEventMute",
                        "lex:com.atproto.admin.defs#modEventReverseTakedown",
                        "lex:com.atproto.admin.defs#modEventUnmute",
                        "lex:com.atproto.admin.defs#modEventEmail"
                      ]
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    subjectBlobCids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    },
                    createdBy: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#modEventView"
                }
              },
              errors: [
                {
                  name: "SubjectHasAction"
                }
              ]
            }
          }
        },
        ComAtprotoAdminEnableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.enableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Re-enable an account's ability to receive invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for enabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetAccountInfo: {
          lexicon: 1,
          id: "com.atproto.admin.getAccountInfo",
          defs: {
            main: {
              type: "query",
              description: "Get details about an account.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#accountView"
                }
              }
            }
          }
        },
        ComAtprotoAdminGetInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.getInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get an admin view of invite codes.",
              parameters: {
                type: "params",
                properties: {
                  sort: {
                    type: "string",
                    knownValues: ["recent", "usage"],
                    default: "recent"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 500,
                    default: 100
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetModerationEvent: {
          lexicon: 1,
          id: "com.atproto.admin.getModerationEvent",
          defs: {
            main: {
              type: "query",
              description: "Get details about a moderation event.",
              parameters: {
                type: "params",
                required: ["id"],
                properties: {
                  id: {
                    type: "integer"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#modEventViewDetail"
                }
              }
            }
          }
        },
        ComAtprotoAdminGetRecord: {
          lexicon: 1,
          id: "com.atproto.admin.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get details about a record.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#recordViewDetail"
                }
              },
              errors: [
                {
                  name: "RecordNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoAdminGetRepo: {
          lexicon: 1,
          id: "com.atproto.admin.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Get details about a repository.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#repoViewDetail"
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoAdminGetSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.getSubjectStatus",
          defs: {
            main: {
              type: "query",
              description: "Get the service-specific admin status of a subject (account, record, or blob).",
              parameters: {
                type: "params",
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  blob: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminQueryModerationEvents: {
          lexicon: 1,
          id: "com.atproto.admin.queryModerationEvents",
          defs: {
            main: {
              type: "query",
              description: "List moderation events related to a subject.",
              parameters: {
                type: "params",
                properties: {
                  types: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "The types of events (fully qualified string in the format of com.atproto.admin#modEvent<name>) to filter by. If not specified, all events are returned."
                  },
                  createdBy: {
                    type: "string",
                    format: "did"
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"],
                    description: "Sort direction for the events. Defaults to descending order of created at timestamp."
                  },
                  subject: {
                    type: "string",
                    format: "uri"
                  },
                  includeAllUserRecords: {
                    type: "boolean",
                    default: false,
                    description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["events"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    events: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#modEventView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminQueryModerationStatuses: {
          lexicon: 1,
          id: "com.atproto.admin.queryModerationStatuses",
          defs: {
            main: {
              type: "query",
              description: "View moderation statuses of subjects (record or repo).",
              parameters: {
                type: "params",
                properties: {
                  subject: {
                    type: "string",
                    format: "uri"
                  },
                  comment: {
                    type: "string",
                    description: "Search subjects by keyword from comments"
                  },
                  reportedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported after a given timestamp"
                  },
                  reportedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported before a given timestamp"
                  },
                  reviewedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed after a given timestamp"
                  },
                  reviewedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed before a given timestamp"
                  },
                  includeMuted: {
                    type: "boolean",
                    description: "By default, we don't include muted subjects in the results. Set this to true to include them."
                  },
                  reviewState: {
                    type: "string",
                    description: "Specify when fetching subjects in a certain state"
                  },
                  ignoreSubjects: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "uri"
                    }
                  },
                  lastReviewedBy: {
                    type: "string",
                    format: "did",
                    description: "Get all subject statuses that were reviewed by a specific moderator"
                  },
                  sortField: {
                    type: "string",
                    default: "lastReportedAt",
                    enum: ["lastReviewedAt", "lastReportedAt"]
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"]
                  },
                  takendown: {
                    type: "boolean",
                    description: "Get subjects that were taken down"
                  },
                  appealed: {
                    type: "boolean",
                    description: "Get subjects in unresolved appealed status"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subjectStatuses"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    subjectStatuses: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#subjectStatusView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSearchRepos: {
          lexicon: 1,
          id: "com.atproto.admin.searchRepos",
          defs: {
            main: {
              type: "query",
              description: "Find repositories based on a search term.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead"
                  },
                  q: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#repoView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSendEmail: {
          lexicon: 1,
          id: "com.atproto.admin.sendEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Send email to a user's account email address.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["recipientDid", "content", "senderDid"],
                  properties: {
                    recipientDid: {
                      type: "string",
                      format: "did"
                    },
                    content: {
                      type: "string"
                    },
                    subject: {
                      type: "string"
                    },
                    senderDid: {
                      type: "string",
                      format: "did"
                    },
                    comment: {
                      type: "string",
                      description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["sent"],
                  properties: {
                    sent: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountEmail: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account", "email"],
                  properties: {
                    account: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountHandle: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "handle"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.updateSubjectStatus",
          defs: {
            main: {
              type: "procedure",
              description: "Update the service-specific admin status of a subject (account, record, or blob).",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityResolveHandle: {
          lexicon: 1,
          id: "com.atproto.identity.resolveHandle",
          defs: {
            main: {
              type: "query",
              description: "Provides the DID of a repo.",
              parameters: {
                type: "params",
                required: ["handle"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle",
                    description: "The handle to resolve."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityUpdateHandle: {
          lexicon: 1,
          id: "com.atproto.identity.updateHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Updates the handle of the account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelDefs: {
          lexicon: 1,
          id: "com.atproto.label.defs",
          defs: {
            label: {
              type: "object",
              description: "Metadata tag on an atproto resource (eg, repo or record).",
              required: ["src", "uri", "val", "cts"],
              properties: {
                src: {
                  type: "string",
                  format: "did",
                  description: "DID of the actor who created this label."
                },
                uri: {
                  type: "string",
                  format: "uri",
                  description: "AT URI of the record, repository (account), or other resource that this label applies to."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
                },
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                },
                neg: {
                  type: "boolean",
                  description: "If true, this is a negation label, overwriting a previous label."
                },
                cts: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp when this label was created."
                }
              }
            },
            selfLabels: {
              type: "object",
              description: "Metadata tags on an atproto record, published by the author within the record.",
              required: ["values"],
              properties: {
                values: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#selfLabel"
                  },
                  maxLength: 10
                }
              }
            },
            selfLabel: {
              type: "object",
              description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
              required: ["val"],
              properties: {
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                }
              }
            }
          }
        },
        ComAtprotoLabelQueryLabels: {
          lexicon: 1,
          id: "com.atproto.label.queryLabels",
          defs: {
            main: {
              type: "query",
              description: "Find labels relevant to the provided URI patterns.",
              parameters: {
                type: "params",
                required: ["uriPatterns"],
                properties: {
                  uriPatterns: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
                  },
                  sources: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    },
                    description: "Optional list of label sources (DIDs) to filter on."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelSubscribeLabels: {
          lexicon: 1,
          id: "com.atproto.label.subscribeLabels",
          defs: {
            main: {
              type: "subscription",
              description: "Subscribe to label updates.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.label.subscribeLabels#labels",
                    "lex:com.atproto.label.subscribeLabels#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                }
              ]
            },
            labels: {
              type: "object",
              required: ["seq", "labels"],
              properties: {
                seq: {
                  type: "integer"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoModerationCreateReport: {
          lexicon: 1,
          id: "com.atproto.moderation.createReport",
          defs: {
            main: {
              type: "procedure",
              description: "Report a repo or a record.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["reasonType", "subject"],
                  properties: {
                    reasonType: {
                      type: "ref",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string"
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "id",
                    "reasonType",
                    "subject",
                    "reportedBy",
                    "createdAt"
                  ],
                  properties: {
                    id: {
                      type: "integer"
                    },
                    reasonType: {
                      type: "ref",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string",
                      maxGraphemes: 2e3,
                      maxLength: 2e4
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    reportedBy: {
                      type: "string",
                      format: "did"
                    },
                    createdAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoModerationDefs: {
          lexicon: 1,
          id: "com.atproto.moderation.defs",
          defs: {
            reasonType: {
              type: "string",
              knownValues: [
                "com.atproto.moderation.defs#reasonSpam",
                "com.atproto.moderation.defs#reasonViolation",
                "com.atproto.moderation.defs#reasonMisleading",
                "com.atproto.moderation.defs#reasonSexual",
                "com.atproto.moderation.defs#reasonRude",
                "com.atproto.moderation.defs#reasonOther",
                "com.atproto.moderation.defs#reasonAppeal"
              ]
            },
            reasonSpam: {
              type: "token",
              description: "Spam: frequent unwanted promotion, replies, mentions"
            },
            reasonViolation: {
              type: "token",
              description: "Direct violation of server rules, laws, terms of service"
            },
            reasonMisleading: {
              type: "token",
              description: "Misleading identity, affiliation, or content"
            },
            reasonSexual: {
              type: "token",
              description: "Unwanted or mislabeled sexual content"
            },
            reasonRude: {
              type: "token",
              description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
            },
            reasonOther: {
              type: "token",
              description: "Other: reports not falling under another report category"
            },
            reasonAppeal: {
              type: "token",
              description: "Appeal: appeal a previously taken moderation action"
            }
          }
        },
        ComAtprotoRepoApplyWrites: {
          lexicon: 1,
          id: "com.atproto.repo.applyWrites",
          defs: {
            main: {
              type: "procedure",
              description: "Apply a batch transaction of creates, updates, and deletes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "writes"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the records."
                    },
                    writes: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:com.atproto.repo.applyWrites#create",
                          "lex:com.atproto.repo.applyWrites#update",
                          "lex:com.atproto.repo.applyWrites#delete"
                        ],
                        closed: true
                      }
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            },
            create: {
              type: "object",
              description: "Create a new record.",
              required: ["collection", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string",
                  maxLength: 15
                },
                value: {
                  type: "unknown"
                }
              }
            },
            update: {
              type: "object",
              description: "Update an existing record.",
              required: ["collection", "rkey", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                },
                value: {
                  type: "unknown"
                }
              }
            },
            delete: {
              type: "object",
              description: "Delete an existing record.",
              required: ["collection", "rkey"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoRepoCreateRecord: {
          lexicon: 1,
          id: "com.atproto.repo.createRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Create a new record.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "record"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record.",
                      maxLength: 15
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the record."
                    },
                    record: {
                      type: "unknown",
                      description: "The record to create."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoDeleteRecord: {
          lexicon: 1,
          id: "com.atproto.repo.deleteRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a record, or ensure it doesn't exist.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoDescribeRepo: {
          lexicon: 1,
          id: "com.atproto.repo.describeRepo",
          defs: {
            main: {
              type: "query",
              description: "Get information about the repo, including the list of collections.",
              parameters: {
                type: "params",
                required: ["repo"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "handle",
                    "did",
                    "didDoc",
                    "collections",
                    "handleIsCorrect"
                  ],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    collections: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "nsid"
                      }
                    },
                    handleIsCorrect: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoRepoGetRecord: {
          lexicon: 1,
          id: "com.atproto.repo.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get a record.",
              parameters: {
                type: "params",
                required: ["repo", "collection", "rkey"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    description: "The key of the record."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the version of the record. If not specified, then return the most recent version."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "value"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    value: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoRepoListRecords: {
          lexicon: 1,
          id: "com.atproto.repo.listRecords",
          defs: {
            main: {
              type: "query",
              description: "List a range of records in a collection.",
              parameters: {
                type: "params",
                required: ["repo", "collection"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record type."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50,
                    description: "The number of records to return."
                  },
                  cursor: {
                    type: "string"
                  },
                  rkeyStart: {
                    type: "string",
                    description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
                  },
                  rkeyEnd: {
                    type: "string",
                    description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
                  },
                  reverse: {
                    type: "boolean",
                    description: "Flag to reverse the order of the returned records."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["records"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    records: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.repo.listRecords#record"
                      }
                    }
                  }
                }
              }
            },
            record: {
              type: "object",
              required: ["uri", "cid", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        },
        ComAtprotoRepoPutRecord: {
          lexicon: 1,
          id: "com.atproto.repo.putRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Write a record, creating or updating it as needed.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey", "record"],
                  nullable: ["swapRecord"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The key of the record.",
                      maxLength: 15
                    },
                    validate: {
                      type: "boolean",
                      default: true,
                      description: "Flag for validating the record."
                    },
                    record: {
                      type: "unknown",
                      description: "The record to write."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoStrongRef: {
          lexicon: 1,
          id: "com.atproto.repo.strongRef",
          description: "A URI with a content-hash fingerprint.",
          defs: {
            main: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          }
        },
        ComAtprotoRepoUploadBlob: {
          lexicon: 1,
          id: "com.atproto.repo.uploadBlob",
          defs: {
            main: {
              type: "procedure",
              description: "Upload a new blob to be added to repo in a later request.",
              input: {
                encoding: "*/*"
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blob"],
                  properties: {
                    blob: {
                      type: "blob"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerConfirmEmail: {
          lexicon: 1,
          id: "com.atproto.server.confirmEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email", "token"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountNotFound"
                },
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "InvalidEmail"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAccount: {
          lexicon: 1,
          id: "com.atproto.server.createAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Create an account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    inviteCode: {
                      type: "string"
                    },
                    password: {
                      type: "string"
                    },
                    recoveryKey: {
                      type: "string"
                    },
                    plcOp: {
                      type: "unknown"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidHandle"
                },
                {
                  name: "InvalidPassword"
                },
                {
                  name: "InvalidInviteCode"
                },
                {
                  name: "HandleNotAvailable"
                },
                {
                  name: "UnsupportedDomain"
                },
                {
                  name: "UnresolvableDid"
                },
                {
                  name: "IncompatibleDidDoc"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.createAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Create an App Password.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.server.createAppPassword#appPassword"
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "password", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                password: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCode: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCode",
          defs: {
            main: {
              type: "procedure",
              description: "Create an invite code.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["useCount"],
                  properties: {
                    useCount: {
                      type: "integer"
                    },
                    forAccount: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["code"],
                  properties: {
                    code: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Create invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codeCount", "useCount"],
                  properties: {
                    codeCount: {
                      type: "integer",
                      default: 1
                    },
                    useCount: {
                      type: "integer"
                    },
                    forAccounts: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "did"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                      }
                    }
                  }
                }
              }
            },
            accountCodes: {
              type: "object",
              required: ["account", "codes"],
              properties: {
                account: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateSession: {
          lexicon: 1,
          id: "com.atproto.server.createSession",
          defs: {
            main: {
              type: "procedure",
              description: "Create an authentication session.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["identifier", "password"],
                  properties: {
                    identifier: {
                      type: "string",
                      description: "Handle or other identifier supported by the server for the authenticating user."
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            }
          }
        },
        ComAtprotoServerDefs: {
          lexicon: 1,
          id: "com.atproto.server.defs",
          defs: {
            inviteCode: {
              type: "object",
              required: [
                "code",
                "available",
                "disabled",
                "forAccount",
                "createdBy",
                "createdAt",
                "uses"
              ],
              properties: {
                code: {
                  type: "string"
                },
                available: {
                  type: "integer"
                },
                disabled: {
                  type: "boolean"
                },
                forAccount: {
                  type: "string"
                },
                createdBy: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                uses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCodeUse"
                  }
                }
              }
            },
            inviteCodeUse: {
              type: "object",
              required: ["usedBy", "usedAt"],
              properties: {
                usedBy: {
                  type: "string",
                  format: "did"
                },
                usedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.server.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete an actor's account with a token and password.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "password", "token"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    password: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerDeleteSession: {
          lexicon: 1,
          id: "com.atproto.server.deleteSession",
          defs: {
            main: {
              type: "procedure",
              description: "Delete the current session."
            }
          }
        },
        ComAtprotoServerDescribeServer: {
          lexicon: 1,
          id: "com.atproto.server.describeServer",
          defs: {
            main: {
              type: "query",
              description: "Get a document describing the service's accounts configuration.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["availableUserDomains"],
                  properties: {
                    inviteCodeRequired: {
                      type: "boolean"
                    },
                    availableUserDomains: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    links: {
                      type: "ref",
                      ref: "lex:com.atproto.server.describeServer#links"
                    }
                  }
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string"
                },
                termsOfService: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoServerGetAccountInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.getAccountInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get all invite codes for a given account.",
              parameters: {
                type: "params",
                properties: {
                  includeUsed: {
                    type: "boolean",
                    default: true
                  },
                  createAvailable: {
                    type: "boolean",
                    default: true
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "DuplicateCreate"
                }
              ]
            }
          }
        },
        ComAtprotoServerGetSession: {
          lexicon: 1,
          id: "com.atproto.server.getSession",
          defs: {
            main: {
              type: "query",
              description: "Get information about the current session.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle", "did"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerListAppPasswords: {
          lexicon: 1,
          id: "com.atproto.server.listAppPasswords",
          defs: {
            main: {
              type: "query",
              description: "List all App Passwords.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["passwords"],
                  properties: {
                    passwords: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerRefreshSession: {
          lexicon: 1,
          id: "com.atproto.server.refreshSession",
          defs: {
            main: {
              type: "procedure",
              description: "Refresh an authentication session.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            }
          }
        },
        ComAtprotoServerRequestAccountDelete: {
          lexicon: 1,
          id: "com.atproto.server.requestAccountDelete",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account deletion via email."
            }
          }
        },
        ComAtprotoServerRequestEmailConfirmation: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailConfirmation",
          defs: {
            main: {
              type: "procedure",
              description: "Request an email with a code to confirm ownership of email."
            }
          }
        },
        ComAtprotoServerRequestEmailUpdate: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Request a token in order to update email.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["tokenRequired"],
                  properties: {
                    tokenRequired: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerRequestPasswordReset: {
          lexicon: 1,
          id: "com.atproto.server.requestPasswordReset",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account password reset via email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerReserveSigningKey: {
          lexicon: 1,
          id: "com.atproto.server.reserveSigningKey",
          defs: {
            main: {
              type: "procedure",
              description: "Reserve a repo signing key for account creation.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    did: {
                      type: "string",
                      description: "The did to reserve a new did:key for"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["signingKey"],
                  properties: {
                    signingKey: {
                      type: "string",
                      description: "Public signing key in the form of a did:key."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerResetPassword: {
          lexicon: 1,
          id: "com.atproto.server.resetPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Reset a user account password using a token.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["token", "password"],
                  properties: {
                    token: {
                      type: "string"
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerRevokeAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.revokeAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Revoke an App Password by name.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerUpdateEmail: {
          lexicon: 1,
          id: "com.atproto.server.updateEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    token: {
                      type: "string",
                      description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "TokenRequired"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetBlob: {
          lexicon: 1,
          id: "com.atproto.sync.getBlob",
          defs: {
            main: {
              type: "query",
              description: "Get a blob associated with a given repo.",
              parameters: {
                type: "params",
                required: ["did", "cid"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the blob to fetch"
                  }
                }
              },
              output: {
                encoding: "*/*"
              }
            }
          }
        },
        ComAtprotoSyncGetBlocks: {
          lexicon: 1,
          id: "com.atproto.sync.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get blocks from a given repo.",
              parameters: {
                type: "params",
                required: ["did", "cids"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  cids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetCheckout: {
          lexicon: 1,
          id: "com.atproto.sync.getCheckout",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetHead: {
          lexicon: 1,
          id: "com.atproto.sync.getHead",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "HeadNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetLatestCommit: {
          lexicon: 1,
          id: "com.atproto.sync.getLatestCommit",
          defs: {
            main: {
              type: "query",
              description: "Get the current commit CID & revision of the repo.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cid", "rev"],
                  properties: {
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    rev: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRecord: {
          lexicon: 1,
          id: "com.atproto.sync.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get blocks needed for existence or non-existence of record.",
              parameters: {
                type: "params",
                required: ["did", "collection", "rkey"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid"
                  },
                  rkey: {
                    type: "string"
                  },
                  commit: {
                    type: "string",
                    format: "cid",
                    description: "An optional past commit CID."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetRepo: {
          lexicon: 1,
          id: "com.atproto.sync.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Gets the DID's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "The revision of the repo to catch up from."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncListBlobs: {
          lexicon: 1,
          id: "com.atproto.sync.listBlobs",
          defs: {
            main: {
              type: "query",
              description: "List blob CIDs since some revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "Optional revision of the repo to list blobs since."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cids"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    cids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncListRepos: {
          lexicon: 1,
          id: "com.atproto.sync.listRepos",
          defs: {
            main: {
              type: "query",
              description: "List DIDs and root CIDs of hosted repos.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.sync.listRepos#repo"
                      }
                    }
                  }
                }
              }
            },
            repo: {
              type: "object",
              required: ["did", "head", "rev"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                head: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoSyncNotifyOfUpdate: {
          lexicon: 1,
          id: "com.atproto.sync.notifyOfUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Notify a crawling service of a recent update; often when a long break between updates causes the connection with the crawling service to break.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the service that is notifying of update."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncRequestCrawl: {
          lexicon: 1,
          id: "com.atproto.sync.requestCrawl",
          defs: {
            main: {
              type: "procedure",
              description: "Request a service to persistently crawl hosted repos.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the service that is requesting to be crawled."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncSubscribeRepos: {
          lexicon: 1,
          id: "com.atproto.sync.subscribeRepos",
          defs: {
            main: {
              type: "subscription",
              description: "Subscribe to repo updates.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.sync.subscribeRepos#commit",
                    "lex:com.atproto.sync.subscribeRepos#handle",
                    "lex:com.atproto.sync.subscribeRepos#migrate",
                    "lex:com.atproto.sync.subscribeRepos#tombstone",
                    "lex:com.atproto.sync.subscribeRepos#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                },
                {
                  name: "ConsumerTooSlow"
                }
              ]
            },
            commit: {
              type: "object",
              required: [
                "seq",
                "rebase",
                "tooBig",
                "repo",
                "commit",
                "rev",
                "since",
                "blocks",
                "ops",
                "blobs",
                "time"
              ],
              nullable: ["prev", "since"],
              properties: {
                seq: {
                  type: "integer"
                },
                rebase: {
                  type: "boolean"
                },
                tooBig: {
                  type: "boolean"
                },
                repo: {
                  type: "string",
                  format: "did"
                },
                commit: {
                  type: "cid-link"
                },
                prev: {
                  type: "cid-link"
                },
                rev: {
                  type: "string",
                  description: "The rev of the emitted commit."
                },
                since: {
                  type: "string",
                  description: "The rev of the last emitted commit from this repo."
                },
                blocks: {
                  type: "bytes",
                  description: "CAR file containing relevant blocks.",
                  maxLength: 1e6
                },
                ops: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.subscribeRepos#repoOp"
                  },
                  maxLength: 200
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "cid-link"
                  }
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            handle: {
              type: "object",
              required: ["seq", "did", "handle", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            migrate: {
              type: "object",
              required: ["seq", "did", "migrateTo", "time"],
              nullable: ["migrateTo"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                migrateTo: {
                  type: "string"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            tombstone: {
              type: "object",
              required: ["seq", "did", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            },
            repoOp: {
              type: "object",
              description: "A repo operation, ie a write of a single record. For creates and updates, CID is the record's CID as of this operation. For deletes, it's null.",
              required: ["action", "path", "cid"],
              nullable: ["cid"],
              properties: {
                action: {
                  type: "string",
                  knownValues: ["create", "update", "delete"]
                },
                path: {
                  type: "string"
                },
                cid: {
                  type: "cid-link"
                }
              }
            }
          }
        },
        ComAtprotoTempFetchLabels: {
          lexicon: 1,
          id: "com.atproto.temp.fetchLabels",
          defs: {
            main: {
              type: "query",
              description: "Fetch all labels from a labeler created after a certain date.",
              parameters: {
                type: "params",
                properties: {
                  since: {
                    type: "integer"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoTempImportRepo: {
          lexicon: 1,
          id: "com.atproto.temp.importRepo",
          defs: {
            main: {
              type: "procedure",
              description: "Gets the did's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              input: {
                encoding: "application/vnd.ipld.car"
              },
              output: {
                encoding: "text/plain"
              }
            }
          }
        },
        ComAtprotoTempPushBlob: {
          lexicon: 1,
          id: "com.atproto.temp.pushBlob",
          defs: {
            main: {
              type: "procedure",
              description: "Gets the did's repo, optionally catching up from a specific revision.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              input: {
                encoding: "*/*"
              }
            }
          }
        },
        ComAtprotoTempTransferAccount: {
          lexicon: 1,
          id: "com.atproto.temp.transferAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Transfer an account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle", "did", "plcOp"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    plcOp: {
                      type: "unknown"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidHandle"
                },
                {
                  name: "InvalidPassword"
                },
                {
                  name: "InvalidInviteCode"
                },
                {
                  name: "HandleNotAvailable"
                },
                {
                  name: "UnsupportedDomain"
                },
                {
                  name: "UnresolvableDid"
                },
                {
                  name: "IncompatibleDidDoc"
                }
              ]
            }
          }
        },
        AppBskyActorDefs: {
          lexicon: 1,
          id: "app.bsky.actor.defs",
          description: "A reference to an actor in the network.",
          defs: {
            profileViewBasic: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            profileView: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            profileViewDetailed: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string"
                },
                banner: {
                  type: "string"
                },
                followersCount: {
                  type: "integer"
                },
                followsCount: {
                  type: "integer"
                },
                postsCount: {
                  type: "integer"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            viewerState: {
              type: "object",
              properties: {
                muted: {
                  type: "boolean"
                },
                mutedByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                blockedBy: {
                  type: "boolean"
                },
                blocking: {
                  type: "string",
                  format: "at-uri"
                },
                blockingByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                following: {
                  type: "string",
                  format: "at-uri"
                },
                followedBy: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            preferences: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.actor.defs#adultContentPref",
                  "lex:app.bsky.actor.defs#contentLabelPref",
                  "lex:app.bsky.actor.defs#savedFeedsPref",
                  "lex:app.bsky.actor.defs#personalDetailsPref",
                  "lex:app.bsky.actor.defs#feedViewPref",
                  "lex:app.bsky.actor.defs#threadViewPref"
                ]
              }
            },
            adultContentPref: {
              type: "object",
              required: ["enabled"],
              properties: {
                enabled: {
                  type: "boolean",
                  default: false
                }
              }
            },
            contentLabelPref: {
              type: "object",
              required: ["label", "visibility"],
              properties: {
                label: {
                  type: "string"
                },
                visibility: {
                  type: "string",
                  knownValues: ["show", "warn", "hide"]
                }
              }
            },
            savedFeedsPref: {
              type: "object",
              required: ["pinned", "saved"],
              properties: {
                pinned: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                },
                saved: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            },
            personalDetailsPref: {
              type: "object",
              properties: {
                birthDate: {
                  type: "string",
                  format: "datetime",
                  description: "The birth date of account owner."
                }
              }
            },
            feedViewPref: {
              type: "object",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  description: "The URI of the feed, or an identifier which describes the feed."
                },
                hideReplies: {
                  type: "boolean",
                  description: "Hide replies in the feed."
                },
                hideRepliesByUnfollowed: {
                  type: "boolean",
                  description: "Hide replies in the feed if they are not by followed users."
                },
                hideRepliesByLikeCount: {
                  type: "integer",
                  description: "Hide replies in the feed if they do not have this number of likes."
                },
                hideReposts: {
                  type: "boolean",
                  description: "Hide reposts in the feed."
                },
                hideQuotePosts: {
                  type: "boolean",
                  description: "Hide quote posts in the feed."
                }
              }
            },
            threadViewPref: {
              type: "object",
              properties: {
                sort: {
                  type: "string",
                  description: "Sorting mode for threads.",
                  knownValues: ["oldest", "newest", "most-likes", "random"]
                },
                prioritizeFollowedUsers: {
                  type: "boolean",
                  description: "Show followed users at the top of all replies."
                }
              }
            }
          }
        },
        AppBskyActorGetPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.getPreferences",
          defs: {
            main: {
              type: "query",
              description: "Get private preferences attached to the account.",
              parameters: {
                type: "params",
                properties: {}
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetProfile: {
          lexicon: 1,
          id: "app.bsky.actor.getProfile",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile view of an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                }
              }
            }
          }
        },
        AppBskyActorGetProfiles: {
          lexicon: 1,
          id: "app.bsky.actor.getProfiles",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile views of multiple actors.",
              parameters: {
                type: "params",
                required: ["actors"],
                properties: {
                  actors: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-identifier"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["profiles"],
                  properties: {
                    profiles: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetSuggestions: {
          lexicon: 1,
          id: "app.bsky.actor.getSuggestions",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested actors, used for discovery.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorProfile: {
          lexicon: 1,
          id: "app.bsky.actor.profile",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a profile.",
              key: "literal:self",
              record: {
                type: "object",
                properties: {
                  displayName: {
                    type: "string",
                    maxGraphemes: 64,
                    maxLength: 640
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 256,
                    maxLength: 2560
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  banner: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  }
                }
              }
            }
          }
        },
        AppBskyActorPutPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.putPreferences",
          defs: {
            main: {
              type: "procedure",
              description: "Set the private preferences attached to the account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActors: {
          lexicon: 1,
          id: "app.bsky.actor.searchActors",
          defs: {
            main: {
              type: "query",
              description: "Find actors (profiles) matching search criteria.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActorsTypeahead: {
          lexicon: 1,
          id: "app.bsky.actor.searchActorsTypeahead",
          defs: {
            main: {
              type: "query",
              description: "Find actor suggestions for a prefix search term.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query prefix; not a full query string."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 10
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyEmbedExternal: {
          lexicon: 1,
          id: "app.bsky.embed.external",
          description: "A representation of some externally linked content, embedded in another form of content.",
          defs: {
            main: {
              type: "object",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#external"
                }
              }
            },
            external: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                }
              }
            },
            view: {
              type: "object",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#viewExternal"
                }
              }
            },
            viewExternal: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyEmbedImages: {
          lexicon: 1,
          id: "app.bsky.embed.images",
          description: "A set of images embedded in some other form of content.",
          defs: {
            main: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#image"
                  },
                  maxLength: 4
                }
              }
            },
            image: {
              type: "object",
              required: ["image", "alt"],
              properties: {
                image: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                },
                alt: {
                  type: "string"
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#aspectRatio"
                }
              }
            },
            aspectRatio: {
              type: "object",
              description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer",
                  minimum: 1
                },
                height: {
                  type: "integer",
                  minimum: 1
                }
              }
            },
            view: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#viewImage"
                  },
                  maxLength: 4
                }
              }
            },
            viewImage: {
              type: "object",
              required: ["thumb", "fullsize", "alt"],
              properties: {
                thumb: {
                  type: "string"
                },
                fullsize: {
                  type: "string"
                },
                alt: {
                  type: "string"
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#aspectRatio"
                }
              }
            }
          }
        },
        AppBskyEmbedRecord: {
          lexicon: 1,
          id: "app.bsky.embed.record",
          description: "A representation of a record embedded in another form of content.",
          defs: {
            main: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            view: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.record#viewRecord",
                    "lex:app.bsky.embed.record#viewNotFound",
                    "lex:app.bsky.embed.record#viewBlocked",
                    "lex:app.bsky.feed.defs#generatorView",
                    "lex:app.bsky.graph.defs#listView"
                  ]
                }
              }
            },
            viewRecord: {
              type: "object",
              required: ["uri", "cid", "author", "value", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                value: {
                  type: "unknown"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                embeds: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images#view",
                      "lex:app.bsky.embed.external#view",
                      "lex:app.bsky.embed.record#view",
                      "lex:app.bsky.embed.recordWithMedia#view"
                    ]
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            viewNotFound: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            viewBlocked: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            }
          }
        },
        AppBskyEmbedRecordWithMedia: {
          lexicon: 1,
          id: "app.bsky.embed.recordWithMedia",
          description: "A representation of a record embedded in another form of content, alongside other compatible embeds.",
          defs: {
            main: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record"
                },
                media: {
                  type: "union",
                  refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
                }
              }
            },
            view: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record#view"
                },
                media: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.external#view"
                  ]
                }
              }
            }
          }
        },
        AppBskyFeedDefs: {
          lexicon: 1,
          id: "app.bsky.feed.defs",
          defs: {
            postView: {
              type: "object",
              required: ["uri", "cid", "author", "record", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                record: {
                  type: "unknown"
                },
                embed: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.external#view",
                    "lex:app.bsky.embed.record#view",
                    "lex:app.bsky.embed.recordWithMedia#view"
                  ]
                },
                replyCount: {
                  type: "integer"
                },
                repostCount: {
                  type: "integer"
                },
                likeCount: {
                  type: "integer"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                threadgate: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#threadgateView"
                }
              }
            },
            viewerState: {
              type: "object",
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                },
                like: {
                  type: "string",
                  format: "at-uri"
                },
                replyDisabled: {
                  type: "boolean"
                }
              }
            },
            feedViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                reply: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#replyRef"
                },
                reason: {
                  type: "union",
                  refs: ["lex:app.bsky.feed.defs#reasonRepost"]
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            },
            reasonRepost: {
              type: "object",
              required: ["by", "indexedAt"],
              properties: {
                by: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            threadViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                replies: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.defs#threadViewPost",
                      "lex:app.bsky.feed.defs#notFoundPost",
                      "lex:app.bsky.feed.defs#blockedPost"
                    ]
                  }
                }
              }
            },
            notFoundPost: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            blockedPost: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            },
            blockedAuthor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                }
              }
            },
            generatorView: {
              type: "object",
              required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                displayName: {
                  type: "string"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            generatorViewerState: {
              type: "object",
              properties: {
                like: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonFeedPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "string",
                  format: "at-uri"
                },
                reason: {
                  type: "union",
                  refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
                }
              }
            },
            skeletonReasonRepost: {
              type: "object",
              required: ["repost"],
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            threadgateView: {
              type: "object",
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listViewBasic"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedDescribeFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.describeFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator, including policies and offered feed URIs.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "feeds"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                      }
                    },
                    links: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                    }
                  }
                }
              }
            },
            feed: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string"
                },
                termsOfService: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.generator",
          defs: {
            main: {
              type: "record",
              description: "A declaration of the existence of a feed generator.",
              key: "any",
              record: {
                type: "object",
                required: ["did", "displayName", "createdAt"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  displayName: {
                    type: "string",
                    maxGraphemes: 24,
                    maxLength: 240
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getActorFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of feeds created by the actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getActorLikes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of posts liked by an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetAuthorFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getAuthorFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a view of an actor's feed.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  filter: {
                    type: "string",
                    knownValues: [
                      "posts_with_replies",
                      "posts_no_replies",
                      "posts_with_media",
                      "posts_and_author_threads"
                    ],
                    default: "posts_with_replies"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a hydrated feed from an actor's selected feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["view", "isOnline", "isValid"],
                  properties: {
                    view: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    },
                    isOnline: {
                      type: "boolean"
                    },
                    isValid: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "Get information about a list of feed generators.",
              parameters: {
                type: "params",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedSkeleton: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Get a skeleton of a feed provided by a feed generator.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getLikes",
          defs: {
            main: {
              type: "query",
              description: "Get the list of likes.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "likes"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    likes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.getLikes#like"
                      }
                    }
                  }
                }
              }
            },
            like: {
              type: "object",
              required: ["indexedAt", "createdAt", "actor"],
              properties: {
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                actor: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            }
          }
        },
        AppBskyFeedGetListFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getListFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a view of a recent posts from actors in a list.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownList"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPostThread: {
          lexicon: 1,
          id: "app.bsky.feed.getPostThread",
          defs: {
            main: {
              type: "query",
              description: "Get posts in a thread.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  depth: {
                    type: "integer",
                    default: 6,
                    minimum: 0,
                    maximum: 1e3
                  },
                  parentHeight: {
                    type: "integer",
                    default: 80,
                    minimum: 0,
                    maximum: 1e3
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["thread"],
                  properties: {
                    thread: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.defs#threadViewPost",
                        "lex:app.bsky.feed.defs#notFoundPost",
                        "lex:app.bsky.feed.defs#blockedPost"
                      ]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "NotFound"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPosts: {
          lexicon: 1,
          id: "app.bsky.feed.getPosts",
          defs: {
            main: {
              type: "query",
              description: "Get a view of an actor's feed.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetRepostedBy: {
          lexicon: 1,
          id: "app.bsky.feed.getRepostedBy",
          defs: {
            main: {
              type: "query",
              description: "Get a list of reposts.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "repostedBy"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    repostedBy: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetSuggestedFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getSuggestedFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested feeds for the viewer.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetTimeline: {
          lexicon: 1,
          id: "app.bsky.feed.getTimeline",
          defs: {
            main: {
              type: "query",
              description: "Get a view of the actor's home timeline.",
              parameters: {
                type: "params",
                properties: {
                  algorithm: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedLike: {
          lexicon: 1,
          id: "app.bsky.feed.like",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a like.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedPost: {
          lexicon: 1,
          id: "app.bsky.feed.post",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a post.",
              key: "tid",
              record: {
                type: "object",
                required: ["text", "createdAt"],
                properties: {
                  text: {
                    type: "string",
                    maxLength: 3e3,
                    maxGraphemes: 300
                  },
                  entities: {
                    type: "array",
                    description: "Deprecated: replaced by app.bsky.richtext.facet.",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.post#entity"
                    }
                  },
                  facets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  reply: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.post#replyRef"
                  },
                  embed: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images",
                      "lex:app.bsky.embed.external",
                      "lex:app.bsky.embed.record",
                      "lex:app.bsky.embed.recordWithMedia"
                    ]
                  },
                  langs: {
                    type: "array",
                    maxLength: 3,
                    items: {
                      type: "string",
                      format: "language"
                    }
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  tags: {
                    type: "array",
                    maxLength: 8,
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    },
                    description: "Additional non-inline tags describing this post."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                parent: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            entity: {
              type: "object",
              description: "Deprecated: use facets instead.",
              required: ["index", "type", "value"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#textSlice"
                },
                type: {
                  type: "string",
                  description: "Expected values are 'mention' and 'link'."
                },
                value: {
                  type: "string"
                }
              }
            },
            textSlice: {
              type: "object",
              description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
              required: ["start", "end"],
              properties: {
                start: {
                  type: "integer",
                  minimum: 0
                },
                end: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyFeedRepost: {
          lexicon: 1,
          id: "app.bsky.feed.repost",
          defs: {
            main: {
              description: "A declaration of a repost.",
              type: "record",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedSearchPosts: {
          lexicon: 1,
          id: "app.bsky.feed.searchPosts",
          defs: {
            main: {
              type: "query",
              description: "Find posts matching search criteria.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyFeedThreadgate: {
          lexicon: 1,
          id: "app.bsky.feed.threadgate",
          defs: {
            main: {
              type: "record",
              key: "tid",
              description: "Defines interaction gating rules for a thread. The rkey of the threadgate record should match the rkey of the thread's root post.",
              record: {
                type: "object",
                required: ["post", "createdAt"],
                properties: {
                  post: {
                    type: "string",
                    format: "at-uri"
                  },
                  allow: {
                    type: "array",
                    maxLength: 5,
                    items: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.threadgate#mentionRule",
                        "lex:app.bsky.feed.threadgate#followingRule",
                        "lex:app.bsky.feed.threadgate#listRule"
                      ]
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            },
            mentionRule: {
              type: "object",
              description: "Allow replies from actors mentioned in your post.",
              properties: {}
            },
            followingRule: {
              type: "object",
              description: "Allow replies from actors you follow.",
              properties: {}
            },
            listRule: {
              type: "object",
              description: "Allow replies from actors on a list.",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphBlock: {
          lexicon: 1,
          id: "app.bsky.graph.block",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a block.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphDefs: {
          lexicon: 1,
          id: "app.bsky.graph.defs",
          defs: {
            listViewBasic: {
              type: "object",
              required: ["uri", "cid", "name", "purpose"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listView: {
              type: "object",
              required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listItemView: {
              type: "object",
              required: ["uri", "subject"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            },
            listPurpose: {
              type: "string",
              knownValues: [
                "app.bsky.graph.defs#modlist",
                "app.bsky.graph.defs#curatelist"
              ]
            },
            modlist: {
              type: "token",
              description: "A list of actors to apply an aggregate moderation action (mute/block) on."
            },
            curatelist: {
              type: "token",
              description: "A list of actors used for curation purposes such as list feeds or interaction gating."
            },
            listViewerState: {
              type: "object",
              properties: {
                muted: {
                  type: "boolean"
                },
                blocked: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphFollow: {
          lexicon: 1,
          id: "app.bsky.graph.follow",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a social follow.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor is blocking.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blocks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    blocks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollowers: {
          lexicon: 1,
          id: "app.bsky.graph.getFollowers",
          defs: {
            main: {
              type: "query",
              description: "Get a list of an actor's followers.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "followers"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    followers: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollows: {
          lexicon: 1,
          id: "app.bsky.graph.getFollows",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor follows.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "follows"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    follows: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetList: {
          lexicon: 1,
          id: "app.bsky.graph.getList",
          defs: {
            main: {
              type: "query",
              description: "Get a list of actors.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list", "items"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    list: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    },
                    items: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listItemView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getListBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get lists that the actor is blocking.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getListMutes",
          defs: {
            main: {
              type: "query",
              description: "Get lists that the actor is muting.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetLists: {
          lexicon: 1,
          id: "app.bsky.graph.getLists",
          defs: {
            main: {
              type: "query",
              description: "Get a list of lists that belong to an actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getMutes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of who the actor mutes.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["mutes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    mutes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetSuggestedFollowsByActor: {
          lexicon: 1,
          id: "app.bsky.graph.getSuggestedFollowsByActor",
          defs: {
            main: {
              type: "query",
              description: "Get suggested follows related to a given actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["suggestions"],
                  properties: {
                    suggestions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphList: {
          lexicon: 1,
          id: "app.bsky.graph.list",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["name", "purpose", "createdAt"],
                properties: {
                  purpose: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listPurpose"
                  },
                  name: {
                    type: "string",
                    maxLength: 64,
                    minLength: 1
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListblock: {
          lexicon: 1,
          id: "app.bsky.graph.listblock",
          defs: {
            main: {
              type: "record",
              description: "A block of an entire list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "at-uri"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListitem: {
          lexicon: 1,
          id: "app.bsky.graph.listitem",
          defs: {
            main: {
              type: "record",
              description: "An item under a declared list of actors.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "list", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  list: {
                    type: "string",
                    format: "at-uri"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.muteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Mute an actor by DID or handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.muteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Mute a list of actors.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Unmute an actor by DID or handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Unmute a list of actors.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationGetUnreadCount: {
          lexicon: 1,
          id: "app.bsky.notification.getUnreadCount",
          defs: {
            main: {
              type: "query",
              description: "Get the count of unread notifications.",
              parameters: {
                type: "params",
                properties: {
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["count"],
                  properties: {
                    count: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationListNotifications: {
          lexicon: 1,
          id: "app.bsky.notification.listNotifications",
          defs: {
            main: {
              type: "query",
              description: "Get a list of notifications.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["notifications"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    notifications: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.notification.listNotifications#notification"
                      }
                    },
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            },
            notification: {
              type: "object",
              required: [
                "uri",
                "cid",
                "author",
                "reason",
                "record",
                "isRead",
                "indexedAt"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                reason: {
                  type: "string",
                  description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.",
                  knownValues: [
                    "like",
                    "repost",
                    "follow",
                    "mention",
                    "reply",
                    "quote"
                  ]
                },
                reasonSubject: {
                  type: "string",
                  format: "at-uri"
                },
                record: {
                  type: "unknown"
                },
                isRead: {
                  type: "boolean"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationRegisterPush: {
          lexicon: 1,
          id: "app.bsky.notification.registerPush",
          defs: {
            main: {
              type: "procedure",
              description: "Register for push notifications with a service.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["serviceDid", "token", "platform", "appId"],
                  properties: {
                    serviceDid: {
                      type: "string",
                      format: "did"
                    },
                    token: {
                      type: "string"
                    },
                    platform: {
                      type: "string",
                      knownValues: ["ios", "android", "web"]
                    },
                    appId: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationUpdateSeen: {
          lexicon: 1,
          id: "app.bsky.notification.updateSeen",
          defs: {
            main: {
              type: "procedure",
              description: "Notify server that the user has seen notifications.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["seenAt"],
                  properties: {
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyRichtextFacet: {
          lexicon: 1,
          id: "app.bsky.richtext.facet",
          defs: {
            main: {
              type: "object",
              required: ["index", "features"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet#byteSlice"
                },
                features: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.richtext.facet#mention",
                      "lex:app.bsky.richtext.facet#link",
                      "lex:app.bsky.richtext.facet#tag"
                    ]
                  }
                }
              }
            },
            mention: {
              type: "object",
              description: "A facet feature for actor mentions.",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            link: {
              type: "object",
              description: "A facet feature for links.",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            tag: {
              type: "object",
              description: "A hashtag.",
              required: ["tag"],
              properties: {
                tag: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              }
            },
            byteSlice: {
              type: "object",
              description: "A text segment. Start is inclusive, end is exclusive. Indices are for utf8-encoded strings.",
              required: ["byteStart", "byteEnd"],
              properties: {
                byteStart: {
                  type: "integer",
                  minimum: 0
                },
                byteEnd: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyUnspeccedDefs: {
          lexicon: 1,
          id: "app.bsky.unspecced.defs",
          defs: {
            skeletonSearchPost: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonSearchActor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetPopular: {
          lexicon: 1,
          id: "app.bsky.unspecced.getPopular",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED: will be removed soon. Use a feed generator alternative.",
              parameters: {
                type: "params",
                properties: {
                  includeNsfw: {
                    type: "boolean",
                    default: false
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetPopularFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.unspecced.getPopularFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "An unspecced view of globally popular feed generators.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  query: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetTimelineSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.getTimelineSkeleton",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED: a skeleton of a timeline. Unspecced and will be unavailable soon.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchActorsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchActorsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Actors (profile) search, returns only skeleton.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
                  },
                  typeahead: {
                    type: "boolean",
                    description: "If true, acts as fast/simple 'typeahead' query."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchPostsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchPostsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Posts search, returns only skeleton",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        }
      };
      var schemas = Object.values(schemaDict);
      var lexicons = new Lexicons(schemas);
      var deleteAccount_exports = {};
      __export2(deleteAccount_exports, {
        toKnownErr: () => toKnownErr
      });
      function toKnownErr(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var disableAccountInvites_exports = {};
      __export2(disableAccountInvites_exports, {
        toKnownErr: () => toKnownErr2
      });
      function toKnownErr2(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var disableInviteCodes_exports = {};
      __export2(disableInviteCodes_exports, {
        toKnownErr: () => toKnownErr3
      });
      function toKnownErr3(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var emitModerationEvent_exports = {};
      __export2(emitModerationEvent_exports, {
        SubjectHasActionError: () => SubjectHasActionError,
        toKnownErr: () => toKnownErr4
      });
      var SubjectHasActionError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr4(e) {
        if (e instanceof XRPCError) {
          if (e.error === "SubjectHasAction")
            return new SubjectHasActionError(e);
        }
        return e;
      }
      var enableAccountInvites_exports = {};
      __export2(enableAccountInvites_exports, {
        toKnownErr: () => toKnownErr5
      });
      function toKnownErr5(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getAccountInfo_exports = {};
      __export2(getAccountInfo_exports, {
        toKnownErr: () => toKnownErr6
      });
      function toKnownErr6(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getInviteCodes_exports = {};
      __export2(getInviteCodes_exports, {
        toKnownErr: () => toKnownErr7
      });
      function toKnownErr7(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getModerationEvent_exports = {};
      __export2(getModerationEvent_exports, {
        toKnownErr: () => toKnownErr8
      });
      function toKnownErr8(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRecord_exports = {};
      __export2(getRecord_exports, {
        RecordNotFoundError: () => RecordNotFoundError,
        toKnownErr: () => toKnownErr9
      });
      var RecordNotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr9(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RecordNotFound")
            return new RecordNotFoundError(e);
        }
        return e;
      }
      var getRepo_exports = {};
      __export2(getRepo_exports, {
        RepoNotFoundError: () => RepoNotFoundError,
        toKnownErr: () => toKnownErr10
      });
      var RepoNotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr10(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RepoNotFound")
            return new RepoNotFoundError(e);
        }
        return e;
      }
      var getSubjectStatus_exports = {};
      __export2(getSubjectStatus_exports, {
        toKnownErr: () => toKnownErr11
      });
      function toKnownErr11(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryModerationEvents_exports = {};
      __export2(queryModerationEvents_exports, {
        toKnownErr: () => toKnownErr12
      });
      function toKnownErr12(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryModerationStatuses_exports = {};
      __export2(queryModerationStatuses_exports, {
        toKnownErr: () => toKnownErr13
      });
      function toKnownErr13(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchRepos_exports = {};
      __export2(searchRepos_exports, {
        toKnownErr: () => toKnownErr14
      });
      function toKnownErr14(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var sendEmail_exports = {};
      __export2(sendEmail_exports, {
        toKnownErr: () => toKnownErr15
      });
      function toKnownErr15(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateAccountEmail_exports = {};
      __export2(updateAccountEmail_exports, {
        toKnownErr: () => toKnownErr16
      });
      function toKnownErr16(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateAccountHandle_exports = {};
      __export2(updateAccountHandle_exports, {
        toKnownErr: () => toKnownErr17
      });
      function toKnownErr17(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateSubjectStatus_exports = {};
      __export2(updateSubjectStatus_exports, {
        toKnownErr: () => toKnownErr18
      });
      function toKnownErr18(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var resolveHandle_exports = {};
      __export2(resolveHandle_exports, {
        toKnownErr: () => toKnownErr19
      });
      function toKnownErr19(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateHandle_exports = {};
      __export2(updateHandle_exports, {
        toKnownErr: () => toKnownErr20
      });
      function toKnownErr20(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var queryLabels_exports = {};
      __export2(queryLabels_exports, {
        toKnownErr: () => toKnownErr21
      });
      function toKnownErr21(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var createReport_exports = {};
      __export2(createReport_exports, {
        toKnownErr: () => toKnownErr22
      });
      function toKnownErr22(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var applyWrites_exports = {};
      __export2(applyWrites_exports, {
        InvalidSwapError: () => InvalidSwapError,
        isCreate: () => isCreate,
        isDelete: () => isDelete,
        isUpdate: () => isUpdate,
        toKnownErr: () => toKnownErr23,
        validateCreate: () => validateCreate,
        validateDelete: () => validateDelete,
        validateUpdate: () => validateUpdate
      });
      function isObj2(v) {
        return typeof v === "object" && v !== null;
      }
      function hasProp2(data, prop) {
        return prop in data;
      }
      var InvalidSwapError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr23(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError(e);
        }
        return e;
      }
      function isCreate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#create";
      }
      function validateCreate(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#create", v);
      }
      function isUpdate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#update";
      }
      function validateUpdate(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#update", v);
      }
      function isDelete(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.applyWrites#delete";
      }
      function validateDelete(v) {
        return lexicons.validate("com.atproto.repo.applyWrites#delete", v);
      }
      var createRecord_exports = {};
      __export2(createRecord_exports, {
        InvalidSwapError: () => InvalidSwapError2,
        toKnownErr: () => toKnownErr24
      });
      var InvalidSwapError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr24(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError2(e);
        }
        return e;
      }
      var deleteRecord_exports = {};
      __export2(deleteRecord_exports, {
        InvalidSwapError: () => InvalidSwapError3,
        toKnownErr: () => toKnownErr25
      });
      var InvalidSwapError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr25(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError3(e);
        }
        return e;
      }
      var describeRepo_exports = {};
      __export2(describeRepo_exports, {
        toKnownErr: () => toKnownErr26
      });
      function toKnownErr26(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRecord_exports2 = {};
      __export2(getRecord_exports2, {
        toKnownErr: () => toKnownErr27
      });
      function toKnownErr27(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listRecords_exports = {};
      __export2(listRecords_exports, {
        isRecord: () => isRecord,
        toKnownErr: () => toKnownErr28,
        validateRecord: () => validateRecord
      });
      function toKnownErr28(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isRecord(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.repo.listRecords#record";
      }
      function validateRecord(v) {
        return lexicons.validate("com.atproto.repo.listRecords#record", v);
      }
      var putRecord_exports = {};
      __export2(putRecord_exports, {
        InvalidSwapError: () => InvalidSwapError4,
        toKnownErr: () => toKnownErr29
      });
      var InvalidSwapError4 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr29(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidSwap")
            return new InvalidSwapError4(e);
        }
        return e;
      }
      var uploadBlob_exports = {};
      __export2(uploadBlob_exports, {
        toKnownErr: () => toKnownErr30
      });
      function toKnownErr30(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var confirmEmail_exports = {};
      __export2(confirmEmail_exports, {
        AccountNotFoundError: () => AccountNotFoundError,
        ExpiredTokenError: () => ExpiredTokenError,
        InvalidEmailError: () => InvalidEmailError,
        InvalidTokenError: () => InvalidTokenError,
        toKnownErr: () => toKnownErr31
      });
      var AccountNotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var ExpiredTokenError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidTokenError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidEmailError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr31(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountNotFound")
            return new AccountNotFoundError(e);
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError(e);
          if (e.error === "InvalidEmail")
            return new InvalidEmailError(e);
        }
        return e;
      }
      var createAccount_exports = {};
      __export2(createAccount_exports, {
        HandleNotAvailableError: () => HandleNotAvailableError,
        IncompatibleDidDocError: () => IncompatibleDidDocError,
        InvalidHandleError: () => InvalidHandleError2,
        InvalidInviteCodeError: () => InvalidInviteCodeError,
        InvalidPasswordError: () => InvalidPasswordError,
        UnresolvableDidError: () => UnresolvableDidError,
        UnsupportedDomainError: () => UnsupportedDomainError,
        toKnownErr: () => toKnownErr32
      });
      var InvalidHandleError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidPasswordError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidInviteCodeError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var HandleNotAvailableError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var UnsupportedDomainError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var UnresolvableDidError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var IncompatibleDidDocError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr32(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidHandle")
            return new InvalidHandleError2(e);
          if (e.error === "InvalidPassword")
            return new InvalidPasswordError(e);
          if (e.error === "InvalidInviteCode")
            return new InvalidInviteCodeError(e);
          if (e.error === "HandleNotAvailable")
            return new HandleNotAvailableError(e);
          if (e.error === "UnsupportedDomain")
            return new UnsupportedDomainError(e);
          if (e.error === "UnresolvableDid")
            return new UnresolvableDidError(e);
          if (e.error === "IncompatibleDidDoc")
            return new IncompatibleDidDocError(e);
        }
        return e;
      }
      var createAppPassword_exports = {};
      __export2(createAppPassword_exports, {
        AccountTakedownError: () => AccountTakedownError,
        isAppPassword: () => isAppPassword,
        toKnownErr: () => toKnownErr33,
        validateAppPassword: () => validateAppPassword
      });
      var AccountTakedownError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr33(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError(e);
        }
        return e;
      }
      function isAppPassword(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.createAppPassword#appPassword";
      }
      function validateAppPassword(v) {
        return lexicons.validate("com.atproto.server.createAppPassword#appPassword", v);
      }
      var createInviteCode_exports = {};
      __export2(createInviteCode_exports, {
        toKnownErr: () => toKnownErr34
      });
      function toKnownErr34(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var createInviteCodes_exports = {};
      __export2(createInviteCodes_exports, {
        isAccountCodes: () => isAccountCodes,
        toKnownErr: () => toKnownErr35,
        validateAccountCodes: () => validateAccountCodes
      });
      function toKnownErr35(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isAccountCodes(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.createInviteCodes#accountCodes";
      }
      function validateAccountCodes(v) {
        return lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", v);
      }
      var createSession_exports = {};
      __export2(createSession_exports, {
        AccountTakedownError: () => AccountTakedownError2,
        toKnownErr: () => toKnownErr36
      });
      var AccountTakedownError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr36(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError2(e);
        }
        return e;
      }
      var deleteAccount_exports2 = {};
      __export2(deleteAccount_exports2, {
        ExpiredTokenError: () => ExpiredTokenError2,
        InvalidTokenError: () => InvalidTokenError2,
        toKnownErr: () => toKnownErr37
      });
      var ExpiredTokenError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidTokenError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr37(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError2(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError2(e);
        }
        return e;
      }
      var deleteSession_exports = {};
      __export2(deleteSession_exports, {
        toKnownErr: () => toKnownErr38
      });
      function toKnownErr38(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var describeServer_exports = {};
      __export2(describeServer_exports, {
        isLinks: () => isLinks,
        toKnownErr: () => toKnownErr39,
        validateLinks: () => validateLinks
      });
      function toKnownErr39(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isLinks(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.describeServer#links";
      }
      function validateLinks(v) {
        return lexicons.validate("com.atproto.server.describeServer#links", v);
      }
      var getAccountInviteCodes_exports = {};
      __export2(getAccountInviteCodes_exports, {
        DuplicateCreateError: () => DuplicateCreateError,
        toKnownErr: () => toKnownErr40
      });
      var DuplicateCreateError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr40(e) {
        if (e instanceof XRPCError) {
          if (e.error === "DuplicateCreate")
            return new DuplicateCreateError(e);
        }
        return e;
      }
      var getSession_exports = {};
      __export2(getSession_exports, {
        toKnownErr: () => toKnownErr41
      });
      function toKnownErr41(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listAppPasswords_exports = {};
      __export2(listAppPasswords_exports, {
        AccountTakedownError: () => AccountTakedownError3,
        isAppPassword: () => isAppPassword2,
        toKnownErr: () => toKnownErr42,
        validateAppPassword: () => validateAppPassword2
      });
      var AccountTakedownError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr42(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError3(e);
        }
        return e;
      }
      function isAppPassword2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.listAppPasswords#appPassword";
      }
      function validateAppPassword2(v) {
        return lexicons.validate("com.atproto.server.listAppPasswords#appPassword", v);
      }
      var refreshSession_exports = {};
      __export2(refreshSession_exports, {
        AccountTakedownError: () => AccountTakedownError4,
        toKnownErr: () => toKnownErr43
      });
      var AccountTakedownError4 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr43(e) {
        if (e instanceof XRPCError) {
          if (e.error === "AccountTakedown")
            return new AccountTakedownError4(e);
        }
        return e;
      }
      var requestAccountDelete_exports = {};
      __export2(requestAccountDelete_exports, {
        toKnownErr: () => toKnownErr44
      });
      function toKnownErr44(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestEmailConfirmation_exports = {};
      __export2(requestEmailConfirmation_exports, {
        toKnownErr: () => toKnownErr45
      });
      function toKnownErr45(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestEmailUpdate_exports = {};
      __export2(requestEmailUpdate_exports, {
        toKnownErr: () => toKnownErr46
      });
      function toKnownErr46(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestPasswordReset_exports = {};
      __export2(requestPasswordReset_exports, {
        toKnownErr: () => toKnownErr47
      });
      function toKnownErr47(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var reserveSigningKey_exports = {};
      __export2(reserveSigningKey_exports, {
        toKnownErr: () => toKnownErr48
      });
      function toKnownErr48(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var resetPassword_exports = {};
      __export2(resetPassword_exports, {
        ExpiredTokenError: () => ExpiredTokenError3,
        InvalidTokenError: () => InvalidTokenError3,
        toKnownErr: () => toKnownErr49
      });
      var ExpiredTokenError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidTokenError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr49(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError3(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError3(e);
        }
        return e;
      }
      var revokeAppPassword_exports = {};
      __export2(revokeAppPassword_exports, {
        toKnownErr: () => toKnownErr50
      });
      function toKnownErr50(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateEmail_exports = {};
      __export2(updateEmail_exports, {
        ExpiredTokenError: () => ExpiredTokenError4,
        InvalidTokenError: () => InvalidTokenError4,
        TokenRequiredError: () => TokenRequiredError,
        toKnownErr: () => toKnownErr51
      });
      var ExpiredTokenError4 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidTokenError4 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var TokenRequiredError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr51(e) {
        if (e instanceof XRPCError) {
          if (e.error === "ExpiredToken")
            return new ExpiredTokenError4(e);
          if (e.error === "InvalidToken")
            return new InvalidTokenError4(e);
          if (e.error === "TokenRequired")
            return new TokenRequiredError(e);
        }
        return e;
      }
      var getBlob_exports = {};
      __export2(getBlob_exports, {
        toKnownErr: () => toKnownErr52
      });
      function toKnownErr52(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getBlocks_exports = {};
      __export2(getBlocks_exports, {
        toKnownErr: () => toKnownErr53
      });
      function toKnownErr53(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getCheckout_exports = {};
      __export2(getCheckout_exports, {
        toKnownErr: () => toKnownErr54
      });
      function toKnownErr54(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getHead_exports = {};
      __export2(getHead_exports, {
        HeadNotFoundError: () => HeadNotFoundError,
        toKnownErr: () => toKnownErr55
      });
      var HeadNotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr55(e) {
        if (e instanceof XRPCError) {
          if (e.error === "HeadNotFound")
            return new HeadNotFoundError(e);
        }
        return e;
      }
      var getLatestCommit_exports = {};
      __export2(getLatestCommit_exports, {
        RepoNotFoundError: () => RepoNotFoundError2,
        toKnownErr: () => toKnownErr56
      });
      var RepoNotFoundError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr56(e) {
        if (e instanceof XRPCError) {
          if (e.error === "RepoNotFound")
            return new RepoNotFoundError2(e);
        }
        return e;
      }
      var getRecord_exports3 = {};
      __export2(getRecord_exports3, {
        toKnownErr: () => toKnownErr57
      });
      function toKnownErr57(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRepo_exports2 = {};
      __export2(getRepo_exports2, {
        toKnownErr: () => toKnownErr58
      });
      function toKnownErr58(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listBlobs_exports = {};
      __export2(listBlobs_exports, {
        toKnownErr: () => toKnownErr59
      });
      function toKnownErr59(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listRepos_exports = {};
      __export2(listRepos_exports, {
        isRepo: () => isRepo,
        toKnownErr: () => toKnownErr60,
        validateRepo: () => validateRepo
      });
      function toKnownErr60(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isRepo(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.listRepos#repo";
      }
      function validateRepo(v) {
        return lexicons.validate("com.atproto.sync.listRepos#repo", v);
      }
      var notifyOfUpdate_exports = {};
      __export2(notifyOfUpdate_exports, {
        toKnownErr: () => toKnownErr61
      });
      function toKnownErr61(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var requestCrawl_exports = {};
      __export2(requestCrawl_exports, {
        toKnownErr: () => toKnownErr62
      });
      function toKnownErr62(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var fetchLabels_exports = {};
      __export2(fetchLabels_exports, {
        toKnownErr: () => toKnownErr63
      });
      function toKnownErr63(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var importRepo_exports = {};
      __export2(importRepo_exports, {
        toKnownErr: () => toKnownErr64
      });
      function toKnownErr64(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var pushBlob_exports = {};
      __export2(pushBlob_exports, {
        toKnownErr: () => toKnownErr65
      });
      function toKnownErr65(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var transferAccount_exports = {};
      __export2(transferAccount_exports, {
        HandleNotAvailableError: () => HandleNotAvailableError2,
        IncompatibleDidDocError: () => IncompatibleDidDocError2,
        InvalidHandleError: () => InvalidHandleError3,
        InvalidInviteCodeError: () => InvalidInviteCodeError2,
        InvalidPasswordError: () => InvalidPasswordError2,
        UnresolvableDidError: () => UnresolvableDidError2,
        UnsupportedDomainError: () => UnsupportedDomainError2,
        toKnownErr: () => toKnownErr66
      });
      var InvalidHandleError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidPasswordError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var InvalidInviteCodeError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var HandleNotAvailableError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var UnsupportedDomainError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var UnresolvableDidError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var IncompatibleDidDocError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr66(e) {
        if (e instanceof XRPCError) {
          if (e.error === "InvalidHandle")
            return new InvalidHandleError3(e);
          if (e.error === "InvalidPassword")
            return new InvalidPasswordError2(e);
          if (e.error === "InvalidInviteCode")
            return new InvalidInviteCodeError2(e);
          if (e.error === "HandleNotAvailable")
            return new HandleNotAvailableError2(e);
          if (e.error === "UnsupportedDomain")
            return new UnsupportedDomainError2(e);
          if (e.error === "UnresolvableDid")
            return new UnresolvableDidError2(e);
          if (e.error === "IncompatibleDidDoc")
            return new IncompatibleDidDocError2(e);
        }
        return e;
      }
      var getPreferences_exports = {};
      __export2(getPreferences_exports, {
        toKnownErr: () => toKnownErr67
      });
      function toKnownErr67(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getProfile_exports = {};
      __export2(getProfile_exports, {
        toKnownErr: () => toKnownErr68
      });
      function toKnownErr68(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getProfiles_exports = {};
      __export2(getProfiles_exports, {
        toKnownErr: () => toKnownErr69
      });
      function toKnownErr69(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestions_exports = {};
      __export2(getSuggestions_exports, {
        toKnownErr: () => toKnownErr70
      });
      function toKnownErr70(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var putPreferences_exports = {};
      __export2(putPreferences_exports, {
        toKnownErr: () => toKnownErr71
      });
      function toKnownErr71(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchActors_exports = {};
      __export2(searchActors_exports, {
        toKnownErr: () => toKnownErr72
      });
      function toKnownErr72(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchActorsTypeahead_exports = {};
      __export2(searchActorsTypeahead_exports, {
        toKnownErr: () => toKnownErr73
      });
      function toKnownErr73(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var describeFeedGenerator_exports = {};
      __export2(describeFeedGenerator_exports, {
        isFeed: () => isFeed,
        isLinks: () => isLinks2,
        toKnownErr: () => toKnownErr74,
        validateFeed: () => validateFeed,
        validateLinks: () => validateLinks2
      });
      function toKnownErr74(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isFeed(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.describeFeedGenerator#feed";
      }
      function validateFeed(v) {
        return lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", v);
      }
      function isLinks2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.describeFeedGenerator#links";
      }
      function validateLinks2(v) {
        return lexicons.validate("app.bsky.feed.describeFeedGenerator#links", v);
      }
      var getActorFeeds_exports = {};
      __export2(getActorFeeds_exports, {
        toKnownErr: () => toKnownErr75
      });
      function toKnownErr75(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getActorLikes_exports = {};
      __export2(getActorLikes_exports, {
        BlockedActorError: () => BlockedActorError,
        BlockedByActorError: () => BlockedByActorError,
        toKnownErr: () => toKnownErr76
      });
      var BlockedActorError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var BlockedByActorError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr76(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BlockedActor")
            return new BlockedActorError(e);
          if (e.error === "BlockedByActor")
            return new BlockedByActorError(e);
        }
        return e;
      }
      var getAuthorFeed_exports = {};
      __export2(getAuthorFeed_exports, {
        BlockedActorError: () => BlockedActorError2,
        BlockedByActorError: () => BlockedByActorError2,
        toKnownErr: () => toKnownErr77
      });
      var BlockedActorError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      var BlockedByActorError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr77(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BlockedActor")
            return new BlockedActorError2(e);
          if (e.error === "BlockedByActor")
            return new BlockedByActorError2(e);
        }
        return e;
      }
      var getFeed_exports = {};
      __export2(getFeed_exports, {
        UnknownFeedError: () => UnknownFeedError,
        toKnownErr: () => toKnownErr78
      });
      var UnknownFeedError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr78(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError(e);
        }
        return e;
      }
      var getFeedGenerator_exports = {};
      __export2(getFeedGenerator_exports, {
        toKnownErr: () => toKnownErr79
      });
      function toKnownErr79(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFeedGenerators_exports = {};
      __export2(getFeedGenerators_exports, {
        toKnownErr: () => toKnownErr80
      });
      function toKnownErr80(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFeedSkeleton_exports = {};
      __export2(getFeedSkeleton_exports, {
        UnknownFeedError: () => UnknownFeedError2,
        toKnownErr: () => toKnownErr81
      });
      var UnknownFeedError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr81(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError2(e);
        }
        return e;
      }
      var getLikes_exports = {};
      __export2(getLikes_exports, {
        isLike: () => isLike,
        toKnownErr: () => toKnownErr82,
        validateLike: () => validateLike
      });
      function toKnownErr82(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isLike(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.getLikes#like";
      }
      function validateLike(v) {
        return lexicons.validate("app.bsky.feed.getLikes#like", v);
      }
      var getListFeed_exports = {};
      __export2(getListFeed_exports, {
        UnknownListError: () => UnknownListError,
        toKnownErr: () => toKnownErr83
      });
      var UnknownListError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr83(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownList")
            return new UnknownListError(e);
        }
        return e;
      }
      var getPostThread_exports = {};
      __export2(getPostThread_exports, {
        NotFoundError: () => NotFoundError,
        toKnownErr: () => toKnownErr84
      });
      var NotFoundError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr84(e) {
        if (e instanceof XRPCError) {
          if (e.error === "NotFound")
            return new NotFoundError(e);
        }
        return e;
      }
      var getPosts_exports = {};
      __export2(getPosts_exports, {
        toKnownErr: () => toKnownErr85
      });
      function toKnownErr85(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getRepostedBy_exports = {};
      __export2(getRepostedBy_exports, {
        toKnownErr: () => toKnownErr86
      });
      function toKnownErr86(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestedFeeds_exports = {};
      __export2(getSuggestedFeeds_exports, {
        toKnownErr: () => toKnownErr87
      });
      function toKnownErr87(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getTimeline_exports = {};
      __export2(getTimeline_exports, {
        toKnownErr: () => toKnownErr88
      });
      function toKnownErr88(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var searchPosts_exports = {};
      __export2(searchPosts_exports, {
        BadQueryStringError: () => BadQueryStringError,
        toKnownErr: () => toKnownErr89
      });
      var BadQueryStringError = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr89(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError(e);
        }
        return e;
      }
      var getBlocks_exports2 = {};
      __export2(getBlocks_exports2, {
        toKnownErr: () => toKnownErr90
      });
      function toKnownErr90(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFollowers_exports = {};
      __export2(getFollowers_exports, {
        toKnownErr: () => toKnownErr91
      });
      function toKnownErr91(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getFollows_exports = {};
      __export2(getFollows_exports, {
        toKnownErr: () => toKnownErr92
      });
      function toKnownErr92(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getList_exports = {};
      __export2(getList_exports, {
        toKnownErr: () => toKnownErr93
      });
      function toKnownErr93(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getListBlocks_exports = {};
      __export2(getListBlocks_exports, {
        toKnownErr: () => toKnownErr94
      });
      function toKnownErr94(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getListMutes_exports = {};
      __export2(getListMutes_exports, {
        toKnownErr: () => toKnownErr95
      });
      function toKnownErr95(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getLists_exports = {};
      __export2(getLists_exports, {
        toKnownErr: () => toKnownErr96
      });
      function toKnownErr96(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getMutes_exports = {};
      __export2(getMutes_exports, {
        toKnownErr: () => toKnownErr97
      });
      function toKnownErr97(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getSuggestedFollowsByActor_exports = {};
      __export2(getSuggestedFollowsByActor_exports, {
        toKnownErr: () => toKnownErr98
      });
      function toKnownErr98(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var muteActor_exports = {};
      __export2(muteActor_exports, {
        toKnownErr: () => toKnownErr99
      });
      function toKnownErr99(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var muteActorList_exports = {};
      __export2(muteActorList_exports, {
        toKnownErr: () => toKnownErr100
      });
      function toKnownErr100(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var unmuteActor_exports = {};
      __export2(unmuteActor_exports, {
        toKnownErr: () => toKnownErr101
      });
      function toKnownErr101(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var unmuteActorList_exports = {};
      __export2(unmuteActorList_exports, {
        toKnownErr: () => toKnownErr102
      });
      function toKnownErr102(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getUnreadCount_exports = {};
      __export2(getUnreadCount_exports, {
        toKnownErr: () => toKnownErr103
      });
      function toKnownErr103(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var listNotifications_exports = {};
      __export2(listNotifications_exports, {
        isNotification: () => isNotification,
        toKnownErr: () => toKnownErr104,
        validateNotification: () => validateNotification
      });
      function toKnownErr104(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      function isNotification(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.notification.listNotifications#notification";
      }
      function validateNotification(v) {
        return lexicons.validate("app.bsky.notification.listNotifications#notification", v);
      }
      var registerPush_exports = {};
      __export2(registerPush_exports, {
        toKnownErr: () => toKnownErr105
      });
      function toKnownErr105(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var updateSeen_exports = {};
      __export2(updateSeen_exports, {
        toKnownErr: () => toKnownErr106
      });
      function toKnownErr106(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getPopular_exports = {};
      __export2(getPopular_exports, {
        toKnownErr: () => toKnownErr107
      });
      function toKnownErr107(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getPopularFeedGenerators_exports = {};
      __export2(getPopularFeedGenerators_exports, {
        toKnownErr: () => toKnownErr108
      });
      function toKnownErr108(e) {
        if (e instanceof XRPCError) {
        }
        return e;
      }
      var getTimelineSkeleton_exports = {};
      __export2(getTimelineSkeleton_exports, {
        UnknownFeedError: () => UnknownFeedError3,
        toKnownErr: () => toKnownErr109
      });
      var UnknownFeedError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr109(e) {
        if (e instanceof XRPCError) {
          if (e.error === "UnknownFeed")
            return new UnknownFeedError3(e);
        }
        return e;
      }
      var searchActorsSkeleton_exports = {};
      __export2(searchActorsSkeleton_exports, {
        BadQueryStringError: () => BadQueryStringError2,
        toKnownErr: () => toKnownErr110
      });
      var BadQueryStringError2 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr110(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError2(e);
        }
        return e;
      }
      var searchPostsSkeleton_exports = {};
      __export2(searchPostsSkeleton_exports, {
        BadQueryStringError: () => BadQueryStringError3,
        toKnownErr: () => toKnownErr111
      });
      var BadQueryStringError3 = class extends XRPCError {
        constructor(src22) {
          super(src22.status, src22.error, src22.message, src22.headers);
        }
      };
      function toKnownErr111(e) {
        if (e instanceof XRPCError) {
          if (e.error === "BadQueryString")
            return new BadQueryStringError3(e);
        }
        return e;
      }
      var defs_exports = {};
      __export2(defs_exports, {
        REVIEWCLOSED: () => REVIEWCLOSED,
        REVIEWESCALATED: () => REVIEWESCALATED,
        REVIEWOPEN: () => REVIEWOPEN,
        isAccountView: () => isAccountView,
        isBlobView: () => isBlobView,
        isImageDetails: () => isImageDetails,
        isModEventAcknowledge: () => isModEventAcknowledge,
        isModEventComment: () => isModEventComment,
        isModEventEmail: () => isModEventEmail,
        isModEventEscalate: () => isModEventEscalate,
        isModEventLabel: () => isModEventLabel,
        isModEventMute: () => isModEventMute,
        isModEventReport: () => isModEventReport,
        isModEventResolveAppeal: () => isModEventResolveAppeal,
        isModEventReverseTakedown: () => isModEventReverseTakedown,
        isModEventTakedown: () => isModEventTakedown,
        isModEventUnmute: () => isModEventUnmute,
        isModEventView: () => isModEventView,
        isModEventViewDetail: () => isModEventViewDetail,
        isModeration: () => isModeration,
        isModerationDetail: () => isModerationDetail,
        isRecordView: () => isRecordView,
        isRecordViewDetail: () => isRecordViewDetail,
        isRecordViewNotFound: () => isRecordViewNotFound,
        isRepoBlobRef: () => isRepoBlobRef,
        isRepoRef: () => isRepoRef,
        isRepoView: () => isRepoView,
        isRepoViewDetail: () => isRepoViewDetail,
        isRepoViewNotFound: () => isRepoViewNotFound,
        isReportView: () => isReportView,
        isReportViewDetail: () => isReportViewDetail,
        isStatusAttr: () => isStatusAttr,
        isSubjectStatusView: () => isSubjectStatusView,
        isVideoDetails: () => isVideoDetails,
        validateAccountView: () => validateAccountView,
        validateBlobView: () => validateBlobView,
        validateImageDetails: () => validateImageDetails,
        validateModEventAcknowledge: () => validateModEventAcknowledge,
        validateModEventComment: () => validateModEventComment,
        validateModEventEmail: () => validateModEventEmail,
        validateModEventEscalate: () => validateModEventEscalate,
        validateModEventLabel: () => validateModEventLabel,
        validateModEventMute: () => validateModEventMute,
        validateModEventReport: () => validateModEventReport,
        validateModEventResolveAppeal: () => validateModEventResolveAppeal,
        validateModEventReverseTakedown: () => validateModEventReverseTakedown,
        validateModEventTakedown: () => validateModEventTakedown,
        validateModEventUnmute: () => validateModEventUnmute,
        validateModEventView: () => validateModEventView,
        validateModEventViewDetail: () => validateModEventViewDetail,
        validateModeration: () => validateModeration,
        validateModerationDetail: () => validateModerationDetail,
        validateRecordView: () => validateRecordView,
        validateRecordViewDetail: () => validateRecordViewDetail,
        validateRecordViewNotFound: () => validateRecordViewNotFound,
        validateRepoBlobRef: () => validateRepoBlobRef,
        validateRepoRef: () => validateRepoRef,
        validateRepoView: () => validateRepoView,
        validateRepoViewDetail: () => validateRepoViewDetail,
        validateRepoViewNotFound: () => validateRepoViewNotFound,
        validateReportView: () => validateReportView,
        validateReportViewDetail: () => validateReportViewDetail,
        validateStatusAttr: () => validateStatusAttr,
        validateSubjectStatusView: () => validateSubjectStatusView,
        validateVideoDetails: () => validateVideoDetails
      });
      function isStatusAttr(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#statusAttr";
      }
      function validateStatusAttr(v) {
        return lexicons.validate("com.atproto.admin.defs#statusAttr", v);
      }
      function isModEventView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventView";
      }
      function validateModEventView(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventView", v);
      }
      function isModEventViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventViewDetail";
      }
      function validateModEventViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventViewDetail", v);
      }
      function isReportView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#reportView";
      }
      function validateReportView(v) {
        return lexicons.validate("com.atproto.admin.defs#reportView", v);
      }
      function isSubjectStatusView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#subjectStatusView";
      }
      function validateSubjectStatusView(v) {
        return lexicons.validate("com.atproto.admin.defs#subjectStatusView", v);
      }
      function isReportViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#reportViewDetail";
      }
      function validateReportViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#reportViewDetail", v);
      }
      function isRepoView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoView";
      }
      function validateRepoView(v) {
        return lexicons.validate("com.atproto.admin.defs#repoView", v);
      }
      function isRepoViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoViewDetail";
      }
      function validateRepoViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#repoViewDetail", v);
      }
      function isAccountView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#accountView";
      }
      function validateAccountView(v) {
        return lexicons.validate("com.atproto.admin.defs#accountView", v);
      }
      function isRepoViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoViewNotFound";
      }
      function validateRepoViewNotFound(v) {
        return lexicons.validate("com.atproto.admin.defs#repoViewNotFound", v);
      }
      function isRepoRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoRef";
      }
      function validateRepoRef(v) {
        return lexicons.validate("com.atproto.admin.defs#repoRef", v);
      }
      function isRepoBlobRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#repoBlobRef";
      }
      function validateRepoBlobRef(v) {
        return lexicons.validate("com.atproto.admin.defs#repoBlobRef", v);
      }
      function isRecordView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordView";
      }
      function validateRecordView(v) {
        return lexicons.validate("com.atproto.admin.defs#recordView", v);
      }
      function isRecordViewDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordViewDetail";
      }
      function validateRecordViewDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#recordViewDetail", v);
      }
      function isRecordViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#recordViewNotFound";
      }
      function validateRecordViewNotFound(v) {
        return lexicons.validate("com.atproto.admin.defs#recordViewNotFound", v);
      }
      function isModeration(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#moderation";
      }
      function validateModeration(v) {
        return lexicons.validate("com.atproto.admin.defs#moderation", v);
      }
      function isModerationDetail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#moderationDetail";
      }
      function validateModerationDetail(v) {
        return lexicons.validate("com.atproto.admin.defs#moderationDetail", v);
      }
      function isBlobView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#blobView";
      }
      function validateBlobView(v) {
        return lexicons.validate("com.atproto.admin.defs#blobView", v);
      }
      function isImageDetails(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#imageDetails";
      }
      function validateImageDetails(v) {
        return lexicons.validate("com.atproto.admin.defs#imageDetails", v);
      }
      function isVideoDetails(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#videoDetails";
      }
      function validateVideoDetails(v) {
        return lexicons.validate("com.atproto.admin.defs#videoDetails", v);
      }
      var REVIEWOPEN = "com.atproto.admin.defs#reviewOpen";
      var REVIEWESCALATED = "com.atproto.admin.defs#reviewEscalated";
      var REVIEWCLOSED = "com.atproto.admin.defs#reviewClosed";
      function isModEventTakedown(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventTakedown";
      }
      function validateModEventTakedown(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventTakedown", v);
      }
      function isModEventReverseTakedown(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventReverseTakedown";
      }
      function validateModEventReverseTakedown(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventReverseTakedown", v);
      }
      function isModEventResolveAppeal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventResolveAppeal";
      }
      function validateModEventResolveAppeal(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventResolveAppeal", v);
      }
      function isModEventComment(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventComment";
      }
      function validateModEventComment(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventComment", v);
      }
      function isModEventReport(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventReport";
      }
      function validateModEventReport(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventReport", v);
      }
      function isModEventLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventLabel";
      }
      function validateModEventLabel(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventLabel", v);
      }
      function isModEventAcknowledge(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventAcknowledge";
      }
      function validateModEventAcknowledge(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventAcknowledge", v);
      }
      function isModEventEscalate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventEscalate";
      }
      function validateModEventEscalate(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventEscalate", v);
      }
      function isModEventMute(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventMute";
      }
      function validateModEventMute(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventMute", v);
      }
      function isModEventUnmute(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventUnmute";
      }
      function validateModEventUnmute(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventUnmute", v);
      }
      function isModEventEmail(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.admin.defs#modEventEmail";
      }
      function validateModEventEmail(v) {
        return lexicons.validate("com.atproto.admin.defs#modEventEmail", v);
      }
      var defs_exports2 = {};
      __export2(defs_exports2, {
        isLabel: () => isLabel,
        isSelfLabel: () => isSelfLabel,
        isSelfLabels: () => isSelfLabels,
        validateLabel: () => validateLabel,
        validateSelfLabel: () => validateSelfLabel,
        validateSelfLabels: () => validateSelfLabels
      });
      function isLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#label";
      }
      function validateLabel(v) {
        return lexicons.validate("com.atproto.label.defs#label", v);
      }
      function isSelfLabels(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#selfLabels";
      }
      function validateSelfLabels(v) {
        return lexicons.validate("com.atproto.label.defs#selfLabels", v);
      }
      function isSelfLabel(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.defs#selfLabel";
      }
      function validateSelfLabel(v) {
        return lexicons.validate("com.atproto.label.defs#selfLabel", v);
      }
      var subscribeLabels_exports = {};
      __export2(subscribeLabels_exports, {
        isInfo: () => isInfo,
        isLabels: () => isLabels,
        validateInfo: () => validateInfo,
        validateLabels: () => validateLabels
      });
      function isLabels(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.subscribeLabels#labels";
      }
      function validateLabels(v) {
        return lexicons.validate("com.atproto.label.subscribeLabels#labels", v);
      }
      function isInfo(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.label.subscribeLabels#info";
      }
      function validateInfo(v) {
        return lexicons.validate("com.atproto.label.subscribeLabels#info", v);
      }
      var defs_exports3 = {};
      __export2(defs_exports3, {
        REASONAPPEAL: () => REASONAPPEAL,
        REASONMISLEADING: () => REASONMISLEADING,
        REASONOTHER: () => REASONOTHER,
        REASONRUDE: () => REASONRUDE,
        REASONSEXUAL: () => REASONSEXUAL,
        REASONSPAM: () => REASONSPAM,
        REASONVIOLATION: () => REASONVIOLATION
      });
      var REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
      var REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
      var REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
      var REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
      var REASONRUDE = "com.atproto.moderation.defs#reasonRude";
      var REASONOTHER = "com.atproto.moderation.defs#reasonOther";
      var REASONAPPEAL = "com.atproto.moderation.defs#reasonAppeal";
      var strongRef_exports = {};
      __export2(strongRef_exports, {
        isMain: () => isMain,
        validateMain: () => validateMain
      });
      function isMain(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "com.atproto.repo.strongRef#main" || v.$type === "com.atproto.repo.strongRef");
      }
      function validateMain(v) {
        return lexicons.validate("com.atproto.repo.strongRef#main", v);
      }
      var defs_exports4 = {};
      __export2(defs_exports4, {
        isInviteCode: () => isInviteCode,
        isInviteCodeUse: () => isInviteCodeUse,
        validateInviteCode: () => validateInviteCode,
        validateInviteCodeUse: () => validateInviteCodeUse
      });
      function isInviteCode(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.defs#inviteCode";
      }
      function validateInviteCode(v) {
        return lexicons.validate("com.atproto.server.defs#inviteCode", v);
      }
      function isInviteCodeUse(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.server.defs#inviteCodeUse";
      }
      function validateInviteCodeUse(v) {
        return lexicons.validate("com.atproto.server.defs#inviteCodeUse", v);
      }
      var subscribeRepos_exports = {};
      __export2(subscribeRepos_exports, {
        isCommit: () => isCommit,
        isHandle: () => isHandle,
        isInfo: () => isInfo2,
        isMigrate: () => isMigrate,
        isRepoOp: () => isRepoOp,
        isTombstone: () => isTombstone,
        validateCommit: () => validateCommit,
        validateHandle: () => validateHandle,
        validateInfo: () => validateInfo2,
        validateMigrate: () => validateMigrate,
        validateRepoOp: () => validateRepoOp,
        validateTombstone: () => validateTombstone
      });
      function isCommit(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#commit";
      }
      function validateCommit(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#commit", v);
      }
      function isHandle(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#handle";
      }
      function validateHandle(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#handle", v);
      }
      function isMigrate(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#migrate";
      }
      function validateMigrate(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#migrate", v);
      }
      function isTombstone(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#tombstone";
      }
      function validateTombstone(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", v);
      }
      function isInfo2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#info";
      }
      function validateInfo2(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#info", v);
      }
      function isRepoOp(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "com.atproto.sync.subscribeRepos#repoOp";
      }
      function validateRepoOp(v) {
        return lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", v);
      }
      var defs_exports5 = {};
      __export2(defs_exports5, {
        isAdultContentPref: () => isAdultContentPref,
        isContentLabelPref: () => isContentLabelPref,
        isFeedViewPref: () => isFeedViewPref,
        isPersonalDetailsPref: () => isPersonalDetailsPref,
        isProfileView: () => isProfileView,
        isProfileViewBasic: () => isProfileViewBasic,
        isProfileViewDetailed: () => isProfileViewDetailed,
        isSavedFeedsPref: () => isSavedFeedsPref,
        isThreadViewPref: () => isThreadViewPref,
        isViewerState: () => isViewerState,
        validateAdultContentPref: () => validateAdultContentPref,
        validateContentLabelPref: () => validateContentLabelPref,
        validateFeedViewPref: () => validateFeedViewPref,
        validatePersonalDetailsPref: () => validatePersonalDetailsPref,
        validateProfileView: () => validateProfileView,
        validateProfileViewBasic: () => validateProfileViewBasic,
        validateProfileViewDetailed: () => validateProfileViewDetailed,
        validateSavedFeedsPref: () => validateSavedFeedsPref,
        validateThreadViewPref: () => validateThreadViewPref,
        validateViewerState: () => validateViewerState
      });
      function isProfileViewBasic(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileViewBasic";
      }
      function validateProfileViewBasic(v) {
        return lexicons.validate("app.bsky.actor.defs#profileViewBasic", v);
      }
      function isProfileView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileView";
      }
      function validateProfileView(v) {
        return lexicons.validate("app.bsky.actor.defs#profileView", v);
      }
      function isProfileViewDetailed(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#profileViewDetailed";
      }
      function validateProfileViewDetailed(v) {
        return lexicons.validate("app.bsky.actor.defs#profileViewDetailed", v);
      }
      function isViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#viewerState";
      }
      function validateViewerState(v) {
        return lexicons.validate("app.bsky.actor.defs#viewerState", v);
      }
      function isAdultContentPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#adultContentPref";
      }
      function validateAdultContentPref(v) {
        return lexicons.validate("app.bsky.actor.defs#adultContentPref", v);
      }
      function isContentLabelPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#contentLabelPref";
      }
      function validateContentLabelPref(v) {
        return lexicons.validate("app.bsky.actor.defs#contentLabelPref", v);
      }
      function isSavedFeedsPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#savedFeedsPref";
      }
      function validateSavedFeedsPref(v) {
        return lexicons.validate("app.bsky.actor.defs#savedFeedsPref", v);
      }
      function isPersonalDetailsPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#personalDetailsPref";
      }
      function validatePersonalDetailsPref(v) {
        return lexicons.validate("app.bsky.actor.defs#personalDetailsPref", v);
      }
      function isFeedViewPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#feedViewPref";
      }
      function validateFeedViewPref(v) {
        return lexicons.validate("app.bsky.actor.defs#feedViewPref", v);
      }
      function isThreadViewPref(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.actor.defs#threadViewPref";
      }
      function validateThreadViewPref(v) {
        return lexicons.validate("app.bsky.actor.defs#threadViewPref", v);
      }
      var profile_exports = {};
      __export2(profile_exports, {
        isRecord: () => isRecord2,
        validateRecord: () => validateRecord2
      });
      function isRecord2(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.actor.profile#main" || v.$type === "app.bsky.actor.profile");
      }
      function validateRecord2(v) {
        return lexicons.validate("app.bsky.actor.profile#main", v);
      }
      var external_exports = {};
      __export2(external_exports, {
        isExternal: () => isExternal,
        isMain: () => isMain2,
        isView: () => isView,
        isViewExternal: () => isViewExternal,
        validateExternal: () => validateExternal,
        validateMain: () => validateMain2,
        validateView: () => validateView,
        validateViewExternal: () => validateViewExternal
      });
      function isMain2(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.external#main" || v.$type === "app.bsky.embed.external");
      }
      function validateMain2(v) {
        return lexicons.validate("app.bsky.embed.external#main", v);
      }
      function isExternal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#external";
      }
      function validateExternal(v) {
        return lexicons.validate("app.bsky.embed.external#external", v);
      }
      function isView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#view";
      }
      function validateView(v) {
        return lexicons.validate("app.bsky.embed.external#view", v);
      }
      function isViewExternal(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.external#viewExternal";
      }
      function validateViewExternal(v) {
        return lexicons.validate("app.bsky.embed.external#viewExternal", v);
      }
      var images_exports = {};
      __export2(images_exports, {
        isAspectRatio: () => isAspectRatio,
        isImage: () => isImage,
        isMain: () => isMain3,
        isView: () => isView2,
        isViewImage: () => isViewImage,
        validateAspectRatio: () => validateAspectRatio,
        validateImage: () => validateImage,
        validateMain: () => validateMain3,
        validateView: () => validateView2,
        validateViewImage: () => validateViewImage
      });
      function isMain3(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.images#main" || v.$type === "app.bsky.embed.images");
      }
      function validateMain3(v) {
        return lexicons.validate("app.bsky.embed.images#main", v);
      }
      function isImage(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#image";
      }
      function validateImage(v) {
        return lexicons.validate("app.bsky.embed.images#image", v);
      }
      function isAspectRatio(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#aspectRatio";
      }
      function validateAspectRatio(v) {
        return lexicons.validate("app.bsky.embed.images#aspectRatio", v);
      }
      function isView2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#view";
      }
      function validateView2(v) {
        return lexicons.validate("app.bsky.embed.images#view", v);
      }
      function isViewImage(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.images#viewImage";
      }
      function validateViewImage(v) {
        return lexicons.validate("app.bsky.embed.images#viewImage", v);
      }
      var record_exports = {};
      __export2(record_exports, {
        isMain: () => isMain4,
        isView: () => isView3,
        isViewBlocked: () => isViewBlocked,
        isViewNotFound: () => isViewNotFound,
        isViewRecord: () => isViewRecord,
        validateMain: () => validateMain4,
        validateView: () => validateView3,
        validateViewBlocked: () => validateViewBlocked,
        validateViewNotFound: () => validateViewNotFound,
        validateViewRecord: () => validateViewRecord
      });
      function isMain4(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.record#main" || v.$type === "app.bsky.embed.record");
      }
      function validateMain4(v) {
        return lexicons.validate("app.bsky.embed.record#main", v);
      }
      function isView3(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#view";
      }
      function validateView3(v) {
        return lexicons.validate("app.bsky.embed.record#view", v);
      }
      function isViewRecord(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewRecord";
      }
      function validateViewRecord(v) {
        return lexicons.validate("app.bsky.embed.record#viewRecord", v);
      }
      function isViewNotFound(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewNotFound";
      }
      function validateViewNotFound(v) {
        return lexicons.validate("app.bsky.embed.record#viewNotFound", v);
      }
      function isViewBlocked(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.record#viewBlocked";
      }
      function validateViewBlocked(v) {
        return lexicons.validate("app.bsky.embed.record#viewBlocked", v);
      }
      var recordWithMedia_exports = {};
      __export2(recordWithMedia_exports, {
        isMain: () => isMain5,
        isView: () => isView4,
        validateMain: () => validateMain5,
        validateView: () => validateView4
      });
      function isMain5(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.embed.recordWithMedia#main" || v.$type === "app.bsky.embed.recordWithMedia");
      }
      function validateMain5(v) {
        return lexicons.validate("app.bsky.embed.recordWithMedia#main", v);
      }
      function isView4(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.embed.recordWithMedia#view";
      }
      function validateView4(v) {
        return lexicons.validate("app.bsky.embed.recordWithMedia#view", v);
      }
      var defs_exports6 = {};
      __export2(defs_exports6, {
        isBlockedAuthor: () => isBlockedAuthor,
        isBlockedPost: () => isBlockedPost,
        isFeedViewPost: () => isFeedViewPost,
        isGeneratorView: () => isGeneratorView,
        isGeneratorViewerState: () => isGeneratorViewerState,
        isNotFoundPost: () => isNotFoundPost,
        isPostView: () => isPostView,
        isReasonRepost: () => isReasonRepost,
        isReplyRef: () => isReplyRef,
        isSkeletonFeedPost: () => isSkeletonFeedPost,
        isSkeletonReasonRepost: () => isSkeletonReasonRepost,
        isThreadViewPost: () => isThreadViewPost,
        isThreadgateView: () => isThreadgateView,
        isViewerState: () => isViewerState2,
        validateBlockedAuthor: () => validateBlockedAuthor,
        validateBlockedPost: () => validateBlockedPost,
        validateFeedViewPost: () => validateFeedViewPost,
        validateGeneratorView: () => validateGeneratorView,
        validateGeneratorViewerState: () => validateGeneratorViewerState,
        validateNotFoundPost: () => validateNotFoundPost,
        validatePostView: () => validatePostView,
        validateReasonRepost: () => validateReasonRepost,
        validateReplyRef: () => validateReplyRef,
        validateSkeletonFeedPost: () => validateSkeletonFeedPost,
        validateSkeletonReasonRepost: () => validateSkeletonReasonRepost,
        validateThreadViewPost: () => validateThreadViewPost,
        validateThreadgateView: () => validateThreadgateView,
        validateViewerState: () => validateViewerState2
      });
      function isPostView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#postView";
      }
      function validatePostView(v) {
        return lexicons.validate("app.bsky.feed.defs#postView", v);
      }
      function isViewerState2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#viewerState";
      }
      function validateViewerState2(v) {
        return lexicons.validate("app.bsky.feed.defs#viewerState", v);
      }
      function isFeedViewPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#feedViewPost";
      }
      function validateFeedViewPost(v) {
        return lexicons.validate("app.bsky.feed.defs#feedViewPost", v);
      }
      function isReplyRef(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#replyRef";
      }
      function validateReplyRef(v) {
        return lexicons.validate("app.bsky.feed.defs#replyRef", v);
      }
      function isReasonRepost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#reasonRepost";
      }
      function validateReasonRepost(v) {
        return lexicons.validate("app.bsky.feed.defs#reasonRepost", v);
      }
      function isThreadViewPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#threadViewPost";
      }
      function validateThreadViewPost(v) {
        return lexicons.validate("app.bsky.feed.defs#threadViewPost", v);
      }
      function isNotFoundPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#notFoundPost";
      }
      function validateNotFoundPost(v) {
        return lexicons.validate("app.bsky.feed.defs#notFoundPost", v);
      }
      function isBlockedPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#blockedPost";
      }
      function validateBlockedPost(v) {
        return lexicons.validate("app.bsky.feed.defs#blockedPost", v);
      }
      function isBlockedAuthor(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#blockedAuthor";
      }
      function validateBlockedAuthor(v) {
        return lexicons.validate("app.bsky.feed.defs#blockedAuthor", v);
      }
      function isGeneratorView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#generatorView";
      }
      function validateGeneratorView(v) {
        return lexicons.validate("app.bsky.feed.defs#generatorView", v);
      }
      function isGeneratorViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#generatorViewerState";
      }
      function validateGeneratorViewerState(v) {
        return lexicons.validate("app.bsky.feed.defs#generatorViewerState", v);
      }
      function isSkeletonFeedPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#skeletonFeedPost";
      }
      function validateSkeletonFeedPost(v) {
        return lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", v);
      }
      function isSkeletonReasonRepost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#skeletonReasonRepost";
      }
      function validateSkeletonReasonRepost(v) {
        return lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", v);
      }
      function isThreadgateView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.defs#threadgateView";
      }
      function validateThreadgateView(v) {
        return lexicons.validate("app.bsky.feed.defs#threadgateView", v);
      }
      var generator_exports = {};
      __export2(generator_exports, {
        isRecord: () => isRecord3,
        validateRecord: () => validateRecord3
      });
      function isRecord3(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.generator#main" || v.$type === "app.bsky.feed.generator");
      }
      function validateRecord3(v) {
        return lexicons.validate("app.bsky.feed.generator#main", v);
      }
      var like_exports = {};
      __export2(like_exports, {
        isRecord: () => isRecord4,
        validateRecord: () => validateRecord4
      });
      function isRecord4(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.like#main" || v.$type === "app.bsky.feed.like");
      }
      function validateRecord4(v) {
        return lexicons.validate("app.bsky.feed.like#main", v);
      }
      var post_exports = {};
      __export2(post_exports, {
        isEntity: () => isEntity,
        isRecord: () => isRecord5,
        isReplyRef: () => isReplyRef2,
        isTextSlice: () => isTextSlice,
        validateEntity: () => validateEntity,
        validateRecord: () => validateRecord5,
        validateReplyRef: () => validateReplyRef2,
        validateTextSlice: () => validateTextSlice
      });
      function isRecord5(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.post#main" || v.$type === "app.bsky.feed.post");
      }
      function validateRecord5(v) {
        return lexicons.validate("app.bsky.feed.post#main", v);
      }
      function isReplyRef2(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#replyRef";
      }
      function validateReplyRef2(v) {
        return lexicons.validate("app.bsky.feed.post#replyRef", v);
      }
      function isEntity(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#entity";
      }
      function validateEntity(v) {
        return lexicons.validate("app.bsky.feed.post#entity", v);
      }
      function isTextSlice(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.post#textSlice";
      }
      function validateTextSlice(v) {
        return lexicons.validate("app.bsky.feed.post#textSlice", v);
      }
      var repost_exports = {};
      __export2(repost_exports, {
        isRecord: () => isRecord6,
        validateRecord: () => validateRecord6
      });
      function isRecord6(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.repost#main" || v.$type === "app.bsky.feed.repost");
      }
      function validateRecord6(v) {
        return lexicons.validate("app.bsky.feed.repost#main", v);
      }
      var threadgate_exports = {};
      __export2(threadgate_exports, {
        isFollowingRule: () => isFollowingRule,
        isListRule: () => isListRule,
        isMentionRule: () => isMentionRule,
        isRecord: () => isRecord7,
        validateFollowingRule: () => validateFollowingRule,
        validateListRule: () => validateListRule,
        validateMentionRule: () => validateMentionRule,
        validateRecord: () => validateRecord7
      });
      function isRecord7(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.feed.threadgate#main" || v.$type === "app.bsky.feed.threadgate");
      }
      function validateRecord7(v) {
        return lexicons.validate("app.bsky.feed.threadgate#main", v);
      }
      function isMentionRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#mentionRule";
      }
      function validateMentionRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#mentionRule", v);
      }
      function isFollowingRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#followingRule";
      }
      function validateFollowingRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#followingRule", v);
      }
      function isListRule(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.feed.threadgate#listRule";
      }
      function validateListRule(v) {
        return lexicons.validate("app.bsky.feed.threadgate#listRule", v);
      }
      var block_exports = {};
      __export2(block_exports, {
        isRecord: () => isRecord8,
        validateRecord: () => validateRecord8
      });
      function isRecord8(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.block#main" || v.$type === "app.bsky.graph.block");
      }
      function validateRecord8(v) {
        return lexicons.validate("app.bsky.graph.block#main", v);
      }
      var defs_exports7 = {};
      __export2(defs_exports7, {
        CURATELIST: () => CURATELIST,
        MODLIST: () => MODLIST,
        isListItemView: () => isListItemView,
        isListView: () => isListView,
        isListViewBasic: () => isListViewBasic,
        isListViewerState: () => isListViewerState,
        validateListItemView: () => validateListItemView,
        validateListView: () => validateListView,
        validateListViewBasic: () => validateListViewBasic,
        validateListViewerState: () => validateListViewerState
      });
      function isListViewBasic(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listViewBasic";
      }
      function validateListViewBasic(v) {
        return lexicons.validate("app.bsky.graph.defs#listViewBasic", v);
      }
      function isListView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listView";
      }
      function validateListView(v) {
        return lexicons.validate("app.bsky.graph.defs#listView", v);
      }
      function isListItemView(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listItemView";
      }
      function validateListItemView(v) {
        return lexicons.validate("app.bsky.graph.defs#listItemView", v);
      }
      var MODLIST = "app.bsky.graph.defs#modlist";
      var CURATELIST = "app.bsky.graph.defs#curatelist";
      function isListViewerState(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.graph.defs#listViewerState";
      }
      function validateListViewerState(v) {
        return lexicons.validate("app.bsky.graph.defs#listViewerState", v);
      }
      var follow_exports = {};
      __export2(follow_exports, {
        isRecord: () => isRecord9,
        validateRecord: () => validateRecord9
      });
      function isRecord9(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.follow#main" || v.$type === "app.bsky.graph.follow");
      }
      function validateRecord9(v) {
        return lexicons.validate("app.bsky.graph.follow#main", v);
      }
      var list_exports = {};
      __export2(list_exports, {
        isRecord: () => isRecord10,
        validateRecord: () => validateRecord10
      });
      function isRecord10(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.list#main" || v.$type === "app.bsky.graph.list");
      }
      function validateRecord10(v) {
        return lexicons.validate("app.bsky.graph.list#main", v);
      }
      var listblock_exports = {};
      __export2(listblock_exports, {
        isRecord: () => isRecord11,
        validateRecord: () => validateRecord11
      });
      function isRecord11(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.listblock#main" || v.$type === "app.bsky.graph.listblock");
      }
      function validateRecord11(v) {
        return lexicons.validate("app.bsky.graph.listblock#main", v);
      }
      var listitem_exports = {};
      __export2(listitem_exports, {
        isRecord: () => isRecord12,
        validateRecord: () => validateRecord12
      });
      function isRecord12(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.graph.listitem#main" || v.$type === "app.bsky.graph.listitem");
      }
      function validateRecord12(v) {
        return lexicons.validate("app.bsky.graph.listitem#main", v);
      }
      var facet_exports = {};
      __export2(facet_exports, {
        isByteSlice: () => isByteSlice,
        isLink: () => isLink,
        isMain: () => isMain6,
        isMention: () => isMention,
        isTag: () => isTag,
        validateByteSlice: () => validateByteSlice,
        validateLink: () => validateLink,
        validateMain: () => validateMain6,
        validateMention: () => validateMention,
        validateTag: () => validateTag
      });
      function isMain6(v) {
        return isObj2(v) && hasProp2(v, "$type") && (v.$type === "app.bsky.richtext.facet#main" || v.$type === "app.bsky.richtext.facet");
      }
      function validateMain6(v) {
        return lexicons.validate("app.bsky.richtext.facet#main", v);
      }
      function isMention(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#mention";
      }
      function validateMention(v) {
        return lexicons.validate("app.bsky.richtext.facet#mention", v);
      }
      function isLink(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#link";
      }
      function validateLink(v) {
        return lexicons.validate("app.bsky.richtext.facet#link", v);
      }
      function isTag(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#tag";
      }
      function validateTag(v) {
        return lexicons.validate("app.bsky.richtext.facet#tag", v);
      }
      function isByteSlice(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.richtext.facet#byteSlice";
      }
      function validateByteSlice(v) {
        return lexicons.validate("app.bsky.richtext.facet#byteSlice", v);
      }
      var defs_exports8 = {};
      __export2(defs_exports8, {
        isSkeletonSearchActor: () => isSkeletonSearchActor,
        isSkeletonSearchPost: () => isSkeletonSearchPost,
        validateSkeletonSearchActor: () => validateSkeletonSearchActor,
        validateSkeletonSearchPost: () => validateSkeletonSearchPost
      });
      function isSkeletonSearchPost(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
      }
      function validateSkeletonSearchPost(v) {
        return lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", v);
      }
      function isSkeletonSearchActor(v) {
        return isObj2(v) && hasProp2(v, "$type") && v.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
      }
      function validateSkeletonSearchActor(v) {
        return lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", v);
      }
      var COM_ATPROTO_ADMIN = {
        DefsReviewOpen: "com.atproto.admin.defs#reviewOpen",
        DefsReviewEscalated: "com.atproto.admin.defs#reviewEscalated",
        DefsReviewClosed: "com.atproto.admin.defs#reviewClosed"
      };
      var COM_ATPROTO_MODERATION = {
        DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
        DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
        DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
        DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
        DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
        DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
        DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
      };
      var APP_BSKY_GRAPH = {
        DefsModlist: "app.bsky.graph.defs#modlist",
        DefsCuratelist: "app.bsky.graph.defs#curatelist"
      };
      var AtpBaseClient = class {
        constructor() {
          this.xrpc = new Client();
          this.xrpc.addLexicons(schemas);
        }
        service(serviceUri) {
          return new AtpServiceClient(this, this.xrpc.service(serviceUri));
        }
      };
      var AtpServiceClient = class {
        constructor(baseClient, xrpcService) {
          this._baseClient = baseClient;
          this.xrpc = xrpcService;
          this.com = new ComNS(this);
          this.app = new AppNS(this);
        }
        setHeader(key, value) {
          this.xrpc.setHeader(key, value);
        }
      };
      var ComNS = class {
        constructor(service2) {
          this._service = service2;
          this.atproto = new AtprotoNS(service2);
        }
      };
      var AtprotoNS = class {
        constructor(service2) {
          this._service = service2;
          this.admin = new AdminNS(service2);
          this.identity = new IdentityNS(service2);
          this.label = new LabelNS(service2);
          this.moderation = new ModerationNS(service2);
          this.repo = new RepoNS(service2);
          this.server = new ServerNS(service2);
          this.sync = new SyncNS(service2);
          this.temp = new TempNS(service2);
        }
      };
      var AdminNS = class {
        constructor(service2) {
          this._service = service2;
        }
        deleteAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.deleteAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr(e);
          });
        }
        disableAccountInvites(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr2(e);
          });
        }
        disableInviteCodes(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr3(e);
          });
        }
        emitModerationEvent(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.emitModerationEvent", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr4(e);
          });
        }
        enableAccountInvites(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr5(e);
          });
        }
        getAccountInfo(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getAccountInfo", params2, void 0, opts).catch((e) => {
            throw toKnownErr6(e);
          });
        }
        getInviteCodes(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getInviteCodes", params2, void 0, opts).catch((e) => {
            throw toKnownErr7(e);
          });
        }
        getModerationEvent(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getModerationEvent", params2, void 0, opts).catch((e) => {
            throw toKnownErr8(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr9(e);
          });
        }
        getRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr10(e);
          });
        }
        getSubjectStatus(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", params2, void 0, opts).catch((e) => {
            throw toKnownErr11(e);
          });
        }
        queryModerationEvents(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.queryModerationEvents", params2, void 0, opts).catch((e) => {
            throw toKnownErr12(e);
          });
        }
        queryModerationStatuses(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.queryModerationStatuses", params2, void 0, opts).catch((e) => {
            throw toKnownErr13(e);
          });
        }
        searchRepos(params2, opts) {
          return this._service.xrpc.call("com.atproto.admin.searchRepos", params2, void 0, opts).catch((e) => {
            throw toKnownErr14(e);
          });
        }
        sendEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.sendEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr15(e);
          });
        }
        updateAccountEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr16(e);
          });
        }
        updateAccountHandle(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr17(e);
          });
        }
        updateSubjectStatus(data, opts) {
          return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr18(e);
          });
        }
      };
      var IdentityNS = class {
        constructor(service2) {
          this._service = service2;
        }
        resolveHandle(params2, opts) {
          return this._service.xrpc.call("com.atproto.identity.resolveHandle", params2, void 0, opts).catch((e) => {
            throw toKnownErr19(e);
          });
        }
        updateHandle(data, opts) {
          return this._service.xrpc.call("com.atproto.identity.updateHandle", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr20(e);
          });
        }
      };
      var LabelNS = class {
        constructor(service2) {
          this._service = service2;
        }
        queryLabels(params2, opts) {
          return this._service.xrpc.call("com.atproto.label.queryLabels", params2, void 0, opts).catch((e) => {
            throw toKnownErr21(e);
          });
        }
      };
      var ModerationNS = class {
        constructor(service2) {
          this._service = service2;
        }
        createReport(data, opts) {
          return this._service.xrpc.call("com.atproto.moderation.createReport", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr22(e);
          });
        }
      };
      var RepoNS = class {
        constructor(service2) {
          this._service = service2;
        }
        applyWrites(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.applyWrites", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr23(e);
          });
        }
        createRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.createRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr24(e);
          });
        }
        deleteRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.deleteRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr25(e);
          });
        }
        describeRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.describeRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr26(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr27(e);
          });
        }
        listRecords(params2, opts) {
          return this._service.xrpc.call("com.atproto.repo.listRecords", params2, void 0, opts).catch((e) => {
            throw toKnownErr28(e);
          });
        }
        putRecord(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.putRecord", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr29(e);
          });
        }
        uploadBlob(data, opts) {
          return this._service.xrpc.call("com.atproto.repo.uploadBlob", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr30(e);
          });
        }
      };
      var ServerNS = class {
        constructor(service2) {
          this._service = service2;
        }
        confirmEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.server.confirmEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr31(e);
          });
        }
        createAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr32(e);
          });
        }
        createAppPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createAppPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr33(e);
          });
        }
        createInviteCode(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createInviteCode", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr34(e);
          });
        }
        createInviteCodes(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createInviteCodes", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr35(e);
          });
        }
        createSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.createSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr36(e);
          });
        }
        deleteAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.server.deleteAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr37(e);
          });
        }
        deleteSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.deleteSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr38(e);
          });
        }
        describeServer(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.describeServer", params2, void 0, opts).catch((e) => {
            throw toKnownErr39(e);
          });
        }
        getAccountInviteCodes(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", params2, void 0, opts).catch((e) => {
            throw toKnownErr40(e);
          });
        }
        getSession(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.getSession", params2, void 0, opts).catch((e) => {
            throw toKnownErr41(e);
          });
        }
        listAppPasswords(params2, opts) {
          return this._service.xrpc.call("com.atproto.server.listAppPasswords", params2, void 0, opts).catch((e) => {
            throw toKnownErr42(e);
          });
        }
        refreshSession(data, opts) {
          return this._service.xrpc.call("com.atproto.server.refreshSession", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr43(e);
          });
        }
        requestAccountDelete(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestAccountDelete", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr44(e);
          });
        }
        requestEmailConfirmation(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr45(e);
          });
        }
        requestEmailUpdate(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr46(e);
          });
        }
        requestPasswordReset(data, opts) {
          return this._service.xrpc.call("com.atproto.server.requestPasswordReset", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr47(e);
          });
        }
        reserveSigningKey(data, opts) {
          return this._service.xrpc.call("com.atproto.server.reserveSigningKey", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr48(e);
          });
        }
        resetPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.resetPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr49(e);
          });
        }
        revokeAppPassword(data, opts) {
          return this._service.xrpc.call("com.atproto.server.revokeAppPassword", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr50(e);
          });
        }
        updateEmail(data, opts) {
          return this._service.xrpc.call("com.atproto.server.updateEmail", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr51(e);
          });
        }
      };
      var SyncNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getBlob(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getBlob", params2, void 0, opts).catch((e) => {
            throw toKnownErr52(e);
          });
        }
        getBlocks(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr53(e);
          });
        }
        getCheckout(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getCheckout", params2, void 0, opts).catch((e) => {
            throw toKnownErr54(e);
          });
        }
        getHead(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getHead", params2, void 0, opts).catch((e) => {
            throw toKnownErr55(e);
          });
        }
        getLatestCommit(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getLatestCommit", params2, void 0, opts).catch((e) => {
            throw toKnownErr56(e);
          });
        }
        getRecord(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getRecord", params2, void 0, opts).catch((e) => {
            throw toKnownErr57(e);
          });
        }
        getRepo(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.getRepo", params2, void 0, opts).catch((e) => {
            throw toKnownErr58(e);
          });
        }
        listBlobs(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.listBlobs", params2, void 0, opts).catch((e) => {
            throw toKnownErr59(e);
          });
        }
        listRepos(params2, opts) {
          return this._service.xrpc.call("com.atproto.sync.listRepos", params2, void 0, opts).catch((e) => {
            throw toKnownErr60(e);
          });
        }
        notifyOfUpdate(data, opts) {
          return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr61(e);
          });
        }
        requestCrawl(data, opts) {
          return this._service.xrpc.call("com.atproto.sync.requestCrawl", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr62(e);
          });
        }
      };
      var TempNS = class {
        constructor(service2) {
          this._service = service2;
        }
        fetchLabels(params2, opts) {
          return this._service.xrpc.call("com.atproto.temp.fetchLabels", params2, void 0, opts).catch((e) => {
            throw toKnownErr63(e);
          });
        }
        importRepo(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.importRepo", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr64(e);
          });
        }
        pushBlob(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.pushBlob", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr65(e);
          });
        }
        transferAccount(data, opts) {
          return this._service.xrpc.call("com.atproto.temp.transferAccount", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr66(e);
          });
        }
      };
      var AppNS = class {
        constructor(service2) {
          this._service = service2;
          this.bsky = new BskyNS(service2);
        }
      };
      var BskyNS = class {
        constructor(service2) {
          this._service = service2;
          this.actor = new ActorNS(service2);
          this.embed = new EmbedNS(service2);
          this.feed = new FeedNS(service2);
          this.graph = new GraphNS(service2);
          this.notification = new NotificationNS(service2);
          this.richtext = new RichtextNS(service2);
          this.unspecced = new UnspeccedNS(service2);
        }
      };
      var ActorNS = class {
        constructor(service2) {
          this._service = service2;
          this.profile = new ProfileRecord(service2);
        }
        getPreferences(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getPreferences", params2, void 0, opts).catch((e) => {
            throw toKnownErr67(e);
          });
        }
        getProfile(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getProfile", params2, void 0, opts).catch((e) => {
            throw toKnownErr68(e);
          });
        }
        getProfiles(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getProfiles", params2, void 0, opts).catch((e) => {
            throw toKnownErr69(e);
          });
        }
        getSuggestions(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.getSuggestions", params2, void 0, opts).catch((e) => {
            throw toKnownErr70(e);
          });
        }
        putPreferences(data, opts) {
          return this._service.xrpc.call("app.bsky.actor.putPreferences", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr71(e);
          });
        }
        searchActors(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.searchActors", params2, void 0, opts).catch((e) => {
            throw toKnownErr72(e);
          });
        }
        searchActorsTypeahead(params2, opts) {
          return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", params2, void 0, opts).catch((e) => {
            throw toKnownErr73(e);
          });
        }
      };
      var ProfileRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.actor.profile"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.actor.profile"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.actor.profile";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.actor.profile", rkey: "self" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.actor.profile" }, params2), { headers });
          });
        }
      };
      var EmbedNS = class {
        constructor(service2) {
          this._service = service2;
        }
      };
      var FeedNS = class {
        constructor(service2) {
          this._service = service2;
          this.generator = new GeneratorRecord(service2);
          this.like = new LikeRecord(service2);
          this.post = new PostRecord(service2);
          this.repost = new RepostRecord(service2);
          this.threadgate = new ThreadgateRecord(service2);
        }
        describeFeedGenerator(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", params2, void 0, opts).catch((e) => {
            throw toKnownErr74(e);
          });
        }
        getActorFeeds(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getActorFeeds", params2, void 0, opts).catch((e) => {
            throw toKnownErr75(e);
          });
        }
        getActorLikes(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getActorLikes", params2, void 0, opts).catch((e) => {
            throw toKnownErr76(e);
          });
        }
        getAuthorFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr77(e);
          });
        }
        getFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr78(e);
          });
        }
        getFeedGenerator(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", params2, void 0, opts).catch((e) => {
            throw toKnownErr79(e);
          });
        }
        getFeedGenerators(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", params2, void 0, opts).catch((e) => {
            throw toKnownErr80(e);
          });
        }
        getFeedSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr81(e);
          });
        }
        getLikes(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getLikes", params2, void 0, opts).catch((e) => {
            throw toKnownErr82(e);
          });
        }
        getListFeed(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getListFeed", params2, void 0, opts).catch((e) => {
            throw toKnownErr83(e);
          });
        }
        getPostThread(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getPostThread", params2, void 0, opts).catch((e) => {
            throw toKnownErr84(e);
          });
        }
        getPosts(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getPosts", params2, void 0, opts).catch((e) => {
            throw toKnownErr85(e);
          });
        }
        getRepostedBy(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getRepostedBy", params2, void 0, opts).catch((e) => {
            throw toKnownErr86(e);
          });
        }
        getSuggestedFeeds(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", params2, void 0, opts).catch((e) => {
            throw toKnownErr87(e);
          });
        }
        getTimeline(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.getTimeline", params2, void 0, opts).catch((e) => {
            throw toKnownErr88(e);
          });
        }
        searchPosts(params2, opts) {
          return this._service.xrpc.call("app.bsky.feed.searchPosts", params2, void 0, opts).catch((e) => {
            throw toKnownErr89(e);
          });
        }
      };
      var GeneratorRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.generator"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.generator"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.generator";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.generator" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.generator" }, params2), { headers });
          });
        }
      };
      var LikeRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.like"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.like"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.like";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.like" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.like" }, params2), { headers });
          });
        }
      };
      var PostRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.post"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.post"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.post";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.post" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.post" }, params2), { headers });
          });
        }
      };
      var RepostRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.repost"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.repost"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.repost";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.repost" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.repost" }, params2), { headers });
          });
        }
      };
      var ThreadgateRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.feed.threadgate"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.feed.threadgate"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.feed.threadgate";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.feed.threadgate" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.feed.threadgate" }, params2), { headers });
          });
        }
      };
      var GraphNS = class {
        constructor(service2) {
          this._service = service2;
          this.block = new BlockRecord(service2);
          this.follow = new FollowRecord(service2);
          this.list = new ListRecord(service2);
          this.listblock = new ListblockRecord(service2);
          this.listitem = new ListitemRecord(service2);
        }
        getBlocks(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr90(e);
          });
        }
        getFollowers(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getFollowers", params2, void 0, opts).catch((e) => {
            throw toKnownErr91(e);
          });
        }
        getFollows(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getFollows", params2, void 0, opts).catch((e) => {
            throw toKnownErr92(e);
          });
        }
        getList(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getList", params2, void 0, opts).catch((e) => {
            throw toKnownErr93(e);
          });
        }
        getListBlocks(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getListBlocks", params2, void 0, opts).catch((e) => {
            throw toKnownErr94(e);
          });
        }
        getListMutes(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getListMutes", params2, void 0, opts).catch((e) => {
            throw toKnownErr95(e);
          });
        }
        getLists(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getLists", params2, void 0, opts).catch((e) => {
            throw toKnownErr96(e);
          });
        }
        getMutes(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getMutes", params2, void 0, opts).catch((e) => {
            throw toKnownErr97(e);
          });
        }
        getSuggestedFollowsByActor(params2, opts) {
          return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", params2, void 0, opts).catch((e) => {
            throw toKnownErr98(e);
          });
        }
        muteActor(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.muteActor", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr99(e);
          });
        }
        muteActorList(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.muteActorList", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr100(e);
          });
        }
        unmuteActor(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.unmuteActor", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr101(e);
          });
        }
        unmuteActorList(data, opts) {
          return this._service.xrpc.call("app.bsky.graph.unmuteActorList", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr102(e);
          });
        }
      };
      var BlockRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.block"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.block"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.block";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.block" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.block" }, params2), { headers });
          });
        }
      };
      var FollowRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.follow"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.follow"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.follow";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.follow" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.follow" }, params2), { headers });
          });
        }
      };
      var ListRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.list"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.list"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.list";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.list" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.list" }, params2), { headers });
          });
        }
      };
      var ListblockRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.listblock"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.listblock"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.listblock";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.listblock" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.listblock" }, params2), { headers });
          });
        }
      };
      var ListitemRecord = class {
        constructor(service2) {
          this._service = service2;
        }
        list(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.listRecords", __spreadValues({
              collection: "app.bsky.graph.listitem"
            }, params2));
            return res.data;
          });
        }
        get(params2) {
          return __async(this, null, function* () {
            const res = yield this._service.xrpc.call("com.atproto.repo.getRecord", __spreadValues({
              collection: "app.bsky.graph.listitem"
            }, params2));
            return res.data;
          });
        }
        create(params2, record, headers) {
          return __async(this, null, function* () {
            record.$type = "app.bsky.graph.listitem";
            const res = yield this._service.xrpc.call("com.atproto.repo.createRecord", void 0, __spreadProps(__spreadValues({ collection: "app.bsky.graph.listitem" }, params2), { record }), { encoding: "application/json", headers });
            return res.data;
          });
        }
        delete(params2, headers) {
          return __async(this, null, function* () {
            yield this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, __spreadValues({ collection: "app.bsky.graph.listitem" }, params2), { headers });
          });
        }
      };
      var NotificationNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getUnreadCount(params2, opts) {
          return this._service.xrpc.call("app.bsky.notification.getUnreadCount", params2, void 0, opts).catch((e) => {
            throw toKnownErr103(e);
          });
        }
        listNotifications(params2, opts) {
          return this._service.xrpc.call("app.bsky.notification.listNotifications", params2, void 0, opts).catch((e) => {
            throw toKnownErr104(e);
          });
        }
        registerPush(data, opts) {
          return this._service.xrpc.call("app.bsky.notification.registerPush", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr105(e);
          });
        }
        updateSeen(data, opts) {
          return this._service.xrpc.call("app.bsky.notification.updateSeen", opts == null ? void 0 : opts.qp, data, opts).catch((e) => {
            throw toKnownErr106(e);
          });
        }
      };
      var RichtextNS = class {
        constructor(service2) {
          this._service = service2;
        }
      };
      var UnspeccedNS = class {
        constructor(service2) {
          this._service = service2;
        }
        getPopular(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getPopular", params2, void 0, opts).catch((e) => {
            throw toKnownErr107(e);
          });
        }
        getPopularFeedGenerators(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", params2, void 0, opts).catch((e) => {
            throw toKnownErr108(e);
          });
        }
        getTimelineSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.getTimelineSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr109(e);
          });
        }
        searchActorsSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr110(e);
          });
        }
        searchPostsSkeleton(params2, opts) {
          return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", params2, void 0, opts).catch((e) => {
            throw toKnownErr111(e);
          });
        }
      };
      var REFRESH_SESSION = "com.atproto.server.refreshSession";
      var _AtpAgent = class {
        constructor(opts) {
          this.uploadBlob = (data, opts2) => this.api.com.atproto.repo.uploadBlob(data, opts2);
          this.resolveHandle = (params2, opts2) => this.api.com.atproto.identity.resolveHandle(params2, opts2);
          this.updateHandle = (data, opts2) => this.api.com.atproto.identity.updateHandle(data, opts2);
          this.createModerationReport = (data, opts2) => this.api.com.atproto.moderation.createReport(data, opts2);
          this.service = opts.service instanceof URL ? opts.service : new URL(opts.service);
          this._persistSession = opts.persistSession;
          this._baseClient = new AtpBaseClient();
          this._baseClient.xrpc.fetch = this._fetch.bind(this);
          this.api = this._baseClient.service(opts.service);
        }
        get com() {
          return this.api.com;
        }
        static configure(opts) {
          _AtpAgent.fetch = opts.fetch;
        }
        get hasSession() {
          return !!this.session;
        }
        setPersistSessionHandler(handler) {
          this._persistSession = handler;
        }
        createAccount(opts) {
          return __async(this, null, function* () {
            var _a3, _b;
            try {
              const res = yield this.api.com.atproto.server.createAccount({
                handle: opts.handle,
                password: opts.password,
                email: opts.email,
                inviteCode: opts.inviteCode
              });
              this.session = {
                accessJwt: res.data.accessJwt,
                refreshJwt: res.data.refreshJwt,
                handle: res.data.handle,
                did: res.data.did,
                email: opts.email,
                emailConfirmed: false
              };
              this._updateApiEndpoint(res.data.didDoc);
              return res;
            } catch (e) {
              this.session = void 0;
              throw e;
            } finally {
              if (this.session) {
                (_a3 = this._persistSession) == null ? void 0 : _a3.call(this, "create", this.session);
              } else {
                (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
              }
            }
          });
        }
        login(opts) {
          return __async(this, null, function* () {
            var _a3, _b;
            try {
              const res = yield this.api.com.atproto.server.createSession({
                identifier: opts.identifier,
                password: opts.password
              });
              this.session = {
                accessJwt: res.data.accessJwt,
                refreshJwt: res.data.refreshJwt,
                handle: res.data.handle,
                did: res.data.did,
                email: res.data.email,
                emailConfirmed: res.data.emailConfirmed
              };
              this._updateApiEndpoint(res.data.didDoc);
              return res;
            } catch (e) {
              this.session = void 0;
              throw e;
            } finally {
              if (this.session) {
                (_a3 = this._persistSession) == null ? void 0 : _a3.call(this, "create", this.session);
              } else {
                (_b = this._persistSession) == null ? void 0 : _b.call(this, "create-failed", void 0);
              }
            }
          });
        }
        resumeSession(session) {
          return __async(this, null, function* () {
            var _a3, _b, _c, _d;
            try {
              this.session = session;
              const res = yield this.api.com.atproto.server.getSession();
              if (res.data.did !== this.session.did) {
                throw new XRPCError(400, "Invalid session", "InvalidDID");
              }
              this.session.email = res.data.email;
              this.session.handle = res.data.handle;
              this.session.emailConfirmed = res.data.emailConfirmed;
              this._updateApiEndpoint(res.data.didDoc);
              (_a3 = this._persistSession) == null ? void 0 : _a3.call(this, "update", this.session);
              return res;
            } catch (e) {
              this.session = void 0;
              if (e instanceof XRPCError) {
                if ([1, 408, 425, 429, 500, 502, 503, 504, 522, 524].includes(e.status)) {
                  (_b = this._persistSession) == null ? void 0 : _b.call(this, "network-error", void 0);
                } else {
                  (_c = this._persistSession) == null ? void 0 : _c.call(this, "expired", void 0);
                }
              } else {
                (_d = this._persistSession) == null ? void 0 : _d.call(this, "network-error", void 0);
              }
              throw e;
            }
          });
        }
        _addAuthHeader(reqHeaders) {
          var _a3;
          if (!reqHeaders.authorization && ((_a3 = this.session) == null ? void 0 : _a3.accessJwt)) {
            return __spreadProps(__spreadValues({}, reqHeaders), {
              authorization: `Bearer ${this.session.accessJwt}`
            });
          }
          return reqHeaders;
        }
        _fetch(reqUri, reqMethod, reqHeaders, reqBody) {
          return __async(this, null, function* () {
            var _a3;
            if (!_AtpAgent.fetch) {
              throw new Error("AtpAgent fetch() method not configured");
            }
            yield this._refreshSessionPromise;
            let res = yield _AtpAgent.fetch(reqUri, reqMethod, this._addAuthHeader(reqHeaders), reqBody);
            if (isErrorResponse(res, ["ExpiredToken"]) && ((_a3 = this.session) == null ? void 0 : _a3.refreshJwt)) {
              yield this._refreshSession();
              res = yield _AtpAgent.fetch(reqUri, reqMethod, this._addAuthHeader(reqHeaders), reqBody);
            }
            return res;
          });
        }
        _refreshSession() {
          return __async(this, null, function* () {
            if (this._refreshSessionPromise) {
              return this._refreshSessionPromise;
            }
            this._refreshSessionPromise = this._refreshSessionInner();
            try {
              yield this._refreshSessionPromise;
            } finally {
              this._refreshSessionPromise = void 0;
            }
          });
        }
        _refreshSessionInner() {
          return __async(this, null, function* () {
            var _a3, _b, _c;
            if (!_AtpAgent.fetch) {
              throw new Error("AtpAgent fetch() method not configured");
            }
            if (!((_a3 = this.session) == null ? void 0 : _a3.refreshJwt)) {
              return;
            }
            const url = new URL((this.pdsUrl || this.service).origin);
            url.pathname = `/xrpc/${REFRESH_SESSION}`;
            const res = yield _AtpAgent.fetch(url.toString(), "POST", {
              authorization: `Bearer ${this.session.refreshJwt}`
            }, void 0);
            if (isErrorResponse(res, ["ExpiredToken", "InvalidToken"])) {
              this.session = void 0;
              (_b = this._persistSession) == null ? void 0 : _b.call(this, "expired", void 0);
            } else if (isNewSessionObject(this._baseClient, res.body)) {
              this.session = __spreadProps(__spreadValues({}, this.session || {}), {
                accessJwt: res.body.accessJwt,
                refreshJwt: res.body.refreshJwt,
                handle: res.body.handle,
                did: res.body.did
              });
              this._updateApiEndpoint(res.body.didDoc);
              (_c = this._persistSession) == null ? void 0 : _c.call(this, "update", this.session);
            }
          });
        }
        _updateApiEndpoint(didDoc) {
          if (isValidDidDoc(didDoc)) {
            const endpoint = getPdsEndpoint(didDoc);
            this.pdsUrl = endpoint ? new URL(endpoint) : void 0;
          }
          this.api.xrpc.uri = this.pdsUrl || this.service;
        }
      };
      var AtpAgent = _AtpAgent;
      AtpAgent.fetch = defaultFetchHandler;
      function isErrorObject(v) {
        return errorResponseBody.safeParse(v).success;
      }
      function isErrorResponse(res, errorNames) {
        if (res.status !== 400) {
          return false;
        }
        if (!isErrorObject(res.body)) {
          return false;
        }
        return typeof res.body.error === "string" && errorNames.includes(res.body.error);
      }
      function isNewSessionObject(client, v) {
        try {
          client.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", v);
          return true;
        } catch (e) {
          return false;
        }
      }
      var encoder = new TextEncoder();
      var decoder2 = new TextDecoder();
      var UnicodeString = class {
        constructor(utf16) {
          this.utf16 = utf16;
          this.utf8 = encoder.encode(utf16);
        }
        get length() {
          return this.utf8.byteLength;
        }
        get graphemeLength() {
          if (!this._graphemeLen) {
            this._graphemeLen = graphemeLen(this.utf16);
          }
          return this._graphemeLen;
        }
        slice(start, end) {
          return decoder2.decode(this.utf8.slice(start, end));
        }
        utf16IndexToUtf8Index(i) {
          return encoder.encode(this.utf16.slice(0, i)).byteLength;
        }
        toString() {
          return this.utf16;
        }
      };
      var EXCESS_SPACE_RE = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/;
      var REPLACEMENT_STR = "\n\n";
      function sanitizeRichText(richText, opts) {
        if (opts.cleanNewlines) {
          richText = clean(richText, EXCESS_SPACE_RE, REPLACEMENT_STR);
        }
        return richText;
      }
      function clean(richText, targetRegexp, replacementString) {
        richText = richText.clone();
        let match = richText.unicodeText.utf16.match(targetRegexp);
        while (match && typeof match.index !== "undefined") {
          const oldText = richText.unicodeText;
          const removeStartIndex = richText.unicodeText.utf16IndexToUtf8Index(match.index);
          const removeEndIndex = removeStartIndex + new UnicodeString(match[0]).length;
          richText.delete(removeStartIndex, removeEndIndex);
          if (richText.unicodeText.utf16 === oldText.utf16) {
            break;
          }
          richText.insert(removeStartIndex, replacementString);
          match = richText.unicodeText.utf16.match(targetRegexp);
        }
        return richText;
      }
      var tlds_default = [
        "aaa",
        "aarp",
        "abarth",
        "abb",
        "abbott",
        "abbvie",
        "abc",
        "able",
        "abogado",
        "abudhabi",
        "ac",
        "academy",
        "accenture",
        "accountant",
        "accountants",
        "aco",
        "actor",
        "ad",
        "ads",
        "adult",
        "ae",
        "aeg",
        "aero",
        "aetna",
        "af",
        "afl",
        "africa",
        "ag",
        "agakhan",
        "agency",
        "ai",
        "aig",
        "airbus",
        "airforce",
        "airtel",
        "akdn",
        "al",
        "alfaromeo",
        "alibaba",
        "alipay",
        "allfinanz",
        "allstate",
        "ally",
        "alsace",
        "alstom",
        "am",
        "amazon",
        "americanexpress",
        "americanfamily",
        "amex",
        "amfam",
        "amica",
        "amsterdam",
        "analytics",
        "android",
        "anquan",
        "anz",
        "ao",
        "aol",
        "apartments",
        "app",
        "apple",
        "aq",
        "aquarelle",
        "ar",
        "arab",
        "aramco",
        "archi",
        "army",
        "arpa",
        "art",
        "arte",
        "as",
        "asda",
        "asia",
        "associates",
        "at",
        "athleta",
        "attorney",
        "au",
        "auction",
        "audi",
        "audible",
        "audio",
        "auspost",
        "author",
        "auto",
        "autos",
        "avianca",
        "aw",
        "aws",
        "ax",
        "axa",
        "az",
        "azure",
        "ba",
        "baby",
        "baidu",
        "banamex",
        "bananarepublic",
        "band",
        "bank",
        "bar",
        "barcelona",
        "barclaycard",
        "barclays",
        "barefoot",
        "bargains",
        "baseball",
        "basketball",
        "bauhaus",
        "bayern",
        "bb",
        "bbc",
        "bbt",
        "bbva",
        "bcg",
        "bcn",
        "bd",
        "be",
        "beats",
        "beauty",
        "beer",
        "bentley",
        "berlin",
        "best",
        "bestbuy",
        "bet",
        "bf",
        "bg",
        "bh",
        "bharti",
        "bi",
        "bible",
        "bid",
        "bike",
        "bing",
        "bingo",
        "bio",
        "biz",
        "bj",
        "black",
        "blackfriday",
        "blockbuster",
        "blog",
        "bloomberg",
        "blue",
        "bm",
        "bms",
        "bmw",
        "bn",
        "bnpparibas",
        "bo",
        "boats",
        "boehringer",
        "bofa",
        "bom",
        "bond",
        "boo",
        "book",
        "booking",
        "bosch",
        "bostik",
        "boston",
        "bot",
        "boutique",
        "box",
        "br",
        "bradesco",
        "bridgestone",
        "broadway",
        "broker",
        "brother",
        "brussels",
        "bs",
        "bt",
        "build",
        "builders",
        "business",
        "buy",
        "buzz",
        "bv",
        "bw",
        "by",
        "bz",
        "bzh",
        "ca",
        "cab",
        "cafe",
        "cal",
        "call",
        "calvinklein",
        "cam",
        "camera",
        "camp",
        "canon",
        "capetown",
        "capital",
        "capitalone",
        "car",
        "caravan",
        "cards",
        "care",
        "career",
        "careers",
        "cars",
        "casa",
        "case",
        "cash",
        "casino",
        "cat",
        "catering",
        "catholic",
        "cba",
        "cbn",
        "cbre",
        "cbs",
        "cc",
        "cd",
        "center",
        "ceo",
        "cern",
        "cf",
        "cfa",
        "cfd",
        "cg",
        "ch",
        "chanel",
        "channel",
        "charity",
        "chase",
        "chat",
        "cheap",
        "chintai",
        "christmas",
        "chrome",
        "church",
        "ci",
        "cipriani",
        "circle",
        "cisco",
        "citadel",
        "citi",
        "citic",
        "city",
        "cityeats",
        "ck",
        "cl",
        "claims",
        "cleaning",
        "click",
        "clinic",
        "clinique",
        "clothing",
        "cloud",
        "club",
        "clubmed",
        "cm",
        "cn",
        "co",
        "coach",
        "codes",
        "coffee",
        "college",
        "cologne",
        "com",
        "comcast",
        "commbank",
        "community",
        "company",
        "compare",
        "computer",
        "comsec",
        "condos",
        "construction",
        "consulting",
        "contact",
        "contractors",
        "cooking",
        "cookingchannel",
        "cool",
        "coop",
        "corsica",
        "country",
        "coupon",
        "coupons",
        "courses",
        "cpa",
        "cr",
        "credit",
        "creditcard",
        "creditunion",
        "cricket",
        "crown",
        "crs",
        "cruise",
        "cruises",
        "cu",
        "cuisinella",
        "cv",
        "cw",
        "cx",
        "cy",
        "cymru",
        "cyou",
        "cz",
        "dabur",
        "dad",
        "dance",
        "data",
        "date",
        "dating",
        "datsun",
        "day",
        "dclk",
        "dds",
        "de",
        "deal",
        "dealer",
        "deals",
        "degree",
        "delivery",
        "dell",
        "deloitte",
        "delta",
        "democrat",
        "dental",
        "dentist",
        "desi",
        "design",
        "dev",
        "dhl",
        "diamonds",
        "diet",
        "digital",
        "direct",
        "directory",
        "discount",
        "discover",
        "dish",
        "diy",
        "dj",
        "dk",
        "dm",
        "dnp",
        "do",
        "docs",
        "doctor",
        "dog",
        "domains",
        "dot",
        "download",
        "drive",
        "dtv",
        "dubai",
        "dunlop",
        "dupont",
        "durban",
        "dvag",
        "dvr",
        "dz",
        "earth",
        "eat",
        "ec",
        "eco",
        "edeka",
        "edu",
        "education",
        "ee",
        "eg",
        "email",
        "emerck",
        "energy",
        "engineer",
        "engineering",
        "enterprises",
        "epson",
        "equipment",
        "er",
        "ericsson",
        "erni",
        "es",
        "esq",
        "estate",
        "et",
        "etisalat",
        "eu",
        "eurovision",
        "eus",
        "events",
        "exchange",
        "expert",
        "exposed",
        "express",
        "extraspace",
        "fage",
        "fail",
        "fairwinds",
        "faith",
        "family",
        "fan",
        "fans",
        "farm",
        "farmers",
        "fashion",
        "fast",
        "fedex",
        "feedback",
        "ferrari",
        "ferrero",
        "fi",
        "fiat",
        "fidelity",
        "fido",
        "film",
        "final",
        "finance",
        "financial",
        "fire",
        "firestone",
        "firmdale",
        "fish",
        "fishing",
        "fit",
        "fitness",
        "fj",
        "fk",
        "flickr",
        "flights",
        "flir",
        "florist",
        "flowers",
        "fly",
        "fm",
        "fo",
        "foo",
        "food",
        "foodnetwork",
        "football",
        "ford",
        "forex",
        "forsale",
        "forum",
        "foundation",
        "fox",
        "fr",
        "free",
        "fresenius",
        "frl",
        "frogans",
        "frontdoor",
        "frontier",
        "ftr",
        "fujitsu",
        "fun",
        "fund",
        "furniture",
        "futbol",
        "fyi",
        "ga",
        "gal",
        "gallery",
        "gallo",
        "gallup",
        "game",
        "games",
        "gap",
        "garden",
        "gay",
        "gb",
        "gbiz",
        "gd",
        "gdn",
        "ge",
        "gea",
        "gent",
        "genting",
        "george",
        "gf",
        "gg",
        "ggee",
        "gh",
        "gi",
        "gift",
        "gifts",
        "gives",
        "giving",
        "gl",
        "glass",
        "gle",
        "global",
        "globo",
        "gm",
        "gmail",
        "gmbh",
        "gmo",
        "gmx",
        "gn",
        "godaddy",
        "gold",
        "goldpoint",
        "golf",
        "goo",
        "goodyear",
        "goog",
        "google",
        "gop",
        "got",
        "gov",
        "gp",
        "gq",
        "gr",
        "grainger",
        "graphics",
        "gratis",
        "green",
        "gripe",
        "grocery",
        "group",
        "gs",
        "gt",
        "gu",
        "guardian",
        "gucci",
        "guge",
        "guide",
        "guitars",
        "guru",
        "gw",
        "gy",
        "hair",
        "hamburg",
        "hangout",
        "haus",
        "hbo",
        "hdfc",
        "hdfcbank",
        "health",
        "healthcare",
        "help",
        "helsinki",
        "here",
        "hermes",
        "hgtv",
        "hiphop",
        "hisamitsu",
        "hitachi",
        "hiv",
        "hk",
        "hkt",
        "hm",
        "hn",
        "hockey",
        "holdings",
        "holiday",
        "homedepot",
        "homegoods",
        "homes",
        "homesense",
        "honda",
        "horse",
        "hospital",
        "host",
        "hosting",
        "hot",
        "hoteles",
        "hotels",
        "hotmail",
        "house",
        "how",
        "hr",
        "hsbc",
        "ht",
        "hu",
        "hughes",
        "hyatt",
        "hyundai",
        "ibm",
        "icbc",
        "ice",
        "icu",
        "id",
        "ie",
        "ieee",
        "ifm",
        "ikano",
        "il",
        "im",
        "imamat",
        "imdb",
        "immo",
        "immobilien",
        "in",
        "inc",
        "industries",
        "infiniti",
        "info",
        "ing",
        "ink",
        "institute",
        "insurance",
        "insure",
        "int",
        "international",
        "intuit",
        "investments",
        "io",
        "ipiranga",
        "iq",
        "ir",
        "irish",
        "is",
        "ismaili",
        "ist",
        "istanbul",
        "it",
        "itau",
        "itv",
        "jaguar",
        "java",
        "jcb",
        "je",
        "jeep",
        "jetzt",
        "jewelry",
        "jio",
        "jll",
        "jm",
        "jmp",
        "jnj",
        "jo",
        "jobs",
        "joburg",
        "jot",
        "joy",
        "jp",
        "jpmorgan",
        "jprs",
        "juegos",
        "juniper",
        "kaufen",
        "kddi",
        "ke",
        "kerryhotels",
        "kerrylogistics",
        "kerryproperties",
        "kfh",
        "kg",
        "kh",
        "ki",
        "kia",
        "kids",
        "kim",
        "kinder",
        "kindle",
        "kitchen",
        "kiwi",
        "km",
        "kn",
        "koeln",
        "komatsu",
        "kosher",
        "kp",
        "kpmg",
        "kpn",
        "kr",
        "krd",
        "kred",
        "kuokgroup",
        "kw",
        "ky",
        "kyoto",
        "kz",
        "la",
        "lacaixa",
        "lamborghini",
        "lamer",
        "lancaster",
        "lancia",
        "land",
        "landrover",
        "lanxess",
        "lasalle",
        "lat",
        "latino",
        "latrobe",
        "law",
        "lawyer",
        "lb",
        "lc",
        "lds",
        "lease",
        "leclerc",
        "lefrak",
        "legal",
        "lego",
        "lexus",
        "lgbt",
        "li",
        "lidl",
        "life",
        "lifeinsurance",
        "lifestyle",
        "lighting",
        "like",
        "lilly",
        "limited",
        "limo",
        "lincoln",
        "linde",
        "link",
        "lipsy",
        "live",
        "living",
        "lk",
        "llc",
        "llp",
        "loan",
        "loans",
        "locker",
        "locus",
        "loft",
        "lol",
        "london",
        "lotte",
        "lotto",
        "love",
        "lpl",
        "lplfinancial",
        "lr",
        "ls",
        "lt",
        "ltd",
        "ltda",
        "lu",
        "lundbeck",
        "luxe",
        "luxury",
        "lv",
        "ly",
        "ma",
        "macys",
        "madrid",
        "maif",
        "maison",
        "makeup",
        "man",
        "management",
        "mango",
        "map",
        "market",
        "marketing",
        "markets",
        "marriott",
        "marshalls",
        "maserati",
        "mattel",
        "mba",
        "mc",
        "mckinsey",
        "md",
        "me",
        "med",
        "media",
        "meet",
        "melbourne",
        "meme",
        "memorial",
        "men",
        "menu",
        "merckmsd",
        "mg",
        "mh",
        "miami",
        "microsoft",
        "mil",
        "mini",
        "mint",
        "mit",
        "mitsubishi",
        "mk",
        "ml",
        "mlb",
        "mls",
        "mm",
        "mma",
        "mn",
        "mo",
        "mobi",
        "mobile",
        "moda",
        "moe",
        "moi",
        "mom",
        "monash",
        "money",
        "monster",
        "mormon",
        "mortgage",
        "moscow",
        "moto",
        "motorcycles",
        "mov",
        "movie",
        "mp",
        "mq",
        "mr",
        "ms",
        "msd",
        "mt",
        "mtn",
        "mtr",
        "mu",
        "museum",
        "music",
        "mutual",
        "mv",
        "mw",
        "mx",
        "my",
        "mz",
        "na",
        "nab",
        "nagoya",
        "name",
        "natura",
        "navy",
        "nba",
        "nc",
        "ne",
        "nec",
        "net",
        "netbank",
        "netflix",
        "network",
        "neustar",
        "new",
        "news",
        "next",
        "nextdirect",
        "nexus",
        "nf",
        "nfl",
        "ng",
        "ngo",
        "nhk",
        "ni",
        "nico",
        "nike",
        "nikon",
        "ninja",
        "nissan",
        "nissay",
        "nl",
        "no",
        "nokia",
        "northwesternmutual",
        "norton",
        "now",
        "nowruz",
        "nowtv",
        "np",
        "nr",
        "nra",
        "nrw",
        "ntt",
        "nu",
        "nyc",
        "nz",
        "obi",
        "observer",
        "office",
        "okinawa",
        "olayan",
        "olayangroup",
        "oldnavy",
        "ollo",
        "om",
        "omega",
        "one",
        "ong",
        "onl",
        "online",
        "ooo",
        "open",
        "oracle",
        "orange",
        "org",
        "organic",
        "origins",
        "osaka",
        "otsuka",
        "ott",
        "ovh",
        "pa",
        "page",
        "panasonic",
        "paris",
        "pars",
        "partners",
        "parts",
        "party",
        "passagens",
        "pay",
        "pccw",
        "pe",
        "pet",
        "pf",
        "pfizer",
        "pg",
        "ph",
        "pharmacy",
        "phd",
        "philips",
        "phone",
        "photo",
        "photography",
        "photos",
        "physio",
        "pics",
        "pictet",
        "pictures",
        "pid",
        "pin",
        "ping",
        "pink",
        "pioneer",
        "pizza",
        "pk",
        "pl",
        "place",
        "play",
        "playstation",
        "plumbing",
        "plus",
        "pm",
        "pn",
        "pnc",
        "pohl",
        "poker",
        "politie",
        "porn",
        "post",
        "pr",
        "pramerica",
        "praxi",
        "press",
        "prime",
        "pro",
        "prod",
        "productions",
        "prof",
        "progressive",
        "promo",
        "properties",
        "property",
        "protection",
        "pru",
        "prudential",
        "ps",
        "pt",
        "pub",
        "pw",
        "pwc",
        "py",
        "qa",
        "qpon",
        "quebec",
        "quest",
        "racing",
        "radio",
        "re",
        "read",
        "realestate",
        "realtor",
        "realty",
        "recipes",
        "red",
        "redstone",
        "redumbrella",
        "rehab",
        "reise",
        "reisen",
        "reit",
        "reliance",
        "ren",
        "rent",
        "rentals",
        "repair",
        "report",
        "republican",
        "rest",
        "restaurant",
        "review",
        "reviews",
        "rexroth",
        "rich",
        "richardli",
        "ricoh",
        "ril",
        "rio",
        "rip",
        "ro",
        "rocher",
        "rocks",
        "rodeo",
        "rogers",
        "room",
        "rs",
        "rsvp",
        "ru",
        "rugby",
        "ruhr",
        "run",
        "rw",
        "rwe",
        "ryukyu",
        "sa",
        "saarland",
        "safe",
        "safety",
        "sakura",
        "sale",
        "salon",
        "samsclub",
        "samsung",
        "sandvik",
        "sandvikcoromant",
        "sanofi",
        "sap",
        "sarl",
        "sas",
        "save",
        "saxo",
        "sb",
        "sbi",
        "sbs",
        "sc",
        "sca",
        "scb",
        "schaeffler",
        "schmidt",
        "scholarships",
        "school",
        "schule",
        "schwarz",
        "science",
        "scot",
        "sd",
        "se",
        "search",
        "seat",
        "secure",
        "security",
        "seek",
        "select",
        "sener",
        "services",
        "ses",
        "seven",
        "sew",
        "sex",
        "sexy",
        "sfr",
        "sg",
        "sh",
        "shangrila",
        "sharp",
        "shaw",
        "shell",
        "shia",
        "shiksha",
        "shoes",
        "shop",
        "shopping",
        "shouji",
        "show",
        "showtime",
        "si",
        "silk",
        "sina",
        "singles",
        "site",
        "sj",
        "sk",
        "ski",
        "skin",
        "sky",
        "skype",
        "sl",
        "sling",
        "sm",
        "smart",
        "smile",
        "sn",
        "sncf",
        "so",
        "soccer",
        "social",
        "softbank",
        "software",
        "sohu",
        "solar",
        "solutions",
        "song",
        "sony",
        "soy",
        "spa",
        "space",
        "sport",
        "spot",
        "sr",
        "srl",
        "ss",
        "st",
        "stada",
        "staples",
        "star",
        "statebank",
        "statefarm",
        "stc",
        "stcgroup",
        "stockholm",
        "storage",
        "store",
        "stream",
        "studio",
        "study",
        "style",
        "su",
        "sucks",
        "supplies",
        "supply",
        "support",
        "surf",
        "surgery",
        "suzuki",
        "sv",
        "swatch",
        "swiss",
        "sx",
        "sy",
        "sydney",
        "systems",
        "sz",
        "tab",
        "taipei",
        "talk",
        "taobao",
        "target",
        "tatamotors",
        "tatar",
        "tattoo",
        "tax",
        "taxi",
        "tc",
        "tci",
        "td",
        "tdk",
        "team",
        "tech",
        "technology",
        "tel",
        "temasek",
        "tennis",
        "teva",
        "tf",
        "tg",
        "th",
        "thd",
        "theater",
        "theatre",
        "tiaa",
        "tickets",
        "tienda",
        "tiffany",
        "tips",
        "tires",
        "tirol",
        "tj",
        "tjmaxx",
        "tjx",
        "tk",
        "tkmaxx",
        "tl",
        "tm",
        "tmall",
        "tn",
        "to",
        "today",
        "tokyo",
        "tools",
        "top",
        "toray",
        "toshiba",
        "total",
        "tours",
        "town",
        "toyota",
        "toys",
        "tr",
        "trade",
        "trading",
        "training",
        "travel",
        "travelchannel",
        "travelers",
        "travelersinsurance",
        "trust",
        "trv",
        "tt",
        "tube",
        "tui",
        "tunes",
        "tushu",
        "tv",
        "tvs",
        "tw",
        "tz",
        "ua",
        "ubank",
        "ubs",
        "ug",
        "uk",
        "unicom",
        "university",
        "uno",
        "uol",
        "ups",
        "us",
        "uy",
        "uz",
        "va",
        "vacations",
        "vana",
        "vanguard",
        "vc",
        "ve",
        "vegas",
        "ventures",
        "verisign",
        "verm\xF6gensberater",
        "verm\xF6gensberatung",
        "versicherung",
        "vet",
        "vg",
        "vi",
        "viajes",
        "video",
        "vig",
        "viking",
        "villas",
        "vin",
        "vip",
        "virgin",
        "visa",
        "vision",
        "viva",
        "vivo",
        "vlaanderen",
        "vn",
        "vodka",
        "volkswagen",
        "volvo",
        "vote",
        "voting",
        "voto",
        "voyage",
        "vu",
        "vuelos",
        "wales",
        "walmart",
        "walter",
        "wang",
        "wanggou",
        "watch",
        "watches",
        "weather",
        "weatherchannel",
        "webcam",
        "weber",
        "website",
        "wed",
        "wedding",
        "weibo",
        "weir",
        "wf",
        "whoswho",
        "wien",
        "wiki",
        "williamhill",
        "win",
        "windows",
        "wine",
        "winners",
        "wme",
        "wolterskluwer",
        "woodside",
        "work",
        "works",
        "world",
        "wow",
        "ws",
        "wtc",
        "wtf",
        "xbox",
        "xerox",
        "xfinity",
        "xihuan",
        "xin",
        "xxx",
        "xyz",
        "yachts",
        "yahoo",
        "yamaxun",
        "yandex",
        "ye",
        "yodobashi",
        "yoga",
        "yokohama",
        "you",
        "youtube",
        "yt",
        "yun",
        "za",
        "zappos",
        "zara",
        "zero",
        "zip",
        "zm",
        "zone",
        "zuerich",
        "zw",
        "\u03B5\u03BB",
        "\u03B5\u03C5",
        "\u0431\u0433",
        "\u0431\u0435\u043B",
        "\u0434\u0435\u0442\u0438",
        "\u0435\u044E",
        "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
        "\u043A\u043E\u043C",
        "\u043C\u043A\u0434",
        "\u043C\u043E\u043D",
        "\u043C\u043E\u0441\u043A\u0432\u0430",
        "\u043E\u043D\u043B\u0430\u0439\u043D",
        "\u043E\u0440\u0433",
        "\u0440\u0443\u0441",
        "\u0440\u0444",
        "\u0441\u0430\u0439\u0442",
        "\u0441\u0440\u0431",
        "\u0443\u043A\u0440",
        "\u049B\u0430\u0437",
        "\u0570\u0561\u0575",
        "\u05D9\u05E9\u05E8\u05D0\u05DC",
        "\u05E7\u05D5\u05DD",
        "\u0627\u0628\u0648\u0638\u0628\u064A",
        "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
        "\u0627\u0631\u0627\u0645\u0643\u0648",
        "\u0627\u0644\u0627\u0631\u062F\u0646",
        "\u0627\u0644\u0628\u062D\u0631\u064A\u0646",
        "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
        "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
        "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
        "\u0627\u0644\u0645\u063A\u0631\u0628",
        "\u0627\u0645\u0627\u0631\u0627\u062A",
        "\u0627\u06CC\u0631\u0627\u0646",
        "\u0628\u0627\u0631\u062A",
        "\u0628\u0627\u0632\u0627\u0631",
        "\u0628\u064A\u062A\u0643",
        "\u0628\u06BE\u0627\u0631\u062A",
        "\u062A\u0648\u0646\u0633",
        "\u0633\u0648\u062F\u0627\u0646",
        "\u0633\u0648\u0631\u064A\u0629",
        "\u0634\u0628\u0643\u0629",
        "\u0639\u0631\u0627\u0642",
        "\u0639\u0631\u0628",
        "\u0639\u0645\u0627\u0646",
        "\u0641\u0644\u0633\u0637\u064A\u0646",
        "\u0642\u0637\u0631",
        "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
        "\u0643\u0648\u0645",
        "\u0645\u0635\u0631",
        "\u0645\u0644\u064A\u0633\u064A\u0627",
        "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
        "\u0645\u0648\u0642\u0639",
        "\u0647\u0645\u0631\u0627\u0647",
        "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
        "\u0680\u0627\u0631\u062A",
        "\u0915\u0949\u092E",
        "\u0928\u0947\u091F",
        "\u092D\u093E\u0930\u0924",
        "\u092D\u093E\u0930\u0924\u092E\u094D",
        "\u092D\u093E\u0930\u094B\u0924",
        "\u0938\u0902\u0917\u0920\u0928",
        "\u09AC\u09BE\u0982\u09B2\u09BE",
        "\u09AD\u09BE\u09B0\u09A4",
        "\u09AD\u09BE\u09F0\u09A4",
        "\u0A2D\u0A3E\u0A30\u0A24",
        "\u0AAD\u0ABE\u0AB0\u0AA4",
        "\u0B2D\u0B3E\u0B30\u0B24",
        "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
        "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
        "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
        "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
        "\u0CAD\u0CBE\u0CB0\u0CA4",
        "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
        "\u0DBD\u0D82\u0D9A\u0DCF",
        "\u0E04\u0E2D\u0E21",
        "\u0E44\u0E17\u0E22",
        "\u0EA5\u0EB2\u0EA7",
        "\u10D2\u10D4",
        "\u307F\u3093\u306A",
        "\u30A2\u30DE\u30BE\u30F3",
        "\u30AF\u30E9\u30A6\u30C9",
        "\u30B0\u30FC\u30B0\u30EB",
        "\u30B3\u30E0",
        "\u30B9\u30C8\u30A2",
        "\u30BB\u30FC\u30EB",
        "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
        "\u30DD\u30A4\u30F3\u30C8",
        "\u4E16\u754C",
        "\u4E2D\u4FE1",
        "\u4E2D\u56FD",
        "\u4E2D\u570B",
        "\u4E2D\u6587\u7F51",
        "\u4E9A\u9A6C\u900A",
        "\u4F01\u4E1A",
        "\u4F5B\u5C71",
        "\u4FE1\u606F",
        "\u5065\u5EB7",
        "\u516B\u5366",
        "\u516C\u53F8",
        "\u516C\u76CA",
        "\u53F0\u6E7E",
        "\u53F0\u7063",
        "\u5546\u57CE",
        "\u5546\u5E97",
        "\u5546\u6807",
        "\u5609\u91CC",
        "\u5609\u91CC\u5927\u9152\u5E97",
        "\u5728\u7EBF",
        "\u5927\u62FF",
        "\u5929\u4E3B\u6559",
        "\u5A31\u4E50",
        "\u5BB6\u96FB",
        "\u5E7F\u4E1C",
        "\u5FAE\u535A",
        "\u6148\u5584",
        "\u6211\u7231\u4F60",
        "\u624B\u673A",
        "\u62DB\u8058",
        "\u653F\u52A1",
        "\u653F\u5E9C",
        "\u65B0\u52A0\u5761",
        "\u65B0\u95FB",
        "\u65F6\u5C1A",
        "\u66F8\u7C4D",
        "\u673A\u6784",
        "\u6DE1\u9A6C\u9521",
        "\u6E38\u620F",
        "\u6FB3\u9580",
        "\u70B9\u770B",
        "\u79FB\u52A8",
        "\u7EC4\u7EC7\u673A\u6784",
        "\u7F51\u5740",
        "\u7F51\u5E97",
        "\u7F51\u7AD9",
        "\u7F51\u7EDC",
        "\u8054\u901A",
        "\u8BFA\u57FA\u4E9A",
        "\u8C37\u6B4C",
        "\u8D2D\u7269",
        "\u901A\u8CA9",
        "\u96C6\u56E2",
        "\u96FB\u8A0A\u76C8\u79D1",
        "\u98DE\u5229\u6D66",
        "\u98DF\u54C1",
        "\u9910\u5385",
        "\u9999\u683C\u91CC\u62C9",
        "\u9999\u6E2F",
        "\uB2F7\uB137",
        "\uB2F7\uCEF4",
        "\uC0BC\uC131",
        "\uD55C\uAD6D"
      ];
      function detectFacets(text) {
        var _a3;
        let match;
        const facets = [];
        {
          const re = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
          while (match = re.exec(text.utf16)) {
            if (!isValidDomain(match[3]) && !match[3].endsWith(".test")) {
              continue;
            }
            const start = text.utf16.indexOf(match[3], match.index) - 1;
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(start),
                byteEnd: text.utf16IndexToUtf8Index(start + match[3].length + 1)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#mention",
                  did: match[3]
                }
              ]
            });
          }
        }
        {
          const re = new RegExp("(^|\\s|\\()((https?:\\/\\/[\\S]+)|((?<domain>[a-z][a-z0-9]*(\\.[a-z0-9]+)+)[\\S]*))", "gim");
          while (match = re.exec(text.utf16)) {
            let uri2 = match[2];
            if (!uri2.startsWith("http")) {
              const domain = (_a3 = match.groups) == null ? void 0 : _a3.domain;
              if (!domain || !isValidDomain(domain)) {
                continue;
              }
              uri2 = `https://${uri2}`;
            }
            const start = text.utf16.indexOf(match[2], match.index);
            const index = { start, end: start + match[2].length };
            if (/[.,;:!?]$/.test(uri2)) {
              uri2 = uri2.slice(0, -1);
              index.end--;
            }
            if (/[)]$/.test(uri2) && !uri2.includes("(")) {
              uri2 = uri2.slice(0, -1);
              index.end--;
            }
            facets.push({
              index: {
                byteStart: text.utf16IndexToUtf8Index(index.start),
                byteEnd: text.utf16IndexToUtf8Index(index.end)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#link",
                  uri: uri2
                }
              ]
            });
          }
        }
        {
          const re = /(?:^|\s)(#[^\d\s]\S*)(?=\s)?/g;
          while (match = re.exec(text.utf16)) {
            let [tag] = match;
            const hasLeadingSpace = /^\s/.test(tag);
            tag = tag.trim().replace(new RegExp("\\p{P}+$", "gu"), "");
            if (tag.length > 66)
              continue;
            const index = match.index + (hasLeadingSpace ? 1 : 0);
            facets.push({
              index: {
                byteStart: text.utf16IndexToUtf8Index(index),
                byteEnd: text.utf16IndexToUtf8Index(index + tag.length)
              },
              features: [
                {
                  $type: "app.bsky.richtext.facet#tag",
                  tag: tag.replace(/^#/, "")
                }
              ]
            });
          }
        }
        return facets.length > 0 ? facets : void 0;
      }
      function isValidDomain(str) {
        return !!tlds_default.find((tld) => {
          const i = str.lastIndexOf(tld);
          if (i === -1) {
            return false;
          }
          return str.charAt(i - 1) === "." && i === str.length - tld.length;
        });
      }
      var RichTextSegment = class {
        constructor(text, facet) {
          this.text = text;
          this.facet = facet;
        }
        get link() {
          var _a3;
          const link = (_a3 = this.facet) == null ? void 0 : _a3.features.find(facet_exports.isLink);
          if (facet_exports.isLink(link)) {
            return link;
          }
          return void 0;
        }
        isLink() {
          return !!this.link;
        }
        get mention() {
          var _a3;
          const mention = (_a3 = this.facet) == null ? void 0 : _a3.features.find(facet_exports.isMention);
          if (facet_exports.isMention(mention)) {
            return mention;
          }
          return void 0;
        }
        isMention() {
          return !!this.mention;
        }
        get tag() {
          var _a3;
          const tag = (_a3 = this.facet) == null ? void 0 : _a3.features.find(facet_exports.isTag);
          if (facet_exports.isTag(tag)) {
            return tag;
          }
          return void 0;
        }
        isTag() {
          return !!this.tag;
        }
      };
      var RichText = class {
        constructor(props, opts) {
          var _a3, _b;
          this.unicodeText = new UnicodeString(props.text);
          this.facets = props.facets;
          if (!((_a3 = this.facets) == null ? void 0 : _a3.length) && ((_b = props.entities) == null ? void 0 : _b.length)) {
            this.facets = entitiesToFacets(this.unicodeText, props.entities);
          }
          if (this.facets) {
            this.facets.sort(facetSort);
          }
          if (opts == null ? void 0 : opts.cleanNewlines) {
            sanitizeRichText(this, { cleanNewlines: true }).copyInto(this);
          }
        }
        get text() {
          return this.unicodeText.toString();
        }
        get length() {
          return this.unicodeText.length;
        }
        get graphemeLength() {
          return this.unicodeText.graphemeLength;
        }
        clone() {
          return new RichText({
            text: this.unicodeText.utf16,
            facets: cloneDeep(this.facets)
          });
        }
        copyInto(target2) {
          target2.unicodeText = this.unicodeText;
          target2.facets = cloneDeep(this.facets);
        }
        *segments() {
          const facets = this.facets || [];
          if (!facets.length) {
            yield new RichTextSegment(this.unicodeText.utf16);
            return;
          }
          let textCursor = 0;
          let facetCursor = 0;
          do {
            const currFacet = facets[facetCursor];
            if (textCursor < currFacet.index.byteStart) {
              yield new RichTextSegment(this.unicodeText.slice(textCursor, currFacet.index.byteStart));
            } else if (textCursor > currFacet.index.byteStart) {
              facetCursor++;
              continue;
            }
            if (currFacet.index.byteStart < currFacet.index.byteEnd) {
              const subtext = this.unicodeText.slice(currFacet.index.byteStart, currFacet.index.byteEnd);
              if (!subtext.trim()) {
                yield new RichTextSegment(subtext);
              } else {
                yield new RichTextSegment(subtext, currFacet);
              }
            }
            textCursor = currFacet.index.byteEnd;
            facetCursor++;
          } while (facetCursor < facets.length);
          if (textCursor < this.unicodeText.length) {
            yield new RichTextSegment(this.unicodeText.slice(textCursor, this.unicodeText.length));
          }
        }
        insert(insertIndex, insertText) {
          var _a3;
          this.unicodeText = new UnicodeString(this.unicodeText.slice(0, insertIndex) + insertText + this.unicodeText.slice(insertIndex));
          if (!((_a3 = this.facets) == null ? void 0 : _a3.length)) {
            return this;
          }
          const numCharsAdded = insertText.length;
          for (const ent of this.facets) {
            if (insertIndex <= ent.index.byteStart) {
              ent.index.byteStart += numCharsAdded;
              ent.index.byteEnd += numCharsAdded;
            } else if (insertIndex >= ent.index.byteStart && insertIndex < ent.index.byteEnd) {
              ent.index.byteEnd += numCharsAdded;
            }
          }
          return this;
        }
        delete(removeStartIndex, removeEndIndex) {
          var _a3;
          this.unicodeText = new UnicodeString(this.unicodeText.slice(0, removeStartIndex) + this.unicodeText.slice(removeEndIndex));
          if (!((_a3 = this.facets) == null ? void 0 : _a3.length)) {
            return this;
          }
          const numCharsRemoved = removeEndIndex - removeStartIndex;
          for (const ent of this.facets) {
            if (removeStartIndex <= ent.index.byteStart && removeEndIndex >= ent.index.byteEnd) {
              ent.index.byteStart = 0;
              ent.index.byteEnd = 0;
            } else if (removeStartIndex > ent.index.byteEnd) {
            } else if (removeStartIndex > ent.index.byteStart && removeStartIndex <= ent.index.byteEnd && removeEndIndex > ent.index.byteEnd) {
              ent.index.byteEnd = removeStartIndex;
            } else if (removeStartIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
              ent.index.byteEnd -= numCharsRemoved;
            } else if (removeStartIndex < ent.index.byteStart && removeEndIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
              ent.index.byteStart = removeStartIndex;
              ent.index.byteEnd -= numCharsRemoved;
            } else if (removeEndIndex < ent.index.byteStart) {
              ent.index.byteStart -= numCharsRemoved;
              ent.index.byteEnd -= numCharsRemoved;
            }
          }
          this.facets = this.facets.filter((ent) => ent.index.byteStart < ent.index.byteEnd);
          return this;
        }
        detectFacets(agent) {
          return __async(this, null, function* () {
            this.facets = detectFacets(this.unicodeText);
            if (this.facets) {
              for (const facet of this.facets) {
                for (const feature of facet.features) {
                  if (facet_exports.isMention(feature)) {
                    const did2 = yield agent.resolveHandle({ handle: feature.did }).catch((_) => void 0).then((res) => res == null ? void 0 : res.data.did);
                    feature.did = did2 || "";
                  }
                }
              }
              this.facets.sort(facetSort);
            }
          });
        }
        detectFacetsWithoutResolution() {
          this.facets = detectFacets(this.unicodeText);
          if (this.facets) {
            this.facets.sort(facetSort);
          }
        }
      };
      var facetSort = (a, b) => a.index.byteStart - b.index.byteStart;
      function entitiesToFacets(text, entities) {
        const facets = [];
        for (const ent of entities) {
          if (ent.type === "link") {
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(ent.index.start),
                byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
              },
              features: [{ $type: "app.bsky.richtext.facet#link", uri: ent.value }]
            });
          } else if (ent.type === "mention") {
            facets.push({
              $type: "app.bsky.richtext.facet",
              index: {
                byteStart: text.utf16IndexToUtf8Index(ent.index.start),
                byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
              },
              features: [
                { $type: "app.bsky.richtext.facet#mention", did: ent.value }
              ]
            });
          }
        }
        return facets;
      }
      function cloneDeep(v) {
        if (typeof v === "undefined") {
          return v;
        }
        return JSON.parse(JSON.stringify(v));
      }
      var ModerationDecision = class {
        constructor(cause = void 0, alert = false, blur = false, blurMedia = false, filter = false, noOverride = false, additionalCauses = [], did2 = "") {
          this.cause = cause;
          this.alert = alert;
          this.blur = blur;
          this.blurMedia = blurMedia;
          this.filter = filter;
          this.noOverride = noOverride;
          this.additionalCauses = additionalCauses;
          this.did = did2;
        }
        static noop() {
          return new ModerationDecision();
        }
      };
      var LABELS = {
        "!hide": {
          id: "!hide",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Hide",
                description: "Moderator has chosen to hide the content."
              }
            },
            account: {
              en: {
                name: "Content Blocked",
                description: "This account has been hidden by the moderators."
              }
            },
            content: {
              en: {
                name: "Content Blocked",
                description: "This content has been hidden by the moderators."
              }
            }
          }
        },
        "!no-promote": {
          id: "!no-promote",
          preferences: ["hide"],
          flags: [],
          onwarn: null,
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Filter",
                description: "Moderator has chosen to filter the content from feeds."
              }
            },
            account: {
              en: {
                name: "N/A",
                description: "N/A"
              }
            },
            content: {
              en: {
                name: "N/A",
                description: "N/A"
              }
            }
          }
        },
        "!warn": {
          id: "!warn",
          preferences: ["warn"],
          flags: [],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Moderator Warn",
                description: "Moderator has chosen to set a general warning on the content."
              }
            },
            account: {
              en: {
                name: "Content Warning",
                description: "This account has received a general warning from moderators."
              }
            },
            content: {
              en: {
                name: "Content Warning",
                description: "This content has received a general warning from moderators."
              }
            }
          }
        },
        "!no-unauthenticated": {
          id: "!no-unauthenticated",
          preferences: ["hide"],
          flags: ["no-override", "unauthed"],
          onwarn: "blur",
          groupId: "system",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their account only be shown to signed-in users."
              }
            },
            account: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their account only be shown to signed-in users."
              }
            },
            content: {
              en: {
                name: "Sign-in Required",
                description: "This user has requested that their content only be shown to signed-in users."
              }
            }
          }
        },
        "dmca-violation": {
          id: "dmca-violation",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "legal",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Copyright Violation",
                description: "The content has received a DMCA takedown request."
              }
            },
            account: {
              en: {
                name: "Copyright Violation",
                description: "This account has received a DMCA takedown request. It will be restored if the concerns can be resolved."
              }
            },
            content: {
              en: {
                name: "Copyright Violation",
                description: "This content has received a DMCA takedown request. It will be restored if the concerns can be resolved."
              }
            }
          }
        },
        doxxing: {
          id: "doxxing",
          preferences: ["hide"],
          flags: ["no-override"],
          onwarn: "blur",
          groupId: "legal",
          configurable: false,
          strings: {
            settings: {
              en: {
                name: "Doxxing",
                description: "Information that reveals private information about someone which has been shared without the consent of the subject."
              }
            },
            account: {
              en: {
                name: "Doxxing",
                description: "This account has been reported to publish private information about someone without their consent. This report is currently under review."
              }
            },
            content: {
              en: {
                name: "Doxxing",
                description: "This content has been reported to include private information about someone without their consent."
              }
            }
          }
        },
        porn: {
          id: "porn",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Pornography",
                description: "Images of full-frontal nudity (genitalia) in any sexualized context, or explicit sexual activity (meaning contact with genitalia or breasts) even if partially covered. Includes graphic sexual cartoons (often jokes/memes)."
              }
            },
            account: {
              en: {
                name: "Adult Content",
                description: "This account contains imagery of full-frontal nudity or explicit sexual activity."
              }
            },
            content: {
              en: {
                name: "Adult Content",
                description: "This content contains imagery of full-frontal nudity or explicit sexual activity."
              }
            }
          }
        },
        sexual: {
          id: "sexual",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Sexually Suggestive",
                description: 'Content that does not meet the level of "pornography", but is still sexual. Some common examples have been selfies and "hornyposting" with underwear on, or partially naked (naked but covered, eg with hands or from side perspective). Sheer/see-through nipples may end up in this category.'
              }
            },
            account: {
              en: {
                name: "Suggestive Content",
                description: "This account contains imagery which is sexually suggestive. Common examples include selfies in underwear or in partial undress."
              }
            },
            content: {
              en: {
                name: "Suggestive Content",
                description: "This content contains imagery which is sexually suggestive. Common examples include selfies in underwear or in partial undress."
              }
            }
          }
        },
        nudity: {
          id: "nudity",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "sexual",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Nudity",
                description: 'Nudity which is not sexual, or that is primarily "artistic" in nature. For example: breastfeeding; classic art paintings and sculptures; newspaper images with some nudity; fashion modeling. "Erotic photography" is likely to end up in sexual or porn.'
              }
            },
            account: {
              en: {
                name: "Adult Content",
                description: "This account contains imagery which portrays nudity in a non-sexual or artistic setting."
              }
            },
            content: {
              en: {
                name: "Adult Content",
                description: "This content contains imagery which portrays nudity in a non-sexual or artistic setting."
              }
            }
          }
        },
        nsfl: {
          id: "nsfl",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "NSFL",
                description: `"Not Suitable For Life." This includes graphic images like the infamous "goatse" (don't look it up).`
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (NSFL)",
                description: 'This account contains graphic images which are often referred to as "Not Suitable For Life."'
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (NSFL)",
                description: 'This content contains graphic images which are often referred to as "Not Suitable For Life."'
              }
            }
          }
        },
        corpse: {
          id: "corpse",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Corpse",
                description: "Visual image of a dead human body in any context. Includes war images, hanging, funeral caskets. Does not include all figurative cases (cartoons), but can include realistic figurative images or renderings."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Corpse)",
                description: "This account contains images of a dead human body in any context. Includes war images, hanging, funeral caskets."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Corpse)",
                description: "This content contains images of a dead human body in any context. Includes war images, hanging, funeral caskets."
              }
            }
          }
        },
        gore: {
          id: "gore",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Gore",
                description: "Intended for shocking images, typically involving blood or visible wounds."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Gore)",
                description: "This account contains shocking images involving blood or visible wounds."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Gore)",
                description: "This content contains shocking images involving blood or visible wounds."
              }
            }
          }
        },
        torture: {
          id: "torture",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Torture",
                description: "Depictions of torture of a human or animal (animal cruelty)."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Torture)",
                description: "This account contains depictions of torture of a human or animal."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Torture)",
                description: "This content contains depictions of torture of a human or animal."
              }
            }
          }
        },
        "self-harm": {
          id: "self-harm",
          preferences: ["ignore", "warn", "hide"],
          flags: ["adult"],
          onwarn: "blur-media",
          groupId: "violence",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Self-Harm",
                description: "A visual depiction (photo or figurative) of cutting, suicide, or similar."
              }
            },
            account: {
              en: {
                name: "Graphic Imagery (Self-Harm)",
                description: "This account includes depictions of cutting, suicide, or other forms of self-harm."
              }
            },
            content: {
              en: {
                name: "Graphic Imagery (Self-Harm)",
                description: "This content includes depictions of cutting, suicide, or other forms of self-harm."
              }
            }
          }
        },
        "intolerant-race": {
          id: "intolerant-race",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Racial Intolerance",
                description: "Hateful or intolerant content related to race."
              }
            },
            account: {
              en: {
                name: "Intolerance (Racial)",
                description: "This account includes hateful or intolerant content related to race."
              }
            },
            content: {
              en: {
                name: "Intolerance (Racial)",
                description: "This content includes hateful or intolerant views related to race."
              }
            }
          }
        },
        "intolerant-gender": {
          id: "intolerant-gender",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Gender Intolerance",
                description: "Hateful or intolerant content related to gender or gender identity."
              }
            },
            account: {
              en: {
                name: "Intolerance (Gender)",
                description: "This account includes hateful or intolerant content related to gender or gender identity."
              }
            },
            content: {
              en: {
                name: "Intolerance (Gender)",
                description: "This content includes hateful or intolerant views related to gender or gender identity."
              }
            }
          }
        },
        "intolerant-sexual-orientation": {
          id: "intolerant-sexual-orientation",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Sexual Orientation Intolerance",
                description: "Hateful or intolerant content related to sexual preferences."
              }
            },
            account: {
              en: {
                name: "Intolerance (Orientation)",
                description: "This account includes hateful or intolerant content related to sexual preferences."
              }
            },
            content: {
              en: {
                name: "Intolerance (Orientation)",
                description: "This content includes hateful or intolerant views related to sexual preferences."
              }
            }
          }
        },
        "intolerant-religion": {
          id: "intolerant-religion",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Religious Intolerance",
                description: "Hateful or intolerant content related to religious views or practices."
              }
            },
            account: {
              en: {
                name: "Intolerance (Religious)",
                description: "This account includes hateful or intolerant content related to religious views or practices."
              }
            },
            content: {
              en: {
                name: "Intolerance (Religious)",
                description: "This content includes hateful or intolerant views related to religious views or practices."
              }
            }
          }
        },
        intolerant: {
          id: "intolerant",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Intolerance",
                description: "A catchall for hateful or intolerant content which is not covered elsewhere."
              }
            },
            account: {
              en: {
                name: "Intolerance",
                description: "This account includes hateful or intolerant content."
              }
            },
            content: {
              en: {
                name: "Intolerance",
                description: "This content includes hateful or intolerant views."
              }
            }
          }
        },
        "icon-intolerant": {
          id: "icon-intolerant",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur-media",
          groupId: "intolerance",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Intolerant Iconography",
                description: "Visual imagery associated with a hate group, such as the KKK or Nazi, in any context (supportive, critical, documentary, etc)."
              }
            },
            account: {
              en: {
                name: "Intolerant Iconography",
                description: "This account includes imagery associated with a hate group such as the KKK or Nazis. This warning may apply to content any context, including critical or documentary purposes."
              }
            },
            content: {
              en: {
                name: "Intolerant Iconography",
                description: "This content includes imagery associated with a hate group such as the KKK or Nazis. This warning may apply to content any context, including critical or documentary purposes."
              }
            }
          }
        },
        threat: {
          id: "threat",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "rude",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Threats",
                description: "Statements or imagery published with the intent to threaten, intimidate, or harm."
              }
            },
            account: {
              en: {
                name: "Threats",
                description: "The moderators believe this account has published statements or imagery with the intent to threaten, intimidate, or harm others."
              }
            },
            content: {
              en: {
                name: "Threats",
                description: "The moderators believe this content was published with the intent to threaten, intimidate, or harm others."
              }
            }
          }
        },
        spoiler: {
          id: "spoiler",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "curation",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Spoiler",
                description: "Discussion about film, TV, etc which gives away plot points."
              }
            },
            account: {
              en: {
                name: "Spoiler Warning",
                description: "This account contains discussion about film, TV, etc which gives away plot points."
              }
            },
            content: {
              en: {
                name: "Spoiler Warning",
                description: "This content contains discussion about film, TV, etc which gives away plot points."
              }
            }
          }
        },
        spam: {
          id: "spam",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "spam",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Spam",
                description: "Repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            },
            account: {
              en: {
                name: "Spam",
                description: "This account publishes repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            },
            content: {
              en: {
                name: "Spam",
                description: "This content is a part of repeat, low-quality messages which are clearly not designed to add to a conversation or space."
              }
            }
          }
        },
        "account-security": {
          id: "account-security",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Security Concerns",
                description: "Content designed to hijack user accounts such as a phishing attack."
              }
            },
            account: {
              en: {
                name: "Security Warning",
                description: "This account has published content designed to hijack user accounts such as a phishing attack."
              }
            },
            content: {
              en: {
                name: "Security Warning",
                description: "This content is designed to hijack user accounts such as a phishing attack."
              }
            }
          }
        },
        "net-abuse": {
          id: "net-abuse",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "blur",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Network Attacks",
                description: "Content designed to attack network systems such as denial-of-service attacks."
              }
            },
            account: {
              en: {
                name: "Network Attack Warning",
                description: "This account has published content designed to attack network systems such as denial-of-service attacks."
              }
            },
            content: {
              en: {
                name: "Network Attack Warning",
                description: "This content is designed to attack network systems such as denial-of-service attacks."
              }
            }
          }
        },
        impersonation: {
          id: "impersonation",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Impersonation",
                description: "Accounts which falsely assert some identity."
              }
            },
            account: {
              en: {
                name: "Impersonation Warning",
                description: "The moderators believe this account is lying about their identity."
              }
            },
            content: {
              en: {
                name: "Impersonation Warning",
                description: "The moderators believe this account is lying about their identity."
              }
            }
          }
        },
        scam: {
          id: "scam",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Scam",
                description: "Fraudulent content."
              }
            },
            account: {
              en: {
                name: "Scam Warning",
                description: "The moderators believe this account publishes fraudulent content."
              }
            },
            content: {
              en: {
                name: "Scam Warning",
                description: "The moderators believe this is fraudulent content."
              }
            }
          }
        },
        misleading: {
          id: "misleading",
          preferences: ["ignore", "warn", "hide"],
          flags: [],
          onwarn: "alert",
          groupId: "misinfo",
          configurable: true,
          strings: {
            settings: {
              en: {
                name: "Misleading",
                description: "Accounts which share misleading information."
              }
            },
            account: {
              en: {
                name: "Misleading",
                description: "The moderators believe this account is spreading misleading information."
              }
            },
            content: {
              en: {
                name: "Misleading",
                description: "The moderators believe this account is spreading misleading information."
              }
            }
          }
        }
      };
      var ModerationCauseAccumulator = class {
        constructor() {
          this.did = "";
          this.causes = [];
        }
        setDid(did2) {
          this.did = did2;
        }
        addBlocking(blocking) {
          if (blocking) {
            this.causes.push({
              type: "blocking",
              source: { type: "user" },
              priority: 3
            });
          }
        }
        addBlockingByList(blockingByList) {
          if (blockingByList) {
            this.causes.push({
              type: "blocking",
              source: { type: "list", list: blockingByList },
              priority: 3
            });
          }
        }
        addBlockedBy(blockedBy) {
          if (blockedBy) {
            this.causes.push({
              type: "blocked-by",
              source: { type: "user" },
              priority: 4
            });
          }
        }
        addBlockOther(blockOther) {
          if (blockOther) {
            this.causes.push({
              type: "block-other",
              source: { type: "user" },
              priority: 4
            });
          }
        }
        addLabel(label, opts) {
          const labelDef = LABELS[label.val];
          if (!labelDef) {
            return;
          }
          const isSelf = label.src === this.did;
          const labeler = isSelf ? void 0 : opts.labelers.find((s) => s.labeler.did === label.src);
          let labelPref = "ignore";
          if (!labelDef.configurable) {
            labelPref = labelDef.preferences[0];
          } else if (labelDef.flags.includes("adult") && !opts.adultContentEnabled) {
            labelPref = "hide";
          } else if (labeler == null ? void 0 : labeler.labels[label.val]) {
            labelPref = labeler.labels[label.val];
          } else if (opts.labels[label.val]) {
            labelPref = opts.labels[label.val];
          }
          if (labelPref === "ignore") {
            return;
          }
          if (labelDef.flags.includes("unauthed") && !!opts.userDid) {
            return;
          }
          let priority;
          if (labelDef.flags.includes("no-override")) {
            priority = 1;
          } else if (labelPref === "hide") {
            priority = 2;
          } else if (labelDef.onwarn === "blur") {
            priority = 5;
          } else if (labelDef.onwarn === "blur-media") {
            priority = 7;
          } else {
            priority = 8;
          }
          this.causes.push({
            type: "label",
            source: isSelf || !labeler ? { type: "user" } : { type: "labeler", labeler: labeler.labeler },
            label,
            labelDef,
            setting: labelPref,
            priority
          });
        }
        addMuted(muted) {
          if (muted) {
            this.causes.push({
              type: "muted",
              source: { type: "user" },
              priority: 6
            });
          }
        }
        addMutedByList(mutedByList) {
          if (mutedByList) {
            this.causes.push({
              type: "muted",
              source: { type: "list", list: mutedByList },
              priority: 6
            });
          }
        }
        finalizeDecision(opts) {
          const mod = new ModerationDecision();
          mod.did = this.did;
          if (!this.causes.length) {
            return mod;
          }
          this.causes.sort((a, b) => a.priority - b.priority);
          mod.cause = this.causes[0];
          mod.additionalCauses = this.causes.slice(1);
          if (mod.cause.type === "blocking" || mod.cause.type === "blocked-by" || mod.cause.type === "block-other") {
            mod.filter = true;
            mod.blur = true;
            mod.noOverride = true;
          } else if (mod.cause.type === "muted") {
            mod.filter = true;
            mod.blur = true;
          } else if (mod.cause.type === "label") {
            if (mod.cause.setting === "hide") {
              mod.filter = true;
            }
            switch (mod.cause.labelDef.onwarn) {
              case "alert":
                mod.alert = true;
                break;
              case "blur":
                mod.blur = true;
                break;
              case "blur-media":
                mod.blurMedia = true;
                break;
              case null:
                break;
            }
            if (mod.cause.labelDef.flags.includes("no-override")) {
              mod.noOverride = true;
            } else if (mod.cause.labelDef.flags.includes("adult") && !opts.adultContentEnabled) {
              mod.noOverride = true;
            }
          }
          return mod;
        }
      };
      function decideAccount(subject, opts) {
        var _a3, _b, _c, _d, _e, _f, _g, _h, _i;
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.did);
        if ((_a3 = subject.viewer) == null ? void 0 : _a3.muted) {
          if ((_b = subject.viewer) == null ? void 0 : _b.mutedByList) {
            acc.addMutedByList((_c = subject.viewer) == null ? void 0 : _c.mutedByList);
          } else {
            acc.addMuted((_d = subject.viewer) == null ? void 0 : _d.muted);
          }
        }
        if ((_e = subject.viewer) == null ? void 0 : _e.blocking) {
          if ((_f = subject.viewer) == null ? void 0 : _f.blockingByList) {
            acc.addBlockingByList((_g = subject.viewer) == null ? void 0 : _g.blockingByList);
          } else {
            acc.addBlocking((_h = subject.viewer) == null ? void 0 : _h.blocking);
          }
        }
        acc.addBlockedBy((_i = subject.viewer) == null ? void 0 : _i.blockedBy);
        for (const label of filterAccountLabels(subject.labels)) {
          acc.addLabel(label, opts);
        }
        return acc.finalizeDecision(opts);
      }
      function filterAccountLabels(labels) {
        if (!labels) {
          return [];
        }
        return labels.filter((label) => !label.uri.endsWith("/app.bsky.actor.profile/self") || label.val === "!no-unauthenticated");
      }
      function decideProfile(subject, opts) {
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.did);
        for (const label of filterProfileLabels(subject.labels)) {
          acc.addLabel(label, opts);
        }
        return acc.finalizeDecision(opts);
      }
      function filterProfileLabels(labels) {
        if (!labels) {
          return [];
        }
        return labels.filter((label) => label.uri.endsWith("/app.bsky.actor.profile/self"));
      }
      function decidePost(subject, opts) {
        var _a3;
        const acc = new ModerationCauseAccumulator();
        acc.setDid(subject.author.did);
        if ((_a3 = subject.labels) == null ? void 0 : _a3.length) {
          for (const label of subject.labels) {
            acc.addLabel(label, opts);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPost(subject, opts) {
        var _a3, _b, _c, _d, _e;
        const acc = new ModerationCauseAccumulator();
        if (record_exports.isViewRecord(subject.record)) {
          acc.setDid(subject.record.author.did);
          if ((_a3 = subject.record.labels) == null ? void 0 : _a3.length) {
            for (const label of subject.record.labels) {
              acc.addLabel(label, opts);
            }
          }
        } else if (record_exports.isViewBlocked(subject.record)) {
          acc.setDid(subject.record.author.did);
          if ((_b = subject.record.author.viewer) == null ? void 0 : _b.blocking) {
            acc.addBlocking((_c = subject.record.author.viewer) == null ? void 0 : _c.blocking);
          } else if ((_d = subject.record.author.viewer) == null ? void 0 : _d.blockedBy) {
            acc.addBlockedBy((_e = subject.record.author.viewer) == null ? void 0 : _e.blockedBy);
          } else {
            acc.addBlockOther(true);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPostAccount(subject, opts) {
        if (record_exports.isViewRecord(subject.record)) {
          return decideAccount(subject.record.author, opts);
        }
        return ModerationDecision.noop();
      }
      function decideQuotedPostWithMedia(subject, opts) {
        var _a3, _b, _c, _d, _e;
        const acc = new ModerationCauseAccumulator();
        if (record_exports.isViewRecord(subject.record.record)) {
          acc.setDid(subject.record.record.author.did);
          if ((_a3 = subject.record.record.labels) == null ? void 0 : _a3.length) {
            for (const label of subject.record.record.labels) {
              acc.addLabel(label, opts);
            }
          }
        } else if (record_exports.isViewBlocked(subject.record.record)) {
          acc.setDid(subject.record.record.author.did);
          if ((_b = subject.record.record.author.viewer) == null ? void 0 : _b.blocking) {
            acc.addBlocking((_c = subject.record.record.author.viewer) == null ? void 0 : _c.blocking);
          } else if ((_d = subject.record.record.author.viewer) == null ? void 0 : _d.blockedBy) {
            acc.addBlockedBy((_e = subject.record.record.author.viewer) == null ? void 0 : _e.blockedBy);
          } else {
            acc.addBlockOther(true);
          }
        }
        return acc.finalizeDecision(opts);
      }
      function decideQuotedPostWithMediaAccount(subject, opts) {
        if (record_exports.isViewRecord(subject.record.record)) {
          return decideAccount(subject.record.record.author, opts);
        }
        return ModerationDecision.noop();
      }
      function decideFeedGenerator(_subject, _opts) {
        return ModerationDecision.noop();
      }
      function decideUserList(_subject, _opts) {
        return ModerationDecision.noop();
      }
      function takeHighestPriorityDecision(...decisions) {
        const filtered = decisions.filter((d) => !!d);
        if (filtered.length === 0) {
          return ModerationDecision.noop();
        }
        filtered.sort((a, b) => {
          if (a.cause && b.cause) {
            return a.cause.priority - b.cause.priority;
          }
          if (a.cause) {
            return -1;
          }
          if (b.cause) {
            return 1;
          }
          return 0;
        });
        return filtered[0];
      }
      function downgradeDecision(decision, to) {
        decision.filter = false;
        decision.noOverride = false;
        if (to === "noop") {
          decision.blur = false;
          decision.blurMedia = false;
          decision.alert = false;
          delete decision.cause;
        } else if (to === "alert") {
          decision.blur = false;
          decision.blurMedia = false;
          decision.alert = true;
        }
      }
      function isModerationDecisionNoop(decision, { ignoreFilter } = { ignoreFilter: false }) {
        if (!decision) {
          return true;
        }
        if (decision.alert) {
          return false;
        }
        if (decision.blur) {
          return false;
        }
        if (decision.filter && !ignoreFilter) {
          return false;
        }
        return true;
      }
      function isQuotedPost(embed) {
        return Boolean(embed && record_exports.isView(embed));
      }
      function isQuotedPostWithMedia(embed) {
        return Boolean(embed && recordWithMedia_exports.isView(embed));
      }
      function toModerationUI(decision) {
        return {
          cause: decision.cause,
          filter: decision.filter,
          blur: decision.blur,
          alert: decision.alert,
          noOverride: decision.noOverride
        };
      }
      function moderateProfile(subject, opts) {
        var _a3, _b, _c, _d;
        const account = decideAccount(subject, opts);
        const profile = decideProfile(subject, opts);
        if (account.blurMedia) {
          account.blur = true;
        }
        profile.filter = false;
        if (!isModerationDecisionNoop(account) && account.did === opts.userDid) {
          downgradeDecision(account, "alert");
        }
        if (!isModerationDecisionNoop(profile) && profile.did === opts.userDid) {
          downgradeDecision(profile, "alert");
        }
        let avatarBlur = false;
        let avatarNoOverride = false;
        if ((account.blur || account.blurMedia) && ((_a3 = account.cause) == null ? void 0 : _a3.type) !== "muted") {
          avatarBlur = true;
          avatarNoOverride = account.noOverride || profile.noOverride;
        } else if (profile.blur || profile.blurMedia) {
          avatarBlur = true;
          avatarNoOverride = account.noOverride || profile.noOverride;
        }
        if (((_b = account.cause) == null ? void 0 : _b.type) === "blocking" || ((_c = account.cause) == null ? void 0 : _c.type) === "blocked-by" || ((_d = account.cause) == null ? void 0 : _d.type) === "muted") {
          account.blur = false;
          account.noOverride = false;
        }
        return {
          decisions: { account, profile },
          account: account.filter || account.blur || account.alert ? toModerationUI(account) : {},
          profile: profile.filter || profile.blur || profile.alert ? toModerationUI(profile) : {},
          avatar: {
            blur: avatarBlur,
            alert: account.alert || profile.alert,
            noOverride: avatarNoOverride
          }
        };
      }
      function moderatePost(subject, opts) {
        var _a3, _b;
        const post = decidePost(subject, opts);
        const account = decideAccount(subject.author, opts);
        const profile = decideProfile(subject.author, opts);
        let quote;
        let quotedAccount;
        if (isQuotedPost(subject.embed)) {
          quote = decideQuotedPost(subject.embed, opts);
          quotedAccount = decideQuotedPostAccount(subject.embed, opts);
        } else if (isQuotedPostWithMedia(subject.embed)) {
          quote = decideQuotedPostWithMedia(subject.embed, opts);
          quotedAccount = decideQuotedPostWithMediaAccount(subject.embed, opts);
        }
        if (quote == null ? void 0 : quote.blurMedia) {
          quote.blur = true;
        }
        if (!isModerationDecisionNoop(post) && post.did === opts.userDid) {
          downgradeDecision(post, "blur");
        }
        if (account.cause && account.did === opts.userDid) {
          downgradeDecision(account, "noop");
        }
        if (profile.cause && profile.did === opts.userDid) {
          downgradeDecision(profile, "noop");
        }
        if (quote && !isModerationDecisionNoop(quote) && quote.did === opts.userDid) {
          downgradeDecision(quote, "blur");
        }
        if (quotedAccount && !isModerationDecisionNoop(quotedAccount) && quotedAccount.did === opts.userDid) {
          downgradeDecision(quotedAccount, "noop");
        }
        const mergedForFeed = takeHighestPriorityDecision(post, account, quote, quotedAccount);
        const mergedForView = takeHighestPriorityDecision(post, account);
        const mergedQuote = takeHighestPriorityDecision(quote, quotedAccount);
        let blurAvatar = false;
        if ((account.blur || account.blurMedia) && ((_a3 = account.cause) == null ? void 0 : _a3.type) !== "muted") {
          blurAvatar = true;
        } else if ((profile.blur || profile.blurMedia) && ((_b = profile.cause) == null ? void 0 : _b.type) !== "muted") {
          blurAvatar = true;
        }
        return {
          decisions: { post, account, profile, quote, quotedAccount },
          content: {
            cause: !isModerationDecisionNoop(mergedForView) ? mergedForView.cause : mergedForFeed.filter ? mergedForFeed.cause : void 0,
            filter: mergedForFeed.filter,
            blur: mergedForView.blur,
            alert: mergedForView.alert,
            noOverride: mergedForView.noOverride
          },
          avatar: {
            blur: blurAvatar,
            alert: account.alert || profile.alert,
            noOverride: account.noOverride || profile.noOverride
          },
          embed: !isModerationDecisionNoop(mergedQuote, { ignoreFilter: true }) ? {
            cause: mergedQuote.cause,
            blur: mergedQuote.blur,
            alert: mergedQuote.alert,
            noOverride: mergedQuote.noOverride
          } : account.blurMedia ? {
            cause: account.cause,
            blur: true,
            noOverride: account.noOverride
          } : post.blurMedia ? {
            cause: post.cause,
            blur: true,
            noOverride: post.noOverride
          } : {}
        };
      }
      function moderateFeedGenerator(subject, opts) {
        const feedGenerator = decideFeedGenerator(subject, opts);
        const account = decideAccount(subject.creator, opts);
        const profile = decideProfile(subject.creator, opts);
        const merged = takeHighestPriorityDecision(feedGenerator, account);
        return {
          decisions: { feedGenerator, account, profile },
          content: {
            cause: isModerationDecisionNoop(merged) ? void 0 : merged.cause,
            filter: merged.filter,
            blur: merged.blur,
            alert: merged.alert,
            noOverride: merged.noOverride
          },
          avatar: {
            blur: account.blurMedia || profile.blurMedia,
            alert: account.alert,
            noOverride: account.noOverride || profile.noOverride
          }
        };
      }
      function moderateUserList(subject, opts) {
        const userList = decideUserList(subject, opts);
        const account = defs_exports5.isProfileViewBasic(subject.creator) ? decideAccount(subject.creator, opts) : ModerationDecision.noop();
        const profile = defs_exports5.isProfileViewBasic(subject.creator) ? decideProfile(subject.creator, opts) : ModerationDecision.noop();
        const merged = takeHighestPriorityDecision(userList, account);
        return {
          decisions: { userList, account, profile },
          content: {
            cause: isModerationDecisionNoop(merged) ? void 0 : merged.cause,
            filter: merged.filter,
            blur: merged.blur,
            alert: merged.alert,
            noOverride: merged.noOverride
          },
          avatar: {
            blur: account.blurMedia || profile.blurMedia,
            alert: account.alert,
            noOverride: account.noOverride || profile.noOverride
          }
        };
      }
      var LABEL_GROUPS = {
        system: {
          id: "system",
          configurable: false,
          labels: [
            LABELS["!hide"],
            LABELS["!no-promote"],
            LABELS["!warn"],
            LABELS["!no-unauthenticated"]
          ],
          strings: {
            settings: {
              en: {
                name: "System",
                description: "Moderator overrides for special cases."
              }
            }
          }
        },
        legal: {
          id: "legal",
          configurable: false,
          labels: [LABELS["dmca-violation"], LABELS["doxxing"]],
          strings: {
            settings: {
              en: {
                name: "Legal",
                description: "Content removed for legal reasons."
              }
            }
          }
        },
        sexual: {
          id: "sexual",
          configurable: true,
          labels: [LABELS["porn"], LABELS["sexual"], LABELS["nudity"]],
          strings: {
            settings: {
              en: {
                name: "Adult Content",
                description: "Content which is sexual in nature."
              }
            }
          }
        },
        violence: {
          id: "violence",
          configurable: true,
          labels: [
            LABELS["nsfl"],
            LABELS["corpse"],
            LABELS["gore"],
            LABELS["torture"],
            LABELS["self-harm"]
          ],
          strings: {
            settings: {
              en: {
                name: "Violence",
                description: "Content which is violent or deeply disturbing."
              }
            }
          }
        },
        intolerance: {
          id: "intolerance",
          configurable: true,
          labels: [
            LABELS["intolerant-race"],
            LABELS["intolerant-gender"],
            LABELS["intolerant-sexual-orientation"],
            LABELS["intolerant-religion"],
            LABELS["intolerant"],
            LABELS["icon-intolerant"]
          ],
          strings: {
            settings: {
              en: {
                name: "Intolerance",
                description: "Content or behavior which is hateful or intolerant toward a group of people."
              }
            }
          }
        },
        rude: {
          id: "rude",
          configurable: true,
          labels: [LABELS["threat"]],
          strings: {
            settings: {
              en: {
                name: "Rude",
                description: "Behavior which is rude toward other users."
              }
            }
          }
        },
        curation: {
          id: "curation",
          configurable: true,
          labels: [LABELS["spoiler"]],
          strings: {
            settings: {
              en: {
                name: "Curational",
                description: "Subjective moderation geared towards curating a more positive environment."
              }
            }
          }
        },
        spam: {
          id: "spam",
          configurable: true,
          labels: [LABELS["spam"]],
          strings: {
            settings: {
              en: {
                name: "Spam",
                description: "Content which doesn't add to the conversation."
              }
            }
          }
        },
        misinfo: {
          id: "misinfo",
          configurable: true,
          labels: [
            LABELS["account-security"],
            LABELS["net-abuse"],
            LABELS["impersonation"],
            LABELS["scam"],
            LABELS["misleading"]
          ],
          strings: {
            settings: {
              en: {
                name: "Misinformation",
                description: "Content which misleads or defrauds users."
              }
            }
          }
        }
      };
      var FEED_VIEW_PREF_DEFAULTS = {
        hideReplies: false,
        hideRepliesByUnfollowed: false,
        hideRepliesByLikeCount: 0,
        hideReposts: false,
        hideQuotePosts: false
      };
      var THREAD_VIEW_PREF_DEFAULTS = {
        sort: "oldest",
        prioritizeFollowedUsers: true
      };
      var BskyAgent2 = class extends AtpAgent {
        constructor() {
          super(...arguments);
          this.getTimeline = (params2, opts) => this.api.app.bsky.feed.getTimeline(params2, opts);
          this.getAuthorFeed = (params2, opts) => this.api.app.bsky.feed.getAuthorFeed(params2, opts);
          this.getActorLikes = (params2, opts) => this.api.app.bsky.feed.getActorLikes(params2, opts);
          this.getPostThread = (params2, opts) => this.api.app.bsky.feed.getPostThread(params2, opts);
          this.getPost = (params2) => this.api.app.bsky.feed.post.get(params2);
          this.getPosts = (params2, opts) => this.api.app.bsky.feed.getPosts(params2, opts);
          this.getLikes = (params2, opts) => this.api.app.bsky.feed.getLikes(params2, opts);
          this.getRepostedBy = (params2, opts) => this.api.app.bsky.feed.getRepostedBy(params2, opts);
          this.getFollows = (params2, opts) => this.api.app.bsky.graph.getFollows(params2, opts);
          this.getFollowers = (params2, opts) => this.api.app.bsky.graph.getFollowers(params2, opts);
          this.getProfile = (params2, opts) => this.api.app.bsky.actor.getProfile(params2, opts);
          this.getProfiles = (params2, opts) => this.api.app.bsky.actor.getProfiles(params2, opts);
          this.getSuggestions = (params2, opts) => this.api.app.bsky.actor.getSuggestions(params2, opts);
          this.searchActors = (params2, opts) => this.api.app.bsky.actor.searchActors(params2, opts);
          this.searchActorsTypeahead = (params2, opts) => this.api.app.bsky.actor.searchActorsTypeahead(params2, opts);
          this.listNotifications = (params2, opts) => this.api.app.bsky.notification.listNotifications(params2, opts);
          this.countUnreadNotifications = (params2, opts) => this.api.app.bsky.notification.getUnreadCount(params2, opts);
        }
        get app() {
          return this.api.app;
        }
        post(record) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            record.createdAt = record.createdAt || (/* @__PURE__ */ new Date()).toISOString();
            return this.api.app.bsky.feed.post.create({ repo: this.session.did }, record);
          });
        }
        deletePost(postUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const postUrip = new AtUri(postUri);
            return yield this.api.app.bsky.feed.post.delete({
              repo: postUrip.hostname,
              rkey: postUrip.rkey
            });
          });
        }
        like(uri2, cid2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
              subject: { uri: uri2, cid: cid2 },
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteLike(likeUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const likeUrip = new AtUri(likeUri);
            return yield this.api.app.bsky.feed.like.delete({
              repo: likeUrip.hostname,
              rkey: likeUrip.rkey
            });
          });
        }
        repost(uri2, cid2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
              subject: { uri: uri2, cid: cid2 },
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteRepost(repostUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const repostUrip = new AtUri(repostUri);
            return yield this.api.app.bsky.feed.repost.delete({
              repo: repostUrip.hostname,
              rkey: repostUrip.rkey
            });
          });
        }
        follow(subjectDid) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
              subject: subjectDid,
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        deleteFollow(followUri) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const followUrip = new AtUri(followUri);
            return yield this.api.app.bsky.graph.follow.delete({
              repo: followUrip.hostname,
              rkey: followUrip.rkey
            });
          });
        }
        upsertProfile(updateFn) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            let retriesRemaining = 5;
            while (retriesRemaining >= 0) {
              const existing = yield this.com.atproto.repo.getRecord({
                repo: this.session.did,
                collection: "app.bsky.actor.profile",
                rkey: "self"
              }).catch((_) => void 0);
              const updated = yield updateFn(existing == null ? void 0 : existing.data.value);
              if (updated) {
                updated.$type = "app.bsky.actor.profile";
              }
              const validation = profile_exports.validateRecord(updated);
              if (!validation.success) {
                throw validation.error;
              }
              try {
                yield this.com.atproto.repo.putRecord({
                  repo: this.session.did,
                  collection: "app.bsky.actor.profile",
                  rkey: "self",
                  record: updated,
                  swapRecord: (existing == null ? void 0 : existing.data.cid) || null
                });
              } catch (e) {
                if (retriesRemaining > 0 && e instanceof putRecord_exports.InvalidSwapError) {
                  retriesRemaining--;
                  continue;
                } else {
                  throw e;
                }
              }
              break;
            }
          });
        }
        mute(actor) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.muteActor({ actor });
          });
        }
        unmute(actor) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.unmuteActor({ actor });
          });
        }
        muteModList(uri2) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.muteActorList({
              list: uri2
            });
          });
        }
        unmuteModList(uri2) {
          return __async(this, null, function* () {
            return this.api.app.bsky.graph.unmuteActorList({
              list: uri2
            });
          });
        }
        blockModList(uri2) {
          return __async(this, null, function* () {
            if (!this.session) {
              throw new Error("Not logged in");
            }
            return yield this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
              subject: uri2,
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
          });
        }
        unblockModList(uri2) {
          return __async(this, null, function* () {
            var _a3;
            if (!this.session) {
              throw new Error("Not logged in");
            }
            const listInfo = yield this.api.app.bsky.graph.getList({
              list: uri2,
              limit: 1
            });
            if (!((_a3 = listInfo.data.list.viewer) == null ? void 0 : _a3.blocked)) {
              return;
            }
            const { rkey } = new AtUri(listInfo.data.list.viewer.blocked);
            return yield this.api.app.bsky.graph.listblock.delete({
              repo: this.session.did,
              rkey
            });
          });
        }
        updateSeenNotifications(seenAt) {
          return __async(this, null, function* () {
            seenAt = seenAt || (/* @__PURE__ */ new Date()).toISOString();
            return this.api.app.bsky.notification.updateSeen({
              seenAt
            });
          });
        }
        getPreferences() {
          return __async(this, null, function* () {
            const prefs = {
              feeds: {
                saved: void 0,
                pinned: void 0
              },
              feedViewPrefs: {
                home: __spreadValues({}, FEED_VIEW_PREF_DEFAULTS)
              },
              threadViewPrefs: __spreadValues({}, THREAD_VIEW_PREF_DEFAULTS),
              adultContentEnabled: false,
              contentLabels: {},
              birthDate: void 0
            };
            const res = yield this.app.bsky.actor.getPreferences({});
            for (const pref of res.data.preferences) {
              if (defs_exports5.isAdultContentPref(pref) && defs_exports5.validateAdultContentPref(pref).success) {
                prefs.adultContentEnabled = pref.enabled;
              } else if (defs_exports5.isContentLabelPref(pref) && defs_exports5.validateAdultContentPref(pref).success) {
                let value = pref.visibility;
                if (value === "show") {
                  value = "ignore";
                }
                if (value === "ignore" || value === "warn" || value === "hide") {
                  prefs.contentLabels[pref.label] = value;
                }
              } else if (defs_exports5.isSavedFeedsPref(pref) && defs_exports5.validateSavedFeedsPref(pref).success) {
                prefs.feeds.saved = pref.saved;
                prefs.feeds.pinned = pref.pinned;
              } else if (defs_exports5.isPersonalDetailsPref(pref) && defs_exports5.validatePersonalDetailsPref(pref).success) {
                if (pref.birthDate) {
                  prefs.birthDate = new Date(pref.birthDate);
                }
              } else if (defs_exports5.isFeedViewPref(pref) && defs_exports5.validateFeedViewPref(pref).success) {
                const _a3 = pref, { $type, feed } = _a3, v = __objRest(_a3, ["$type", "feed"]);
                prefs.feedViewPrefs[pref.feed] = __spreadValues(__spreadValues({}, FEED_VIEW_PREF_DEFAULTS), v);
              } else if (defs_exports5.isThreadViewPref(pref) && defs_exports5.validateThreadViewPref(pref).success) {
                const _b = pref, { $type } = _b, v = __objRest(_b, ["$type"]);
                prefs.threadViewPrefs = __spreadValues(__spreadValues({}, prefs.threadViewPrefs), v);
              }
            }
            return prefs;
          });
        }
        setSavedFeeds(saved, pinned) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, () => ({
              saved,
              pinned
            }));
          });
        }
        addSavedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: [...saved.filter((uri2) => uri2 !== v), v],
              pinned
            }));
          });
        }
        removeSavedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: saved.filter((uri2) => uri2 !== v),
              pinned: pinned.filter((uri2) => uri2 !== v)
            }));
          });
        }
        addPinnedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved: [...saved.filter((uri2) => uri2 !== v), v],
              pinned: [...pinned.filter((uri2) => uri2 !== v), v]
            }));
          });
        }
        removePinnedFeed(v) {
          return __async(this, null, function* () {
            return updateFeedPreferences(this, (saved, pinned) => ({
              saved,
              pinned: pinned.filter((uri2) => uri2 !== v)
            }));
          });
        }
        setAdultContentEnabled(v) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              let adultContentPref = prefs.findLast((pref) => defs_exports5.isAdultContentPref(pref) && defs_exports5.validateAdultContentPref(pref).success);
              if (adultContentPref) {
                adultContentPref.enabled = v;
              } else {
                adultContentPref = {
                  $type: "app.bsky.actor.defs#adultContentPref",
                  enabled: v
                };
              }
              return prefs.filter((pref) => !defs_exports5.isAdultContentPref(pref)).concat([adultContentPref]);
            });
          });
        }
        setContentLabelPref(key, value) {
          return __async(this, null, function* () {
            if (value === "show") {
              value = "ignore";
            }
            yield updatePreferences(this, (prefs) => {
              let labelPref = prefs.findLast((pref) => defs_exports5.isContentLabelPref(pref) && defs_exports5.validateAdultContentPref(pref).success && pref.label === key);
              if (labelPref) {
                labelPref.visibility = value;
              } else {
                labelPref = {
                  $type: "app.bsky.actor.defs#contentLabelPref",
                  label: key,
                  visibility: value
                };
              }
              return prefs.filter((pref) => !defs_exports5.isContentLabelPref(pref) || pref.label !== key).concat([labelPref]);
            });
          });
        }
        setPersonalDetails(_0) {
          return __async(this, arguments, function* ({
            birthDate
          }) {
            birthDate = birthDate instanceof Date ? birthDate.toISOString() : birthDate;
            yield updatePreferences(this, (prefs) => {
              let personalDetailsPref = prefs.findLast((pref) => defs_exports5.isPersonalDetailsPref(pref) && defs_exports5.validatePersonalDetailsPref(pref).success);
              if (personalDetailsPref) {
                personalDetailsPref.birthDate = birthDate;
              } else {
                personalDetailsPref = {
                  $type: "app.bsky.actor.defs#personalDetailsPref",
                  birthDate
                };
              }
              return prefs.filter((pref) => !defs_exports5.isPersonalDetailsPref(pref)).concat([personalDetailsPref]);
            });
          });
        }
        setFeedViewPrefs(feed, pref) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              const existing = prefs.findLast((pref2) => defs_exports5.isFeedViewPref(pref2) && defs_exports5.validateFeedViewPref(pref2).success && pref2.feed === feed);
              if (existing) {
                pref = __spreadValues(__spreadValues({}, existing), pref);
              }
              return prefs.filter((p) => !defs_exports5.isFeedViewPref(pref) || p.feed !== feed).concat([__spreadProps(__spreadValues({}, pref), { $type: "app.bsky.actor.defs#feedViewPref", feed })]);
            });
          });
        }
        setThreadViewPrefs(pref) {
          return __async(this, null, function* () {
            yield updatePreferences(this, (prefs) => {
              const existing = prefs.findLast((pref2) => defs_exports5.isThreadViewPref(pref2) && defs_exports5.validateThreadViewPref(pref2).success);
              if (existing) {
                pref = __spreadValues(__spreadValues({}, existing), pref);
              }
              return prefs.filter((p) => !defs_exports5.isThreadViewPref(p)).concat([__spreadProps(__spreadValues({}, pref), { $type: "app.bsky.actor.defs#threadViewPref" })]);
            });
          });
        }
      };
      function updatePreferences(agent, cb) {
        return __async(this, null, function* () {
          const res = yield agent.app.bsky.actor.getPreferences({});
          const newPrefs = cb(res.data.preferences);
          if (newPrefs === false) {
            return;
          }
          yield agent.app.bsky.actor.putPreferences({
            preferences: newPrefs
          });
        });
      }
      function updateFeedPreferences(agent, cb) {
        return __async(this, null, function* () {
          let res;
          yield updatePreferences(agent, (prefs) => {
            let feedsPref = prefs.findLast((pref) => defs_exports5.isSavedFeedsPref(pref) && defs_exports5.validateSavedFeedsPref(pref).success);
            if (feedsPref) {
              res = cb(feedsPref.saved, feedsPref.pinned);
              feedsPref.saved = res.saved;
              feedsPref.pinned = res.pinned;
            } else {
              res = cb([], []);
              feedsPref = {
                $type: "app.bsky.actor.defs#savedFeedsPref",
                saved: res.saved,
                pinned: res.pinned
              };
            }
            return prefs.filter((pref) => !defs_exports5.isSavedFeedsPref(pref)).concat([feedsPref]);
          });
          return res;
        });
      }
    }
  });

  // node_modules/varint/encode.js
  var require_encode = __commonJS({
    "node_modules/varint/encode.js"(exports, module2) {
      module2.exports = encode10;
      var MSB4 = 128;
      var REST4 = 127;
      var MSBALL4 = ~REST4;
      var INT4 = Math.pow(2, 31);
      function encode10(num, out, offset) {
        if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
          encode10.bytes = 0;
          throw new RangeError("Could not encode varint");
        }
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT4) {
          out[offset++] = num & 255 | MSB4;
          num /= 128;
        }
        while (num & MSBALL4) {
          out[offset++] = num & 255 | MSB4;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode10.bytes = offset - oldOffset + 1;
        return out;
      }
    }
  });

  // node_modules/varint/decode.js
  var require_decode = __commonJS({
    "node_modules/varint/decode.js"(exports, module2) {
      module2.exports = read5;
      var MSB4 = 128;
      var REST4 = 127;
      function read5(buf2, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
        do {
          if (counter >= l || shift > 49) {
            read5.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf2[counter++];
          res += shift < 28 ? (b & REST4) << shift : (b & REST4) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB4);
        read5.bytes = counter - offset;
        return res;
      }
    }
  });

  // node_modules/varint/length.js
  var require_length = __commonJS({
    "node_modules/varint/length.js"(exports, module2) {
      var N14 = Math.pow(2, 7);
      var N24 = Math.pow(2, 14);
      var N34 = Math.pow(2, 21);
      var N44 = Math.pow(2, 28);
      var N54 = Math.pow(2, 35);
      var N64 = Math.pow(2, 42);
      var N74 = Math.pow(2, 49);
      var N84 = Math.pow(2, 56);
      var N94 = Math.pow(2, 63);
      module2.exports = function(value) {
        return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
      };
    }
  });

  // node_modules/varint/index.js
  var require_varint = __commonJS({
    "node_modules/varint/index.js"(exports, module2) {
      module2.exports = {
        encode: require_encode(),
        decode: require_decode(),
        encodingLength: require_length()
      };
    }
  });

  // node_modules/xterm/lib/xterm.js
  var require_xterm = __commonJS({
    "node_modules/xterm/lib/xterm.js"(exports, module2) {
      !function(e, t) {
        if ("object" == typeof exports && "object" == typeof module2)
          module2.exports = t();
        else if ("function" == typeof define && define.amd)
          define([], t);
        else {
          var i = t();
          for (var s in i)
            ("object" == typeof exports ? exports : e)[s] = i[s];
        }
      }(self, () => (() => {
        "use strict";
        var e = { 4567: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.AccessibilityManager = void 0;
          const n = i2(9042), o = i2(6114), a = i2(9924), h = i2(844), c = i2(5596), l = i2(4725), d = i2(3656);
          let _ = t2.AccessibilityManager = class extends h.Disposable {
            constructor(e3, t3) {
              super(), this._terminal = e3, this._renderService = t3, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
              for (let e4 = 0; e4 < this._terminal.rows; e4++)
                this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
              if (this._topBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 0), this._bottomBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new a.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element)
                throw new Error("Cannot enable accessibility before Terminal.open");
              this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((e4) => this._handleResize(e4.rows))), this.register(this._terminal.onRender((e4) => this._refreshRows(e4.start, e4.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((e4) => this._handleChar(e4))), this.register(this._terminal.onLineFeed(() => this._handleChar("\n"))), this.register(this._terminal.onA11yTab((e4) => this._handleTab(e4))), this.register(this._terminal.onKey((e4) => this._handleKey(e4.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new c.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, d.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, h.toDisposable)(() => {
                this._accessibilityContainer.remove(), this._rowElements.length = 0;
              }));
            }
            _handleTab(e3) {
              for (let t3 = 0; t3 < e3; t3++)
                this._handleChar(" ");
            }
            _handleChar(e3) {
              this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e3 && (this._charsToAnnounce += e3) : this._charsToAnnounce += e3, "\n" === e3 && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += n.tooMuchOutput)), o.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {
                this._accessibilityContainer.appendChild(this._liveRegion);
              }, 0));
            }
            _clearLiveRegion() {
              this._liveRegion.textContent = "", this._liveRegionLineCount = 0, o.isMac && this._liveRegion.remove();
            }
            _handleKey(e3) {
              this._clearLiveRegion(), new RegExp("\\p{Control}", "u").test(e3) || this._charsToConsume.push(e3);
            }
            _refreshRows(e3, t3) {
              this._liveRegionDebouncer.refresh(e3, t3, this._terminal.rows);
            }
            _renderRows(e3, t3) {
              const i3 = this._terminal.buffer, s3 = i3.lines.length.toString();
              for (let r2 = e3; r2 <= t3; r2++) {
                const e4 = i3.translateBufferLineToString(i3.ydisp + r2, true), t4 = (i3.ydisp + r2 + 1).toString(), n2 = this._rowElements[r2];
                n2 && (0 === e4.length ? n2.innerText = "\xA0" : n2.textContent = e4, n2.setAttribute("aria-posinset", t4), n2.setAttribute("aria-setsize", s3));
              }
              this._announceCharacters();
            }
            _announceCharacters() {
              0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
            }
            _handleBoundaryFocus(e3, t3) {
              const i3 = e3.target, s3 = this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2];
              if (i3.getAttribute("aria-posinset") === (0 === t3 ? "1" : `${this._terminal.buffer.lines.length}`))
                return;
              if (e3.relatedTarget !== s3)
                return;
              let r2, n2;
              if (0 === t3 ? (r2 = i3, n2 = this._rowElements.pop(), this._rowContainer.removeChild(n2)) : (r2 = this._rowElements.shift(), n2 = i3, this._rowContainer.removeChild(r2)), r2.removeEventListener("focus", this._topBoundaryFocusListener), n2.removeEventListener("focus", this._bottomBoundaryFocusListener), 0 === t3) {
                const e4 = this._createAccessibilityTreeNode();
                this._rowElements.unshift(e4), this._rowContainer.insertAdjacentElement("afterbegin", e4);
              } else {
                const e4 = this._createAccessibilityTreeNode();
                this._rowElements.push(e4), this._rowContainer.appendChild(e4);
              }
              this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t3 ? -1 : 1), this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2].focus(), e3.preventDefault(), e3.stopImmediatePropagation();
            }
            _handleResize(e3) {
              this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
              for (let e4 = this._rowContainer.children.length; e4 < this._terminal.rows; e4++)
                this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
              for (; this._rowElements.length > e3; )
                this._rowContainer.removeChild(this._rowElements.pop());
              this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
            }
            _createAccessibilityTreeNode() {
              const e3 = document.createElement("div");
              return e3.setAttribute("role", "listitem"), e3.tabIndex = -1, this._refreshRowDimensions(e3), e3;
            }
            _refreshRowsDimensions() {
              if (this._renderService.dimensions.css.cell.height) {
                this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
                for (let e3 = 0; e3 < this._terminal.rows; e3++)
                  this._refreshRowDimensions(this._rowElements[e3]);
              }
            }
            _refreshRowDimensions(e3) {
              e3.style.height = `${this._renderService.dimensions.css.cell.height}px`;
            }
          };
          t2.AccessibilityManager = _ = s2([r(1, l.IRenderService)], _);
        }, 3614: (e2, t2) => {
          function i2(e3) {
            return e3.replace(/\r?\n/g, "\r");
          }
          function s2(e3, t3) {
            return t3 ? "\x1B[200~" + e3 + "\x1B[201~" : e3;
          }
          function r(e3, t3, r2, n2) {
            e3 = s2(e3 = i2(e3), r2.decPrivateModes.bracketedPasteMode && true !== n2.rawOptions.ignoreBracketedPasteMode), r2.triggerDataEvent(e3, true), t3.value = "";
          }
          function n(e3, t3, i3) {
            const s3 = i3.getBoundingClientRect(), r2 = e3.clientX - s3.left - 10, n2 = e3.clientY - s3.top - 10;
            t3.style.width = "20px", t3.style.height = "20px", t3.style.left = `${r2}px`, t3.style.top = `${n2}px`, t3.style.zIndex = "1000", t3.focus();
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.rightClickHandler = t2.moveTextAreaUnderMouseCursor = t2.paste = t2.handlePasteEvent = t2.copyHandler = t2.bracketTextForPaste = t2.prepareTextForTerminal = void 0, t2.prepareTextForTerminal = i2, t2.bracketTextForPaste = s2, t2.copyHandler = function(e3, t3) {
            e3.clipboardData && e3.clipboardData.setData("text/plain", t3.selectionText), e3.preventDefault();
          }, t2.handlePasteEvent = function(e3, t3, i3, s3) {
            e3.stopPropagation(), e3.clipboardData && r(e3.clipboardData.getData("text/plain"), t3, i3, s3);
          }, t2.paste = r, t2.moveTextAreaUnderMouseCursor = n, t2.rightClickHandler = function(e3, t3, i3, s3, r2) {
            n(e3, t3, i3), r2 && s3.rightClickSelect(e3), t3.value = s3.selectionText, t3.select();
          };
        }, 7239: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorContrastCache = void 0;
          const s2 = i2(1505);
          t2.ColorContrastCache = class {
            constructor() {
              this._color = new s2.TwoKeyMap(), this._css = new s2.TwoKeyMap();
            }
            setCss(e3, t3, i3) {
              this._css.set(e3, t3, i3);
            }
            getCss(e3, t3) {
              return this._css.get(e3, t3);
            }
            setColor(e3, t3, i3) {
              this._color.set(e3, t3, i3);
            }
            getColor(e3, t3) {
              return this._color.get(e3, t3);
            }
            clear() {
              this._color.clear(), this._css.clear();
            }
          };
        }, 3656: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.addDisposableDomListener = void 0, t2.addDisposableDomListener = function(e3, t3, i2, s2) {
            e3.addEventListener(t3, i2, s2);
            let r = false;
            return { dispose: () => {
              r || (r = true, e3.removeEventListener(t3, i2, s2));
            } };
          };
        }, 6465: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Linkifier2 = void 0;
          const n = i2(3656), o = i2(8460), a = i2(844), h = i2(2585);
          let c = t2.Linkifier2 = class extends a.Disposable {
            get currentLink() {
              return this._currentLink;
            }
            constructor(e3) {
              super(), this._bufferService = e3, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)(() => {
                this._lastMouseEvent = void 0;
              })), this.register(this._bufferService.onResize(() => {
                this._clearCurrentLink(), this._wasResized = true;
              }));
            }
            registerLinkProvider(e3) {
              return this._linkProviders.push(e3), { dispose: () => {
                const t3 = this._linkProviders.indexOf(e3);
                -1 !== t3 && this._linkProviders.splice(t3, 1);
              } };
            }
            attachToDom(e3, t3, i3) {
              this._element = e3, this._mouseService = t3, this._renderService = i3, this.register((0, n.addDisposableDomListener)(this._element, "mouseleave", () => {
                this._isMouseOut = true, this._clearCurrentLink();
              })), this.register((0, n.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
            }
            _handleMouseMove(e3) {
              if (this._lastMouseEvent = e3, !this._element || !this._mouseService)
                return;
              const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
              if (!t3)
                return;
              this._isMouseOut = false;
              const i3 = e3.composedPath();
              for (let e4 = 0; e4 < i3.length; e4++) {
                const t4 = i3[e4];
                if (t4.classList.contains("xterm"))
                  break;
                if (t4.classList.contains("xterm-hover"))
                  return;
              }
              this._lastBufferCell && t3.x === this._lastBufferCell.x && t3.y === this._lastBufferCell.y || (this._handleHover(t3), this._lastBufferCell = t3);
            }
            _handleHover(e3) {
              if (this._activeLine !== e3.y || this._wasResized)
                return this._clearCurrentLink(), this._askForLink(e3, false), void (this._wasResized = false);
              this._currentLink && this._linkAtPosition(this._currentLink.link, e3) || (this._clearCurrentLink(), this._askForLink(e3, true));
            }
            _askForLink(e3, t3) {
              var i3, s3;
              this._activeProviderReplies && t3 || (null === (i3 = this._activeProviderReplies) || void 0 === i3 || i3.forEach((e4) => {
                null == e4 || e4.forEach((e5) => {
                  e5.link.dispose && e5.link.dispose();
                });
              }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = e3.y);
              let r2 = false;
              for (const [i4, n2] of this._linkProviders.entries())
                t3 ? (null === (s3 = this._activeProviderReplies) || void 0 === s3 ? void 0 : s3.get(i4)) && (r2 = this._checkLinkProviderResult(i4, e3, r2)) : n2.provideLinks(e3.y, (t4) => {
                  var s4, n3;
                  if (this._isMouseOut)
                    return;
                  const o2 = null == t4 ? void 0 : t4.map((e4) => ({ link: e4 }));
                  null === (s4 = this._activeProviderReplies) || void 0 === s4 || s4.set(i4, o2), r2 = this._checkLinkProviderResult(i4, e3, r2), (null === (n3 = this._activeProviderReplies) || void 0 === n3 ? void 0 : n3.size) === this._linkProviders.length && this._removeIntersectingLinks(e3.y, this._activeProviderReplies);
                });
            }
            _removeIntersectingLinks(e3, t3) {
              const i3 = /* @__PURE__ */ new Set();
              for (let s3 = 0; s3 < t3.size; s3++) {
                const r2 = t3.get(s3);
                if (r2)
                  for (let t4 = 0; t4 < r2.length; t4++) {
                    const s4 = r2[t4], n2 = s4.link.range.start.y < e3 ? 0 : s4.link.range.start.x, o2 = s4.link.range.end.y > e3 ? this._bufferService.cols : s4.link.range.end.x;
                    for (let e4 = n2; e4 <= o2; e4++) {
                      if (i3.has(e4)) {
                        r2.splice(t4--, 1);
                        break;
                      }
                      i3.add(e4);
                    }
                  }
              }
            }
            _checkLinkProviderResult(e3, t3, i3) {
              var s3;
              if (!this._activeProviderReplies)
                return i3;
              const r2 = this._activeProviderReplies.get(e3);
              let n2 = false;
              for (let t4 = 0; t4 < e3; t4++)
                this._activeProviderReplies.has(t4) && !this._activeProviderReplies.get(t4) || (n2 = true);
              if (!n2 && r2) {
                const e4 = r2.find((e5) => this._linkAtPosition(e5.link, t3));
                e4 && (i3 = true, this._handleNewLink(e4));
              }
              if (this._activeProviderReplies.size === this._linkProviders.length && !i3)
                for (let e4 = 0; e4 < this._activeProviderReplies.size; e4++) {
                  const r3 = null === (s3 = this._activeProviderReplies.get(e4)) || void 0 === s3 ? void 0 : s3.find((e5) => this._linkAtPosition(e5.link, t3));
                  if (r3) {
                    i3 = true, this._handleNewLink(r3);
                    break;
                  }
                }
              return i3;
            }
            _handleMouseDown() {
              this._mouseDownLink = this._currentLink;
            }
            _handleMouseUp(e3) {
              if (!this._element || !this._mouseService || !this._currentLink)
                return;
              const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
              t3 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t3) && this._currentLink.link.activate(e3, this._currentLink.link.text);
            }
            _clearCurrentLink(e3, t3) {
              this._element && this._currentLink && this._lastMouseEvent && (!e3 || !t3 || this._currentLink.link.range.start.y >= e3 && this._currentLink.link.range.end.y <= t3) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));
            }
            _handleNewLink(e3) {
              if (!this._element || !this._lastMouseEvent || !this._mouseService)
                return;
              const t3 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
              t3 && this._linkAtPosition(e3.link, t3) && (this._currentLink = e3, this._currentLink.state = { decorations: { underline: void 0 === e3.link.decorations || e3.link.decorations.underline, pointerCursor: void 0 === e3.link.decorations || e3.link.decorations.pointerCursor }, isHovered: true }, this._linkHover(this._element, e3.link, this._lastMouseEvent), e3.link.decorations = {}, Object.defineProperties(e3.link.decorations, { pointerCursor: { get: () => {
                var e4, t4;
                return null === (t4 = null === (e4 = this._currentLink) || void 0 === e4 ? void 0 : e4.state) || void 0 === t4 ? void 0 : t4.decorations.pointerCursor;
              }, set: (e4) => {
                var t4, i3;
                (null === (t4 = this._currentLink) || void 0 === t4 ? void 0 : t4.state) && this._currentLink.state.decorations.pointerCursor !== e4 && (this._currentLink.state.decorations.pointerCursor = e4, this._currentLink.state.isHovered && (null === (i3 = this._element) || void 0 === i3 || i3.classList.toggle("xterm-cursor-pointer", e4)));
              } }, underline: { get: () => {
                var e4, t4;
                return null === (t4 = null === (e4 = this._currentLink) || void 0 === e4 ? void 0 : e4.state) || void 0 === t4 ? void 0 : t4.decorations.underline;
              }, set: (t4) => {
                var i3, s3, r2;
                (null === (i3 = this._currentLink) || void 0 === i3 ? void 0 : i3.state) && (null === (r2 = null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) || void 0 === r2 ? void 0 : r2.decorations.underline) !== t4 && (this._currentLink.state.decorations.underline = t4, this._currentLink.state.isHovered && this._fireUnderlineEvent(e3.link, t4));
              } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((e4) => {
                if (!this._currentLink)
                  return;
                const t4 = 0 === e4.start ? 0 : e4.start + 1 + this._bufferService.buffer.ydisp, i3 = this._bufferService.buffer.ydisp + 1 + e4.end;
                if (this._currentLink.link.range.start.y >= t4 && this._currentLink.link.range.end.y <= i3 && (this._clearCurrentLink(t4, i3), this._lastMouseEvent && this._element)) {
                  const e5 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                  e5 && this._askForLink(e5, false);
                }
              })));
            }
            _linkHover(e3, t3, i3) {
              var s3;
              (null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, true), this._currentLink.state.decorations.pointerCursor && e3.classList.add("xterm-cursor-pointer")), t3.hover && t3.hover(i3, t3.text);
            }
            _fireUnderlineEvent(e3, t3) {
              const i3 = e3.range, s3 = this._bufferService.buffer.ydisp, r2 = this._createLinkUnderlineEvent(i3.start.x - 1, i3.start.y - s3 - 1, i3.end.x, i3.end.y - s3 - 1, void 0);
              (t3 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r2);
            }
            _linkLeave(e3, t3, i3) {
              var s3;
              (null === (s3 = this._currentLink) || void 0 === s3 ? void 0 : s3.state) && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, false), this._currentLink.state.decorations.pointerCursor && e3.classList.remove("xterm-cursor-pointer")), t3.leave && t3.leave(i3, t3.text);
            }
            _linkAtPosition(e3, t3) {
              const i3 = e3.range.start.y * this._bufferService.cols + e3.range.start.x, s3 = e3.range.end.y * this._bufferService.cols + e3.range.end.x, r2 = t3.y * this._bufferService.cols + t3.x;
              return i3 <= r2 && r2 <= s3;
            }
            _positionFromMouseEvent(e3, t3, i3) {
              const s3 = i3.getCoords(e3, t3, this._bufferService.cols, this._bufferService.rows);
              if (s3)
                return { x: s3[0], y: s3[1] + this._bufferService.buffer.ydisp };
            }
            _createLinkUnderlineEvent(e3, t3, i3, s3, r2) {
              return { x1: e3, y1: t3, x2: i3, y2: s3, cols: this._bufferService.cols, fg: r2 };
            }
          };
          t2.Linkifier2 = c = s2([r(0, h.IBufferService)], c);
        }, 9042: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.tooMuchOutput = t2.promptLabel = void 0, t2.promptLabel = "Terminal input", t2.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
        }, 3730: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkProvider = void 0;
          const n = i2(511), o = i2(2585);
          let a = t2.OscLinkProvider = class {
            constructor(e3, t3, i3) {
              this._bufferService = e3, this._optionsService = t3, this._oscLinkService = i3;
            }
            provideLinks(e3, t3) {
              var i3;
              const s3 = this._bufferService.buffer.lines.get(e3 - 1);
              if (!s3)
                return void t3(void 0);
              const r2 = [], o2 = this._optionsService.rawOptions.linkHandler, a2 = new n.CellData(), c = s3.getTrimmedLength();
              let l = -1, d = -1, _ = false;
              for (let t4 = 0; t4 < c; t4++)
                if (-1 !== d || s3.hasContent(t4)) {
                  if (s3.loadCell(t4, a2), a2.hasExtendedAttrs() && a2.extended.urlId) {
                    if (-1 === d) {
                      d = t4, l = a2.extended.urlId;
                      continue;
                    }
                    _ = a2.extended.urlId !== l;
                  } else
                    -1 !== d && (_ = true);
                  if (_ || -1 !== d && t4 === c - 1) {
                    const s4 = null === (i3 = this._oscLinkService.getLinkData(l)) || void 0 === i3 ? void 0 : i3.uri;
                    if (s4) {
                      const i4 = { start: { x: d + 1, y: e3 }, end: { x: t4 + (_ || t4 !== c - 1 ? 0 : 1), y: e3 } };
                      let n2 = false;
                      if (!(null == o2 ? void 0 : o2.allowNonHttpProtocols))
                        try {
                          const e4 = new URL(s4);
                          ["http:", "https:"].includes(e4.protocol) || (n2 = true);
                        } catch (e4) {
                          n2 = true;
                        }
                      n2 || r2.push({ text: s4, range: i4, activate: (e4, t5) => o2 ? o2.activate(e4, t5, i4) : h(0, t5), hover: (e4, t5) => {
                        var s5;
                        return null === (s5 = null == o2 ? void 0 : o2.hover) || void 0 === s5 ? void 0 : s5.call(o2, e4, t5, i4);
                      }, leave: (e4, t5) => {
                        var s5;
                        return null === (s5 = null == o2 ? void 0 : o2.leave) || void 0 === s5 ? void 0 : s5.call(o2, e4, t5, i4);
                      } });
                    }
                    _ = false, a2.hasExtendedAttrs() && a2.extended.urlId ? (d = t4, l = a2.extended.urlId) : (d = -1, l = -1);
                  }
                }
              t3(r2);
            }
          };
          function h(e3, t3) {
            if (confirm(`Do you want to navigate to ${t3}?

WARNING: This link could potentially be dangerous`)) {
              const e4 = window.open();
              if (e4) {
                try {
                  e4.opener = null;
                } catch (e5) {
                }
                e4.location.href = t3;
              } else
                console.warn("Opening link blocked as opener could not be cleared");
            }
          }
          t2.OscLinkProvider = a = s2([r(0, o.IBufferService), r(1, o.IOptionsService), r(2, o.IOscLinkService)], a);
        }, 6193: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderDebouncer = void 0, t2.RenderDebouncer = class {
            constructor(e3, t3) {
              this._parentWindow = e3, this._renderCallback = t3, this._refreshCallbacks = [];
            }
            dispose() {
              this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
            }
            addRefreshCallback(e3) {
              return this._refreshCallbacks.push(e3), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
            }
            refresh(e3, t3, i2) {
              this._rowCount = i2, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
            }
            _innerRefresh() {
              if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount)
                return void this._runRefreshCallbacks();
              const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
              this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3), this._runRefreshCallbacks();
            }
            _runRefreshCallbacks() {
              for (const e3 of this._refreshCallbacks)
                e3(0);
              this._refreshCallbacks = [];
            }
          };
        }, 5596: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ScreenDprMonitor = void 0;
          const s2 = i2(844);
          class r extends s2.Disposable {
            constructor(e3) {
              super(), this._parentWindow = e3, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, s2.toDisposable)(() => {
                this.clearListener();
              }));
            }
            setListener(e3) {
              this._listener && this.clearListener(), this._listener = e3, this._outerListener = () => {
                this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
              }, this._updateDpr();
            }
            _updateDpr() {
              var e3;
              this._outerListener && (null === (e3 = this._resolutionMediaMatchList) || void 0 === e3 || e3.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
            }
            clearListener() {
              this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
            }
          }
          t2.ScreenDprMonitor = r;
        }, 3236: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Terminal = void 0;
          const s2 = i2(3614), r = i2(3656), n = i2(6465), o = i2(9042), a = i2(3730), h = i2(1680), c = i2(3107), l = i2(5744), d = i2(2950), _ = i2(1296), u = i2(428), f = i2(4269), v = i2(5114), p = i2(8934), g = i2(3230), m = i2(9312), S = i2(4725), C = i2(6731), b = i2(8055), y = i2(8969), w = i2(8460), E = i2(844), k = i2(6114), L = i2(8437), D = i2(2584), R = i2(7399), x = i2(5941), A = i2(9074), B = i2(2585), T = i2(5435), M = i2(4567), O = "undefined" != typeof window ? window.document : null;
          class P extends y.CoreTerminal {
            get onFocus() {
              return this._onFocus.event;
            }
            get onBlur() {
              return this._onBlur.event;
            }
            get onA11yChar() {
              return this._onA11yCharEmitter.event;
            }
            get onA11yTab() {
              return this._onA11yTabEmitter.event;
            }
            get onWillOpen() {
              return this._onWillOpen.event;
            }
            constructor(e3 = {}) {
              super(e3), this.browser = k, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._accessibilityManager = this.register(new E.MutableDisposable()), this._onCursorMove = this.register(new w.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new w.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new w.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new w.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new w.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new w.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new w.EventEmitter()), this._onBlur = this.register(new w.EventEmitter()), this._onA11yCharEmitter = this.register(new w.EventEmitter()), this._onA11yTabEmitter = this.register(new w.EventEmitter()), this._onWillOpen = this.register(new w.EventEmitter()), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(n.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(a.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(B.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((e4, t3) => this.refresh(e4, t3))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((e4) => this._reportWindowsOptions(e4))), this.register(this._inputHandler.onColor((e4) => this._handleColorEvent(e4))), this.register((0, w.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, w.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, w.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, w.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((e4) => this._afterResize(e4.cols, e4.rows))), this.register((0, E.toDisposable)(() => {
                var e4, t3;
                this._customKeyEventHandler = void 0, null === (t3 = null === (e4 = this.element) || void 0 === e4 ? void 0 : e4.parentNode) || void 0 === t3 || t3.removeChild(this.element);
              }));
            }
            _handleColorEvent(e3) {
              if (this._themeService)
                for (const t3 of e3) {
                  let e4, i3 = "";
                  switch (t3.index) {
                    case 256:
                      e4 = "foreground", i3 = "10";
                      break;
                    case 257:
                      e4 = "background", i3 = "11";
                      break;
                    case 258:
                      e4 = "cursor", i3 = "12";
                      break;
                    default:
                      e4 = "ansi", i3 = "4;" + t3.index;
                  }
                  switch (t3.type) {
                    case 0:
                      const s3 = b.color.toColorRGB("ansi" === e4 ? this._themeService.colors.ansi[t3.index] : this._themeService.colors[e4]);
                      this.coreService.triggerDataEvent(`${D.C0.ESC}]${i3};${(0, x.toRgbString)(s3)}${D.C1_ESCAPED.ST}`);
                      break;
                    case 1:
                      if ("ansi" === e4)
                        this._themeService.modifyColors((e5) => e5.ansi[t3.index] = b.rgba.toColor(...t3.color));
                      else {
                        const i4 = e4;
                        this._themeService.modifyColors((e5) => e5[i4] = b.rgba.toColor(...t3.color));
                      }
                      break;
                    case 2:
                      this._themeService.restoreColor(t3.index);
                  }
                }
            }
            _setup() {
              super._setup(), this._customKeyEventHandler = void 0;
            }
            get buffer() {
              return this.buffers.active;
            }
            focus() {
              this.textarea && this.textarea.focus({ preventScroll: true });
            }
            _handleScreenReaderModeOptionChange(e3) {
              e3 ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)) : this._accessibilityManager.clear();
            }
            _handleTextAreaFocus(e3) {
              this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[I"), this.updateCursorStyle(e3), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
            }
            blur() {
              var e3;
              return null === (e3 = this.textarea) || void 0 === e3 ? void 0 : e3.blur();
            }
            _handleTextAreaBlur() {
              this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
            }
            _syncTextArea() {
              if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService)
                return;
              const e3 = this.buffer.ybase + this.buffer.y, t3 = this.buffer.lines.get(e3);
              if (!t3)
                return;
              const i3 = Math.min(this.buffer.x, this.cols - 1), s3 = this._renderService.dimensions.css.cell.height, r2 = t3.getWidth(i3), n2 = this._renderService.dimensions.css.cell.width * r2, o2 = this.buffer.y * this._renderService.dimensions.css.cell.height, a2 = i3 * this._renderService.dimensions.css.cell.width;
              this.textarea.style.left = a2 + "px", this.textarea.style.top = o2 + "px", this.textarea.style.width = n2 + "px", this.textarea.style.height = s3 + "px", this.textarea.style.lineHeight = s3 + "px", this.textarea.style.zIndex = "-5";
            }
            _initGlobal() {
              this._bindKeys(), this.register((0, r.addDisposableDomListener)(this.element, "copy", (e4) => {
                this.hasSelection() && (0, s2.copyHandler)(e4, this._selectionService);
              }));
              const e3 = (e4) => (0, s2.handlePasteEvent)(e4, this.textarea, this.coreService, this.optionsService);
              this.register((0, r.addDisposableDomListener)(this.textarea, "paste", e3)), this.register((0, r.addDisposableDomListener)(this.element, "paste", e3)), k.isFirefox ? this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => {
                2 === e4.button && (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
              })) : this.register((0, r.addDisposableDomListener)(this.element, "contextmenu", (e4) => {
                (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
              })), k.isLinux && this.register((0, r.addDisposableDomListener)(this.element, "auxclick", (e4) => {
                1 === e4.button && (0, s2.moveTextAreaUnderMouseCursor)(e4, this.textarea, this.screenElement);
              }));
            }
            _bindKeys() {
              this.register((0, r.addDisposableDomListener)(this.textarea, "keyup", (e3) => this._keyUp(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keydown", (e3) => this._keyDown(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keypress", (e3) => this._keyPress(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionupdate", (e3) => this._compositionHelper.compositionupdate(e3))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, r.addDisposableDomListener)(this.textarea, "input", (e3) => this._inputEvent(e3), true)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
            }
            open(e3) {
              var t3;
              if (!e3)
                throw new Error("Terminal requires a parent element.");
              e3.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = e3.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e3.appendChild(this.element);
              const i3 = O.createDocumentFragment();
              this._viewportElement = O.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), i3.appendChild(this._viewportElement), this._viewportScrollArea = O.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = O.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = O.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), i3.appendChild(this.screenElement), this.textarea = O.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", o.promptLabel), k.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(v.CoreBrowserService, this.textarea, null !== (t3 = this._document.defaultView) && void 0 !== t3 ? t3 : window), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, r.addDisposableDomListener)(this.textarea, "focus", (e4) => this._handleTextAreaFocus(e4))), this.register((0, r.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(u.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(C.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(f.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(g.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((e4) => this._onRender.fire(e4))), this.onResize((e4) => this._renderService.resize(e4.cols, e4.rows)), this._compositionView = O.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(d.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(i3);
              try {
                this._onWillOpen.fire(this.element);
              } catch (e4) {
              }
              this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(p.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(h.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
                this._renderService.handleCursorMove(), this._syncTextArea();
              })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(m.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((e4) => this._renderService.handleSelectionChanged(e4.start, e4.end, e4.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((e4) => {
                this.textarea.value = e4, this.textarea.focus(), this.textarea.select();
              })), this.register(this._onScroll.event((e4) => {
                this.viewport.syncScrollArea(), this._selectionService.refresh();
              })), this.register((0, r.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(c.BufferDecorationRenderer, this.screenElement)), this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => this._selectionService.handleMouseDown(e4))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (e4) => this._handleScreenReaderModeOptionChange(e4))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (e4) => {
                !this._overviewRulerRenderer && e4 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
              }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
            }
            _createRenderer() {
              return this._instantiationService.createInstance(_.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
            }
            bindMouse() {
              const e3 = this, t3 = this.element;
              function i3(t4) {
                const i4 = e3._mouseService.getMouseReportCoords(t4, e3.screenElement);
                if (!i4)
                  return false;
                let s4, r2;
                switch (t4.overrideType || t4.type) {
                  case "mousemove":
                    r2 = 32, void 0 === t4.buttons ? (s4 = 3, void 0 !== t4.button && (s4 = t4.button < 3 ? t4.button : 3)) : s4 = 1 & t4.buttons ? 0 : 4 & t4.buttons ? 1 : 2 & t4.buttons ? 2 : 3;
                    break;
                  case "mouseup":
                    r2 = 0, s4 = t4.button < 3 ? t4.button : 3;
                    break;
                  case "mousedown":
                    r2 = 1, s4 = t4.button < 3 ? t4.button : 3;
                    break;
                  case "wheel":
                    if (0 === e3.viewport.getLinesScrolled(t4))
                      return false;
                    r2 = t4.deltaY < 0 ? 0 : 1, s4 = 4;
                    break;
                  default:
                    return false;
                }
                return !(void 0 === r2 || void 0 === s4 || s4 > 4) && e3.coreMouseService.triggerMouseEvent({ col: i4.col, row: i4.row, x: i4.x, y: i4.y, button: s4, action: r2, ctrl: t4.ctrlKey, alt: t4.altKey, shift: t4.shiftKey });
              }
              const s3 = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, n2 = { mouseup: (e4) => (i3(e4), e4.buttons || (this._document.removeEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.removeEventListener("mousemove", s3.mousedrag)), this.cancel(e4)), wheel: (e4) => (i3(e4), this.cancel(e4, true)), mousedrag: (e4) => {
                e4.buttons && i3(e4);
              }, mousemove: (e4) => {
                e4.buttons || i3(e4);
              } };
              this.register(this.coreMouseService.onProtocolChange((e4) => {
                e4 ? ("debug" === this.optionsService.rawOptions.logLevel && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e4)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e4 ? s3.mousemove || (t3.addEventListener("mousemove", n2.mousemove), s3.mousemove = n2.mousemove) : (t3.removeEventListener("mousemove", s3.mousemove), s3.mousemove = null), 16 & e4 ? s3.wheel || (t3.addEventListener("wheel", n2.wheel, { passive: false }), s3.wheel = n2.wheel) : (t3.removeEventListener("wheel", s3.wheel), s3.wheel = null), 2 & e4 ? s3.mouseup || (t3.addEventListener("mouseup", n2.mouseup), s3.mouseup = n2.mouseup) : (this._document.removeEventListener("mouseup", s3.mouseup), t3.removeEventListener("mouseup", s3.mouseup), s3.mouseup = null), 4 & e4 ? s3.mousedrag || (s3.mousedrag = n2.mousedrag) : (this._document.removeEventListener("mousemove", s3.mousedrag), s3.mousedrag = null);
              })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, r.addDisposableDomListener)(t3, "mousedown", (e4) => {
                if (e4.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e4))
                  return i3(e4), s3.mouseup && this._document.addEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.addEventListener("mousemove", s3.mousedrag), this.cancel(e4);
              })), this.register((0, r.addDisposableDomListener)(t3, "wheel", (e4) => {
                if (!s3.wheel) {
                  if (!this.buffer.hasScrollback) {
                    const t4 = this.viewport.getLinesScrolled(e4);
                    if (0 === t4)
                      return;
                    const i4 = D.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e4.deltaY < 0 ? "A" : "B");
                    let s4 = "";
                    for (let e5 = 0; e5 < Math.abs(t4); e5++)
                      s4 += i4;
                    return this.coreService.triggerDataEvent(s4, true), this.cancel(e4, true);
                  }
                  return this.viewport.handleWheel(e4) ? this.cancel(e4) : void 0;
                }
              }, { passive: false })), this.register((0, r.addDisposableDomListener)(t3, "touchstart", (e4) => {
                if (!this.coreMouseService.areMouseEventsActive)
                  return this.viewport.handleTouchStart(e4), this.cancel(e4);
              }, { passive: true })), this.register((0, r.addDisposableDomListener)(t3, "touchmove", (e4) => {
                if (!this.coreMouseService.areMouseEventsActive)
                  return this.viewport.handleTouchMove(e4) ? void 0 : this.cancel(e4);
              }, { passive: false }));
            }
            refresh(e3, t3) {
              var i3;
              null === (i3 = this._renderService) || void 0 === i3 || i3.refreshRows(e3, t3);
            }
            updateCursorStyle(e3) {
              var t3;
              (null === (t3 = this._selectionService) || void 0 === t3 ? void 0 : t3.shouldColumnSelect(e3)) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
            }
            _showCursor() {
              this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
            }
            scrollLines(e3, t3, i3 = 0) {
              var s3;
              1 === i3 ? (super.scrollLines(e3, t3, i3), this.refresh(0, this.rows - 1)) : null === (s3 = this.viewport) || void 0 === s3 || s3.scrollLines(e3);
            }
            paste(e3) {
              (0, s2.paste)(e3, this.textarea, this.coreService, this.optionsService);
            }
            attachCustomKeyEventHandler(e3) {
              this._customKeyEventHandler = e3;
            }
            registerLinkProvider(e3) {
              return this.linkifier2.registerLinkProvider(e3);
            }
            registerCharacterJoiner(e3) {
              if (!this._characterJoinerService)
                throw new Error("Terminal must be opened first");
              const t3 = this._characterJoinerService.register(e3);
              return this.refresh(0, this.rows - 1), t3;
            }
            deregisterCharacterJoiner(e3) {
              if (!this._characterJoinerService)
                throw new Error("Terminal must be opened first");
              this._characterJoinerService.deregister(e3) && this.refresh(0, this.rows - 1);
            }
            get markers() {
              return this.buffer.markers;
            }
            registerMarker(e3) {
              return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e3);
            }
            registerDecoration(e3) {
              return this._decorationService.registerDecoration(e3);
            }
            hasSelection() {
              return !!this._selectionService && this._selectionService.hasSelection;
            }
            select(e3, t3, i3) {
              this._selectionService.setSelection(e3, t3, i3);
            }
            getSelection() {
              return this._selectionService ? this._selectionService.selectionText : "";
            }
            getSelectionPosition() {
              if (this._selectionService && this._selectionService.hasSelection)
                return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
            }
            clearSelection() {
              var e3;
              null === (e3 = this._selectionService) || void 0 === e3 || e3.clearSelection();
            }
            selectAll() {
              var e3;
              null === (e3 = this._selectionService) || void 0 === e3 || e3.selectAll();
            }
            selectLines(e3, t3) {
              var i3;
              null === (i3 = this._selectionService) || void 0 === i3 || i3.selectLines(e3, t3);
            }
            _keyDown(e3) {
              if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && false === this._customKeyEventHandler(e3))
                return false;
              const t3 = this.browser.isMac && this.options.macOptionIsMeta && e3.altKey;
              if (!t3 && !this._compositionHelper.keydown(e3))
                return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), false;
              t3 || "Dead" !== e3.key && "AltGraph" !== e3.key || (this._unprocessedDeadKey = true);
              const i3 = (0, R.evaluateKeyboardEvent)(e3, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
              if (this.updateCursorStyle(e3), 3 === i3.type || 2 === i3.type) {
                const t4 = this.rows - 1;
                return this.scrollLines(2 === i3.type ? -t4 : t4), this.cancel(e3, true);
              }
              return 1 === i3.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e3) || (i3.cancel && this.cancel(e3, true), !i3.key || !!(e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && 1 === e3.key.length && e3.key.charCodeAt(0) >= 65 && e3.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (i3.key !== D.C0.ETX && i3.key !== D.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: i3.key, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(i3.key, true), !this.optionsService.rawOptions.screenReaderMode || e3.altKey || e3.ctrlKey ? this.cancel(e3, true) : void (this._keyDownHandled = true))));
            }
            _isThirdLevelShift(e3, t3) {
              const i3 = e3.isMac && !this.options.macOptionIsMeta && t3.altKey && !t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.altKey && t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.getModifierState("AltGraph");
              return "keypress" === t3.type ? i3 : i3 && (!t3.keyCode || t3.keyCode > 47);
            }
            _keyUp(e3) {
              this._keyDownSeen = false, this._customKeyEventHandler && false === this._customKeyEventHandler(e3) || (function(e4) {
                return 16 === e4.keyCode || 17 === e4.keyCode || 18 === e4.keyCode;
              }(e3) || this.focus(), this.updateCursorStyle(e3), this._keyPressHandled = false);
            }
            _keyPress(e3) {
              let t3;
              if (this._keyPressHandled = false, this._keyDownHandled)
                return false;
              if (this._customKeyEventHandler && false === this._customKeyEventHandler(e3))
                return false;
              if (this.cancel(e3), e3.charCode)
                t3 = e3.charCode;
              else if (null === e3.which || void 0 === e3.which)
                t3 = e3.keyCode;
              else {
                if (0 === e3.which || 0 === e3.charCode)
                  return false;
                t3 = e3.which;
              }
              return !(!t3 || (e3.altKey || e3.ctrlKey || e3.metaKey) && !this._isThirdLevelShift(this.browser, e3) || (t3 = String.fromCharCode(t3), this._onKey.fire({ key: t3, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(t3, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
            }
            _inputEvent(e3) {
              if (e3.data && "insertText" === e3.inputType && (!e3.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
                if (this._keyPressHandled)
                  return false;
                this._unprocessedDeadKey = false;
                const t3 = e3.data;
                return this.coreService.triggerDataEvent(t3, true), this.cancel(e3), true;
              }
              return false;
            }
            resize(e3, t3) {
              e3 !== this.cols || t3 !== this.rows ? super.resize(e3, t3) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
            }
            _afterResize(e3, t3) {
              var i3, s3;
              null === (i3 = this._charSizeService) || void 0 === i3 || i3.measure(), null === (s3 = this.viewport) || void 0 === s3 || s3.syncScrollArea(true);
            }
            clear() {
              var e3;
              if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
                this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
                for (let e4 = 1; e4 < this.rows; e4++)
                  this.buffer.lines.push(this.buffer.getBlankLine(L.DEFAULT_ATTR_DATA));
                this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), null === (e3 = this.viewport) || void 0 === e3 || e3.reset(), this.refresh(0, this.rows - 1);
              }
            }
            reset() {
              var e3, t3;
              this.options.rows = this.rows, this.options.cols = this.cols;
              const i3 = this._customKeyEventHandler;
              this._setup(), super.reset(), null === (e3 = this._selectionService) || void 0 === e3 || e3.reset(), this._decorationService.reset(), null === (t3 = this.viewport) || void 0 === t3 || t3.reset(), this._customKeyEventHandler = i3, this.refresh(0, this.rows - 1);
            }
            clearTextureAtlas() {
              var e3;
              null === (e3 = this._renderService) || void 0 === e3 || e3.clearTextureAtlas();
            }
            _reportFocus() {
              var e3;
              (null === (e3 = this.element) || void 0 === e3 ? void 0 : e3.classList.contains("focus")) ? this.coreService.triggerDataEvent(D.C0.ESC + "[I") : this.coreService.triggerDataEvent(D.C0.ESC + "[O");
            }
            _reportWindowsOptions(e3) {
              if (this._renderService)
                switch (e3) {
                  case T.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                    const e4 = this._renderService.dimensions.css.canvas.width.toFixed(0), t3 = this._renderService.dimensions.css.canvas.height.toFixed(0);
                    this.coreService.triggerDataEvent(`${D.C0.ESC}[4;${t3};${e4}t`);
                    break;
                  case T.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                    const i3 = this._renderService.dimensions.css.cell.width.toFixed(0), s3 = this._renderService.dimensions.css.cell.height.toFixed(0);
                    this.coreService.triggerDataEvent(`${D.C0.ESC}[6;${s3};${i3}t`);
                }
            }
            cancel(e3, t3) {
              if (this.options.cancelEvents || t3)
                return e3.preventDefault(), e3.stopPropagation(), false;
            }
          }
          t2.Terminal = P;
        }, 9924: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.TimeBasedDebouncer = void 0, t2.TimeBasedDebouncer = class {
            constructor(e3, t3 = 1e3) {
              this._renderCallback = e3, this._debounceThresholdMS = t3, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
            }
            dispose() {
              this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
            }
            refresh(e3, t3, i2) {
              this._rowCount = i2, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3;
              const s2 = Date.now();
              if (s2 - this._lastRefreshMs >= this._debounceThresholdMS)
                this._lastRefreshMs = s2, this._innerRefresh();
              else if (!this._additionalRefreshRequested) {
                const e4 = s2 - this._lastRefreshMs, t4 = this._debounceThresholdMS - e4;
                this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout(() => {
                  this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = void 0;
                }, t4);
              }
            }
            _innerRefresh() {
              if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount)
                return;
              const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
              this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3);
            }
          };
        }, 1680: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Viewport = void 0;
          const n = i2(3656), o = i2(4725), a = i2(8460), h = i2(844), c = i2(2585);
          let l = t2.Viewport = class extends h.Disposable {
            constructor(e3, t3, i3, s3, r2, o2, h2, c2) {
              super(), this._viewportElement = e3, this._scrollArea = t3, this._bufferService = i3, this._optionsService = s3, this._charSizeService = r2, this._renderService = o2, this._coreBrowserService = h2, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new a.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((e4) => this._renderDimensions = e4)), this._handleThemeChange(c2.colors), this.register(c2.onChangeColors((e4) => this._handleThemeChange(e4))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
            }
            _handleThemeChange(e3) {
              this._viewportElement.style.backgroundColor = e3.background.css;
            }
            reset() {
              this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
            }
            _refresh(e3) {
              if (e3)
                return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
              null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
            }
            _innerRefresh() {
              if (this._charSizeService.height > 0) {
                this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
                const e4 = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
                this._lastRecordedBufferHeight !== e4 && (this._lastRecordedBufferHeight = e4, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
              }
              const e3 = this._bufferService.buffer.ydisp * this._currentRowHeight;
              this._viewportElement.scrollTop !== e3 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = e3), this._refreshAnimationFrame = null;
            }
            syncScrollArea(e3 = false) {
              if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length)
                return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e3);
              this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e3);
            }
            _handleScroll(e3) {
              if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent)
                return;
              if (this._ignoreNextScrollEvent)
                return this._ignoreNextScrollEvent = false, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: true });
              const t3 = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
              this._onRequestScrollLines.fire({ amount: t3, suppressScrollEvent: true });
            }
            _smoothScroll() {
              if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target)
                return;
              const e3 = this._smoothScrollPercent();
              this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e3 * (this._smoothScrollState.target - this._smoothScrollState.origin)), e3 < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
            }
            _smoothScrollPercent() {
              return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
            }
            _clearSmoothScrollState() {
              this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
            }
            _bubbleScroll(e3, t3) {
              const i3 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
              return !(t3 < 0 && 0 !== this._viewportElement.scrollTop || t3 > 0 && i3 < this._lastRecordedBufferHeight) || (e3.cancelable && e3.preventDefault(), false);
            }
            handleWheel(e3) {
              const t3 = this._getPixelsScrolled(e3);
              return 0 !== t3 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t3 : this._smoothScrollState.target += t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
            }
            scrollLines(e3) {
              if (0 !== e3)
                if (this._optionsService.rawOptions.smoothScrollDuration) {
                  const t3 = e3 * this._currentRowHeight;
                  this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
                } else
                  this._onRequestScrollLines.fire({ amount: e3, suppressScrollEvent: false });
            }
            _getPixelsScrolled(e3) {
              if (0 === e3.deltaY || e3.shiftKey)
                return 0;
              let t3 = this._applyScrollModifier(e3.deltaY, e3);
              return e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? t3 *= this._currentRowHeight : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._currentRowHeight * this._bufferService.rows), t3;
            }
            getBufferElements(e3, t3) {
              var i3;
              let s3, r2 = "";
              const n2 = [], o2 = null != t3 ? t3 : this._bufferService.buffer.lines.length, a2 = this._bufferService.buffer.lines;
              for (let t4 = e3; t4 < o2; t4++) {
                const e4 = a2.get(t4);
                if (!e4)
                  continue;
                const o3 = null === (i3 = a2.get(t4 + 1)) || void 0 === i3 ? void 0 : i3.isWrapped;
                if (r2 += e4.translateToString(!o3), !o3 || t4 === a2.length - 1) {
                  const e5 = document.createElement("div");
                  e5.textContent = r2, n2.push(e5), r2.length > 0 && (s3 = e5), r2 = "";
                }
              }
              return { bufferElements: n2, cursorElement: s3 };
            }
            getLinesScrolled(e3) {
              if (0 === e3.deltaY || e3.shiftKey)
                return 0;
              let t3 = this._applyScrollModifier(e3.deltaY, e3);
              return e3.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t3 /= this._currentRowHeight + 0, this._wheelPartialScroll += t3, t3 = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._bufferService.rows), t3;
            }
            _applyScrollModifier(e3, t3) {
              const i3 = this._optionsService.rawOptions.fastScrollModifier;
              return "alt" === i3 && t3.altKey || "ctrl" === i3 && t3.ctrlKey || "shift" === i3 && t3.shiftKey ? e3 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e3 * this._optionsService.rawOptions.scrollSensitivity;
            }
            handleTouchStart(e3) {
              this._lastTouchY = e3.touches[0].pageY;
            }
            handleTouchMove(e3) {
              const t3 = this._lastTouchY - e3.touches[0].pageY;
              return this._lastTouchY = e3.touches[0].pageY, 0 !== t3 && (this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
            }
          };
          t2.Viewport = l = s2([r(2, c.IBufferService), r(3, c.IOptionsService), r(4, o.ICharSizeService), r(5, o.IRenderService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], l);
        }, 3107: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferDecorationRenderer = void 0;
          const n = i2(3656), o = i2(4725), a = i2(844), h = i2(2585);
          let c = t2.BufferDecorationRenderer = class extends a.Disposable {
            constructor(e3, t3, i3, s3) {
              super(), this._screenElement = e3, this._bufferService = t3, this._decorationService = i3, this._renderService = s3, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
                this._dimensionsChanged = true, this._queueRefresh();
              })), this.register((0, n.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
                this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
              })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((e4) => this._removeDecoration(e4))), this.register((0, a.toDisposable)(() => {
                this._container.remove(), this._decorationElements.clear();
              }));
            }
            _queueRefresh() {
              void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback(() => {
                this._doRefreshDecorations(), this._animationFrame = void 0;
              }));
            }
            _doRefreshDecorations() {
              for (const e3 of this._decorationService.decorations)
                this._renderDecoration(e3);
              this._dimensionsChanged = false;
            }
            _renderDecoration(e3) {
              this._refreshStyle(e3), this._dimensionsChanged && this._refreshXPosition(e3);
            }
            _createElement(e3) {
              var t3, i3;
              const s3 = document.createElement("div");
              s3.classList.add("xterm-decoration"), s3.classList.toggle("xterm-decoration-top-layer", "top" === (null === (t3 = null == e3 ? void 0 : e3.options) || void 0 === t3 ? void 0 : t3.layer)), s3.style.width = `${Math.round((e3.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, s3.style.height = (e3.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", s3.style.top = (e3.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", s3.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
              const r2 = null !== (i3 = e3.options.x) && void 0 !== i3 ? i3 : 0;
              return r2 && r2 > this._bufferService.cols && (s3.style.display = "none"), this._refreshXPosition(e3, s3), s3;
            }
            _refreshStyle(e3) {
              const t3 = e3.marker.line - this._bufferService.buffers.active.ydisp;
              if (t3 < 0 || t3 >= this._bufferService.rows)
                e3.element && (e3.element.style.display = "none", e3.onRenderEmitter.fire(e3.element));
              else {
                let i3 = this._decorationElements.get(e3);
                i3 || (i3 = this._createElement(e3), e3.element = i3, this._decorationElements.set(e3, i3), this._container.appendChild(i3), e3.onDispose(() => {
                  this._decorationElements.delete(e3), i3.remove();
                })), i3.style.top = t3 * this._renderService.dimensions.css.cell.height + "px", i3.style.display = this._altBufferIsActive ? "none" : "block", e3.onRenderEmitter.fire(i3);
              }
            }
            _refreshXPosition(e3, t3 = e3.element) {
              var i3;
              if (!t3)
                return;
              const s3 = null !== (i3 = e3.options.x) && void 0 !== i3 ? i3 : 0;
              "right" === (e3.options.anchor || "left") ? t3.style.right = s3 ? s3 * this._renderService.dimensions.css.cell.width + "px" : "" : t3.style.left = s3 ? s3 * this._renderService.dimensions.css.cell.width + "px" : "";
            }
            _removeDecoration(e3) {
              var t3;
              null === (t3 = this._decorationElements.get(e3)) || void 0 === t3 || t3.remove(), this._decorationElements.delete(e3), e3.dispose();
            }
          };
          t2.BufferDecorationRenderer = c = s2([r(1, h.IBufferService), r(2, h.IDecorationService), r(3, o.IRenderService)], c);
        }, 5871: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorZoneStore = void 0, t2.ColorZoneStore = class {
            constructor() {
              this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
            }
            get zones() {
              return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
            }
            clear() {
              this._zones.length = 0, this._zonePoolIndex = 0;
            }
            addDecoration(e3) {
              if (e3.options.overviewRulerOptions) {
                for (const t3 of this._zones)
                  if (t3.color === e3.options.overviewRulerOptions.color && t3.position === e3.options.overviewRulerOptions.position) {
                    if (this._lineIntersectsZone(t3, e3.marker.line))
                      return;
                    if (this._lineAdjacentToZone(t3, e3.marker.line, e3.options.overviewRulerOptions.position))
                      return void this._addLineToZone(t3, e3.marker.line);
                  }
                if (this._zonePoolIndex < this._zonePool.length)
                  return this._zonePool[this._zonePoolIndex].color = e3.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e3.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e3.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e3.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
                this._zones.push({ color: e3.options.overviewRulerOptions.color, position: e3.options.overviewRulerOptions.position, startBufferLine: e3.marker.line, endBufferLine: e3.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
              }
            }
            setPadding(e3) {
              this._linePadding = e3;
            }
            _lineIntersectsZone(e3, t3) {
              return t3 >= e3.startBufferLine && t3 <= e3.endBufferLine;
            }
            _lineAdjacentToZone(e3, t3, i2) {
              return t3 >= e3.startBufferLine - this._linePadding[i2 || "full"] && t3 <= e3.endBufferLine + this._linePadding[i2 || "full"];
            }
            _addLineToZone(e3, t3) {
              e3.startBufferLine = Math.min(e3.startBufferLine, t3), e3.endBufferLine = Math.max(e3.endBufferLine, t3);
            }
          };
        }, 5744: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OverviewRulerRenderer = void 0;
          const n = i2(5871), o = i2(3656), a = i2(4725), h = i2(844), c = i2(2585), l = { full: 0, left: 0, center: 0, right: 0 }, d = { full: 0, left: 0, center: 0, right: 0 }, _ = { full: 0, left: 0, center: 0, right: 0 };
          let u = t2.OverviewRulerRenderer = class extends h.Disposable {
            get _width() {
              return this._optionsService.options.overviewRulerWidth || 0;
            }
            constructor(e3, t3, i3, s3, r2, o2, a2) {
              var c2;
              super(), this._viewportElement = e3, this._screenElement = t3, this._bufferService = i3, this._decorationService = s3, this._renderService = r2, this._optionsService = o2, this._coreBrowseService = a2, this._colorZoneStore = new n.ColorZoneStore(), this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), null === (c2 = this._viewportElement.parentElement) || void 0 === c2 || c2.insertBefore(this._canvas, this._viewportElement);
              const l2 = this._canvas.getContext("2d");
              if (!l2)
                throw new Error("Ctx cannot be null");
              this._ctx = l2, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, h.toDisposable)(() => {
                var e4;
                null === (e4 = this._canvas) || void 0 === e4 || e4.remove();
              }));
            }
            _registerDecorationListeners() {
              this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, true))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, true)));
            }
            _registerBufferChangeListeners() {
              this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
                this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
              })), this.register(this._bufferService.onScroll(() => {
                this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
              }));
            }
            _registerDimensionChangeListeners() {
              this.register(this._renderService.onRender(() => {
                this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
              })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(true))), this.register((0, o.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(true))), this._queueRefresh(true);
            }
            _refreshDrawConstants() {
              const e3 = Math.floor(this._canvas.width / 3), t3 = Math.ceil(this._canvas.width / 3);
              d.full = this._canvas.width, d.left = e3, d.center = t3, d.right = e3, this._refreshDrawHeightConstants(), _.full = 0, _.left = 0, _.center = d.left, _.right = d.left + d.center;
            }
            _refreshDrawHeightConstants() {
              l.full = Math.round(2 * this._coreBrowseService.dpr);
              const e3 = this._canvas.height / this._bufferService.buffer.lines.length, t3 = Math.round(Math.max(Math.min(e3, 12), 6) * this._coreBrowseService.dpr);
              l.left = t3, l.center = t3, l.right = t3;
            }
            _refreshColorZonePadding() {
              this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
            }
            _refreshCanvasDimensions() {
              this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
            }
            _refreshDecorations() {
              this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
              for (const e4 of this._decorationService.decorations)
                this._colorZoneStore.addDecoration(e4);
              this._ctx.lineWidth = 1;
              const e3 = this._colorZoneStore.zones;
              for (const t3 of e3)
                "full" !== t3.position && this._renderColorZone(t3);
              for (const t3 of e3)
                "full" === t3.position && this._renderColorZone(t3);
              this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
            }
            _renderColorZone(e3) {
              this._ctx.fillStyle = e3.color, this._ctx.fillRect(_[e3.position || "full"], Math.round((this._canvas.height - 1) * (e3.startBufferLine / this._bufferService.buffers.active.lines.length) - l[e3.position || "full"] / 2), d[e3.position || "full"], Math.round((this._canvas.height - 1) * ((e3.endBufferLine - e3.startBufferLine) / this._bufferService.buffers.active.lines.length) + l[e3.position || "full"]));
            }
            _queueRefresh(e3, t3) {
              this._shouldUpdateDimensions = e3 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t3 || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {
                this._refreshDecorations(), this._animationFrame = void 0;
              }));
            }
          };
          t2.OverviewRulerRenderer = u = s2([r(2, c.IBufferService), r(3, c.IDecorationService), r(4, a.IRenderService), r(5, c.IOptionsService), r(6, a.ICoreBrowserService)], u);
        }, 2950: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CompositionHelper = void 0;
          const n = i2(4725), o = i2(2585), a = i2(2584);
          let h = t2.CompositionHelper = class {
            get isComposing() {
              return this._isComposing;
            }
            constructor(e3, t3, i3, s3, r2, n2) {
              this._textarea = e3, this._compositionView = t3, this._bufferService = i3, this._optionsService = s3, this._coreService = r2, this._renderService = n2, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
            }
            compositionstart() {
              this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
            }
            compositionupdate(e3) {
              this._compositionView.textContent = e3.data, this.updateCompositionElements(), setTimeout(() => {
                this._compositionPosition.end = this._textarea.value.length;
              }, 0);
            }
            compositionend() {
              this._finalizeComposition(true);
            }
            keydown(e3) {
              if (this._isComposing || this._isSendingComposition) {
                if (229 === e3.keyCode)
                  return false;
                if (16 === e3.keyCode || 17 === e3.keyCode || 18 === e3.keyCode)
                  return false;
                this._finalizeComposition(false);
              }
              return 229 !== e3.keyCode || (this._handleAnyTextareaChanges(), false);
            }
            _finalizeComposition(e3) {
              if (this._compositionView.classList.remove("active"), this._isComposing = false, e3) {
                const e4 = { start: this._compositionPosition.start, end: this._compositionPosition.end };
                this._isSendingComposition = true, setTimeout(() => {
                  if (this._isSendingComposition) {
                    let t3;
                    this._isSendingComposition = false, e4.start += this._dataAlreadySent.length, t3 = this._isComposing ? this._textarea.value.substring(e4.start, e4.end) : this._textarea.value.substring(e4.start), t3.length > 0 && this._coreService.triggerDataEvent(t3, true);
                  }
                }, 0);
              } else {
                this._isSendingComposition = false;
                const e4 = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
                this._coreService.triggerDataEvent(e4, true);
              }
            }
            _handleAnyTextareaChanges() {
              const e3 = this._textarea.value;
              setTimeout(() => {
                if (!this._isComposing) {
                  const t3 = this._textarea.value, i3 = t3.replace(e3, "");
                  this._dataAlreadySent = i3, t3.length > e3.length ? this._coreService.triggerDataEvent(i3, true) : t3.length < e3.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, true) : t3.length === e3.length && t3 !== e3 && this._coreService.triggerDataEvent(t3, true);
                }
              }, 0);
            }
            updateCompositionElements(e3) {
              if (this._isComposing) {
                if (this._bufferService.buffer.isCursorInViewport) {
                  const e4 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t3 = this._renderService.dimensions.css.cell.height, i3 = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s3 = e4 * this._renderService.dimensions.css.cell.width;
                  this._compositionView.style.left = s3 + "px", this._compositionView.style.top = i3 + "px", this._compositionView.style.height = t3 + "px", this._compositionView.style.lineHeight = t3 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                  const r2 = this._compositionView.getBoundingClientRect();
                  this._textarea.style.left = s3 + "px", this._textarea.style.top = i3 + "px", this._textarea.style.width = Math.max(r2.width, 1) + "px", this._textarea.style.height = Math.max(r2.height, 1) + "px", this._textarea.style.lineHeight = r2.height + "px";
                }
                e3 || setTimeout(() => this.updateCompositionElements(true), 0);
              }
            }
          };
          t2.CompositionHelper = h = s2([r(2, o.IBufferService), r(3, o.IOptionsService), r(4, o.ICoreService), r(5, n.IRenderService)], h);
        }, 9806: (e2, t2) => {
          function i2(e3, t3, i3) {
            const s2 = i3.getBoundingClientRect(), r = e3.getComputedStyle(i3), n = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
            return [t3.clientX - s2.left - n, t3.clientY - s2.top - o];
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getCoords = t2.getCoordsRelativeToElement = void 0, t2.getCoordsRelativeToElement = i2, t2.getCoords = function(e3, t3, s2, r, n, o, a, h, c) {
            if (!o)
              return;
            const l = i2(e3, t3, s2);
            return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : void 0;
          };
        }, 9504: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.moveToCellSequence = void 0;
          const s2 = i2(2584);
          function r(e3, t3, i3, s3) {
            const r2 = e3 - n(e3, i3), a2 = t3 - n(t3, i3), l = Math.abs(r2 - a2) - function(e4, t4, i4) {
              let s4 = 0;
              const r3 = e4 - n(e4, i4), a3 = t4 - n(t4, i4);
              for (let n2 = 0; n2 < Math.abs(r3 - a3); n2++) {
                const a4 = "A" === o(e4, t4) ? -1 : 1, h2 = i4.buffer.lines.get(r3 + a4 * n2);
                (null == h2 ? void 0 : h2.isWrapped) && s4++;
              }
              return s4;
            }(e3, t3, i3);
            return c(l, h(o(e3, t3), s3));
          }
          function n(e3, t3) {
            let i3 = 0, s3 = t3.buffer.lines.get(e3), r2 = null == s3 ? void 0 : s3.isWrapped;
            for (; r2 && e3 >= 0 && e3 < t3.rows; )
              i3++, s3 = t3.buffer.lines.get(--e3), r2 = null == s3 ? void 0 : s3.isWrapped;
            return i3;
          }
          function o(e3, t3) {
            return e3 > t3 ? "A" : "B";
          }
          function a(e3, t3, i3, s3, r2, n2) {
            let o2 = e3, a2 = t3, h2 = "";
            for (; o2 !== i3 || a2 !== s3; )
              o2 += r2 ? 1 : -1, r2 && o2 > n2.cols - 1 ? (h2 += n2.buffer.translateBufferLineToString(a2, false, e3, o2), o2 = 0, e3 = 0, a2++) : !r2 && o2 < 0 && (h2 += n2.buffer.translateBufferLineToString(a2, false, 0, e3 + 1), o2 = n2.cols - 1, e3 = o2, a2--);
            return h2 + n2.buffer.translateBufferLineToString(a2, false, e3, o2);
          }
          function h(e3, t3) {
            const i3 = t3 ? "O" : "[";
            return s2.C0.ESC + i3 + e3;
          }
          function c(e3, t3) {
            e3 = Math.floor(e3);
            let i3 = "";
            for (let s3 = 0; s3 < e3; s3++)
              i3 += t3;
            return i3;
          }
          t2.moveToCellSequence = function(e3, t3, i3, s3) {
            const o2 = i3.buffer.x, l = i3.buffer.y;
            if (!i3.buffer.hasScrollback)
              return function(e4, t4, i4, s4, o3, l2) {
                return 0 === r(t4, s4, o3, l2).length ? "" : c(a(e4, t4, e4, t4 - n(t4, o3), false, o3).length, h("D", l2));
              }(o2, l, 0, t3, i3, s3) + r(l, t3, i3, s3) + function(e4, t4, i4, s4, o3, l2) {
                let d2;
                d2 = r(t4, s4, o3, l2).length > 0 ? s4 - n(s4, o3) : t4;
                const _2 = s4, u = function(e5, t5, i5, s5, o4, a2) {
                  let h2;
                  return h2 = r(i5, s5, o4, a2).length > 0 ? s5 - n(s5, o4) : t5, e5 < i5 && h2 <= s5 || e5 >= i5 && h2 < s5 ? "C" : "D";
                }(e4, t4, i4, s4, o3, l2);
                return c(a(e4, d2, i4, _2, "C" === u, o3).length, h(u, l2));
              }(o2, l, e3, t3, i3, s3);
            let d;
            if (l === t3)
              return d = o2 > e3 ? "D" : "C", c(Math.abs(o2 - e3), h(d, s3));
            d = l > t3 ? "D" : "C";
            const _ = Math.abs(l - t3);
            return c(function(e4, t4) {
              return t4.cols - e4;
            }(l > t3 ? e3 : o2, i3) + (_ - 1) * i3.cols + 1 + ((l > t3 ? o2 : e3) - 1), h(d, s3));
          };
        }, 1296: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRenderer = void 0;
          const n = i2(3787), o = i2(2550), a = i2(2223), h = i2(6171), c = i2(4725), l = i2(8055), d = i2(8460), _ = i2(844), u = i2(2585), f = "xterm-dom-renderer-owner-", v = "xterm-rows", p = "xterm-fg-", g = "xterm-bg-", m = "xterm-focus", S = "xterm-selection";
          let C = 1, b = t2.DomRenderer = class extends _.Disposable {
            constructor(e3, t3, i3, s3, r2, a2, c2, l2, u2, p2) {
              super(), this._element = e3, this._screenElement = t3, this._viewportElement = i3, this._linkifier2 = s3, this._charSizeService = a2, this._optionsService = c2, this._bufferService = l2, this._coreBrowserService = u2, this._themeService = p2, this._terminalClass = C++, this._rowElements = [], this.onRequestRedraw = this.register(new d.EventEmitter()).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add(v), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add(S), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, h.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((e4) => this._injectCss(e4))), this._injectCss(this._themeService.colors), this._rowFactory = r2.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(f + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((e4) => this._handleLinkHover(e4))), this.register(this._linkifier2.onHideLinkUnderline((e4) => this._handleLinkLeave(e4))), this.register((0, _.toDisposable)(() => {
                this._element.classList.remove(f + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
              })), this._widthCache = new o.WidthCache(document), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
            }
            _updateDimensions() {
              const e3 = this._coreBrowserService.dpr;
              this.dimensions.device.char.width = this._charSizeService.width * e3, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e3), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e3), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e3), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
              for (const e4 of this._rowElements)
                e4.style.width = `${this.dimensions.css.canvas.width}px`, e4.style.height = `${this.dimensions.css.cell.height}px`, e4.style.lineHeight = `${this.dimensions.css.cell.height}px`, e4.style.overflow = "hidden";
              this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
              const t3 = `${this._terminalSelector} .${v} span { display: inline-block; height: 100%; vertical-align: top;}`;
              this._dimensionsStyleElement.textContent = t3, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
            }
            _injectCss(e3) {
              this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
              let t3 = `${this._terminalSelector} .${v} { color: ${e3.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
              t3 += `${this._terminalSelector} .${v} .xterm-dim { color: ${l.color.multiplyOpacity(e3.foreground, 0.5).css};}`, t3 += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`, t3 += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  border-bottom-style: hidden; }}", t3 += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${e3.cursor.css};  color: ${e3.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${e3.cursor.css}; }}`, t3 += `${this._terminalSelector} .${v}.${m} .xterm-cursor.xterm-cursor-blink:not(.xterm-cursor-block) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${v}.${m} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-block { background-color: ${e3.cursor.css}; color: ${e3.cursorAccent.css};}${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${e3.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e3.cursor.css} inset;}${this._terminalSelector} .${v} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${e3.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, t3 += `${this._terminalSelector} .${S} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${S} div { position: absolute; background-color: ${e3.selectionBackgroundOpaque.css};}${this._terminalSelector} .${S} div { position: absolute; background-color: ${e3.selectionInactiveBackgroundOpaque.css};}`;
              for (const [i3, s3] of e3.ansi.entries())
                t3 += `${this._terminalSelector} .${p}${i3} { color: ${s3.css}; }${this._terminalSelector} .${p}${i3}.xterm-dim { color: ${l.color.multiplyOpacity(s3, 0.5).css}; }${this._terminalSelector} .${g}${i3} { background-color: ${s3.css}; }`;
              t3 += `${this._terminalSelector} .${p}${a.INVERTED_DEFAULT_COLOR} { color: ${l.color.opaque(e3.background).css}; }${this._terminalSelector} .${p}${a.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${l.color.multiplyOpacity(l.color.opaque(e3.background), 0.5).css}; }${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR} { background-color: ${e3.foreground.css}; }`, this._themeStyleElement.textContent = t3;
            }
            _setDefaultSpacing() {
              const e3 = this.dimensions.css.cell.width - this._widthCache.get("W", false, false);
              this._rowContainer.style.letterSpacing = `${e3}px`, this._rowFactory.defaultSpacing = e3;
            }
            handleDevicePixelRatioChange() {
              this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
            }
            _refreshRowElements(e3, t3) {
              for (let e4 = this._rowElements.length; e4 <= t3; e4++) {
                const e5 = document.createElement("div");
                this._rowContainer.appendChild(e5), this._rowElements.push(e5);
              }
              for (; this._rowElements.length > t3; )
                this._rowContainer.removeChild(this._rowElements.pop());
            }
            handleResize(e3, t3) {
              this._refreshRowElements(e3, t3), this._updateDimensions();
            }
            handleCharSizeChanged() {
              this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
            }
            handleBlur() {
              this._rowContainer.classList.remove(m);
            }
            handleFocus() {
              this._rowContainer.classList.add(m), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
            }
            handleSelectionChanged(e3, t3, i3) {
              if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(e3, t3, i3), this.renderRows(0, this._bufferService.rows - 1), !e3 || !t3)
                return;
              const s3 = e3[1] - this._bufferService.buffer.ydisp, r2 = t3[1] - this._bufferService.buffer.ydisp, n2 = Math.max(s3, 0), o2 = Math.min(r2, this._bufferService.rows - 1);
              if (n2 >= this._bufferService.rows || o2 < 0)
                return;
              const a2 = document.createDocumentFragment();
              if (i3) {
                const i4 = e3[0] > t3[0];
                a2.appendChild(this._createSelectionElement(n2, i4 ? t3[0] : e3[0], i4 ? e3[0] : t3[0], o2 - n2 + 1));
              } else {
                const i4 = s3 === n2 ? e3[0] : 0, h2 = n2 === r2 ? t3[0] : this._bufferService.cols;
                a2.appendChild(this._createSelectionElement(n2, i4, h2));
                const c2 = o2 - n2 - 1;
                if (a2.appendChild(this._createSelectionElement(n2 + 1, 0, this._bufferService.cols, c2)), n2 !== o2) {
                  const e4 = r2 === o2 ? t3[0] : this._bufferService.cols;
                  a2.appendChild(this._createSelectionElement(o2, 0, e4));
                }
              }
              this._selectionContainer.appendChild(a2);
            }
            _createSelectionElement(e3, t3, i3, s3 = 1) {
              const r2 = document.createElement("div");
              return r2.style.height = s3 * this.dimensions.css.cell.height + "px", r2.style.top = e3 * this.dimensions.css.cell.height + "px", r2.style.left = t3 * this.dimensions.css.cell.width + "px", r2.style.width = this.dimensions.css.cell.width * (i3 - t3) + "px", r2;
            }
            handleCursorMove() {
            }
            _handleOptionsChanged() {
              this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
            }
            clear() {
              for (const e3 of this._rowElements)
                e3.replaceChildren();
            }
            renderRows(e3, t3) {
              const i3 = this._bufferService.buffer, s3 = i3.ybase + i3.y, r2 = Math.min(i3.x, this._bufferService.cols - 1), n2 = this._optionsService.rawOptions.cursorBlink, o2 = this._optionsService.rawOptions.cursorStyle, a2 = this._optionsService.rawOptions.cursorInactiveStyle;
              for (let h2 = e3; h2 <= t3; h2++) {
                const e4 = h2 + i3.ydisp, t4 = this._rowElements[h2], c2 = i3.lines.get(e4);
                if (!t4 || !c2)
                  break;
                t4.replaceChildren(...this._rowFactory.createRow(c2, e4, e4 === s3, o2, a2, r2, n2, this.dimensions.css.cell.width, this._widthCache, -1, -1));
              }
            }
            get _terminalSelector() {
              return `.${f}${this._terminalClass}`;
            }
            _handleLinkHover(e3) {
              this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, true);
            }
            _handleLinkLeave(e3) {
              this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, false);
            }
            _setCellUnderline(e3, t3, i3, s3, r2, n2) {
              i3 < 0 && (e3 = 0), s3 < 0 && (t3 = 0);
              const o2 = this._bufferService.rows - 1;
              i3 = Math.max(Math.min(i3, o2), 0), s3 = Math.max(Math.min(s3, o2), 0), r2 = Math.min(r2, this._bufferService.cols);
              const a2 = this._bufferService.buffer, h2 = a2.ybase + a2.y, c2 = Math.min(a2.x, r2 - 1), l2 = this._optionsService.rawOptions.cursorBlink, d2 = this._optionsService.rawOptions.cursorStyle, _2 = this._optionsService.rawOptions.cursorInactiveStyle;
              for (let o3 = i3; o3 <= s3; ++o3) {
                const u2 = o3 + a2.ydisp, f2 = this._rowElements[o3], v2 = a2.lines.get(u2);
                if (!f2 || !v2)
                  break;
                f2.replaceChildren(...this._rowFactory.createRow(v2, u2, u2 === h2, d2, _2, c2, l2, this.dimensions.css.cell.width, this._widthCache, n2 ? o3 === i3 ? e3 : 0 : -1, n2 ? (o3 === s3 ? t3 : r2) - 1 : -1));
              }
            }
          };
          t2.DomRenderer = b = s2([r(4, u.IInstantiationService), r(5, c.ICharSizeService), r(6, u.IOptionsService), r(7, u.IBufferService), r(8, c.ICoreBrowserService), r(9, c.IThemeService)], b);
        }, 3787: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRendererRowFactory = void 0;
          const n = i2(2223), o = i2(643), a = i2(511), h = i2(2585), c = i2(8055), l = i2(4725), d = i2(4269), _ = i2(6171), u = i2(3734);
          let f = t2.DomRendererRowFactory = class {
            constructor(e3, t3, i3, s3, r2, n2, o2) {
              this._document = e3, this._characterJoinerService = t3, this._optionsService = i3, this._coreBrowserService = s3, this._coreService = r2, this._decorationService = n2, this._themeService = o2, this._workCell = new a.CellData(), this._columnSelectMode = false, this.defaultSpacing = 0;
            }
            handleSelectionChanged(e3, t3, i3) {
              this._selectionStart = e3, this._selectionEnd = t3, this._columnSelectMode = i3;
            }
            createRow(e3, t3, i3, s3, r2, a2, h2, l2, _2, f2, p) {
              const g = [], m = this._characterJoinerService.getJoinedCharacters(t3), S = this._themeService.colors;
              let C, b = e3.getNoBgTrimmedLength();
              i3 && b < a2 + 1 && (b = a2 + 1);
              let y = 0, w = "", E = 0, k = 0, L = 0, D = false, R = 0, x = false, A = 0;
              const B = [], T = -1 !== f2 && -1 !== p;
              for (let M = 0; M < b; M++) {
                e3.loadCell(M, this._workCell);
                let b2 = this._workCell.getWidth();
                if (0 === b2)
                  continue;
                let O = false, P = M, I = this._workCell;
                if (m.length > 0 && M === m[0][0]) {
                  O = true;
                  const t4 = m.shift();
                  I = new d.JoinedCellData(this._workCell, e3.translateToString(true, t4[0], t4[1]), t4[1] - t4[0]), P = t4[1] - 1, b2 = I.getWidth();
                }
                const H = this._isCellInSelection(M, t3), F = i3 && M === a2, W = T && M >= f2 && M <= p;
                let U = false;
                this._decorationService.forEachDecorationAtCell(M, t3, void 0, (e4) => {
                  U = true;
                });
                let N = I.getChars() || o.WHITESPACE_CELL_CHAR;
                if (" " === N && (I.isUnderline() || I.isOverline()) && (N = "\xA0"), A = b2 * l2 - _2.get(N, I.isBold(), I.isItalic()), C) {
                  if (y && (H && x || !H && !x && I.bg === E) && (H && x && S.selectionForeground || I.fg === k) && I.extended.ext === L && W === D && A === R && !F && !O && !U) {
                    w += N, y++;
                    continue;
                  }
                  y && (C.textContent = w), C = this._document.createElement("span"), y = 0, w = "";
                } else
                  C = this._document.createElement("span");
                if (E = I.bg, k = I.fg, L = I.extended.ext, D = W, R = A, x = H, O && a2 >= M && a2 <= P && (a2 = M), !this._coreService.isCursorHidden && F) {
                  if (B.push("xterm-cursor"), this._coreBrowserService.isFocused)
                    h2 && B.push("xterm-cursor-blink"), B.push("bar" === s3 ? "xterm-cursor-bar" : "underline" === s3 ? "xterm-cursor-underline" : "xterm-cursor-block");
                  else if (r2)
                    switch (r2) {
                      case "outline":
                        B.push("xterm-cursor-outline");
                        break;
                      case "block":
                        B.push("xterm-cursor-block");
                        break;
                      case "bar":
                        B.push("xterm-cursor-bar");
                        break;
                      case "underline":
                        B.push("xterm-cursor-underline");
                    }
                }
                if (I.isBold() && B.push("xterm-bold"), I.isItalic() && B.push("xterm-italic"), I.isDim() && B.push("xterm-dim"), w = I.isInvisible() ? o.WHITESPACE_CELL_CHAR : I.getChars() || o.WHITESPACE_CELL_CHAR, I.isUnderline() && (B.push(`xterm-underline-${I.extended.underlineStyle}`), " " === w && (w = "\xA0"), !I.isUnderlineColorDefault()))
                  if (I.isUnderlineColorRGB())
                    C.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(I.getUnderlineColor()).join(",")})`;
                  else {
                    let e4 = I.getUnderlineColor();
                    this._optionsService.rawOptions.drawBoldTextInBrightColors && I.isBold() && e4 < 8 && (e4 += 8), C.style.textDecorationColor = S.ansi[e4].css;
                  }
                I.isOverline() && (B.push("xterm-overline"), " " === w && (w = "\xA0")), I.isStrikethrough() && B.push("xterm-strikethrough"), W && (C.style.textDecoration = "underline");
                let $ = I.getFgColor(), j = I.getFgColorMode(), z = I.getBgColor(), K = I.getBgColorMode();
                const q = !!I.isInverse();
                if (q) {
                  const e4 = $;
                  $ = z, z = e4;
                  const t4 = j;
                  j = K, K = t4;
                }
                let V, G, X, J = false;
                switch (this._decorationService.forEachDecorationAtCell(M, t3, void 0, (e4) => {
                  "top" !== e4.options.layer && J || (e4.backgroundColorRGB && (K = 50331648, z = e4.backgroundColorRGB.rgba >> 8 & 16777215, V = e4.backgroundColorRGB), e4.foregroundColorRGB && (j = 50331648, $ = e4.foregroundColorRGB.rgba >> 8 & 16777215, G = e4.foregroundColorRGB), J = "top" === e4.options.layer);
                }), !J && H && (V = this._coreBrowserService.isFocused ? S.selectionBackgroundOpaque : S.selectionInactiveBackgroundOpaque, z = V.rgba >> 8 & 16777215, K = 50331648, J = true, S.selectionForeground && (j = 50331648, $ = S.selectionForeground.rgba >> 8 & 16777215, G = S.selectionForeground)), J && B.push("xterm-decoration-top"), K) {
                  case 16777216:
                  case 33554432:
                    X = S.ansi[z], B.push(`xterm-bg-${z}`);
                    break;
                  case 50331648:
                    X = c.rgba.toColor(z >> 16, z >> 8 & 255, 255 & z), this._addStyle(C, `background-color:#${v((z >>> 0).toString(16), "0", 6)}`);
                    break;
                  default:
                    q ? (X = S.foreground, B.push(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : X = S.background;
                }
                switch (V || I.isDim() && (V = c.color.multiplyOpacity(X, 0.5)), j) {
                  case 16777216:
                  case 33554432:
                    I.isBold() && $ < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && ($ += 8), this._applyMinimumContrast(C, X, S.ansi[$], I, V, void 0) || B.push(`xterm-fg-${$}`);
                    break;
                  case 50331648:
                    const e4 = c.rgba.toColor($ >> 16 & 255, $ >> 8 & 255, 255 & $);
                    this._applyMinimumContrast(C, X, e4, I, V, G) || this._addStyle(C, `color:#${v($.toString(16), "0", 6)}`);
                    break;
                  default:
                    this._applyMinimumContrast(C, X, S.foreground, I, V, void 0) || q && B.push(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);
                }
                B.length && (C.className = B.join(" "), B.length = 0), F || O || U ? C.textContent = w : y++, A !== this.defaultSpacing && (C.style.letterSpacing = `${A}px`), g.push(C), M = P;
              }
              return C && y && (C.textContent = w), g;
            }
            _applyMinimumContrast(e3, t3, i3, s3, r2, n2) {
              if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _.excludeFromContrastRatioDemands)(s3.getCode()))
                return false;
              const o2 = this._getContrastCache(s3);
              let a2;
              if (r2 || n2 || (a2 = o2.getColor(t3.rgba, i3.rgba)), void 0 === a2) {
                const e4 = this._optionsService.rawOptions.minimumContrastRatio / (s3.isDim() ? 2 : 1);
                a2 = c.color.ensureContrastRatio(r2 || t3, n2 || i3, e4), o2.setColor((r2 || t3).rgba, (n2 || i3).rgba, null != a2 ? a2 : null);
              }
              return !!a2 && (this._addStyle(e3, `color:${a2.css}`), true);
            }
            _getContrastCache(e3) {
              return e3.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
            }
            _addStyle(e3, t3) {
              e3.setAttribute("style", `${e3.getAttribute("style") || ""}${t3};`);
            }
            _isCellInSelection(e3, t3) {
              const i3 = this._selectionStart, s3 = this._selectionEnd;
              return !(!i3 || !s3) && (this._columnSelectMode ? i3[0] <= s3[0] ? e3 >= i3[0] && t3 >= i3[1] && e3 < s3[0] && t3 <= s3[1] : e3 < i3[0] && t3 >= i3[1] && e3 >= s3[0] && t3 <= s3[1] : t3 > i3[1] && t3 < s3[1] || i3[1] === s3[1] && t3 === i3[1] && e3 >= i3[0] && e3 < s3[0] || i3[1] < s3[1] && t3 === s3[1] && e3 < s3[0] || i3[1] < s3[1] && t3 === i3[1] && e3 >= i3[0]);
            }
          };
          function v(e3, t3, i3) {
            for (; e3.length < i3; )
              e3 = t3 + e3;
            return e3;
          }
          t2.DomRendererRowFactory = f = s2([r(1, l.ICharacterJoinerService), r(2, h.IOptionsService), r(3, l.ICoreBrowserService), r(4, h.ICoreService), r(5, h.IDecorationService), r(6, l.IThemeService)], f);
        }, 2550: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.WidthCache = void 0, t2.WidthCache = class {
            constructor(e3) {
              this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = e3.createElement("div"), this._container.style.position = "absolute", this._container.style.top = "-50000px", this._container.style.width = "50000px", this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
              const t3 = e3.createElement("span"), i2 = e3.createElement("span");
              i2.style.fontWeight = "bold";
              const s2 = e3.createElement("span");
              s2.style.fontStyle = "italic";
              const r = e3.createElement("span");
              r.style.fontWeight = "bold", r.style.fontStyle = "italic", this._measureElements = [t3, i2, s2, r], this._container.appendChild(t3), this._container.appendChild(i2), this._container.appendChild(s2), this._container.appendChild(r), e3.body.appendChild(this._container), this.clear();
            }
            dispose() {
              this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
            }
            clear() {
              this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
            }
            setFont(e3, t3, i2, s2) {
              e3 === this._font && t3 === this._fontSize && i2 === this._weight && s2 === this._weightBold || (this._font = e3, this._fontSize = t3, this._weight = i2, this._weightBold = s2, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${i2}`, this._measureElements[1].style.fontWeight = `${s2}`, this._measureElements[2].style.fontWeight = `${i2}`, this._measureElements[3].style.fontWeight = `${s2}`, this.clear());
            }
            get(e3, t3, i2) {
              let s2 = 0;
              if (!t3 && !i2 && 1 === e3.length && (s2 = e3.charCodeAt(0)) < 256)
                return -9999 !== this._flat[s2] ? this._flat[s2] : this._flat[s2] = this._measure(e3, 0);
              let r = e3;
              t3 && (r += "B"), i2 && (r += "I");
              let n = this._holey.get(r);
              if (void 0 === n) {
                let s3 = 0;
                t3 && (s3 |= 1), i2 && (s3 |= 2), n = this._measure(e3, s3), this._holey.set(r, n);
              }
              return n;
            }
            _measure(e3, t3) {
              const i2 = this._measureElements[t3];
              return i2.textContent = e3.repeat(32), i2.offsetWidth / 32;
            }
          };
        }, 2223: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.TEXT_BASELINE = t2.DIM_OPACITY = t2.INVERTED_DEFAULT_COLOR = void 0;
          const s2 = i2(6114);
          t2.INVERTED_DEFAULT_COLOR = 257, t2.DIM_OPACITY = 0.5, t2.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
        }, 6171: (e2, t2) => {
          function i2(e3) {
            return 57508 <= e3 && e3 <= 57558;
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.createRenderDimensions = t2.excludeFromContrastRatioDemands = t2.isRestrictedPowerlineGlyph = t2.isPowerlineGlyph = t2.throwIfFalsy = void 0, t2.throwIfFalsy = function(e3) {
            if (!e3)
              throw new Error("value must not be falsy");
            return e3;
          }, t2.isPowerlineGlyph = i2, t2.isRestrictedPowerlineGlyph = function(e3) {
            return 57520 <= e3 && e3 <= 57527;
          }, t2.excludeFromContrastRatioDemands = function(e3) {
            return i2(e3) || function(e4) {
              return 9472 <= e4 && e4 <= 9631;
            }(e3);
          }, t2.createRenderDimensions = function() {
            return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
          };
        }, 456: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionModel = void 0, t2.SelectionModel = class {
            constructor(e3) {
              this._bufferService = e3, this.isSelectAllActive = false, this.selectionStartLength = 0;
            }
            clearSelection() {
              this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = false, this.selectionStartLength = 0;
            }
            get finalSelectionStart() {
              return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
            }
            get finalSelectionEnd() {
              if (this.isSelectAllActive)
                return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
              if (this.selectionStart) {
                if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                  const e3 = this.selectionStart[0] + this.selectionStartLength;
                  return e3 > this._bufferService.cols ? e3 % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols) - 1] : [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [e3, this.selectionStart[1]];
                }
                if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                  const e3 = this.selectionStart[0] + this.selectionStartLength;
                  return e3 > this._bufferService.cols ? [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [Math.max(e3, this.selectionEnd[0]), this.selectionEnd[1]];
                }
                return this.selectionEnd;
              }
            }
            areSelectionValuesReversed() {
              const e3 = this.selectionStart, t3 = this.selectionEnd;
              return !(!e3 || !t3) && (e3[1] > t3[1] || e3[1] === t3[1] && e3[0] > t3[0]);
            }
            handleTrim(e3) {
              return this.selectionStart && (this.selectionStart[1] -= e3), this.selectionEnd && (this.selectionEnd[1] -= e3), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
            }
          };
        }, 428: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CharSizeService = void 0;
          const n = i2(2585), o = i2(8460), a = i2(844);
          let h = t2.CharSizeService = class extends a.Disposable {
            get hasValidSize() {
              return this.width > 0 && this.height > 0;
            }
            constructor(e3, t3, i3) {
              super(), this._optionsService = i3, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new c(e3, t3, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
            }
            measure() {
              const e3 = this._measureStrategy.measure();
              e3.width === this.width && e3.height === this.height || (this.width = e3.width, this.height = e3.height, this._onCharSizeChange.fire());
            }
          };
          t2.CharSizeService = h = s2([r(2, n.IOptionsService)], h);
          class c {
            constructor(e3, t3, i3) {
              this._document = e3, this._parentElement = t3, this._optionsService = i3, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
            }
            measure() {
              this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
              const e3 = { height: Number(this._measureElement.offsetHeight), width: Number(this._measureElement.offsetWidth) };
              return 0 !== e3.width && 0 !== e3.height && (this._result.width = e3.width / 32, this._result.height = Math.ceil(e3.height)), this._result;
            }
          }
        }, 4269: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CharacterJoinerService = t2.JoinedCellData = void 0;
          const n = i2(3734), o = i2(643), a = i2(511), h = i2(2585);
          class c extends n.AttributeData {
            constructor(e3, t3, i3) {
              super(), this.content = 0, this.combinedData = "", this.fg = e3.fg, this.bg = e3.bg, this.combinedData = t3, this._width = i3;
            }
            isCombined() {
              return 2097152;
            }
            getWidth() {
              return this._width;
            }
            getChars() {
              return this.combinedData;
            }
            getCode() {
              return 2097151;
            }
            setFromCharData(e3) {
              throw new Error("not implemented");
            }
            getAsCharData() {
              return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
            }
          }
          t2.JoinedCellData = c;
          let l = t2.CharacterJoinerService = class e3 {
            constructor(e4) {
              this._bufferService = e4, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();
            }
            register(e4) {
              const t3 = { id: this._nextCharacterJoinerId++, handler: e4 };
              return this._characterJoiners.push(t3), t3.id;
            }
            deregister(e4) {
              for (let t3 = 0; t3 < this._characterJoiners.length; t3++)
                if (this._characterJoiners[t3].id === e4)
                  return this._characterJoiners.splice(t3, 1), true;
              return false;
            }
            getJoinedCharacters(e4) {
              if (0 === this._characterJoiners.length)
                return [];
              const t3 = this._bufferService.buffer.lines.get(e4);
              if (!t3 || 0 === t3.length)
                return [];
              const i3 = [], s3 = t3.translateToString(true);
              let r2 = 0, n2 = 0, a2 = 0, h2 = t3.getFg(0), c2 = t3.getBg(0);
              for (let e5 = 0; e5 < t3.getTrimmedLength(); e5++)
                if (t3.loadCell(e5, this._workCell), 0 !== this._workCell.getWidth()) {
                  if (this._workCell.fg !== h2 || this._workCell.bg !== c2) {
                    if (e5 - r2 > 1) {
                      const e6 = this._getJoinedRanges(s3, a2, n2, t3, r2);
                      for (let t4 = 0; t4 < e6.length; t4++)
                        i3.push(e6[t4]);
                    }
                    r2 = e5, a2 = n2, h2 = this._workCell.fg, c2 = this._workCell.bg;
                  }
                  n2 += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
                }
              if (this._bufferService.cols - r2 > 1) {
                const e5 = this._getJoinedRanges(s3, a2, n2, t3, r2);
                for (let t4 = 0; t4 < e5.length; t4++)
                  i3.push(e5[t4]);
              }
              return i3;
            }
            _getJoinedRanges(t3, i3, s3, r2, n2) {
              const o2 = t3.substring(i3, s3);
              let a2 = [];
              try {
                a2 = this._characterJoiners[0].handler(o2);
              } catch (e4) {
                console.error(e4);
              }
              for (let t4 = 1; t4 < this._characterJoiners.length; t4++)
                try {
                  const i4 = this._characterJoiners[t4].handler(o2);
                  for (let t5 = 0; t5 < i4.length; t5++)
                    e3._mergeRanges(a2, i4[t5]);
                } catch (e4) {
                  console.error(e4);
                }
              return this._stringRangesToCellRanges(a2, r2, n2), a2;
            }
            _stringRangesToCellRanges(e4, t3, i3) {
              let s3 = 0, r2 = false, n2 = 0, a2 = e4[s3];
              if (a2) {
                for (let h2 = i3; h2 < this._bufferService.cols; h2++) {
                  const i4 = t3.getWidth(h2), c2 = t3.getString(h2).length || o.WHITESPACE_CELL_CHAR.length;
                  if (0 !== i4) {
                    if (!r2 && a2[0] <= n2 && (a2[0] = h2, r2 = true), a2[1] <= n2) {
                      if (a2[1] = h2, a2 = e4[++s3], !a2)
                        break;
                      a2[0] <= n2 ? (a2[0] = h2, r2 = true) : r2 = false;
                    }
                    n2 += c2;
                  }
                }
                a2 && (a2[1] = this._bufferService.cols);
              }
            }
            static _mergeRanges(e4, t3) {
              let i3 = false;
              for (let s3 = 0; s3 < e4.length; s3++) {
                const r2 = e4[s3];
                if (i3) {
                  if (t3[1] <= r2[0])
                    return e4[s3 - 1][1] = t3[1], e4;
                  if (t3[1] <= r2[1])
                    return e4[s3 - 1][1] = Math.max(t3[1], r2[1]), e4.splice(s3, 1), e4;
                  e4.splice(s3, 1), s3--;
                } else {
                  if (t3[1] <= r2[0])
                    return e4.splice(s3, 0, t3), e4;
                  if (t3[1] <= r2[1])
                    return r2[0] = Math.min(t3[0], r2[0]), e4;
                  t3[0] < r2[1] && (r2[0] = Math.min(t3[0], r2[0]), i3 = true);
                }
              }
              return i3 ? e4[e4.length - 1][1] = t3[1] : e4.push(t3), e4;
            }
          };
          t2.CharacterJoinerService = l = s2([r(0, h.IBufferService)], l);
        }, 5114: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreBrowserService = void 0, t2.CoreBrowserService = class {
            constructor(e3, t3) {
              this._textarea = e3, this.window = t3, this._isFocused = false, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = true), this._textarea.addEventListener("blur", () => this._isFocused = false);
            }
            get dpr() {
              return this.window.devicePixelRatio;
            }
            get isFocused() {
              return void 0 === this._cachedIsFocused && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
            }
          };
        }, 8934: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.MouseService = void 0;
          const n = i2(4725), o = i2(9806);
          let a = t2.MouseService = class {
            constructor(e3, t3) {
              this._renderService = e3, this._charSizeService = t3;
            }
            getCoords(e3, t3, i3, s3, r2) {
              return (0, o.getCoords)(window, e3, t3, i3, s3, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r2);
            }
            getMouseReportCoords(e3, t3) {
              const i3 = (0, o.getCoordsRelativeToElement)(window, e3, t3);
              if (this._charSizeService.hasValidSize)
                return i3[0] = Math.min(Math.max(i3[0], 0), this._renderService.dimensions.css.canvas.width - 1), i3[1] = Math.min(Math.max(i3[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(i3[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(i3[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(i3[0]), y: Math.floor(i3[1]) };
            }
          };
          t2.MouseService = a = s2([r(0, n.IRenderService), r(1, n.ICharSizeService)], a);
        }, 3230: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderService = void 0;
          const n = i2(3656), o = i2(6193), a = i2(5596), h = i2(4725), c = i2(8460), l = i2(844), d = i2(7226), _ = i2(2585);
          let u = t2.RenderService = class extends l.Disposable {
            get dimensions() {
              return this._renderer.value.dimensions;
            }
            constructor(e3, t3, i3, s3, r2, h2, _2, u2) {
              if (super(), this._rowCount = e3, this._charSizeService = s3, this._renderer = this.register(new l.MutableDisposable()), this._pausedResizeTask = new d.DebouncedIdleTask(), this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: false }, this._onDimensionsChange = this.register(new c.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new c.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new c.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new c.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new o.RenderDebouncer(_2.window, (e4, t4) => this._renderRows(e4, t4)), this.register(this._renderDebouncer), this._screenDprMonitor = new a.ScreenDprMonitor(_2.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(h2.onResize(() => this._fullRefresh())), this.register(h2.buffers.onBufferActivate(() => {
                var e4;
                return null === (e4 = this._renderer.value) || void 0 === e4 ? void 0 : e4.clear();
              })), this.register(i3.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(r2.onDecorationRegistered(() => this._fullRefresh())), this.register(r2.onDecorationRemoved(() => this._fullRefresh())), this.register(i3.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
                this.clear(), this.handleResize(h2.cols, h2.rows), this._fullRefresh();
              })), this.register(i3.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(h2.buffer.y, h2.buffer.y, true))), this.register((0, n.addDisposableDomListener)(_2.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(u2.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in _2.window) {
                const e4 = new _2.window.IntersectionObserver((e5) => this._handleIntersectionChange(e5[e5.length - 1]), { threshold: 0 });
                e4.observe(t3), this.register({ dispose: () => e4.disconnect() });
              }
            }
            _handleIntersectionChange(e3) {
              this._isPaused = void 0 === e3.isIntersecting ? 0 === e3.intersectionRatio : !e3.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
            }
            refreshRows(e3, t3, i3 = false) {
              this._isPaused ? this._needsFullRefresh = true : (i3 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(e3, t3, this._rowCount));
            }
            _renderRows(e3, t3) {
              this._renderer.value && (e3 = Math.min(e3, this._rowCount - 1), t3 = Math.min(t3, this._rowCount - 1), this._renderer.value.renderRows(e3, t3), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: e3, end: t3 }), this._onRender.fire({ start: e3, end: t3 }), this._isNextRenderRedrawOnly = true);
            }
            resize(e3, t3) {
              this._rowCount = t3, this._fireOnCanvasResize();
            }
            _handleOptionsChanged() {
              this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
            }
            _fireOnCanvasResize() {
              this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
            }
            hasRenderer() {
              return !!this._renderer.value;
            }
            setRenderer(e3) {
              this._renderer.value = e3, this._renderer.value.onRequestRedraw((e4) => this.refreshRows(e4.start, e4.end, true)), this._needsSelectionRefresh = true, this._fullRefresh();
            }
            addRefreshCallback(e3) {
              return this._renderDebouncer.addRefreshCallback(e3);
            }
            _fullRefresh() {
              this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
            }
            clearTextureAtlas() {
              var e3, t3;
              this._renderer.value && (null === (t3 = (e3 = this._renderer.value).clearTextureAtlas) || void 0 === t3 || t3.call(e3), this._fullRefresh());
            }
            handleDevicePixelRatioChange() {
              this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
            }
            handleResize(e3, t3) {
              this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value.handleResize(e3, t3)) : this._renderer.value.handleResize(e3, t3), this._fullRefresh());
            }
            handleCharSizeChanged() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.handleCharSizeChanged();
            }
            handleBlur() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.handleBlur();
            }
            handleFocus() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.handleFocus();
            }
            handleSelectionChanged(e3, t3, i3) {
              var s3;
              this._selectionState.start = e3, this._selectionState.end = t3, this._selectionState.columnSelectMode = i3, null === (s3 = this._renderer.value) || void 0 === s3 || s3.handleSelectionChanged(e3, t3, i3);
            }
            handleCursorMove() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.handleCursorMove();
            }
            clear() {
              var e3;
              null === (e3 = this._renderer.value) || void 0 === e3 || e3.clear();
            }
          };
          t2.RenderService = u = s2([r(2, _.IOptionsService), r(3, h.ICharSizeService), r(4, _.IDecorationService), r(5, _.IBufferService), r(6, h.ICoreBrowserService), r(7, h.IThemeService)], u);
        }, 9312: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionService = void 0;
          const n = i2(9806), o = i2(9504), a = i2(456), h = i2(4725), c = i2(8460), l = i2(844), d = i2(6114), _ = i2(4841), u = i2(511), f = i2(2585), v = String.fromCharCode(160), p = new RegExp(v, "g");
          let g = t2.SelectionService = class extends l.Disposable {
            constructor(e3, t3, i3, s3, r2, n2, o2, h2, d2) {
              super(), this._element = e3, this._screenElement = t3, this._linkifier = i3, this._bufferService = s3, this._coreService = r2, this._mouseService = n2, this._optionsService = o2, this._renderService = h2, this._coreBrowserService = d2, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new u.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new c.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new c.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new c.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new c.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e4) => this._handleMouseMove(e4), this._mouseUpListener = (e4) => this._handleMouseUp(e4), this._coreService.onUserInput(() => {
                this.hasSelection && this.clearSelection();
              }), this._trimListener = this._bufferService.buffer.lines.onTrim((e4) => this._handleTrim(e4)), this.register(this._bufferService.buffers.onBufferActivate((e4) => this._handleBufferActivate(e4))), this.enable(), this._model = new a.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, l.toDisposable)(() => {
                this._removeMouseDownListeners();
              }));
            }
            reset() {
              this.clearSelection();
            }
            disable() {
              this.clearSelection(), this._enabled = false;
            }
            enable() {
              this._enabled = true;
            }
            get selectionStart() {
              return this._model.finalSelectionStart;
            }
            get selectionEnd() {
              return this._model.finalSelectionEnd;
            }
            get hasSelection() {
              const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
              return !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
            }
            get selectionText() {
              const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
              if (!e3 || !t3)
                return "";
              const i3 = this._bufferService.buffer, s3 = [];
              if (3 === this._activeSelectionMode) {
                if (e3[0] === t3[0])
                  return "";
                const r2 = e3[0] < t3[0] ? e3[0] : t3[0], n2 = e3[0] < t3[0] ? t3[0] : e3[0];
                for (let o2 = e3[1]; o2 <= t3[1]; o2++) {
                  const e4 = i3.translateBufferLineToString(o2, true, r2, n2);
                  s3.push(e4);
                }
              } else {
                const r2 = e3[1] === t3[1] ? t3[0] : void 0;
                s3.push(i3.translateBufferLineToString(e3[1], true, e3[0], r2));
                for (let r3 = e3[1] + 1; r3 <= t3[1] - 1; r3++) {
                  const e4 = i3.lines.get(r3), t4 = i3.translateBufferLineToString(r3, true);
                  (null == e4 ? void 0 : e4.isWrapped) ? s3[s3.length - 1] += t4 : s3.push(t4);
                }
                if (e3[1] !== t3[1]) {
                  const e4 = i3.lines.get(t3[1]), r3 = i3.translateBufferLineToString(t3[1], true, 0, t3[0]);
                  e4 && e4.isWrapped ? s3[s3.length - 1] += r3 : s3.push(r3);
                }
              }
              return s3.map((e4) => e4.replace(p, " ")).join(d.isWindows ? "\r\n" : "\n");
            }
            clearSelection() {
              this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
            }
            refresh(e3) {
              this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), d.isLinux && e3 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
            }
            _refresh() {
              this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: 3 === this._activeSelectionMode });
            }
            _isClickInSelection(e3) {
              const t3 = this._getMouseBufferCoords(e3), i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
              return !!(i3 && s3 && t3) && this._areCoordsInSelection(t3, i3, s3);
            }
            isCellInSelection(e3, t3) {
              const i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
              return !(!i3 || !s3) && this._areCoordsInSelection([e3, t3], i3, s3);
            }
            _areCoordsInSelection(e3, t3, i3) {
              return e3[1] > t3[1] && e3[1] < i3[1] || t3[1] === i3[1] && e3[1] === t3[1] && e3[0] >= t3[0] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === i3[1] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === t3[1] && e3[0] >= t3[0];
            }
            _selectWordAtCursor(e3, t3) {
              var i3, s3;
              const r2 = null === (s3 = null === (i3 = this._linkifier.currentLink) || void 0 === i3 ? void 0 : i3.link) || void 0 === s3 ? void 0 : s3.range;
              if (r2)
                return this._model.selectionStart = [r2.start.x - 1, r2.start.y - 1], this._model.selectionStartLength = (0, _.getRangeLength)(r2, this._bufferService.cols), this._model.selectionEnd = void 0, true;
              const n2 = this._getMouseBufferCoords(e3);
              return !!n2 && (this._selectWordAt(n2, t3), this._model.selectionEnd = void 0, true);
            }
            selectAll() {
              this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
            }
            selectLines(e3, t3) {
              this._model.clearSelection(), e3 = Math.max(e3, 0), t3 = Math.min(t3, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, e3], this._model.selectionEnd = [this._bufferService.cols, t3], this.refresh(), this._onSelectionChange.fire();
            }
            _handleTrim(e3) {
              this._model.handleTrim(e3) && this.refresh();
            }
            _getMouseBufferCoords(e3) {
              const t3 = this._mouseService.getCoords(e3, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
              if (t3)
                return t3[0]--, t3[1]--, t3[1] += this._bufferService.buffer.ydisp, t3;
            }
            _getMouseEventScrollAmount(e3) {
              let t3 = (0, n.getCoordsRelativeToElement)(this._coreBrowserService.window, e3, this._screenElement)[1];
              const i3 = this._renderService.dimensions.css.canvas.height;
              return t3 >= 0 && t3 <= i3 ? 0 : (t3 > i3 && (t3 -= i3), t3 = Math.min(Math.max(t3, -50), 50), t3 /= 50, t3 / Math.abs(t3) + Math.round(14 * t3));
            }
            shouldForceSelection(e3) {
              return d.isMac ? e3.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e3.shiftKey;
            }
            handleMouseDown(e3) {
              if (this._mouseDownTimeStamp = e3.timeStamp, (2 !== e3.button || !this.hasSelection) && 0 === e3.button) {
                if (!this._enabled) {
                  if (!this.shouldForceSelection(e3))
                    return;
                  e3.stopPropagation();
                }
                e3.preventDefault(), this._dragScrollAmount = 0, this._enabled && e3.shiftKey ? this._handleIncrementalClick(e3) : 1 === e3.detail ? this._handleSingleClick(e3) : 2 === e3.detail ? this._handleDoubleClick(e3) : 3 === e3.detail && this._handleTripleClick(e3), this._addMouseDownListeners(), this.refresh(true);
              }
            }
            _addMouseDownListeners() {
              this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
            }
            _removeMouseDownListeners() {
              this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
            }
            _handleIncrementalClick(e3) {
              this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e3));
            }
            _handleSingleClick(e3) {
              if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(e3) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e3), !this._model.selectionStart)
                return;
              this._model.selectionEnd = void 0;
              const t3 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
              t3 && t3.length !== this._model.selectionStart[0] && 0 === t3.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;
            }
            _handleDoubleClick(e3) {
              this._selectWordAtCursor(e3, true) && (this._activeSelectionMode = 1);
            }
            _handleTripleClick(e3) {
              const t3 = this._getMouseBufferCoords(e3);
              t3 && (this._activeSelectionMode = 2, this._selectLineAt(t3[1]));
            }
            shouldColumnSelect(e3) {
              return e3.altKey && !(d.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
            }
            _handleMouseMove(e3) {
              if (e3.stopImmediatePropagation(), !this._model.selectionStart)
                return;
              const t3 = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
              if (this._model.selectionEnd = this._getMouseBufferCoords(e3), !this._model.selectionEnd)
                return void this.refresh(true);
              2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e3), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
              const i3 = this._bufferService.buffer;
              if (this._model.selectionEnd[1] < i3.lines.length) {
                const e4 = i3.lines.get(this._model.selectionEnd[1]);
                e4 && 0 === e4.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0]++;
              }
              t3 && t3[0] === this._model.selectionEnd[0] && t3[1] === this._model.selectionEnd[1] || this.refresh(true);
            }
            _dragScroll() {
              if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
                this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: false });
                const e3 = this._bufferService.buffer;
                this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e3.ydisp + this._bufferService.rows, e3.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e3.ydisp), this.refresh();
              }
            }
            _handleMouseUp(e3) {
              const t3 = e3.timeStamp - this._mouseDownTimeStamp;
              if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t3 < 500 && e3.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
                if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                  const t4 = this._mouseService.getCoords(e3, this._element, this._bufferService.cols, this._bufferService.rows, false);
                  if (t4 && void 0 !== t4[0] && void 0 !== t4[1]) {
                    const e4 = (0, o.moveToCellSequence)(t4[0] - 1, t4[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                    this._coreService.triggerDataEvent(e4, true);
                  }
                }
              } else
                this._fireEventIfSelectionChanged();
            }
            _fireEventIfSelectionChanged() {
              const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd, i3 = !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
              i3 ? e3 && t3 && (this._oldSelectionStart && this._oldSelectionEnd && e3[0] === this._oldSelectionStart[0] && e3[1] === this._oldSelectionStart[1] && t3[0] === this._oldSelectionEnd[0] && t3[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e3, t3, i3)) : this._oldHasSelection && this._fireOnSelectionChange(e3, t3, i3);
            }
            _fireOnSelectionChange(e3, t3, i3) {
              this._oldSelectionStart = e3, this._oldSelectionEnd = t3, this._oldHasSelection = i3, this._onSelectionChange.fire();
            }
            _handleBufferActivate(e3) {
              this.clearSelection(), this._trimListener.dispose(), this._trimListener = e3.activeBuffer.lines.onTrim((e4) => this._handleTrim(e4));
            }
            _convertViewportColToCharacterIndex(e3, t3) {
              let i3 = t3;
              for (let s3 = 0; t3 >= s3; s3++) {
                const r2 = e3.loadCell(s3, this._workCell).getChars().length;
                0 === this._workCell.getWidth() ? i3-- : r2 > 1 && t3 !== s3 && (i3 += r2 - 1);
              }
              return i3;
            }
            setSelection(e3, t3, i3) {
              this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [e3, t3], this._model.selectionStartLength = i3, this.refresh(), this._fireEventIfSelectionChanged();
            }
            rightClickSelect(e3) {
              this._isClickInSelection(e3) || (this._selectWordAtCursor(e3, false) && this.refresh(true), this._fireEventIfSelectionChanged());
            }
            _getWordAt(e3, t3, i3 = true, s3 = true) {
              if (e3[0] >= this._bufferService.cols)
                return;
              const r2 = this._bufferService.buffer, n2 = r2.lines.get(e3[1]);
              if (!n2)
                return;
              const o2 = r2.translateBufferLineToString(e3[1], false);
              let a2 = this._convertViewportColToCharacterIndex(n2, e3[0]), h2 = a2;
              const c2 = e3[0] - a2;
              let l2 = 0, d2 = 0, _2 = 0, u2 = 0;
              if (" " === o2.charAt(a2)) {
                for (; a2 > 0 && " " === o2.charAt(a2 - 1); )
                  a2--;
                for (; h2 < o2.length && " " === o2.charAt(h2 + 1); )
                  h2++;
              } else {
                let t4 = e3[0], i4 = e3[0];
                0 === n2.getWidth(t4) && (l2++, t4--), 2 === n2.getWidth(i4) && (d2++, i4++);
                const s4 = n2.getString(i4).length;
                for (s4 > 1 && (u2 += s4 - 1, h2 += s4 - 1); t4 > 0 && a2 > 0 && !this._isCharWordSeparator(n2.loadCell(t4 - 1, this._workCell)); ) {
                  n2.loadCell(t4 - 1, this._workCell);
                  const e4 = this._workCell.getChars().length;
                  0 === this._workCell.getWidth() ? (l2++, t4--) : e4 > 1 && (_2 += e4 - 1, a2 -= e4 - 1), a2--, t4--;
                }
                for (; i4 < n2.length && h2 + 1 < o2.length && !this._isCharWordSeparator(n2.loadCell(i4 + 1, this._workCell)); ) {
                  n2.loadCell(i4 + 1, this._workCell);
                  const e4 = this._workCell.getChars().length;
                  2 === this._workCell.getWidth() ? (d2++, i4++) : e4 > 1 && (u2 += e4 - 1, h2 += e4 - 1), h2++, i4++;
                }
              }
              h2++;
              let f2 = a2 + c2 - l2 + _2, v2 = Math.min(this._bufferService.cols, h2 - a2 + l2 + d2 - _2 - u2);
              if (t3 || "" !== o2.slice(a2, h2).trim()) {
                if (i3 && 0 === f2 && 32 !== n2.getCodePoint(0)) {
                  const t4 = r2.lines.get(e3[1] - 1);
                  if (t4 && n2.isWrapped && 32 !== t4.getCodePoint(this._bufferService.cols - 1)) {
                    const t5 = this._getWordAt([this._bufferService.cols - 1, e3[1] - 1], false, true, false);
                    if (t5) {
                      const e4 = this._bufferService.cols - t5.start;
                      f2 -= e4, v2 += e4;
                    }
                  }
                }
                if (s3 && f2 + v2 === this._bufferService.cols && 32 !== n2.getCodePoint(this._bufferService.cols - 1)) {
                  const t4 = r2.lines.get(e3[1] + 1);
                  if ((null == t4 ? void 0 : t4.isWrapped) && 32 !== t4.getCodePoint(0)) {
                    const t5 = this._getWordAt([0, e3[1] + 1], false, false, true);
                    t5 && (v2 += t5.length);
                  }
                }
                return { start: f2, length: v2 };
              }
            }
            _selectWordAt(e3, t3) {
              const i3 = this._getWordAt(e3, t3);
              if (i3) {
                for (; i3.start < 0; )
                  i3.start += this._bufferService.cols, e3[1]--;
                this._model.selectionStart = [i3.start, e3[1]], this._model.selectionStartLength = i3.length;
              }
            }
            _selectToWordAt(e3) {
              const t3 = this._getWordAt(e3, true);
              if (t3) {
                let i3 = e3[1];
                for (; t3.start < 0; )
                  t3.start += this._bufferService.cols, i3--;
                if (!this._model.areSelectionValuesReversed())
                  for (; t3.start + t3.length > this._bufferService.cols; )
                    t3.length -= this._bufferService.cols, i3++;
                this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? t3.start : t3.start + t3.length, i3];
              }
            }
            _isCharWordSeparator(e3) {
              return 0 !== e3.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e3.getChars()) >= 0;
            }
            _selectLineAt(e3) {
              const t3 = this._bufferService.buffer.getWrappedRangeForLine(e3), i3 = { start: { x: 0, y: t3.first }, end: { x: this._bufferService.cols - 1, y: t3.last } };
              this._model.selectionStart = [0, t3.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, _.getRangeLength)(i3, this._bufferService.cols);
            }
          };
          t2.SelectionService = g = s2([r(3, f.IBufferService), r(4, f.ICoreService), r(5, h.IMouseService), r(6, f.IOptionsService), r(7, h.IRenderService), r(8, h.ICoreBrowserService)], g);
        }, 4725: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.IThemeService = t2.ICharacterJoinerService = t2.ISelectionService = t2.IRenderService = t2.IMouseService = t2.ICoreBrowserService = t2.ICharSizeService = void 0;
          const s2 = i2(8343);
          t2.ICharSizeService = (0, s2.createDecorator)("CharSizeService"), t2.ICoreBrowserService = (0, s2.createDecorator)("CoreBrowserService"), t2.IMouseService = (0, s2.createDecorator)("MouseService"), t2.IRenderService = (0, s2.createDecorator)("RenderService"), t2.ISelectionService = (0, s2.createDecorator)("SelectionService"), t2.ICharacterJoinerService = (0, s2.createDecorator)("CharacterJoinerService"), t2.IThemeService = (0, s2.createDecorator)("ThemeService");
        }, 6731: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ThemeService = t2.DEFAULT_ANSI_COLORS = void 0;
          const n = i2(7239), o = i2(8055), a = i2(8460), h = i2(844), c = i2(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _ = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
          t2.DEFAULT_ANSI_COLORS = Object.freeze((() => {
            const e3 = [o.css.toColor("#2e3436"), o.css.toColor("#cc0000"), o.css.toColor("#4e9a06"), o.css.toColor("#c4a000"), o.css.toColor("#3465a4"), o.css.toColor("#75507b"), o.css.toColor("#06989a"), o.css.toColor("#d3d7cf"), o.css.toColor("#555753"), o.css.toColor("#ef2929"), o.css.toColor("#8ae234"), o.css.toColor("#fce94f"), o.css.toColor("#729fcf"), o.css.toColor("#ad7fa8"), o.css.toColor("#34e2e2"), o.css.toColor("#eeeeec")], t3 = [0, 95, 135, 175, 215, 255];
            for (let i3 = 0; i3 < 216; i3++) {
              const s3 = t3[i3 / 36 % 6 | 0], r2 = t3[i3 / 6 % 6 | 0], n2 = t3[i3 % 6];
              e3.push({ css: o.channels.toCss(s3, r2, n2), rgba: o.channels.toRgba(s3, r2, n2) });
            }
            for (let t4 = 0; t4 < 24; t4++) {
              const i3 = 8 + 10 * t4;
              e3.push({ css: o.channels.toCss(i3, i3, i3), rgba: o.channels.toRgba(i3, i3, i3) });
            }
            return e3;
          })());
          let v = t2.ThemeService = class extends h.Disposable {
            get colors() {
              return this._colors;
            }
            constructor(e3) {
              super(), this._optionsService = e3, this._contrastCache = new n.ColorContrastCache(), this._halfContrastCache = new n.ColorContrastCache(), this._onChangeColors = this.register(new a.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: l, background: d, cursor: _, cursorAccent: u, selectionForeground: void 0, selectionBackgroundTransparent: f, selectionBackgroundOpaque: o.color.blend(d, f), selectionInactiveBackgroundTransparent: f, selectionInactiveBackgroundOpaque: o.color.blend(d, f), ansi: t2.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
            }
            _setTheme(e3 = {}) {
              const i3 = this._colors;
              if (i3.foreground = p(e3.foreground, l), i3.background = p(e3.background, d), i3.cursor = p(e3.cursor, _), i3.cursorAccent = p(e3.cursorAccent, u), i3.selectionBackgroundTransparent = p(e3.selectionBackground, f), i3.selectionBackgroundOpaque = o.color.blend(i3.background, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundTransparent = p(e3.selectionInactiveBackground, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundOpaque = o.color.blend(i3.background, i3.selectionInactiveBackgroundTransparent), i3.selectionForeground = e3.selectionForeground ? p(e3.selectionForeground, o.NULL_COLOR) : void 0, i3.selectionForeground === o.NULL_COLOR && (i3.selectionForeground = void 0), o.color.isOpaque(i3.selectionBackgroundTransparent)) {
                const e4 = 0.3;
                i3.selectionBackgroundTransparent = o.color.opacity(i3.selectionBackgroundTransparent, e4);
              }
              if (o.color.isOpaque(i3.selectionInactiveBackgroundTransparent)) {
                const e4 = 0.3;
                i3.selectionInactiveBackgroundTransparent = o.color.opacity(i3.selectionInactiveBackgroundTransparent, e4);
              }
              if (i3.ansi = t2.DEFAULT_ANSI_COLORS.slice(), i3.ansi[0] = p(e3.black, t2.DEFAULT_ANSI_COLORS[0]), i3.ansi[1] = p(e3.red, t2.DEFAULT_ANSI_COLORS[1]), i3.ansi[2] = p(e3.green, t2.DEFAULT_ANSI_COLORS[2]), i3.ansi[3] = p(e3.yellow, t2.DEFAULT_ANSI_COLORS[3]), i3.ansi[4] = p(e3.blue, t2.DEFAULT_ANSI_COLORS[4]), i3.ansi[5] = p(e3.magenta, t2.DEFAULT_ANSI_COLORS[5]), i3.ansi[6] = p(e3.cyan, t2.DEFAULT_ANSI_COLORS[6]), i3.ansi[7] = p(e3.white, t2.DEFAULT_ANSI_COLORS[7]), i3.ansi[8] = p(e3.brightBlack, t2.DEFAULT_ANSI_COLORS[8]), i3.ansi[9] = p(e3.brightRed, t2.DEFAULT_ANSI_COLORS[9]), i3.ansi[10] = p(e3.brightGreen, t2.DEFAULT_ANSI_COLORS[10]), i3.ansi[11] = p(e3.brightYellow, t2.DEFAULT_ANSI_COLORS[11]), i3.ansi[12] = p(e3.brightBlue, t2.DEFAULT_ANSI_COLORS[12]), i3.ansi[13] = p(e3.brightMagenta, t2.DEFAULT_ANSI_COLORS[13]), i3.ansi[14] = p(e3.brightCyan, t2.DEFAULT_ANSI_COLORS[14]), i3.ansi[15] = p(e3.brightWhite, t2.DEFAULT_ANSI_COLORS[15]), e3.extendedAnsi) {
                const s3 = Math.min(i3.ansi.length - 16, e3.extendedAnsi.length);
                for (let r2 = 0; r2 < s3; r2++)
                  i3.ansi[r2 + 16] = p(e3.extendedAnsi[r2], t2.DEFAULT_ANSI_COLORS[r2 + 16]);
              }
              this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
            }
            restoreColor(e3) {
              this._restoreColor(e3), this._onChangeColors.fire(this.colors);
            }
            _restoreColor(e3) {
              if (void 0 !== e3)
                switch (e3) {
                  case 256:
                    this._colors.foreground = this._restoreColors.foreground;
                    break;
                  case 257:
                    this._colors.background = this._restoreColors.background;
                    break;
                  case 258:
                    this._colors.cursor = this._restoreColors.cursor;
                    break;
                  default:
                    this._colors.ansi[e3] = this._restoreColors.ansi[e3];
                }
              else
                for (let e4 = 0; e4 < this._restoreColors.ansi.length; ++e4)
                  this._colors.ansi[e4] = this._restoreColors.ansi[e4];
            }
            modifyColors(e3) {
              e3(this._colors), this._onChangeColors.fire(this.colors);
            }
            _updateRestoreColors() {
              this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
            }
          };
          function p(e3, t3) {
            if (void 0 !== e3)
              try {
                return o.css.toColor(e3);
              } catch (e4) {
              }
            return t3;
          }
          t2.ThemeService = v = s2([r(0, c.IOptionsService)], v);
        }, 6349: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CircularList = void 0;
          const s2 = i2(8460), r = i2(844);
          class n extends r.Disposable {
            constructor(e3) {
              super(), this._maxLength = e3, this.onDeleteEmitter = this.register(new s2.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s2.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s2.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
            }
            get maxLength() {
              return this._maxLength;
            }
            set maxLength(e3) {
              if (this._maxLength === e3)
                return;
              const t3 = new Array(e3);
              for (let i3 = 0; i3 < Math.min(e3, this.length); i3++)
                t3[i3] = this._array[this._getCyclicIndex(i3)];
              this._array = t3, this._maxLength = e3, this._startIndex = 0;
            }
            get length() {
              return this._length;
            }
            set length(e3) {
              if (e3 > this._length)
                for (let t3 = this._length; t3 < e3; t3++)
                  this._array[t3] = void 0;
              this._length = e3;
            }
            get(e3) {
              return this._array[this._getCyclicIndex(e3)];
            }
            set(e3, t3) {
              this._array[this._getCyclicIndex(e3)] = t3;
            }
            push(e3) {
              this._array[this._getCyclicIndex(this._length)] = e3, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
            }
            recycle() {
              if (this._length !== this._maxLength)
                throw new Error("Can only recycle when the buffer is full");
              return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
            }
            get isFull() {
              return this._length === this._maxLength;
            }
            pop() {
              return this._array[this._getCyclicIndex(this._length-- - 1)];
            }
            splice(e3, t3, ...i3) {
              if (t3) {
                for (let i4 = e3; i4 < this._length - t3; i4++)
                  this._array[this._getCyclicIndex(i4)] = this._array[this._getCyclicIndex(i4 + t3)];
                this._length -= t3, this.onDeleteEmitter.fire({ index: e3, amount: t3 });
              }
              for (let t4 = this._length - 1; t4 >= e3; t4--)
                this._array[this._getCyclicIndex(t4 + i3.length)] = this._array[this._getCyclicIndex(t4)];
              for (let t4 = 0; t4 < i3.length; t4++)
                this._array[this._getCyclicIndex(e3 + t4)] = i3[t4];
              if (i3.length && this.onInsertEmitter.fire({ index: e3, amount: i3.length }), this._length + i3.length > this._maxLength) {
                const e4 = this._length + i3.length - this._maxLength;
                this._startIndex += e4, this._length = this._maxLength, this.onTrimEmitter.fire(e4);
              } else
                this._length += i3.length;
            }
            trimStart(e3) {
              e3 > this._length && (e3 = this._length), this._startIndex += e3, this._length -= e3, this.onTrimEmitter.fire(e3);
            }
            shiftElements(e3, t3, i3) {
              if (!(t3 <= 0)) {
                if (e3 < 0 || e3 >= this._length)
                  throw new Error("start argument out of range");
                if (e3 + i3 < 0)
                  throw new Error("Cannot shift elements in list beyond index 0");
                if (i3 > 0) {
                  for (let s4 = t3 - 1; s4 >= 0; s4--)
                    this.set(e3 + s4 + i3, this.get(e3 + s4));
                  const s3 = e3 + t3 + i3 - this._length;
                  if (s3 > 0)
                    for (this._length += s3; this._length > this._maxLength; )
                      this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
                } else
                  for (let s3 = 0; s3 < t3; s3++)
                    this.set(e3 + s3 + i3, this.get(e3 + s3));
              }
            }
            _getCyclicIndex(e3) {
              return (this._startIndex + e3) % this._maxLength;
            }
          }
          t2.CircularList = n;
        }, 1439: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.clone = void 0, t2.clone = function e3(t3, i2 = 5) {
            if ("object" != typeof t3)
              return t3;
            const s2 = Array.isArray(t3) ? [] : {};
            for (const r in t3)
              s2[r] = i2 <= 1 ? t3[r] : t3[r] && e3(t3[r], i2 - 1);
            return s2;
          };
        }, 8055: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.contrastRatio = t2.toPaddedHex = t2.rgba = t2.rgb = t2.css = t2.color = t2.channels = t2.NULL_COLOR = void 0;
          const s2 = i2(6114);
          let r = 0, n = 0, o = 0, a = 0;
          var h, c, l, d, _;
          function u(e3) {
            const t3 = e3.toString(16);
            return t3.length < 2 ? "0" + t3 : t3;
          }
          function f(e3, t3) {
            return e3 < t3 ? (t3 + 0.05) / (e3 + 0.05) : (e3 + 0.05) / (t3 + 0.05);
          }
          t2.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(e3) {
            e3.toCss = function(e4, t3, i3, s3) {
              return void 0 !== s3 ? `#${u(e4)}${u(t3)}${u(i3)}${u(s3)}` : `#${u(e4)}${u(t3)}${u(i3)}`;
            }, e3.toRgba = function(e4, t3, i3, s3 = 255) {
              return (e4 << 24 | t3 << 16 | i3 << 8 | s3) >>> 0;
            };
          }(h || (t2.channels = h = {})), function(e3) {
            function t3(e4, t4) {
              return a = Math.round(255 * t4), [r, n, o] = _.toChannels(e4.rgba), { css: h.toCss(r, n, o, a), rgba: h.toRgba(r, n, o, a) };
            }
            e3.blend = function(e4, t4) {
              if (a = (255 & t4.rgba) / 255, 1 === a)
                return { css: t4.css, rgba: t4.rgba };
              const i3 = t4.rgba >> 24 & 255, s3 = t4.rgba >> 16 & 255, c2 = t4.rgba >> 8 & 255, l2 = e4.rgba >> 24 & 255, d2 = e4.rgba >> 16 & 255, _2 = e4.rgba >> 8 & 255;
              return r = l2 + Math.round((i3 - l2) * a), n = d2 + Math.round((s3 - d2) * a), o = _2 + Math.round((c2 - _2) * a), { css: h.toCss(r, n, o), rgba: h.toRgba(r, n, o) };
            }, e3.isOpaque = function(e4) {
              return 255 == (255 & e4.rgba);
            }, e3.ensureContrastRatio = function(e4, t4, i3) {
              const s3 = _.ensureContrastRatio(e4.rgba, t4.rgba, i3);
              if (s3)
                return _.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
            }, e3.opaque = function(e4) {
              const t4 = (255 | e4.rgba) >>> 0;
              return [r, n, o] = _.toChannels(t4), { css: h.toCss(r, n, o), rgba: t4 };
            }, e3.opacity = t3, e3.multiplyOpacity = function(e4, i3) {
              return a = 255 & e4.rgba, t3(e4, a * i3 / 255);
            }, e3.toColorRGB = function(e4) {
              return [e4.rgba >> 24 & 255, e4.rgba >> 16 & 255, e4.rgba >> 8 & 255];
            };
          }(c || (t2.color = c = {})), function(e3) {
            let t3, i3;
            if (!s2.isNode) {
              const e4 = document.createElement("canvas");
              e4.width = 1, e4.height = 1;
              const s3 = e4.getContext("2d", { willReadFrequently: true });
              s3 && (t3 = s3, t3.globalCompositeOperation = "copy", i3 = t3.createLinearGradient(0, 0, 1, 1));
            }
            e3.toColor = function(e4) {
              if (e4.match(/#[\da-f]{3,8}/i))
                switch (e4.length) {
                  case 4:
                    return r = parseInt(e4.slice(1, 2).repeat(2), 16), n = parseInt(e4.slice(2, 3).repeat(2), 16), o = parseInt(e4.slice(3, 4).repeat(2), 16), _.toColor(r, n, o);
                  case 5:
                    return r = parseInt(e4.slice(1, 2).repeat(2), 16), n = parseInt(e4.slice(2, 3).repeat(2), 16), o = parseInt(e4.slice(3, 4).repeat(2), 16), a = parseInt(e4.slice(4, 5).repeat(2), 16), _.toColor(r, n, o, a);
                  case 7:
                    return { css: e4, rgba: (parseInt(e4.slice(1), 16) << 8 | 255) >>> 0 };
                  case 9:
                    return { css: e4, rgba: parseInt(e4.slice(1), 16) >>> 0 };
                }
              const s3 = e4.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
              if (s3)
                return r = parseInt(s3[1]), n = parseInt(s3[2]), o = parseInt(s3[3]), a = Math.round(255 * (void 0 === s3[5] ? 1 : parseFloat(s3[5]))), _.toColor(r, n, o, a);
              if (!t3 || !i3)
                throw new Error("css.toColor: Unsupported css format");
              if (t3.fillStyle = i3, t3.fillStyle = e4, "string" != typeof t3.fillStyle)
                throw new Error("css.toColor: Unsupported css format");
              if (t3.fillRect(0, 0, 1, 1), [r, n, o, a] = t3.getImageData(0, 0, 1, 1).data, 255 !== a)
                throw new Error("css.toColor: Unsupported css format");
              return { rgba: h.toRgba(r, n, o, a), css: e4 };
            };
          }(l || (t2.css = l = {})), function(e3) {
            function t3(e4, t4, i3) {
              const s3 = e4 / 255, r2 = t4 / 255, n2 = i3 / 255;
              return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n2 <= 0.03928 ? n2 / 12.92 : Math.pow((n2 + 0.055) / 1.055, 2.4));
            }
            e3.relativeLuminance = function(e4) {
              return t3(e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4);
            }, e3.relativeLuminance2 = t3;
          }(d || (t2.rgb = d = {})), function(e3) {
            function t3(e4, t4, i4) {
              const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
              let o2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
              for (; c2 < i4 && (o2 > 0 || a2 > 0 || h2 > 0); )
                o2 -= Math.max(0, Math.ceil(0.1 * o2)), a2 -= Math.max(0, Math.ceil(0.1 * a2)), h2 -= Math.max(0, Math.ceil(0.1 * h2)), c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
              return (o2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
            }
            function i3(e4, t4, i4) {
              const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
              let o2 = t4 >> 24 & 255, a2 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
              for (; c2 < i4 && (o2 < 255 || a2 < 255 || h2 < 255); )
                o2 = Math.min(255, o2 + Math.ceil(0.1 * (255 - o2))), a2 = Math.min(255, a2 + Math.ceil(0.1 * (255 - a2))), h2 = Math.min(255, h2 + Math.ceil(0.1 * (255 - h2))), c2 = f(d.relativeLuminance2(o2, a2, h2), d.relativeLuminance2(s3, r2, n2));
              return (o2 << 24 | a2 << 16 | h2 << 8 | 255) >>> 0;
            }
            e3.ensureContrastRatio = function(e4, s3, r2) {
              const n2 = d.relativeLuminance(e4 >> 8), o2 = d.relativeLuminance(s3 >> 8);
              if (f(n2, o2) < r2) {
                if (o2 < n2) {
                  const o3 = t3(e4, s3, r2), a3 = f(n2, d.relativeLuminance(o3 >> 8));
                  if (a3 < r2) {
                    const t4 = i3(e4, s3, r2);
                    return a3 > f(n2, d.relativeLuminance(t4 >> 8)) ? o3 : t4;
                  }
                  return o3;
                }
                const a2 = i3(e4, s3, r2), h2 = f(n2, d.relativeLuminance(a2 >> 8));
                if (h2 < r2) {
                  const i4 = t3(e4, s3, r2);
                  return h2 > f(n2, d.relativeLuminance(i4 >> 8)) ? a2 : i4;
                }
                return a2;
              }
            }, e3.reduceLuminance = t3, e3.increaseLuminance = i3, e3.toChannels = function(e4) {
              return [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
            }, e3.toColor = function(e4, t4, i4, s3) {
              return { css: h.toCss(e4, t4, i4, s3), rgba: h.toRgba(e4, t4, i4, s3) };
            };
          }(_ || (t2.rgba = _ = {})), t2.toPaddedHex = u, t2.contrastRatio = f;
        }, 8969: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreTerminal = void 0;
          const s2 = i2(844), r = i2(2585), n = i2(4348), o = i2(7866), a = i2(744), h = i2(7302), c = i2(6975), l = i2(8460), d = i2(1753), _ = i2(1480), u = i2(7994), f = i2(9282), v = i2(5435), p = i2(5981), g = i2(2660);
          let m = false;
          class S extends s2.Disposable {
            get onScroll() {
              return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter()), this._onScroll.event((e3) => {
                var t3;
                null === (t3 = this._onScrollApi) || void 0 === t3 || t3.fire(e3.position);
              })), this._onScrollApi.event;
            }
            get cols() {
              return this._bufferService.cols;
            }
            get rows() {
              return this._bufferService.rows;
            }
            get buffers() {
              return this._bufferService.buffers;
            }
            get options() {
              return this.optionsService.options;
            }
            set options(e3) {
              for (const t3 in e3)
                this.optionsService.options[t3] = e3[t3];
            }
            constructor(e3) {
              super(), this._windowsWrappingHeuristics = this.register(new s2.MutableDisposable()), this._onBinary = this.register(new l.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter()), this._instantiationService = new n.InstantiationService(), this.optionsService = this.register(new h.OptionsService(e3)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(g.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((e4) => {
                this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
              })), this.register(this._inputHandler.onScroll((e4) => {
                this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
              })), this._writeBuffer = this.register(new p.WriteBuffer((e4, t3) => this._inputHandler.parse(e4, t3))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
            }
            write(e3, t3) {
              this._writeBuffer.write(e3, t3);
            }
            writeSync(e3, t3) {
              this._logService.logLevel <= r.LogLevelEnum.WARN && !m && (this._logService.warn("writeSync is unreliable and will be removed soon."), m = true), this._writeBuffer.writeSync(e3, t3);
            }
            resize(e3, t3) {
              isNaN(e3) || isNaN(t3) || (e3 = Math.max(e3, a.MINIMUM_COLS), t3 = Math.max(t3, a.MINIMUM_ROWS), this._bufferService.resize(e3, t3));
            }
            scroll(e3, t3 = false) {
              this._bufferService.scroll(e3, t3);
            }
            scrollLines(e3, t3, i3) {
              this._bufferService.scrollLines(e3, t3, i3);
            }
            scrollPages(e3) {
              this.scrollLines(e3 * (this.rows - 1));
            }
            scrollToTop() {
              this.scrollLines(-this._bufferService.buffer.ydisp);
            }
            scrollToBottom() {
              this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
            }
            scrollToLine(e3) {
              const t3 = e3 - this._bufferService.buffer.ydisp;
              0 !== t3 && this.scrollLines(t3);
            }
            registerEscHandler(e3, t3) {
              return this._inputHandler.registerEscHandler(e3, t3);
            }
            registerDcsHandler(e3, t3) {
              return this._inputHandler.registerDcsHandler(e3, t3);
            }
            registerCsiHandler(e3, t3) {
              return this._inputHandler.registerCsiHandler(e3, t3);
            }
            registerOscHandler(e3, t3) {
              return this._inputHandler.registerOscHandler(e3, t3);
            }
            _setup() {
              this._handleWindowsPtyOptionChange();
            }
            reset() {
              this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
            }
            _handleWindowsPtyOptionChange() {
              let e3 = false;
              const t3 = this.optionsService.rawOptions.windowsPty;
              t3 && void 0 !== t3.buildNumber && void 0 !== t3.buildNumber ? e3 = !!("conpty" === t3.backend && t3.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (e3 = true), e3 ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
            }
            _enableWindowsWrappingHeuristics() {
              if (!this._windowsWrappingHeuristics.value) {
                const e3 = [];
                e3.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e3.push(this.registerCsiHandler({ final: "H" }, () => ((0, f.updateWindowsModeWrappedState)(this._bufferService), false))), this._windowsWrappingHeuristics.value = (0, s2.toDisposable)(() => {
                  for (const t3 of e3)
                    t3.dispose();
                });
              }
            }
          }
          t2.CoreTerminal = S;
        }, 8460: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.forwardEvent = t2.EventEmitter = void 0, t2.EventEmitter = class {
            constructor() {
              this._listeners = [], this._disposed = false;
            }
            get event() {
              return this._event || (this._event = (e3) => (this._listeners.push(e3), { dispose: () => {
                if (!this._disposed) {
                  for (let t3 = 0; t3 < this._listeners.length; t3++)
                    if (this._listeners[t3] === e3)
                      return void this._listeners.splice(t3, 1);
                }
              } })), this._event;
            }
            fire(e3, t3) {
              const i2 = [];
              for (let e4 = 0; e4 < this._listeners.length; e4++)
                i2.push(this._listeners[e4]);
              for (let s2 = 0; s2 < i2.length; s2++)
                i2[s2].call(void 0, e3, t3);
            }
            dispose() {
              this.clearListeners(), this._disposed = true;
            }
            clearListeners() {
              this._listeners && (this._listeners.length = 0);
            }
          }, t2.forwardEvent = function(e3, t3) {
            return e3((e4) => t3.fire(e4));
          };
        }, 5435: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.InputHandler = t2.WindowsOptionsReportType = void 0;
          const n = i2(2584), o = i2(7116), a = i2(2015), h = i2(844), c = i2(482), l = i2(8437), d = i2(8460), _ = i2(643), u = i2(511), f = i2(3734), v = i2(2585), p = i2(6242), g = i2(6351), m = i2(5941), S = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, C = 131072;
          function b(e3, t3) {
            if (e3 > 24)
              return t3.setWinLines || false;
            switch (e3) {
              case 1:
                return !!t3.restoreWin;
              case 2:
                return !!t3.minimizeWin;
              case 3:
                return !!t3.setWinPosition;
              case 4:
                return !!t3.setWinSizePixels;
              case 5:
                return !!t3.raiseWin;
              case 6:
                return !!t3.lowerWin;
              case 7:
                return !!t3.refreshWin;
              case 8:
                return !!t3.setWinSizeChars;
              case 9:
                return !!t3.maximizeWin;
              case 10:
                return !!t3.fullscreenWin;
              case 11:
                return !!t3.getWinState;
              case 13:
                return !!t3.getWinPosition;
              case 14:
                return !!t3.getWinSizePixels;
              case 15:
                return !!t3.getScreenSizePixels;
              case 16:
                return !!t3.getCellSizePixels;
              case 18:
                return !!t3.getWinSizeChars;
              case 19:
                return !!t3.getScreenSizeChars;
              case 20:
                return !!t3.getIconTitle;
              case 21:
                return !!t3.getWinTitle;
              case 22:
                return !!t3.pushTitle;
              case 23:
                return !!t3.popTitle;
              case 24:
                return !!t3.setWinLines;
            }
            return false;
          }
          var y;
          !function(e3) {
            e3[e3.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e3[e3.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
          }(y || (t2.WindowsOptionsReportType = y = {}));
          let w = 0;
          class E extends h.Disposable {
            getAttrData() {
              return this._curAttrData;
            }
            constructor(e3, t3, i3, s3, r2, h2, _2, f2, v2 = new a.EscapeSequenceParser()) {
              super(), this._bufferService = e3, this._charsetService = t3, this._coreService = i3, this._logService = s3, this._optionsService = r2, this._oscLinkService = h2, this._coreMouseService = _2, this._unicodeService = f2, this._parser = v2, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32(), this._utf8Decoder = new c.Utf8ToUtf32(), this._workCell = new u.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: false, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new k(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._parser.setCsiHandlerFallback((e4, t4) => {
                this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(e4), params: t4.toArray() });
              }), this._parser.setEscHandlerFallback((e4) => {
                this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(e4) });
              }), this._parser.setExecuteHandlerFallback((e4) => {
                this._logService.debug("Unknown EXECUTE code: ", { code: e4 });
              }), this._parser.setOscHandlerFallback((e4, t4, i4) => {
                this._logService.debug("Unknown OSC code: ", { identifier: e4, action: t4, data: i4 });
              }), this._parser.setDcsHandlerFallback((e4, t4, i4) => {
                "HOOK" === t4 && (i4 = i4.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(e4), action: t4, payload: i4 });
              }), this._parser.setPrintHandler((e4, t4, i4) => this.print(e4, t4, i4)), this._parser.registerCsiHandler({ final: "@" }, (e4) => this.insertChars(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (e4) => this.scrollLeft(e4)), this._parser.registerCsiHandler({ final: "A" }, (e4) => this.cursorUp(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (e4) => this.scrollRight(e4)), this._parser.registerCsiHandler({ final: "B" }, (e4) => this.cursorDown(e4)), this._parser.registerCsiHandler({ final: "C" }, (e4) => this.cursorForward(e4)), this._parser.registerCsiHandler({ final: "D" }, (e4) => this.cursorBackward(e4)), this._parser.registerCsiHandler({ final: "E" }, (e4) => this.cursorNextLine(e4)), this._parser.registerCsiHandler({ final: "F" }, (e4) => this.cursorPrecedingLine(e4)), this._parser.registerCsiHandler({ final: "G" }, (e4) => this.cursorCharAbsolute(e4)), this._parser.registerCsiHandler({ final: "H" }, (e4) => this.cursorPosition(e4)), this._parser.registerCsiHandler({ final: "I" }, (e4) => this.cursorForwardTab(e4)), this._parser.registerCsiHandler({ final: "J" }, (e4) => this.eraseInDisplay(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (e4) => this.eraseInDisplay(e4, true)), this._parser.registerCsiHandler({ final: "K" }, (e4) => this.eraseInLine(e4, false)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (e4) => this.eraseInLine(e4, true)), this._parser.registerCsiHandler({ final: "L" }, (e4) => this.insertLines(e4)), this._parser.registerCsiHandler({ final: "M" }, (e4) => this.deleteLines(e4)), this._parser.registerCsiHandler({ final: "P" }, (e4) => this.deleteChars(e4)), this._parser.registerCsiHandler({ final: "S" }, (e4) => this.scrollUp(e4)), this._parser.registerCsiHandler({ final: "T" }, (e4) => this.scrollDown(e4)), this._parser.registerCsiHandler({ final: "X" }, (e4) => this.eraseChars(e4)), this._parser.registerCsiHandler({ final: "Z" }, (e4) => this.cursorBackwardTab(e4)), this._parser.registerCsiHandler({ final: "`" }, (e4) => this.charPosAbsolute(e4)), this._parser.registerCsiHandler({ final: "a" }, (e4) => this.hPositionRelative(e4)), this._parser.registerCsiHandler({ final: "b" }, (e4) => this.repeatPrecedingCharacter(e4)), this._parser.registerCsiHandler({ final: "c" }, (e4) => this.sendDeviceAttributesPrimary(e4)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (e4) => this.sendDeviceAttributesSecondary(e4)), this._parser.registerCsiHandler({ final: "d" }, (e4) => this.linePosAbsolute(e4)), this._parser.registerCsiHandler({ final: "e" }, (e4) => this.vPositionRelative(e4)), this._parser.registerCsiHandler({ final: "f" }, (e4) => this.hVPosition(e4)), this._parser.registerCsiHandler({ final: "g" }, (e4) => this.tabClear(e4)), this._parser.registerCsiHandler({ final: "h" }, (e4) => this.setMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (e4) => this.setModePrivate(e4)), this._parser.registerCsiHandler({ final: "l" }, (e4) => this.resetMode(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (e4) => this.resetModePrivate(e4)), this._parser.registerCsiHandler({ final: "m" }, (e4) => this.charAttributes(e4)), this._parser.registerCsiHandler({ final: "n" }, (e4) => this.deviceStatus(e4)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (e4) => this.deviceStatusPrivate(e4)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (e4) => this.softReset(e4)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (e4) => this.setCursorStyle(e4)), this._parser.registerCsiHandler({ final: "r" }, (e4) => this.setScrollRegion(e4)), this._parser.registerCsiHandler({ final: "s" }, (e4) => this.saveCursor(e4)), this._parser.registerCsiHandler({ final: "t" }, (e4) => this.windowOptions(e4)), this._parser.registerCsiHandler({ final: "u" }, (e4) => this.restoreCursor(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (e4) => this.insertColumns(e4)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (e4) => this.deleteColumns(e4)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (e4) => this.selectProtected(e4)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, true)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (e4) => this.requestMode(e4, false)), this._parser.setExecuteHandler(n.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n.C1.IND, () => this.index()), this._parser.setExecuteHandler(n.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new p.OscHandler((e4) => (this.setTitle(e4), this.setIconName(e4), true))), this._parser.registerOscHandler(1, new p.OscHandler((e4) => this.setIconName(e4))), this._parser.registerOscHandler(2, new p.OscHandler((e4) => this.setTitle(e4))), this._parser.registerOscHandler(4, new p.OscHandler((e4) => this.setOrReportIndexedColor(e4))), this._parser.registerOscHandler(8, new p.OscHandler((e4) => this.setHyperlink(e4))), this._parser.registerOscHandler(10, new p.OscHandler((e4) => this.setOrReportFgColor(e4))), this._parser.registerOscHandler(11, new p.OscHandler((e4) => this.setOrReportBgColor(e4))), this._parser.registerOscHandler(12, new p.OscHandler((e4) => this.setOrReportCursorColor(e4))), this._parser.registerOscHandler(104, new p.OscHandler((e4) => this.restoreIndexedColor(e4))), this._parser.registerOscHandler(110, new p.OscHandler((e4) => this.restoreFgColor(e4))), this._parser.registerOscHandler(111, new p.OscHandler((e4) => this.restoreBgColor(e4))), this._parser.registerOscHandler(112, new p.OscHandler((e4) => this.restoreCursorColor(e4))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
              for (const e4 in o.CHARSETS)
                this._parser.registerEscHandler({ intermediates: "(", final: e4 }, () => this.selectCharset("(" + e4)), this._parser.registerEscHandler({ intermediates: ")", final: e4 }, () => this.selectCharset(")" + e4)), this._parser.registerEscHandler({ intermediates: "*", final: e4 }, () => this.selectCharset("*" + e4)), this._parser.registerEscHandler({ intermediates: "+", final: e4 }, () => this.selectCharset("+" + e4)), this._parser.registerEscHandler({ intermediates: "-", final: e4 }, () => this.selectCharset("-" + e4)), this._parser.registerEscHandler({ intermediates: ".", final: e4 }, () => this.selectCharset("." + e4)), this._parser.registerEscHandler({ intermediates: "/", final: e4 }, () => this.selectCharset("/" + e4));
              this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((e4) => (this._logService.error("Parsing error: ", e4), e4)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new g.DcsHandler((e4, t4) => this.requestStatusString(e4, t4)));
            }
            _preserveStack(e3, t3, i3, s3) {
              this._parseStack.paused = true, this._parseStack.cursorStartX = e3, this._parseStack.cursorStartY = t3, this._parseStack.decodedLength = i3, this._parseStack.position = s3;
            }
            _logSlowResolvingAsync(e3) {
              this._logService.logLevel <= v.LogLevelEnum.WARN && Promise.race([e3, new Promise((e4, t3) => setTimeout(() => t3("#SLOW_TIMEOUT"), 5e3))]).catch((e4) => {
                if ("#SLOW_TIMEOUT" !== e4)
                  throw e4;
                console.warn("async parser handler taking longer than 5000 ms");
              });
            }
            _getCurrentLinkId() {
              return this._curAttrData.extended.urlId;
            }
            parse(e3, t3) {
              let i3, s3 = this._activeBuffer.x, r2 = this._activeBuffer.y, n2 = 0;
              const o2 = this._parseStack.paused;
              if (o2) {
                if (i3 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t3))
                  return this._logSlowResolvingAsync(i3), i3;
                s3 = this._parseStack.cursorStartX, r2 = this._parseStack.cursorStartY, this._parseStack.paused = false, e3.length > C && (n2 = this._parseStack.position + C);
              }
              if (this._logService.logLevel <= v.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + ("string" == typeof e3 ? ` "${e3}"` : ` "${Array.prototype.map.call(e3, (e4) => String.fromCharCode(e4)).join("")}"`), "string" == typeof e3 ? e3.split("").map((e4) => e4.charCodeAt(0)) : e3), this._parseBuffer.length < e3.length && this._parseBuffer.length < C && (this._parseBuffer = new Uint32Array(Math.min(e3.length, C))), o2 || this._dirtyRowTracker.clearRange(), e3.length > C)
                for (let t4 = n2; t4 < e3.length; t4 += C) {
                  const n3 = t4 + C < e3.length ? t4 + C : e3.length, o3 = "string" == typeof e3 ? this._stringDecoder.decode(e3.substring(t4, n3), this._parseBuffer) : this._utf8Decoder.decode(e3.subarray(t4, n3), this._parseBuffer);
                  if (i3 = this._parser.parse(this._parseBuffer, o3))
                    return this._preserveStack(s3, r2, o3, t4), this._logSlowResolvingAsync(i3), i3;
                }
              else if (!o2) {
                const t4 = "string" == typeof e3 ? this._stringDecoder.decode(e3, this._parseBuffer) : this._utf8Decoder.decode(e3, this._parseBuffer);
                if (i3 = this._parser.parse(this._parseBuffer, t4))
                  return this._preserveStack(s3, r2, t4, 0), this._logSlowResolvingAsync(i3), i3;
              }
              this._activeBuffer.x === s3 && this._activeBuffer.y === r2 || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
            }
            print(e3, t3, i3) {
              let s3, r2;
              const n2 = this._charsetService.charset, o2 = this._optionsService.rawOptions.screenReaderMode, a2 = this._bufferService.cols, h2 = this._coreService.decPrivateModes.wraparound, l2 = this._coreService.modes.insertMode, d2 = this._curAttrData;
              let u2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i3 - t3 > 0 && 2 === u2.getWidth(this._activeBuffer.x - 1) && u2.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, d2.fg, d2.bg, d2.extended);
              for (let f2 = t3; f2 < i3; ++f2) {
                if (s3 = e3[f2], r2 = this._unicodeService.wcwidth(s3), s3 < 127 && n2) {
                  const e4 = n2[String.fromCharCode(s3)];
                  e4 && (s3 = e4.charCodeAt(0));
                }
                if (o2 && this._onA11yChar.fire((0, c.stringFromCodePoint)(s3)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), r2 || !this._activeBuffer.x) {
                  if (this._activeBuffer.x + r2 - 1 >= a2) {
                    if (h2) {
                      for (; this._activeBuffer.x < a2; )
                        u2.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, d2.fg, d2.bg, d2.extended);
                      this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), u2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                    } else if (this._activeBuffer.x = a2 - 1, 2 === r2)
                      continue;
                  }
                  if (l2 && (u2.insertCells(this._activeBuffer.x, r2, this._activeBuffer.getNullCell(d2), d2), 2 === u2.getWidth(a2 - 1) && u2.setCellFromCodePoint(a2 - 1, _.NULL_CELL_CODE, _.NULL_CELL_WIDTH, d2.fg, d2.bg, d2.extended)), u2.setCellFromCodePoint(this._activeBuffer.x++, s3, r2, d2.fg, d2.bg, d2.extended), r2 > 0)
                    for (; --r2; )
                      u2.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, d2.fg, d2.bg, d2.extended);
                } else
                  u2.getWidth(this._activeBuffer.x - 1) ? u2.addCodepointToCell(this._activeBuffer.x - 1, s3) : u2.addCodepointToCell(this._activeBuffer.x - 2, s3);
              }
              i3 - t3 > 0 && (u2.loadCell(this._activeBuffer.x - 1, this._workCell), 2 === this._workCell.getWidth() || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < a2 && i3 - t3 > 0 && 0 === u2.getWidth(this._activeBuffer.x) && !u2.hasContent(this._activeBuffer.x) && u2.setCellFromCodePoint(this._activeBuffer.x, 0, 1, d2.fg, d2.bg, d2.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            registerCsiHandler(e3, t3) {
              return "t" !== e3.final || e3.prefix || e3.intermediates ? this._parser.registerCsiHandler(e3, t3) : this._parser.registerCsiHandler(e3, (e4) => !b(e4.params[0], this._optionsService.rawOptions.windowOptions) || t3(e4));
            }
            registerDcsHandler(e3, t3) {
              return this._parser.registerDcsHandler(e3, new g.DcsHandler(t3));
            }
            registerEscHandler(e3, t3) {
              return this._parser.registerEscHandler(e3, t3);
            }
            registerOscHandler(e3, t3) {
              return this._parser.registerOscHandler(e3, new p.OscHandler(t3));
            }
            bell() {
              return this._onRequestBell.fire(), true;
            }
            lineFeed() {
              return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
            }
            carriageReturn() {
              return this._activeBuffer.x = 0, true;
            }
            backspace() {
              var e3;
              if (!this._coreService.decPrivateModes.reverseWraparound)
                return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
              if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0)
                this._activeBuffer.x--;
              else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (null === (e3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) || void 0 === e3 ? void 0 : e3.isWrapped)) {
                this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
                const e4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                e4.hasWidth(this._activeBuffer.x) && !e4.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
              }
              return this._restrictCursor(), true;
            }
            tab() {
              if (this._activeBuffer.x >= this._bufferService.cols)
                return true;
              const e3 = this._activeBuffer.x;
              return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e3), true;
            }
            shiftOut() {
              return this._charsetService.setgLevel(1), true;
            }
            shiftIn() {
              return this._charsetService.setgLevel(0), true;
            }
            _restrictCursor(e3 = this._bufferService.cols - 1) {
              this._activeBuffer.x = Math.min(e3, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            _setCursor(e3, t3) {
              this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e3, this._activeBuffer.y = this._activeBuffer.scrollTop + t3) : (this._activeBuffer.x = e3, this._activeBuffer.y = t3), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            _moveCursor(e3, t3) {
              this._restrictCursor(), this._setCursor(this._activeBuffer.x + e3, this._activeBuffer.y + t3);
            }
            cursorUp(e3) {
              const t3 = this._activeBuffer.y - this._activeBuffer.scrollTop;
              return t3 >= 0 ? this._moveCursor(0, -Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, -(e3.params[0] || 1)), true;
            }
            cursorDown(e3) {
              const t3 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
              return t3 >= 0 ? this._moveCursor(0, Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, e3.params[0] || 1), true;
            }
            cursorForward(e3) {
              return this._moveCursor(e3.params[0] || 1, 0), true;
            }
            cursorBackward(e3) {
              return this._moveCursor(-(e3.params[0] || 1), 0), true;
            }
            cursorNextLine(e3) {
              return this.cursorDown(e3), this._activeBuffer.x = 0, true;
            }
            cursorPrecedingLine(e3) {
              return this.cursorUp(e3), this._activeBuffer.x = 0, true;
            }
            cursorCharAbsolute(e3) {
              return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
            }
            cursorPosition(e3) {
              return this._setCursor(e3.length >= 2 ? (e3.params[1] || 1) - 1 : 0, (e3.params[0] || 1) - 1), true;
            }
            charPosAbsolute(e3) {
              return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
            }
            hPositionRelative(e3) {
              return this._moveCursor(e3.params[0] || 1, 0), true;
            }
            linePosAbsolute(e3) {
              return this._setCursor(this._activeBuffer.x, (e3.params[0] || 1) - 1), true;
            }
            vPositionRelative(e3) {
              return this._moveCursor(0, e3.params[0] || 1), true;
            }
            hVPosition(e3) {
              return this.cursorPosition(e3), true;
            }
            tabClear(e3) {
              const t3 = e3.params[0];
              return 0 === t3 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t3 && (this._activeBuffer.tabs = {}), true;
            }
            cursorForwardTab(e3) {
              if (this._activeBuffer.x >= this._bufferService.cols)
                return true;
              let t3 = e3.params[0] || 1;
              for (; t3--; )
                this._activeBuffer.x = this._activeBuffer.nextStop();
              return true;
            }
            cursorBackwardTab(e3) {
              if (this._activeBuffer.x >= this._bufferService.cols)
                return true;
              let t3 = e3.params[0] || 1;
              for (; t3--; )
                this._activeBuffer.x = this._activeBuffer.prevStop();
              return true;
            }
            selectProtected(e3) {
              const t3 = e3.params[0];
              return 1 === t3 && (this._curAttrData.bg |= 536870912), 2 !== t3 && 0 !== t3 || (this._curAttrData.bg &= -536870913), true;
            }
            _eraseInBufferLine(e3, t3, i3, s3 = false, r2 = false) {
              const n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
              n2.replaceCells(t3, i3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), r2), s3 && (n2.isWrapped = false);
            }
            _resetBufferLine(e3, t3 = false) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
              i3 && (i3.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t3), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e3), i3.isWrapped = false);
            }
            eraseInDisplay(e3, t3 = false) {
              let i3;
              switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
                case 0:
                  for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3); i3 < this._bufferService.rows; i3++)
                    this._resetBufferLine(i3, t3);
                  this._dirtyRowTracker.markDirty(i3);
                  break;
                case 1:
                  for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3, 0, this._activeBuffer.x + 1, true, t3), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i3 + 1).isWrapped = false); i3--; )
                    this._resetBufferLine(i3, t3);
                  this._dirtyRowTracker.markDirty(0);
                  break;
                case 2:
                  for (i3 = this._bufferService.rows, this._dirtyRowTracker.markDirty(i3 - 1); i3--; )
                    this._resetBufferLine(i3, t3);
                  this._dirtyRowTracker.markDirty(0);
                  break;
                case 3:
                  const e4 = this._activeBuffer.lines.length - this._bufferService.rows;
                  e4 > 0 && (this._activeBuffer.lines.trimStart(e4), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e4, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e4, 0), this._onScroll.fire(0));
              }
              return true;
            }
            eraseInLine(e3, t3 = false) {
              switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
                case 0:
                  this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3);
                  break;
                case 1:
                  this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, t3);
                  break;
                case 2:
                  this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, t3);
              }
              return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
            }
            insertLines(e3) {
              this._restrictCursor();
              let t3 = e3.params[0] || 1;
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const i3 = this._activeBuffer.ybase + this._activeBuffer.y, s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r2 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3 + 1;
              for (; t3--; )
                this._activeBuffer.lines.splice(r2 - 1, 1), this._activeBuffer.lines.splice(i3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
            }
            deleteLines(e3) {
              this._restrictCursor();
              let t3 = e3.params[0] || 1;
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const i3 = this._activeBuffer.ybase + this._activeBuffer.y;
              let s3;
              for (s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s3 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3; t3--; )
                this._activeBuffer.lines.splice(i3, 1), this._activeBuffer.lines.splice(s3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
            }
            insertChars(e3) {
              this._restrictCursor();
              const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t3 && (t3.insertCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            deleteChars(e3) {
              this._restrictCursor();
              const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t3 && (t3.deleteCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            scrollUp(e3) {
              let t3 = e3.params[0] || 1;
              for (; t3--; )
                this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollDown(e3) {
              let t3 = e3.params[0] || 1;
              for (; t3--; )
                this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollLeft(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const t3 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i3.deleteCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollRight(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const t3 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i3.insertCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            insertColumns(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const t3 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i3.insertCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            deleteColumns(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
                return true;
              const t3 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i3.deleteCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i3.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            eraseChars(e3) {
              this._restrictCursor();
              const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t3 && (t3.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e3.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            repeatPrecedingCharacter(e3) {
              if (!this._parser.precedingCodepoint)
                return true;
              const t3 = e3.params[0] || 1, i3 = new Uint32Array(t3);
              for (let e4 = 0; e4 < t3; ++e4)
                i3[e4] = this._parser.precedingCodepoint;
              return this.print(i3, 0, i3.length), true;
            }
            sendDeviceAttributesPrimary(e3) {
              return e3.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), true;
            }
            sendDeviceAttributesSecondary(e3) {
              return e3.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e3.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), true;
            }
            _is(e3) {
              return 0 === (this._optionsService.rawOptions.termName + "").indexOf(e3);
            }
            setMode(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                switch (e3.params[t3]) {
                  case 4:
                    this._coreService.modes.insertMode = true;
                    break;
                  case 20:
                    this._optionsService.options.convertEol = true;
                }
              return true;
            }
            setModePrivate(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                switch (e3.params[t3]) {
                  case 1:
                    this._coreService.decPrivateModes.applicationCursorKeys = true;
                    break;
                  case 2:
                    this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
                    break;
                  case 3:
                    this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                    break;
                  case 6:
                    this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
                    break;
                  case 7:
                    this._coreService.decPrivateModes.wraparound = true;
                    break;
                  case 12:
                    this._optionsService.options.cursorBlink = true;
                    break;
                  case 45:
                    this._coreService.decPrivateModes.reverseWraparound = true;
                    break;
                  case 66:
                    this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
                    break;
                  case 9:
                    this._coreMouseService.activeProtocol = "X10";
                    break;
                  case 1e3:
                    this._coreMouseService.activeProtocol = "VT200";
                    break;
                  case 1002:
                    this._coreMouseService.activeProtocol = "DRAG";
                    break;
                  case 1003:
                    this._coreMouseService.activeProtocol = "ANY";
                    break;
                  case 1004:
                    this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
                    break;
                  case 1005:
                    this._logService.debug("DECSET 1005 not supported (see #2507)");
                    break;
                  case 1006:
                    this._coreMouseService.activeEncoding = "SGR";
                    break;
                  case 1015:
                    this._logService.debug("DECSET 1015 not supported (see #2507)");
                    break;
                  case 1016:
                    this._coreMouseService.activeEncoding = "SGR_PIXELS";
                    break;
                  case 25:
                    this._coreService.isCursorHidden = false;
                    break;
                  case 1048:
                    this.saveCursor();
                    break;
                  case 1049:
                    this.saveCursor();
                  case 47:
                  case 1047:
                    this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                    break;
                  case 2004:
                    this._coreService.decPrivateModes.bracketedPasteMode = true;
                }
              return true;
            }
            resetMode(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                switch (e3.params[t3]) {
                  case 4:
                    this._coreService.modes.insertMode = false;
                    break;
                  case 20:
                    this._optionsService.options.convertEol = false;
                }
              return true;
            }
            resetModePrivate(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                switch (e3.params[t3]) {
                  case 1:
                    this._coreService.decPrivateModes.applicationCursorKeys = false;
                    break;
                  case 3:
                    this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                    break;
                  case 6:
                    this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
                    break;
                  case 7:
                    this._coreService.decPrivateModes.wraparound = false;
                    break;
                  case 12:
                    this._optionsService.options.cursorBlink = false;
                    break;
                  case 45:
                    this._coreService.decPrivateModes.reverseWraparound = false;
                    break;
                  case 66:
                    this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
                    break;
                  case 9:
                  case 1e3:
                  case 1002:
                  case 1003:
                    this._coreMouseService.activeProtocol = "NONE";
                    break;
                  case 1004:
                    this._coreService.decPrivateModes.sendFocus = false;
                    break;
                  case 1005:
                    this._logService.debug("DECRST 1005 not supported (see #2507)");
                    break;
                  case 1006:
                  case 1016:
                    this._coreMouseService.activeEncoding = "DEFAULT";
                    break;
                  case 1015:
                    this._logService.debug("DECRST 1015 not supported (see #2507)");
                    break;
                  case 25:
                    this._coreService.isCursorHidden = true;
                    break;
                  case 1048:
                    this.restoreCursor();
                    break;
                  case 1049:
                  case 47:
                  case 1047:
                    this._bufferService.buffers.activateNormalBuffer(), 1049 === e3.params[t3] && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                    break;
                  case 2004:
                    this._coreService.decPrivateModes.bracketedPasteMode = false;
                }
              return true;
            }
            requestMode(e3, t3) {
              const i3 = this._coreService.decPrivateModes, { activeProtocol: s3, activeEncoding: r2 } = this._coreMouseService, o2 = this._coreService, { buffers: a2, cols: h2 } = this._bufferService, { active: c2, alt: l2 } = a2, d2 = this._optionsService.rawOptions, _2 = (e4) => e4 ? 1 : 2, u2 = e3.params[0];
              return f2 = u2, v2 = t3 ? 2 === u2 ? 4 : 4 === u2 ? _2(o2.modes.insertMode) : 12 === u2 ? 3 : 20 === u2 ? _2(d2.convertEol) : 0 : 1 === u2 ? _2(i3.applicationCursorKeys) : 3 === u2 ? d2.windowOptions.setWinLines ? 80 === h2 ? 2 : 132 === h2 ? 1 : 0 : 0 : 6 === u2 ? _2(i3.origin) : 7 === u2 ? _2(i3.wraparound) : 8 === u2 ? 3 : 9 === u2 ? _2("X10" === s3) : 12 === u2 ? _2(d2.cursorBlink) : 25 === u2 ? _2(!o2.isCursorHidden) : 45 === u2 ? _2(i3.reverseWraparound) : 66 === u2 ? _2(i3.applicationKeypad) : 67 === u2 ? 4 : 1e3 === u2 ? _2("VT200" === s3) : 1002 === u2 ? _2("DRAG" === s3) : 1003 === u2 ? _2("ANY" === s3) : 1004 === u2 ? _2(i3.sendFocus) : 1005 === u2 ? 4 : 1006 === u2 ? _2("SGR" === r2) : 1015 === u2 ? 4 : 1016 === u2 ? _2("SGR_PIXELS" === r2) : 1048 === u2 ? 1 : 47 === u2 || 1047 === u2 || 1049 === u2 ? _2(c2 === l2) : 2004 === u2 ? _2(i3.bracketedPasteMode) : 0, o2.triggerDataEvent(`${n.C0.ESC}[${t3 ? "" : "?"}${f2};${v2}$y`), true;
              var f2, v2;
            }
            _updateAttrColor(e3, t3, i3, s3, r2) {
              return 2 === t3 ? (e3 |= 50331648, e3 &= -16777216, e3 |= f.AttributeData.fromColorRGB([i3, s3, r2])) : 5 === t3 && (e3 &= -50331904, e3 |= 33554432 | 255 & i3), e3;
            }
            _extractColor(e3, t3, i3) {
              const s3 = [0, 0, -1, 0, 0, 0];
              let r2 = 0, n2 = 0;
              do {
                if (s3[n2 + r2] = e3.params[t3 + n2], e3.hasSubParams(t3 + n2)) {
                  const i4 = e3.getSubParams(t3 + n2);
                  let o2 = 0;
                  do {
                    5 === s3[1] && (r2 = 1), s3[n2 + o2 + 1 + r2] = i4[o2];
                  } while (++o2 < i4.length && o2 + n2 + 1 + r2 < s3.length);
                  break;
                }
                if (5 === s3[1] && n2 + r2 >= 2 || 2 === s3[1] && n2 + r2 >= 5)
                  break;
                s3[1] && (r2 = 1);
              } while (++n2 + t3 < e3.length && n2 + r2 < s3.length);
              for (let e4 = 2; e4 < s3.length; ++e4)
                -1 === s3[e4] && (s3[e4] = 0);
              switch (s3[0]) {
                case 38:
                  i3.fg = this._updateAttrColor(i3.fg, s3[1], s3[3], s3[4], s3[5]);
                  break;
                case 48:
                  i3.bg = this._updateAttrColor(i3.bg, s3[1], s3[3], s3[4], s3[5]);
                  break;
                case 58:
                  i3.extended = i3.extended.clone(), i3.extended.underlineColor = this._updateAttrColor(i3.extended.underlineColor, s3[1], s3[3], s3[4], s3[5]);
              }
              return n2;
            }
            _processUnderline(e3, t3) {
              t3.extended = t3.extended.clone(), (!~e3 || e3 > 5) && (e3 = 1), t3.extended.underlineStyle = e3, t3.fg |= 268435456, 0 === e3 && (t3.fg &= -268435457), t3.updateExtended();
            }
            _processSGR0(e3) {
              e3.fg = l.DEFAULT_ATTR_DATA.fg, e3.bg = l.DEFAULT_ATTR_DATA.bg, e3.extended = e3.extended.clone(), e3.extended.underlineStyle = 0, e3.extended.underlineColor &= -67108864, e3.updateExtended();
            }
            charAttributes(e3) {
              if (1 === e3.length && 0 === e3.params[0])
                return this._processSGR0(this._curAttrData), true;
              const t3 = e3.length;
              let i3;
              const s3 = this._curAttrData;
              for (let r2 = 0; r2 < t3; r2++)
                i3 = e3.params[r2], i3 >= 30 && i3 <= 37 ? (s3.fg &= -50331904, s3.fg |= 16777216 | i3 - 30) : i3 >= 40 && i3 <= 47 ? (s3.bg &= -50331904, s3.bg |= 16777216 | i3 - 40) : i3 >= 90 && i3 <= 97 ? (s3.fg &= -50331904, s3.fg |= 16777224 | i3 - 90) : i3 >= 100 && i3 <= 107 ? (s3.bg &= -50331904, s3.bg |= 16777224 | i3 - 100) : 0 === i3 ? this._processSGR0(s3) : 1 === i3 ? s3.fg |= 134217728 : 3 === i3 ? s3.bg |= 67108864 : 4 === i3 ? (s3.fg |= 268435456, this._processUnderline(e3.hasSubParams(r2) ? e3.getSubParams(r2)[0] : 1, s3)) : 5 === i3 ? s3.fg |= 536870912 : 7 === i3 ? s3.fg |= 67108864 : 8 === i3 ? s3.fg |= 1073741824 : 9 === i3 ? s3.fg |= 2147483648 : 2 === i3 ? s3.bg |= 134217728 : 21 === i3 ? this._processUnderline(2, s3) : 22 === i3 ? (s3.fg &= -134217729, s3.bg &= -134217729) : 23 === i3 ? s3.bg &= -67108865 : 24 === i3 ? (s3.fg &= -268435457, this._processUnderline(0, s3)) : 25 === i3 ? s3.fg &= -536870913 : 27 === i3 ? s3.fg &= -67108865 : 28 === i3 ? s3.fg &= -1073741825 : 29 === i3 ? s3.fg &= 2147483647 : 39 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : 49 === i3 ? (s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : 38 === i3 || 48 === i3 || 58 === i3 ? r2 += this._extractColor(e3, r2, s3) : 53 === i3 ? s3.bg |= 1073741824 : 55 === i3 ? s3.bg &= -1073741825 : 59 === i3 ? (s3.extended = s3.extended.clone(), s3.extended.underlineColor = -1, s3.updateExtended()) : 100 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i3);
              return true;
            }
            deviceStatus(e3) {
              switch (e3.params[0]) {
                case 5:
                  this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
                  break;
                case 6:
                  const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
                  this._coreService.triggerDataEvent(`${n.C0.ESC}[${e4};${t3}R`);
              }
              return true;
            }
            deviceStatusPrivate(e3) {
              if (6 === e3.params[0]) {
                const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${n.C0.ESC}[?${e4};${t3}R`);
              }
              return true;
            }
            softReset(e3) {
              return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
            }
            setCursorStyle(e3) {
              const t3 = e3.params[0] || 1;
              switch (t3) {
                case 1:
                case 2:
                  this._optionsService.options.cursorStyle = "block";
                  break;
                case 3:
                case 4:
                  this._optionsService.options.cursorStyle = "underline";
                  break;
                case 5:
                case 6:
                  this._optionsService.options.cursorStyle = "bar";
              }
              const i3 = t3 % 2 == 1;
              return this._optionsService.options.cursorBlink = i3, true;
            }
            setScrollRegion(e3) {
              const t3 = e3.params[0] || 1;
              let i3;
              return (e3.length < 2 || (i3 = e3.params[1]) > this._bufferService.rows || 0 === i3) && (i3 = this._bufferService.rows), i3 > t3 && (this._activeBuffer.scrollTop = t3 - 1, this._activeBuffer.scrollBottom = i3 - 1, this._setCursor(0, 0)), true;
            }
            windowOptions(e3) {
              if (!b(e3.params[0], this._optionsService.rawOptions.windowOptions))
                return true;
              const t3 = e3.length > 1 ? e3.params[1] : 0;
              switch (e3.params[0]) {
                case 14:
                  2 !== t3 && this._onRequestWindowsOptionsReport.fire(y.GET_WIN_SIZE_PIXELS);
                  break;
                case 16:
                  this._onRequestWindowsOptionsReport.fire(y.GET_CELL_SIZE_PIXELS);
                  break;
                case 18:
                  this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                  break;
                case 22:
                  0 !== t3 && 2 !== t3 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t3 && 1 !== t3 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                  break;
                case 23:
                  0 !== t3 && 2 !== t3 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t3 && 1 !== t3 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
              }
              return true;
            }
            saveCursor(e3) {
              return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
            }
            restoreCursor(e3) {
              return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
            }
            setTitle(e3) {
              return this._windowTitle = e3, this._onTitleChange.fire(e3), true;
            }
            setIconName(e3) {
              return this._iconName = e3, true;
            }
            setOrReportIndexedColor(e3) {
              const t3 = [], i3 = e3.split(";");
              for (; i3.length > 1; ) {
                const e4 = i3.shift(), s3 = i3.shift();
                if (/^\d+$/.exec(e4)) {
                  const i4 = parseInt(e4);
                  if (L(i4))
                    if ("?" === s3)
                      t3.push({ type: 0, index: i4 });
                    else {
                      const e5 = (0, m.parseColor)(s3);
                      e5 && t3.push({ type: 1, index: i4, color: e5 });
                    }
                }
              }
              return t3.length && this._onColor.fire(t3), true;
            }
            setHyperlink(e3) {
              const t3 = e3.split(";");
              return !(t3.length < 2) && (t3[1] ? this._createHyperlink(t3[0], t3[1]) : !t3[0] && this._finishHyperlink());
            }
            _createHyperlink(e3, t3) {
              this._getCurrentLinkId() && this._finishHyperlink();
              const i3 = e3.split(":");
              let s3;
              const r2 = i3.findIndex((e4) => e4.startsWith("id="));
              return -1 !== r2 && (s3 = i3[r2].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: s3, uri: t3 }), this._curAttrData.updateExtended(), true;
            }
            _finishHyperlink() {
              return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
            }
            _setOrReportSpecialColor(e3, t3) {
              const i3 = e3.split(";");
              for (let e4 = 0; e4 < i3.length && !(t3 >= this._specialColors.length); ++e4, ++t3)
                if ("?" === i3[e4])
                  this._onColor.fire([{ type: 0, index: this._specialColors[t3] }]);
                else {
                  const s3 = (0, m.parseColor)(i3[e4]);
                  s3 && this._onColor.fire([{ type: 1, index: this._specialColors[t3], color: s3 }]);
                }
              return true;
            }
            setOrReportFgColor(e3) {
              return this._setOrReportSpecialColor(e3, 0);
            }
            setOrReportBgColor(e3) {
              return this._setOrReportSpecialColor(e3, 1);
            }
            setOrReportCursorColor(e3) {
              return this._setOrReportSpecialColor(e3, 2);
            }
            restoreIndexedColor(e3) {
              if (!e3)
                return this._onColor.fire([{ type: 2 }]), true;
              const t3 = [], i3 = e3.split(";");
              for (let e4 = 0; e4 < i3.length; ++e4)
                if (/^\d+$/.exec(i3[e4])) {
                  const s3 = parseInt(i3[e4]);
                  L(s3) && t3.push({ type: 2, index: s3 });
                }
              return t3.length && this._onColor.fire(t3), true;
            }
            restoreFgColor(e3) {
              return this._onColor.fire([{ type: 2, index: 256 }]), true;
            }
            restoreBgColor(e3) {
              return this._onColor.fire([{ type: 2, index: 257 }]), true;
            }
            restoreCursorColor(e3) {
              return this._onColor.fire([{ type: 2, index: 258 }]), true;
            }
            nextLine() {
              return this._activeBuffer.x = 0, this.index(), true;
            }
            keypadApplicationMode() {
              return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
            }
            keypadNumericMode() {
              return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
            }
            selectDefaultCharset() {
              return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), true;
            }
            selectCharset(e3) {
              return 2 !== e3.length ? (this.selectDefaultCharset(), true) : ("/" === e3[0] || this._charsetService.setgCharset(S[e3[0]], o.CHARSETS[e3[1]] || o.DEFAULT_CHARSET), true);
            }
            index() {
              return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
            }
            tabSet() {
              return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
            }
            reverseIndex() {
              if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
                const e3 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
                this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e3, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
              } else
                this._activeBuffer.y--, this._restrictCursor();
              return true;
            }
            fullReset() {
              return this._parser.reset(), this._onRequestReset.fire(), true;
            }
            reset() {
              this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
            }
            _eraseAttrData() {
              return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
            }
            setgLevel(e3) {
              return this._charsetService.setgLevel(e3), true;
            }
            screenAlignmentPattern() {
              const e3 = new u.CellData();
              e3.content = 1 << 22 | "E".charCodeAt(0), e3.fg = this._curAttrData.fg, e3.bg = this._curAttrData.bg, this._setCursor(0, 0);
              for (let t3 = 0; t3 < this._bufferService.rows; ++t3) {
                const i3 = this._activeBuffer.ybase + this._activeBuffer.y + t3, s3 = this._activeBuffer.lines.get(i3);
                s3 && (s3.fill(e3), s3.isWrapped = false);
              }
              return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
            }
            requestStatusString(e3, t3) {
              const i3 = this._bufferService.buffer, s3 = this._optionsService.rawOptions;
              return ((e4) => (this._coreService.triggerDataEvent(`${n.C0.ESC}${e4}${n.C0.ESC}\\`), true))('"q' === e3 ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : '"p' === e3 ? 'P1$r61;1"p' : "r" === e3 ? `P1$r${i3.scrollTop + 1};${i3.scrollBottom + 1}r` : "m" === e3 ? "P1$r0m" : " q" === e3 ? `P1$r${{ block: 2, underline: 4, bar: 6 }[s3.cursorStyle] - (s3.cursorBlink ? 1 : 0)} q` : "P0$r");
            }
            markRangeDirty(e3, t3) {
              this._dirtyRowTracker.markRangeDirty(e3, t3);
            }
          }
          t2.InputHandler = E;
          let k = class {
            constructor(e3) {
              this._bufferService = e3, this.clearRange();
            }
            clearRange() {
              this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
            }
            markDirty(e3) {
              e3 < this.start ? this.start = e3 : e3 > this.end && (this.end = e3);
            }
            markRangeDirty(e3, t3) {
              e3 > t3 && (w = e3, e3 = t3, t3 = w), e3 < this.start && (this.start = e3), t3 > this.end && (this.end = t3);
            }
            markAllDirty() {
              this.markRangeDirty(0, this._bufferService.rows - 1);
            }
          };
          function L(e3) {
            return 0 <= e3 && e3 < 256;
          }
          k = s2([r(0, v.IBufferService)], k);
        }, 844: (e2, t2) => {
          function i2(e3) {
            for (const t3 of e3)
              t3.dispose();
            e3.length = 0;
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getDisposeArrayDisposable = t2.disposeArray = t2.toDisposable = t2.MutableDisposable = t2.Disposable = void 0, t2.Disposable = class {
            constructor() {
              this._disposables = [], this._isDisposed = false;
            }
            dispose() {
              this._isDisposed = true;
              for (const e3 of this._disposables)
                e3.dispose();
              this._disposables.length = 0;
            }
            register(e3) {
              return this._disposables.push(e3), e3;
            }
            unregister(e3) {
              const t3 = this._disposables.indexOf(e3);
              -1 !== t3 && this._disposables.splice(t3, 1);
            }
          }, t2.MutableDisposable = class {
            constructor() {
              this._isDisposed = false;
            }
            get value() {
              return this._isDisposed ? void 0 : this._value;
            }
            set value(e3) {
              var t3;
              this._isDisposed || e3 === this._value || (null === (t3 = this._value) || void 0 === t3 || t3.dispose(), this._value = e3);
            }
            clear() {
              this.value = void 0;
            }
            dispose() {
              var e3;
              this._isDisposed = true, null === (e3 = this._value) || void 0 === e3 || e3.dispose(), this._value = void 0;
            }
          }, t2.toDisposable = function(e3) {
            return { dispose: e3 };
          }, t2.disposeArray = i2, t2.getDisposeArrayDisposable = function(e3) {
            return { dispose: () => i2(e3) };
          };
        }, 1505: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.FourKeyMap = t2.TwoKeyMap = void 0;
          class i2 {
            constructor() {
              this._data = {};
            }
            set(e3, t3, i3) {
              this._data[e3] || (this._data[e3] = {}), this._data[e3][t3] = i3;
            }
            get(e3, t3) {
              return this._data[e3] ? this._data[e3][t3] : void 0;
            }
            clear() {
              this._data = {};
            }
          }
          t2.TwoKeyMap = i2, t2.FourKeyMap = class {
            constructor() {
              this._data = new i2();
            }
            set(e3, t3, s2, r, n) {
              this._data.get(e3, t3) || this._data.set(e3, t3, new i2()), this._data.get(e3, t3).set(s2, r, n);
            }
            get(e3, t3, i3, s2) {
              var r;
              return null === (r = this._data.get(e3, t3)) || void 0 === r ? void 0 : r.get(i3, s2);
            }
            clear() {
              this._data.clear();
            }
          };
        }, 6114: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.isChromeOS = t2.isLinux = t2.isWindows = t2.isIphone = t2.isIpad = t2.isMac = t2.getSafariVersion = t2.isSafari = t2.isLegacyEdge = t2.isFirefox = t2.isNode = void 0, t2.isNode = "undefined" == typeof navigator;
          const i2 = t2.isNode ? "node" : navigator.userAgent, s2 = t2.isNode ? "node" : navigator.platform;
          t2.isFirefox = i2.includes("Firefox"), t2.isLegacyEdge = i2.includes("Edge"), t2.isSafari = /^((?!chrome|android).)*safari/i.test(i2), t2.getSafariVersion = function() {
            if (!t2.isSafari)
              return 0;
            const e3 = i2.match(/Version\/(\d+)/);
            return null === e3 || e3.length < 2 ? 0 : parseInt(e3[1]);
          }, t2.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(s2), t2.isIpad = "iPad" === s2, t2.isIphone = "iPhone" === s2, t2.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(s2), t2.isLinux = s2.indexOf("Linux") >= 0, t2.isChromeOS = /\bCrOS\b/.test(i2);
        }, 6106: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.SortedList = void 0;
          let i2 = 0;
          t2.SortedList = class {
            constructor(e3) {
              this._getKey = e3, this._array = [];
            }
            clear() {
              this._array.length = 0;
            }
            insert(e3) {
              0 !== this._array.length ? (i2 = this._search(this._getKey(e3)), this._array.splice(i2, 0, e3)) : this._array.push(e3);
            }
            delete(e3) {
              if (0 === this._array.length)
                return false;
              const t3 = this._getKey(e3);
              if (void 0 === t3)
                return false;
              if (i2 = this._search(t3), -1 === i2)
                return false;
              if (this._getKey(this._array[i2]) !== t3)
                return false;
              do {
                if (this._array[i2] === e3)
                  return this._array.splice(i2, 1), true;
              } while (++i2 < this._array.length && this._getKey(this._array[i2]) === t3);
              return false;
            }
            *getKeyIterator(e3) {
              if (0 !== this._array.length && (i2 = this._search(e3), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3))
                do {
                  yield this._array[i2];
                } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
            }
            forEachByKey(e3, t3) {
              if (0 !== this._array.length && (i2 = this._search(e3), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3))
                do {
                  t3(this._array[i2]);
                } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
            }
            values() {
              return [...this._array].values();
            }
            _search(e3) {
              let t3 = 0, i3 = this._array.length - 1;
              for (; i3 >= t3; ) {
                let s2 = t3 + i3 >> 1;
                const r = this._getKey(this._array[s2]);
                if (r > e3)
                  i3 = s2 - 1;
                else {
                  if (!(r < e3)) {
                    for (; s2 > 0 && this._getKey(this._array[s2 - 1]) === e3; )
                      s2--;
                    return s2;
                  }
                  t3 = s2 + 1;
                }
              }
              return t3;
            }
          };
        }, 7226: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DebouncedIdleTask = t2.IdleTaskQueue = t2.PriorityTaskQueue = void 0;
          const s2 = i2(6114);
          class r {
            constructor() {
              this._tasks = [], this._i = 0;
            }
            enqueue(e3) {
              this._tasks.push(e3), this._start();
            }
            flush() {
              for (; this._i < this._tasks.length; )
                this._tasks[this._i]() || this._i++;
              this.clear();
            }
            clear() {
              this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
            }
            _start() {
              this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
            }
            _process(e3) {
              this._idleCallback = void 0;
              let t3 = 0, i3 = 0, s3 = e3.timeRemaining(), r2 = 0;
              for (; this._i < this._tasks.length; ) {
                if (t3 = Date.now(), this._tasks[this._i]() || this._i++, t3 = Math.max(1, Date.now() - t3), i3 = Math.max(t3, i3), r2 = e3.timeRemaining(), 1.5 * i3 > r2)
                  return s3 - t3 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t3))}ms`), void this._start();
                s3 = r2;
              }
              this.clear();
            }
          }
          class n extends r {
            _requestCallback(e3) {
              return setTimeout(() => e3(this._createDeadline(16)));
            }
            _cancelCallback(e3) {
              clearTimeout(e3);
            }
            _createDeadline(e3) {
              const t3 = Date.now() + e3;
              return { timeRemaining: () => Math.max(0, t3 - Date.now()) };
            }
          }
          t2.PriorityTaskQueue = n, t2.IdleTaskQueue = !s2.isNode && "requestIdleCallback" in window ? class extends r {
            _requestCallback(e3) {
              return requestIdleCallback(e3);
            }
            _cancelCallback(e3) {
              cancelIdleCallback(e3);
            }
          } : n, t2.DebouncedIdleTask = class {
            constructor() {
              this._queue = new t2.IdleTaskQueue();
            }
            set(e3) {
              this._queue.clear(), this._queue.enqueue(e3);
            }
            flush() {
              this._queue.flush();
            }
          };
        }, 9282: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.updateWindowsModeWrappedState = void 0;
          const s2 = i2(643);
          t2.updateWindowsModeWrappedState = function(e3) {
            const t3 = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y - 1), i3 = null == t3 ? void 0 : t3.get(e3.cols - 1), r = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y);
            r && i3 && (r.isWrapped = i3[s2.CHAR_DATA_CODE_INDEX] !== s2.NULL_CELL_CODE && i3[s2.CHAR_DATA_CODE_INDEX] !== s2.WHITESPACE_CELL_CODE);
          };
        }, 3734: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ExtendedAttrs = t2.AttributeData = void 0;
          class i2 {
            constructor() {
              this.fg = 0, this.bg = 0, this.extended = new s2();
            }
            static toColorRGB(e3) {
              return [e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
            }
            static fromColorRGB(e3) {
              return (255 & e3[0]) << 16 | (255 & e3[1]) << 8 | 255 & e3[2];
            }
            clone() {
              const e3 = new i2();
              return e3.fg = this.fg, e3.bg = this.bg, e3.extended = this.extended.clone(), e3;
            }
            isInverse() {
              return 67108864 & this.fg;
            }
            isBold() {
              return 134217728 & this.fg;
            }
            isUnderline() {
              return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
            }
            isBlink() {
              return 536870912 & this.fg;
            }
            isInvisible() {
              return 1073741824 & this.fg;
            }
            isItalic() {
              return 67108864 & this.bg;
            }
            isDim() {
              return 134217728 & this.bg;
            }
            isStrikethrough() {
              return 2147483648 & this.fg;
            }
            isProtected() {
              return 536870912 & this.bg;
            }
            isOverline() {
              return 1073741824 & this.bg;
            }
            getFgColorMode() {
              return 50331648 & this.fg;
            }
            getBgColorMode() {
              return 50331648 & this.bg;
            }
            isFgRGB() {
              return 50331648 == (50331648 & this.fg);
            }
            isBgRGB() {
              return 50331648 == (50331648 & this.bg);
            }
            isFgPalette() {
              return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
            }
            isBgPalette() {
              return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
            }
            isFgDefault() {
              return 0 == (50331648 & this.fg);
            }
            isBgDefault() {
              return 0 == (50331648 & this.bg);
            }
            isAttributeDefault() {
              return 0 === this.fg && 0 === this.bg;
            }
            getFgColor() {
              switch (50331648 & this.fg) {
                case 16777216:
                case 33554432:
                  return 255 & this.fg;
                case 50331648:
                  return 16777215 & this.fg;
                default:
                  return -1;
              }
            }
            getBgColor() {
              switch (50331648 & this.bg) {
                case 16777216:
                case 33554432:
                  return 255 & this.bg;
                case 50331648:
                  return 16777215 & this.bg;
                default:
                  return -1;
              }
            }
            hasExtendedAttrs() {
              return 268435456 & this.bg;
            }
            updateExtended() {
              this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
            }
            getUnderlineColor() {
              if (268435456 & this.bg && ~this.extended.underlineColor)
                switch (50331648 & this.extended.underlineColor) {
                  case 16777216:
                  case 33554432:
                    return 255 & this.extended.underlineColor;
                  case 50331648:
                    return 16777215 & this.extended.underlineColor;
                  default:
                    return this.getFgColor();
                }
              return this.getFgColor();
            }
            getUnderlineColorMode() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
            }
            isUnderlineColorRGB() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
            }
            isUnderlineColorPalette() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
            }
            isUnderlineColorDefault() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
            }
            getUnderlineStyle() {
              return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
            }
          }
          t2.AttributeData = i2;
          class s2 {
            get ext() {
              return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
            }
            set ext(e3) {
              this._ext = e3;
            }
            get underlineStyle() {
              return this._urlId ? 5 : (469762048 & this._ext) >> 26;
            }
            set underlineStyle(e3) {
              this._ext &= -469762049, this._ext |= e3 << 26 & 469762048;
            }
            get underlineColor() {
              return 67108863 & this._ext;
            }
            set underlineColor(e3) {
              this._ext &= -67108864, this._ext |= 67108863 & e3;
            }
            get urlId() {
              return this._urlId;
            }
            set urlId(e3) {
              this._urlId = e3;
            }
            constructor(e3 = 0, t3 = 0) {
              this._ext = 0, this._urlId = 0, this._ext = e3, this._urlId = t3;
            }
            clone() {
              return new s2(this._ext, this._urlId);
            }
            isEmpty() {
              return 0 === this.underlineStyle && 0 === this._urlId;
            }
          }
          t2.ExtendedAttrs = s2;
        }, 9092: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Buffer = t2.MAX_BUFFER_SIZE = void 0;
          const s2 = i2(6349), r = i2(7226), n = i2(3734), o = i2(8437), a = i2(4634), h = i2(511), c = i2(643), l = i2(4863), d = i2(7116);
          t2.MAX_BUFFER_SIZE = 4294967295, t2.Buffer = class {
            constructor(e3, t3, i3) {
              this._hasScrollback = e3, this._optionsService = t3, this._bufferService = i3, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = o.DEFAULT_ATTR_DATA.clone(), this.savedCharset = d.DEFAULT_CHARSET, this.markers = [], this._nullCell = h.CellData.fromCharData([0, c.NULL_CELL_CHAR, c.NULL_CELL_WIDTH, c.NULL_CELL_CODE]), this._whitespaceCell = h.CellData.fromCharData([0, c.WHITESPACE_CELL_CHAR, c.WHITESPACE_CELL_WIDTH, c.WHITESPACE_CELL_CODE]), this._isClearing = false, this._memoryCleanupQueue = new r.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
            }
            getNullCell(e3) {
              return e3 ? (this._nullCell.fg = e3.fg, this._nullCell.bg = e3.bg, this._nullCell.extended = e3.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs()), this._nullCell;
            }
            getWhitespaceCell(e3) {
              return e3 ? (this._whitespaceCell.fg = e3.fg, this._whitespaceCell.bg = e3.bg, this._whitespaceCell.extended = e3.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs()), this._whitespaceCell;
            }
            getBlankLine(e3, t3) {
              return new o.BufferLine(this._bufferService.cols, this.getNullCell(e3), t3);
            }
            get hasScrollback() {
              return this._hasScrollback && this.lines.maxLength > this._rows;
            }
            get isCursorInViewport() {
              const e3 = this.ybase + this.y - this.ydisp;
              return e3 >= 0 && e3 < this._rows;
            }
            _getCorrectBufferLength(e3) {
              if (!this._hasScrollback)
                return e3;
              const i3 = e3 + this._optionsService.rawOptions.scrollback;
              return i3 > t2.MAX_BUFFER_SIZE ? t2.MAX_BUFFER_SIZE : i3;
            }
            fillViewportRows(e3) {
              if (0 === this.lines.length) {
                void 0 === e3 && (e3 = o.DEFAULT_ATTR_DATA);
                let t3 = this._rows;
                for (; t3--; )
                  this.lines.push(this.getBlankLine(e3));
              }
            }
            clear() {
              this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
            }
            resize(e3, t3) {
              const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
              let s3 = 0;
              const r2 = this._getCorrectBufferLength(t3);
              if (r2 > this.lines.maxLength && (this.lines.maxLength = r2), this.lines.length > 0) {
                if (this._cols < e3)
                  for (let t4 = 0; t4 < this.lines.length; t4++)
                    s3 += +this.lines.get(t4).resize(e3, i3);
                let n2 = 0;
                if (this._rows < t3)
                  for (let s4 = this._rows; s4 < t3; s4++)
                    this.lines.length < t3 + this.ybase && (this._optionsService.rawOptions.windowsMode || void 0 !== this._optionsService.rawOptions.windowsPty.backend || void 0 !== this._optionsService.rawOptions.windowsPty.buildNumber ? this.lines.push(new o.BufferLine(e3, i3)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + n2 + 1 ? (this.ybase--, n2++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new o.BufferLine(e3, i3)));
                else
                  for (let e4 = this._rows; e4 > t3; e4--)
                    this.lines.length > t3 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
                if (r2 < this.lines.maxLength) {
                  const e4 = this.lines.length - r2;
                  e4 > 0 && (this.lines.trimStart(e4), this.ybase = Math.max(this.ybase - e4, 0), this.ydisp = Math.max(this.ydisp - e4, 0), this.savedY = Math.max(this.savedY - e4, 0)), this.lines.maxLength = r2;
                }
                this.x = Math.min(this.x, e3 - 1), this.y = Math.min(this.y, t3 - 1), n2 && (this.y += n2), this.savedX = Math.min(this.savedX, e3 - 1), this.scrollTop = 0;
              }
              if (this.scrollBottom = t3 - 1, this._isReflowEnabled && (this._reflow(e3, t3), this._cols > e3))
                for (let t4 = 0; t4 < this.lines.length; t4++)
                  s3 += +this.lines.get(t4).resize(e3, i3);
              this._cols = e3, this._rows = t3, this._memoryCleanupQueue.clear(), s3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
            }
            _batchedMemoryCleanup() {
              let e3 = true;
              this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e3 = false);
              let t3 = 0;
              for (; this._memoryCleanupPosition < this.lines.length; )
                if (t3 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t3 > 100)
                  return true;
              return e3;
            }
            get _isReflowEnabled() {
              const e3 = this._optionsService.rawOptions.windowsPty;
              return e3 && e3.buildNumber ? this._hasScrollback && "conpty" === e3.backend && e3.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
            }
            _reflow(e3, t3) {
              this._cols !== e3 && (e3 > this._cols ? this._reflowLarger(e3, t3) : this._reflowSmaller(e3, t3));
            }
            _reflowLarger(e3, t3) {
              const i3 = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e3, this.ybase + this.y, this.getNullCell(o.DEFAULT_ATTR_DATA));
              if (i3.length > 0) {
                const s3 = (0, a.reflowLargerCreateNewLayout)(this.lines, i3);
                (0, a.reflowLargerApplyNewLayout)(this.lines, s3.layout), this._reflowLargerAdjustViewport(e3, t3, s3.countRemoved);
              }
            }
            _reflowLargerAdjustViewport(e3, t3, i3) {
              const s3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
              let r2 = i3;
              for (; r2-- > 0; )
                0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t3 && this.lines.push(new o.BufferLine(e3, s3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
              this.savedY = Math.max(this.savedY - i3, 0);
            }
            _reflowSmaller(e3, t3) {
              const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA), s3 = [];
              let r2 = 0;
              for (let n2 = this.lines.length - 1; n2 >= 0; n2--) {
                let h2 = this.lines.get(n2);
                if (!h2 || !h2.isWrapped && h2.getTrimmedLength() <= e3)
                  continue;
                const c2 = [h2];
                for (; h2.isWrapped && n2 > 0; )
                  h2 = this.lines.get(--n2), c2.unshift(h2);
                const l2 = this.ybase + this.y;
                if (l2 >= n2 && l2 < n2 + c2.length)
                  continue;
                const d2 = c2[c2.length - 1].getTrimmedLength(), _ = (0, a.reflowSmallerGetNewLineLengths)(c2, this._cols, e3), u = _.length - c2.length;
                let f;
                f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
                const v = [];
                for (let e4 = 0; e4 < u; e4++) {
                  const e5 = this.getBlankLine(o.DEFAULT_ATTR_DATA, true);
                  v.push(e5);
                }
                v.length > 0 && (s3.push({ start: n2 + c2.length + r2, newLines: v }), r2 += v.length), c2.push(...v);
                let p = _.length - 1, g = _[p];
                0 === g && (p--, g = _[p]);
                let m = c2.length - u - 1, S = d2;
                for (; m >= 0; ) {
                  const e4 = Math.min(S, g);
                  if (void 0 === c2[p])
                    break;
                  if (c2[p].copyCellsFrom(c2[m], S - e4, g - e4, e4, true), g -= e4, 0 === g && (p--, g = _[p]), S -= e4, 0 === S) {
                    m--;
                    const e5 = Math.max(m, 0);
                    S = (0, a.getWrappedLineTrimmedLength)(c2, e5, this._cols);
                  }
                }
                for (let t4 = 0; t4 < c2.length; t4++)
                  _[t4] < e3 && c2[t4].setCell(_[t4], i3);
                let C = u - f;
                for (; C-- > 0; )
                  0 === this.ybase ? this.y < t3 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + r2) - t3 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
                this.savedY = Math.min(this.savedY + u, this.ybase + t3 - 1);
              }
              if (s3.length > 0) {
                const e4 = [], t4 = [];
                for (let e5 = 0; e5 < this.lines.length; e5++)
                  t4.push(this.lines.get(e5));
                const i4 = this.lines.length;
                let n2 = i4 - 1, o2 = 0, a2 = s3[o2];
                this.lines.length = Math.min(this.lines.maxLength, this.lines.length + r2);
                let h2 = 0;
                for (let c3 = Math.min(this.lines.maxLength - 1, i4 + r2 - 1); c3 >= 0; c3--)
                  if (a2 && a2.start > n2 + h2) {
                    for (let e5 = a2.newLines.length - 1; e5 >= 0; e5--)
                      this.lines.set(c3--, a2.newLines[e5]);
                    c3++, e4.push({ index: n2 + 1, amount: a2.newLines.length }), h2 += a2.newLines.length, a2 = s3[++o2];
                  } else
                    this.lines.set(c3, t4[n2--]);
                let c2 = 0;
                for (let t5 = e4.length - 1; t5 >= 0; t5--)
                  e4[t5].index += c2, this.lines.onInsertEmitter.fire(e4[t5]), c2 += e4[t5].amount;
                const l2 = Math.max(0, i4 + r2 - this.lines.maxLength);
                l2 > 0 && this.lines.onTrimEmitter.fire(l2);
              }
            }
            translateBufferLineToString(e3, t3, i3 = 0, s3) {
              const r2 = this.lines.get(e3);
              return r2 ? r2.translateToString(t3, i3, s3) : "";
            }
            getWrappedRangeForLine(e3) {
              let t3 = e3, i3 = e3;
              for (; t3 > 0 && this.lines.get(t3).isWrapped; )
                t3--;
              for (; i3 + 1 < this.lines.length && this.lines.get(i3 + 1).isWrapped; )
                i3++;
              return { first: t3, last: i3 };
            }
            setupTabStops(e3) {
              for (null != e3 ? this.tabs[e3] || (e3 = this.prevStop(e3)) : (this.tabs = {}, e3 = 0); e3 < this._cols; e3 += this._optionsService.rawOptions.tabStopWidth)
                this.tabs[e3] = true;
            }
            prevStop(e3) {
              for (null == e3 && (e3 = this.x); !this.tabs[--e3] && e3 > 0; )
                ;
              return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
            }
            nextStop(e3) {
              for (null == e3 && (e3 = this.x); !this.tabs[++e3] && e3 < this._cols; )
                ;
              return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
            }
            clearMarkers(e3) {
              this._isClearing = true;
              for (let t3 = 0; t3 < this.markers.length; t3++)
                this.markers[t3].line === e3 && (this.markers[t3].dispose(), this.markers.splice(t3--, 1));
              this._isClearing = false;
            }
            clearAllMarkers() {
              this._isClearing = true;
              for (let e3 = 0; e3 < this.markers.length; e3++)
                this.markers[e3].dispose(), this.markers.splice(e3--, 1);
              this._isClearing = false;
            }
            addMarker(e3) {
              const t3 = new l.Marker(e3);
              return this.markers.push(t3), t3.register(this.lines.onTrim((e4) => {
                t3.line -= e4, t3.line < 0 && t3.dispose();
              })), t3.register(this.lines.onInsert((e4) => {
                t3.line >= e4.index && (t3.line += e4.amount);
              })), t3.register(this.lines.onDelete((e4) => {
                t3.line >= e4.index && t3.line < e4.index + e4.amount && t3.dispose(), t3.line > e4.index && (t3.line -= e4.amount);
              })), t3.register(t3.onDispose(() => this._removeMarker(t3))), t3;
            }
            _removeMarker(e3) {
              this._isClearing || this.markers.splice(this.markers.indexOf(e3), 1);
            }
          };
        }, 8437: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLine = t2.DEFAULT_ATTR_DATA = void 0;
          const s2 = i2(3734), r = i2(511), n = i2(643), o = i2(482);
          t2.DEFAULT_ATTR_DATA = Object.freeze(new s2.AttributeData());
          let a = 0;
          class h {
            constructor(e3, t3, i3 = false) {
              this.isWrapped = i3, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e3);
              const s3 = t3 || r.CellData.fromCharData([0, n.NULL_CELL_CHAR, n.NULL_CELL_WIDTH, n.NULL_CELL_CODE]);
              for (let t4 = 0; t4 < e3; ++t4)
                this.setCell(t4, s3);
              this.length = e3;
            }
            get(e3) {
              const t3 = this._data[3 * e3 + 0], i3 = 2097151 & t3;
              return [this._data[3 * e3 + 1], 2097152 & t3 ? this._combined[e3] : i3 ? (0, o.stringFromCodePoint)(i3) : "", t3 >> 22, 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : i3];
            }
            set(e3, t3) {
              this._data[3 * e3 + 1] = t3[n.CHAR_DATA_ATTR_INDEX], t3[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e3] = t3[1], this._data[3 * e3 + 0] = 2097152 | e3 | t3[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e3 + 0] = t3[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t3[n.CHAR_DATA_WIDTH_INDEX] << 22;
            }
            getWidth(e3) {
              return this._data[3 * e3 + 0] >> 22;
            }
            hasWidth(e3) {
              return 12582912 & this._data[3 * e3 + 0];
            }
            getFg(e3) {
              return this._data[3 * e3 + 1];
            }
            getBg(e3) {
              return this._data[3 * e3 + 2];
            }
            hasContent(e3) {
              return 4194303 & this._data[3 * e3 + 0];
            }
            getCodePoint(e3) {
              const t3 = this._data[3 * e3 + 0];
              return 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : 2097151 & t3;
            }
            isCombined(e3) {
              return 2097152 & this._data[3 * e3 + 0];
            }
            getString(e3) {
              const t3 = this._data[3 * e3 + 0];
              return 2097152 & t3 ? this._combined[e3] : 2097151 & t3 ? (0, o.stringFromCodePoint)(2097151 & t3) : "";
            }
            isProtected(e3) {
              return 536870912 & this._data[3 * e3 + 2];
            }
            loadCell(e3, t3) {
              return a = 3 * e3, t3.content = this._data[a + 0], t3.fg = this._data[a + 1], t3.bg = this._data[a + 2], 2097152 & t3.content && (t3.combinedData = this._combined[e3]), 268435456 & t3.bg && (t3.extended = this._extendedAttrs[e3]), t3;
            }
            setCell(e3, t3) {
              2097152 & t3.content && (this._combined[e3] = t3.combinedData), 268435456 & t3.bg && (this._extendedAttrs[e3] = t3.extended), this._data[3 * e3 + 0] = t3.content, this._data[3 * e3 + 1] = t3.fg, this._data[3 * e3 + 2] = t3.bg;
            }
            setCellFromCodePoint(e3, t3, i3, s3, r2, n2) {
              268435456 & r2 && (this._extendedAttrs[e3] = n2), this._data[3 * e3 + 0] = t3 | i3 << 22, this._data[3 * e3 + 1] = s3, this._data[3 * e3 + 2] = r2;
            }
            addCodepointToCell(e3, t3) {
              let i3 = this._data[3 * e3 + 0];
              2097152 & i3 ? this._combined[e3] += (0, o.stringFromCodePoint)(t3) : (2097151 & i3 ? (this._combined[e3] = (0, o.stringFromCodePoint)(2097151 & i3) + (0, o.stringFromCodePoint)(t3), i3 &= -2097152, i3 |= 2097152) : i3 = t3 | 1 << 22, this._data[3 * e3 + 0] = i3);
            }
            insertCells(e3, t3, i3, n2) {
              if ((e3 %= this.length) && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == n2 ? void 0 : n2.fg) || 0, (null == n2 ? void 0 : n2.bg) || 0, (null == n2 ? void 0 : n2.extended) || new s2.ExtendedAttrs()), t3 < this.length - e3) {
                const s3 = new r.CellData();
                for (let i4 = this.length - e3 - t3 - 1; i4 >= 0; --i4)
                  this.setCell(e3 + t3 + i4, this.loadCell(e3 + i4, s3));
                for (let s4 = 0; s4 < t3; ++s4)
                  this.setCell(e3 + s4, i3);
              } else
                for (let t4 = e3; t4 < this.length; ++t4)
                  this.setCell(t4, i3);
              2 === this.getWidth(this.length - 1) && this.setCellFromCodePoint(this.length - 1, 0, 1, (null == n2 ? void 0 : n2.fg) || 0, (null == n2 ? void 0 : n2.bg) || 0, (null == n2 ? void 0 : n2.extended) || new s2.ExtendedAttrs());
            }
            deleteCells(e3, t3, i3, n2) {
              if (e3 %= this.length, t3 < this.length - e3) {
                const s3 = new r.CellData();
                for (let i4 = 0; i4 < this.length - e3 - t3; ++i4)
                  this.setCell(e3 + i4, this.loadCell(e3 + t3 + i4, s3));
                for (let e4 = this.length - t3; e4 < this.length; ++e4)
                  this.setCell(e4, i3);
              } else
                for (let t4 = e3; t4 < this.length; ++t4)
                  this.setCell(t4, i3);
              e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == n2 ? void 0 : n2.fg) || 0, (null == n2 ? void 0 : n2.bg) || 0, (null == n2 ? void 0 : n2.extended) || new s2.ExtendedAttrs()), 0 !== this.getWidth(e3) || this.hasContent(e3) || this.setCellFromCodePoint(e3, 0, 1, (null == n2 ? void 0 : n2.fg) || 0, (null == n2 ? void 0 : n2.bg) || 0, (null == n2 ? void 0 : n2.extended) || new s2.ExtendedAttrs());
            }
            replaceCells(e3, t3, i3, r2, n2 = false) {
              if (n2)
                for (e3 && 2 === this.getWidth(e3 - 1) && !this.isProtected(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == r2 ? void 0 : r2.fg) || 0, (null == r2 ? void 0 : r2.bg) || 0, (null == r2 ? void 0 : r2.extended) || new s2.ExtendedAttrs()), t3 < this.length && 2 === this.getWidth(t3 - 1) && !this.isProtected(t3) && this.setCellFromCodePoint(t3, 0, 1, (null == r2 ? void 0 : r2.fg) || 0, (null == r2 ? void 0 : r2.bg) || 0, (null == r2 ? void 0 : r2.extended) || new s2.ExtendedAttrs()); e3 < t3 && e3 < this.length; )
                  this.isProtected(e3) || this.setCell(e3, i3), e3++;
              else
                for (e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodePoint(e3 - 1, 0, 1, (null == r2 ? void 0 : r2.fg) || 0, (null == r2 ? void 0 : r2.bg) || 0, (null == r2 ? void 0 : r2.extended) || new s2.ExtendedAttrs()), t3 < this.length && 2 === this.getWidth(t3 - 1) && this.setCellFromCodePoint(t3, 0, 1, (null == r2 ? void 0 : r2.fg) || 0, (null == r2 ? void 0 : r2.bg) || 0, (null == r2 ? void 0 : r2.extended) || new s2.ExtendedAttrs()); e3 < t3 && e3 < this.length; )
                  this.setCell(e3++, i3);
            }
            resize(e3, t3) {
              if (e3 === this.length)
                return 4 * this._data.length * 2 < this._data.buffer.byteLength;
              const i3 = 3 * e3;
              if (e3 > this.length) {
                if (this._data.buffer.byteLength >= 4 * i3)
                  this._data = new Uint32Array(this._data.buffer, 0, i3);
                else {
                  const e4 = new Uint32Array(i3);
                  e4.set(this._data), this._data = e4;
                }
                for (let i4 = this.length; i4 < e3; ++i4)
                  this.setCell(i4, t3);
              } else {
                this._data = this._data.subarray(0, i3);
                const t4 = Object.keys(this._combined);
                for (let i4 = 0; i4 < t4.length; i4++) {
                  const s4 = parseInt(t4[i4], 10);
                  s4 >= e3 && delete this._combined[s4];
                }
                const s3 = Object.keys(this._extendedAttrs);
                for (let t5 = 0; t5 < s3.length; t5++) {
                  const i4 = parseInt(s3[t5], 10);
                  i4 >= e3 && delete this._extendedAttrs[i4];
                }
              }
              return this.length = e3, 4 * i3 * 2 < this._data.buffer.byteLength;
            }
            cleanupMemory() {
              if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
                const e3 = new Uint32Array(this._data.length);
                return e3.set(this._data), this._data = e3, 1;
              }
              return 0;
            }
            fill(e3, t3 = false) {
              if (t3)
                for (let t4 = 0; t4 < this.length; ++t4)
                  this.isProtected(t4) || this.setCell(t4, e3);
              else {
                this._combined = {}, this._extendedAttrs = {};
                for (let t4 = 0; t4 < this.length; ++t4)
                  this.setCell(t4, e3);
              }
            }
            copyFrom(e3) {
              this.length !== e3.length ? this._data = new Uint32Array(e3._data) : this._data.set(e3._data), this.length = e3.length, this._combined = {};
              for (const t3 in e3._combined)
                this._combined[t3] = e3._combined[t3];
              this._extendedAttrs = {};
              for (const t3 in e3._extendedAttrs)
                this._extendedAttrs[t3] = e3._extendedAttrs[t3];
              this.isWrapped = e3.isWrapped;
            }
            clone() {
              const e3 = new h(0);
              e3._data = new Uint32Array(this._data), e3.length = this.length;
              for (const t3 in this._combined)
                e3._combined[t3] = this._combined[t3];
              for (const t3 in this._extendedAttrs)
                e3._extendedAttrs[t3] = this._extendedAttrs[t3];
              return e3.isWrapped = this.isWrapped, e3;
            }
            getTrimmedLength() {
              for (let e3 = this.length - 1; e3 >= 0; --e3)
                if (4194303 & this._data[3 * e3 + 0])
                  return e3 + (this._data[3 * e3 + 0] >> 22);
              return 0;
            }
            getNoBgTrimmedLength() {
              for (let e3 = this.length - 1; e3 >= 0; --e3)
                if (4194303 & this._data[3 * e3 + 0] || 50331648 & this._data[3 * e3 + 2])
                  return e3 + (this._data[3 * e3 + 0] >> 22);
              return 0;
            }
            copyCellsFrom(e3, t3, i3, s3, r2) {
              const n2 = e3._data;
              if (r2)
                for (let r3 = s3 - 1; r3 >= 0; r3--) {
                  for (let e4 = 0; e4 < 3; e4++)
                    this._data[3 * (i3 + r3) + e4] = n2[3 * (t3 + r3) + e4];
                  268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
                }
              else
                for (let r3 = 0; r3 < s3; r3++) {
                  for (let e4 = 0; e4 < 3; e4++)
                    this._data[3 * (i3 + r3) + e4] = n2[3 * (t3 + r3) + e4];
                  268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
                }
              const o2 = Object.keys(e3._combined);
              for (let s4 = 0; s4 < o2.length; s4++) {
                const r3 = parseInt(o2[s4], 10);
                r3 >= t3 && (this._combined[r3 - t3 + i3] = e3._combined[r3]);
              }
            }
            translateToString(e3 = false, t3 = 0, i3 = this.length) {
              e3 && (i3 = Math.min(i3, this.getTrimmedLength()));
              let s3 = "";
              for (; t3 < i3; ) {
                const e4 = this._data[3 * t3 + 0], i4 = 2097151 & e4;
                s3 += 2097152 & e4 ? this._combined[t3] : i4 ? (0, o.stringFromCodePoint)(i4) : n.WHITESPACE_CELL_CHAR, t3 += e4 >> 22 || 1;
              }
              return s3;
            }
          }
          t2.BufferLine = h;
        }, 4841: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getRangeLength = void 0, t2.getRangeLength = function(e3, t3) {
            if (e3.start.y > e3.end.y)
              throw new Error(`Buffer range end (${e3.end.x}, ${e3.end.y}) cannot be before start (${e3.start.x}, ${e3.start.y})`);
            return t3 * (e3.end.y - e3.start.y) + (e3.end.x - e3.start.x + 1);
          };
        }, 4634: (e2, t2) => {
          function i2(e3, t3, i3) {
            if (t3 === e3.length - 1)
              return e3[t3].getTrimmedLength();
            const s2 = !e3[t3].hasContent(i3 - 1) && 1 === e3[t3].getWidth(i3 - 1), r = 2 === e3[t3 + 1].getWidth(0);
            return s2 && r ? i3 - 1 : i3;
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getWrappedLineTrimmedLength = t2.reflowSmallerGetNewLineLengths = t2.reflowLargerApplyNewLayout = t2.reflowLargerCreateNewLayout = t2.reflowLargerGetLinesToRemove = void 0, t2.reflowLargerGetLinesToRemove = function(e3, t3, s2, r, n) {
            const o = [];
            for (let a = 0; a < e3.length - 1; a++) {
              let h = a, c = e3.get(++h);
              if (!c.isWrapped)
                continue;
              const l = [e3.get(a)];
              for (; h < e3.length && c.isWrapped; )
                l.push(c), c = e3.get(++h);
              if (r >= a && r < h) {
                a += l.length - 1;
                continue;
              }
              let d = 0, _ = i2(l, d, t3), u = 1, f = 0;
              for (; u < l.length; ) {
                const e4 = i2(l, u, t3), r2 = e4 - f, o2 = s2 - _, a2 = Math.min(r2, o2);
                l[d].copyCellsFrom(l[u], f, _, a2, false), _ += a2, _ === s2 && (d++, _ = 0), f += a2, f === e4 && (u++, f = 0), 0 === _ && 0 !== d && 2 === l[d - 1].getWidth(s2 - 1) && (l[d].copyCellsFrom(l[d - 1], s2 - 1, _++, 1, false), l[d - 1].setCell(s2 - 1, n));
              }
              l[d].replaceCells(_, s2, n);
              let v = 0;
              for (let e4 = l.length - 1; e4 > 0 && (e4 > d || 0 === l[e4].getTrimmedLength()); e4--)
                v++;
              v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;
            }
            return o;
          }, t2.reflowLargerCreateNewLayout = function(e3, t3) {
            const i3 = [];
            let s2 = 0, r = t3[s2], n = 0;
            for (let o = 0; o < e3.length; o++)
              if (r === o) {
                const i4 = t3[++s2];
                e3.onDeleteEmitter.fire({ index: o - n, amount: i4 }), o += i4 - 1, n += i4, r = t3[++s2];
              } else
                i3.push(o);
            return { layout: i3, countRemoved: n };
          }, t2.reflowLargerApplyNewLayout = function(e3, t3) {
            const i3 = [];
            for (let s2 = 0; s2 < t3.length; s2++)
              i3.push(e3.get(t3[s2]));
            for (let t4 = 0; t4 < i3.length; t4++)
              e3.set(t4, i3[t4]);
            e3.length = t3.length;
          }, t2.reflowSmallerGetNewLineLengths = function(e3, t3, s2) {
            const r = [], n = e3.map((s3, r2) => i2(e3, r2, t3)).reduce((e4, t4) => e4 + t4);
            let o = 0, a = 0, h = 0;
            for (; h < n; ) {
              if (n - h < s2) {
                r.push(n - h);
                break;
              }
              o += s2;
              const c = i2(e3, a, t3);
              o > c && (o -= c, a++);
              const l = 2 === e3[a].getWidth(o - 1);
              l && o--;
              const d = l ? s2 - 1 : s2;
              r.push(d), h += d;
            }
            return r;
          }, t2.getWrappedLineTrimmedLength = i2;
        }, 5295: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferSet = void 0;
          const s2 = i2(8460), r = i2(844), n = i2(9092);
          class o extends r.Disposable {
            constructor(e3, t3) {
              super(), this._optionsService = e3, this._bufferService = t3, this._onBufferActivate = this.register(new s2.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
            }
            reset() {
              this._normal = new n.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
            }
            get alt() {
              return this._alt;
            }
            get active() {
              return this._activeBuffer;
            }
            get normal() {
              return this._normal;
            }
            activateNormalBuffer() {
              this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
            }
            activateAltBuffer(e3) {
              this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e3), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
            }
            resize(e3, t3) {
              this._normal.resize(e3, t3), this._alt.resize(e3, t3), this.setupTabStops(e3);
            }
            setupTabStops(e3) {
              this._normal.setupTabStops(e3), this._alt.setupTabStops(e3);
            }
          }
          t2.BufferSet = o;
        }, 511: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CellData = void 0;
          const s2 = i2(482), r = i2(643), n = i2(3734);
          class o extends n.AttributeData {
            constructor() {
              super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs(), this.combinedData = "";
            }
            static fromCharData(e3) {
              const t3 = new o();
              return t3.setFromCharData(e3), t3;
            }
            isCombined() {
              return 2097152 & this.content;
            }
            getWidth() {
              return this.content >> 22;
            }
            getChars() {
              return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
            }
            getCode() {
              return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
            }
            setFromCharData(e3) {
              this.fg = e3[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
              let t3 = false;
              if (e3[r.CHAR_DATA_CHAR_INDEX].length > 2)
                t3 = true;
              else if (2 === e3[r.CHAR_DATA_CHAR_INDEX].length) {
                const i3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
                if (55296 <= i3 && i3 <= 56319) {
                  const s3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                  56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i3 - 55296) + s3 - 56320 + 65536 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22 : t3 = true;
                } else
                  t3 = true;
              } else
                this.content = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e3[r.CHAR_DATA_WIDTH_INDEX] << 22;
              t3 && (this.combinedData = e3[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22);
            }
            getAsCharData() {
              return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
            }
          }
          t2.CellData = o;
        }, 643: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.WHITESPACE_CELL_CODE = t2.WHITESPACE_CELL_WIDTH = t2.WHITESPACE_CELL_CHAR = t2.NULL_CELL_CODE = t2.NULL_CELL_WIDTH = t2.NULL_CELL_CHAR = t2.CHAR_DATA_CODE_INDEX = t2.CHAR_DATA_WIDTH_INDEX = t2.CHAR_DATA_CHAR_INDEX = t2.CHAR_DATA_ATTR_INDEX = t2.DEFAULT_EXT = t2.DEFAULT_ATTR = t2.DEFAULT_COLOR = void 0, t2.DEFAULT_COLOR = 0, t2.DEFAULT_ATTR = 256 | t2.DEFAULT_COLOR << 9, t2.DEFAULT_EXT = 0, t2.CHAR_DATA_ATTR_INDEX = 0, t2.CHAR_DATA_CHAR_INDEX = 1, t2.CHAR_DATA_WIDTH_INDEX = 2, t2.CHAR_DATA_CODE_INDEX = 3, t2.NULL_CELL_CHAR = "", t2.NULL_CELL_WIDTH = 1, t2.NULL_CELL_CODE = 0, t2.WHITESPACE_CELL_CHAR = " ", t2.WHITESPACE_CELL_WIDTH = 1, t2.WHITESPACE_CELL_CODE = 32;
        }, 4863: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Marker = void 0;
          const s2 = i2(8460), r = i2(844);
          class n {
            get id() {
              return this._id;
            }
            constructor(e3) {
              this.line = e3, this.isDisposed = false, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new s2.EventEmitter()), this.onDispose = this._onDispose.event;
            }
            dispose() {
              this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
            }
            register(e3) {
              return this._disposables.push(e3), e3;
            }
          }
          t2.Marker = n, n._nextId = 1;
        }, 7116: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_CHARSET = t2.CHARSETS = void 0, t2.CHARSETS = {}, t2.DEFAULT_CHARSET = t2.CHARSETS.B, t2.CHARSETS[0] = { "`": "\u25C6", a: "\u2592", b: "\u2409", c: "\u240C", d: "\u240D", e: "\u240A", f: "\xB0", g: "\xB1", h: "\u2424", i: "\u240B", j: "\u2518", k: "\u2510", l: "\u250C", m: "\u2514", n: "\u253C", o: "\u23BA", p: "\u23BB", q: "\u2500", r: "\u23BC", s: "\u23BD", t: "\u251C", u: "\u2524", v: "\u2534", w: "\u252C", x: "\u2502", y: "\u2264", z: "\u2265", "{": "\u03C0", "|": "\u2260", "}": "\xA3", "~": "\xB7" }, t2.CHARSETS.A = { "#": "\xA3" }, t2.CHARSETS.B = void 0, t2.CHARSETS[4] = { "#": "\xA3", "@": "\xBE", "[": "ij", "\\": "\xBD", "]": "|", "{": "\xA8", "|": "f", "}": "\xBC", "~": "\xB4" }, t2.CHARSETS.C = t2.CHARSETS[5] = { "[": "\xC4", "\\": "\xD6", "]": "\xC5", "^": "\xDC", "`": "\xE9", "{": "\xE4", "|": "\xF6", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS.R = { "#": "\xA3", "@": "\xE0", "[": "\xB0", "\\": "\xE7", "]": "\xA7", "{": "\xE9", "|": "\xF9", "}": "\xE8", "~": "\xA8" }, t2.CHARSETS.Q = { "@": "\xE0", "[": "\xE2", "\\": "\xE7", "]": "\xEA", "^": "\xEE", "`": "\xF4", "{": "\xE9", "|": "\xF9", "}": "\xE8", "~": "\xFB" }, t2.CHARSETS.K = { "@": "\xA7", "[": "\xC4", "\\": "\xD6", "]": "\xDC", "{": "\xE4", "|": "\xF6", "}": "\xFC", "~": "\xDF" }, t2.CHARSETS.Y = { "#": "\xA3", "@": "\xA7", "[": "\xB0", "\\": "\xE7", "]": "\xE9", "`": "\xF9", "{": "\xE0", "|": "\xF2", "}": "\xE8", "~": "\xEC" }, t2.CHARSETS.E = t2.CHARSETS[6] = { "@": "\xC4", "[": "\xC6", "\\": "\xD8", "]": "\xC5", "^": "\xDC", "`": "\xE4", "{": "\xE6", "|": "\xF8", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS.Z = { "#": "\xA3", "@": "\xA7", "[": "\xA1", "\\": "\xD1", "]": "\xBF", "{": "\xB0", "|": "\xF1", "}": "\xE7" }, t2.CHARSETS.H = t2.CHARSETS[7] = { "@": "\xC9", "[": "\xC4", "\\": "\xD6", "]": "\xC5", "^": "\xDC", "`": "\xE9", "{": "\xE4", "|": "\xF6", "}": "\xE5", "~": "\xFC" }, t2.CHARSETS["="] = { "#": "\xF9", "@": "\xE0", "[": "\xE9", "\\": "\xE7", "]": "\xEA", "^": "\xEE", _: "\xE8", "`": "\xF4", "{": "\xE4", "|": "\xF6", "}": "\xFC", "~": "\xFB" };
        }, 2584: (e2, t2) => {
          var i2, s2, r;
          Object.defineProperty(t2, "__esModule", { value: true }), t2.C1_ESCAPED = t2.C1 = t2.C0 = void 0, function(e3) {
            e3.NUL = "\0", e3.SOH = "", e3.STX = "", e3.ETX = "", e3.EOT = "", e3.ENQ = "", e3.ACK = "", e3.BEL = "\x07", e3.BS = "\b", e3.HT = "	", e3.LF = "\n", e3.VT = "\v", e3.FF = "\f", e3.CR = "\r", e3.SO = "", e3.SI = "", e3.DLE = "", e3.DC1 = "", e3.DC2 = "", e3.DC3 = "", e3.DC4 = "", e3.NAK = "", e3.SYN = "", e3.ETB = "", e3.CAN = "", e3.EM = "", e3.SUB = "", e3.ESC = "\x1B", e3.FS = "", e3.GS = "", e3.RS = "", e3.US = "", e3.SP = " ", e3.DEL = "\x7F";
          }(i2 || (t2.C0 = i2 = {})), function(e3) {
            e3.PAD = "\x80", e3.HOP = "\x81", e3.BPH = "\x82", e3.NBH = "\x83", e3.IND = "\x84", e3.NEL = "\x85", e3.SSA = "\x86", e3.ESA = "\x87", e3.HTS = "\x88", e3.HTJ = "\x89", e3.VTS = "\x8A", e3.PLD = "\x8B", e3.PLU = "\x8C", e3.RI = "\x8D", e3.SS2 = "\x8E", e3.SS3 = "\x8F", e3.DCS = "\x90", e3.PU1 = "\x91", e3.PU2 = "\x92", e3.STS = "\x93", e3.CCH = "\x94", e3.MW = "\x95", e3.SPA = "\x96", e3.EPA = "\x97", e3.SOS = "\x98", e3.SGCI = "\x99", e3.SCI = "\x9A", e3.CSI = "\x9B", e3.ST = "\x9C", e3.OSC = "\x9D", e3.PM = "\x9E", e3.APC = "\x9F";
          }(s2 || (t2.C1 = s2 = {})), function(e3) {
            e3.ST = `${i2.ESC}\\`;
          }(r || (t2.C1_ESCAPED = r = {}));
        }, 7399: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluateKeyboardEvent = void 0;
          const s2 = i2(2584), r = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
          t2.evaluateKeyboardEvent = function(e3, t3, i3, n) {
            const o = { type: 0, cancel: false, key: void 0 }, a = (e3.shiftKey ? 1 : 0) | (e3.altKey ? 2 : 0) | (e3.ctrlKey ? 4 : 0) | (e3.metaKey ? 8 : 0);
            switch (e3.keyCode) {
              case 0:
                "UIKeyInputUpArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A" : "UIKeyInputLeftArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D" : "UIKeyInputRightArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C" : "UIKeyInputDownArrow" === e3.key && (o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B");
                break;
              case 8:
                if (e3.altKey) {
                  o.key = s2.C0.ESC + s2.C0.DEL;
                  break;
                }
                o.key = s2.C0.DEL;
                break;
              case 9:
                if (e3.shiftKey) {
                  o.key = s2.C0.ESC + "[Z";
                  break;
                }
                o.key = s2.C0.HT, o.cancel = true;
                break;
              case 13:
                o.key = e3.altKey ? s2.C0.ESC + s2.C0.CR : s2.C0.CR, o.cancel = true;
                break;
              case 27:
                o.key = s2.C0.ESC, e3.altKey && (o.key = s2.C0.ESC + s2.C0.ESC), o.cancel = true;
                break;
              case 37:
                if (e3.metaKey)
                  break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "D", o.key === s2.C0.ESC + "[1;3D" && (o.key = s2.C0.ESC + (i3 ? "b" : "[1;5D"))) : o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D";
                break;
              case 39:
                if (e3.metaKey)
                  break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "C", o.key === s2.C0.ESC + "[1;3C" && (o.key = s2.C0.ESC + (i3 ? "f" : "[1;5C"))) : o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C";
                break;
              case 38:
                if (e3.metaKey)
                  break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "A", i3 || o.key !== s2.C0.ESC + "[1;3A" || (o.key = s2.C0.ESC + "[1;5A")) : o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A";
                break;
              case 40:
                if (e3.metaKey)
                  break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "B", i3 || o.key !== s2.C0.ESC + "[1;3B" || (o.key = s2.C0.ESC + "[1;5B")) : o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B";
                break;
              case 45:
                e3.shiftKey || e3.ctrlKey || (o.key = s2.C0.ESC + "[2~");
                break;
              case 46:
                o.key = a ? s2.C0.ESC + "[3;" + (a + 1) + "~" : s2.C0.ESC + "[3~";
                break;
              case 36:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "H" : t3 ? s2.C0.ESC + "OH" : s2.C0.ESC + "[H";
                break;
              case 35:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "F" : t3 ? s2.C0.ESC + "OF" : s2.C0.ESC + "[F";
                break;
              case 33:
                e3.shiftKey ? o.type = 2 : e3.ctrlKey ? o.key = s2.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[5~";
                break;
              case 34:
                e3.shiftKey ? o.type = 3 : e3.ctrlKey ? o.key = s2.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[6~";
                break;
              case 112:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "P" : s2.C0.ESC + "OP";
                break;
              case 113:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "Q" : s2.C0.ESC + "OQ";
                break;
              case 114:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "R" : s2.C0.ESC + "OR";
                break;
              case 115:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "S" : s2.C0.ESC + "OS";
                break;
              case 116:
                o.key = a ? s2.C0.ESC + "[15;" + (a + 1) + "~" : s2.C0.ESC + "[15~";
                break;
              case 117:
                o.key = a ? s2.C0.ESC + "[17;" + (a + 1) + "~" : s2.C0.ESC + "[17~";
                break;
              case 118:
                o.key = a ? s2.C0.ESC + "[18;" + (a + 1) + "~" : s2.C0.ESC + "[18~";
                break;
              case 119:
                o.key = a ? s2.C0.ESC + "[19;" + (a + 1) + "~" : s2.C0.ESC + "[19~";
                break;
              case 120:
                o.key = a ? s2.C0.ESC + "[20;" + (a + 1) + "~" : s2.C0.ESC + "[20~";
                break;
              case 121:
                o.key = a ? s2.C0.ESC + "[21;" + (a + 1) + "~" : s2.C0.ESC + "[21~";
                break;
              case 122:
                o.key = a ? s2.C0.ESC + "[23;" + (a + 1) + "~" : s2.C0.ESC + "[23~";
                break;
              case 123:
                o.key = a ? s2.C0.ESC + "[24;" + (a + 1) + "~" : s2.C0.ESC + "[24~";
                break;
              default:
                if (!e3.ctrlKey || e3.shiftKey || e3.altKey || e3.metaKey)
                  if (i3 && !n || !e3.altKey || e3.metaKey)
                    !i3 || e3.altKey || e3.ctrlKey || e3.shiftKey || !e3.metaKey ? e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && e3.keyCode >= 48 && 1 === e3.key.length ? o.key = e3.key : e3.key && e3.ctrlKey && ("_" === e3.key && (o.key = s2.C0.US), "@" === e3.key && (o.key = s2.C0.NUL)) : 65 === e3.keyCode && (o.type = 1);
                  else {
                    const t4 = r[e3.keyCode], i4 = null == t4 ? void 0 : t4[e3.shiftKey ? 1 : 0];
                    if (i4)
                      o.key = s2.C0.ESC + i4;
                    else if (e3.keyCode >= 65 && e3.keyCode <= 90) {
                      const t5 = e3.ctrlKey ? e3.keyCode - 64 : e3.keyCode + 32;
                      let i5 = String.fromCharCode(t5);
                      e3.shiftKey && (i5 = i5.toUpperCase()), o.key = s2.C0.ESC + i5;
                    } else if (32 === e3.keyCode)
                      o.key = s2.C0.ESC + (e3.ctrlKey ? s2.C0.NUL : " ");
                    else if ("Dead" === e3.key && e3.code.startsWith("Key")) {
                      let t5 = e3.code.slice(3, 4);
                      e3.shiftKey || (t5 = t5.toLowerCase()), o.key = s2.C0.ESC + t5, o.cancel = true;
                    }
                  }
                else
                  e3.keyCode >= 65 && e3.keyCode <= 90 ? o.key = String.fromCharCode(e3.keyCode - 64) : 32 === e3.keyCode ? o.key = s2.C0.NUL : e3.keyCode >= 51 && e3.keyCode <= 55 ? o.key = String.fromCharCode(e3.keyCode - 51 + 27) : 56 === e3.keyCode ? o.key = s2.C0.DEL : 219 === e3.keyCode ? o.key = s2.C0.ESC : 220 === e3.keyCode ? o.key = s2.C0.FS : 221 === e3.keyCode && (o.key = s2.C0.GS);
            }
            return o;
          };
        }, 482: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Utf8ToUtf32 = t2.StringToUtf32 = t2.utf32ToString = t2.stringFromCodePoint = void 0, t2.stringFromCodePoint = function(e3) {
            return e3 > 65535 ? (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10)) + String.fromCharCode(e3 % 1024 + 56320)) : String.fromCharCode(e3);
          }, t2.utf32ToString = function(e3, t3 = 0, i2 = e3.length) {
            let s2 = "";
            for (let r = t3; r < i2; ++r) {
              let t4 = e3[r];
              t4 > 65535 ? (t4 -= 65536, s2 += String.fromCharCode(55296 + (t4 >> 10)) + String.fromCharCode(t4 % 1024 + 56320)) : s2 += String.fromCharCode(t4);
            }
            return s2;
          }, t2.StringToUtf32 = class {
            constructor() {
              this._interim = 0;
            }
            clear() {
              this._interim = 0;
            }
            decode(e3, t3) {
              const i2 = e3.length;
              if (!i2)
                return 0;
              let s2 = 0, r = 0;
              if (this._interim) {
                const i3 = e3.charCodeAt(r++);
                56320 <= i3 && i3 <= 57343 ? t3[s2++] = 1024 * (this._interim - 55296) + i3 - 56320 + 65536 : (t3[s2++] = this._interim, t3[s2++] = i3), this._interim = 0;
              }
              for (let n = r; n < i2; ++n) {
                const r2 = e3.charCodeAt(n);
                if (55296 <= r2 && r2 <= 56319) {
                  if (++n >= i2)
                    return this._interim = r2, s2;
                  const o = e3.charCodeAt(n);
                  56320 <= o && o <= 57343 ? t3[s2++] = 1024 * (r2 - 55296) + o - 56320 + 65536 : (t3[s2++] = r2, t3[s2++] = o);
                } else
                  65279 !== r2 && (t3[s2++] = r2);
              }
              return s2;
            }
          }, t2.Utf8ToUtf32 = class {
            constructor() {
              this.interim = new Uint8Array(3);
            }
            clear() {
              this.interim.fill(0);
            }
            decode(e3, t3) {
              const i2 = e3.length;
              if (!i2)
                return 0;
              let s2, r, n, o, a = 0, h = 0, c = 0;
              if (this.interim[0]) {
                let s3 = false, r2 = this.interim[0];
                r2 &= 192 == (224 & r2) ? 31 : 224 == (240 & r2) ? 15 : 7;
                let n2, o2 = 0;
                for (; (n2 = 63 & this.interim[++o2]) && o2 < 4; )
                  r2 <<= 6, r2 |= n2;
                const h2 = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, l2 = h2 - o2;
                for (; c < l2; ) {
                  if (c >= i2)
                    return 0;
                  if (n2 = e3[c++], 128 != (192 & n2)) {
                    c--, s3 = true;
                    break;
                  }
                  this.interim[o2++] = n2, r2 <<= 6, r2 |= 63 & n2;
                }
                s3 || (2 === h2 ? r2 < 128 ? c-- : t3[a++] = r2 : 3 === h2 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || 65279 === r2 || (t3[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t3[a++] = r2)), this.interim.fill(0);
              }
              const l = i2 - 4;
              let d = c;
              for (; d < i2; ) {
                for (; !(!(d < l) || 128 & (s2 = e3[d]) || 128 & (r = e3[d + 1]) || 128 & (n = e3[d + 2]) || 128 & (o = e3[d + 3])); )
                  t3[a++] = s2, t3[a++] = r, t3[a++] = n, t3[a++] = o, d += 4;
                if (s2 = e3[d++], s2 < 128)
                  t3[a++] = s2;
                else if (192 == (224 & s2)) {
                  if (d >= i2)
                    return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (h = (31 & s2) << 6 | 63 & r, h < 128) {
                    d--;
                    continue;
                  }
                  t3[a++] = h;
                } else if (224 == (240 & s2)) {
                  if (d >= i2)
                    return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (d >= i2)
                    return this.interim[0] = s2, this.interim[1] = r, a;
                  if (n = e3[d++], 128 != (192 & n)) {
                    d--;
                    continue;
                  }
                  if (h = (15 & s2) << 12 | (63 & r) << 6 | 63 & n, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h)
                    continue;
                  t3[a++] = h;
                } else if (240 == (248 & s2)) {
                  if (d >= i2)
                    return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (d >= i2)
                    return this.interim[0] = s2, this.interim[1] = r, a;
                  if (n = e3[d++], 128 != (192 & n)) {
                    d--;
                    continue;
                  }
                  if (d >= i2)
                    return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = n, a;
                  if (o = e3[d++], 128 != (192 & o)) {
                    d--;
                    continue;
                  }
                  if (h = (7 & s2) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h < 65536 || h > 1114111)
                    continue;
                  t3[a++] = h;
                }
              }
              return a;
            }
          };
        }, 225: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeV6 = void 0;
          const i2 = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], s2 = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
          let r;
          t2.UnicodeV6 = class {
            constructor() {
              if (this.version = "6", !r) {
                r = new Uint8Array(65536), r.fill(1), r[0] = 0, r.fill(0, 1, 32), r.fill(0, 127, 160), r.fill(2, 4352, 4448), r[9001] = 2, r[9002] = 2, r.fill(2, 11904, 42192), r[12351] = 1, r.fill(2, 44032, 55204), r.fill(2, 63744, 64256), r.fill(2, 65040, 65050), r.fill(2, 65072, 65136), r.fill(2, 65280, 65377), r.fill(2, 65504, 65511);
                for (let e3 = 0; e3 < i2.length; ++e3)
                  r.fill(0, i2[e3][0], i2[e3][1] + 1);
              }
            }
            wcwidth(e3) {
              return e3 < 32 ? 0 : e3 < 127 ? 1 : e3 < 65536 ? r[e3] : function(e4, t3) {
                let i3, s3 = 0, r2 = t3.length - 1;
                if (e4 < t3[0][0] || e4 > t3[r2][1])
                  return false;
                for (; r2 >= s3; )
                  if (i3 = s3 + r2 >> 1, e4 > t3[i3][1])
                    s3 = i3 + 1;
                  else {
                    if (!(e4 < t3[i3][0]))
                      return true;
                    r2 = i3 - 1;
                  }
                return false;
              }(e3, s2) ? 0 : e3 >= 131072 && e3 <= 196605 || e3 >= 196608 && e3 <= 262141 ? 2 : 1;
            }
          };
        }, 5981: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.WriteBuffer = void 0;
          const s2 = i2(8460), r = i2(844);
          class n extends r.Disposable {
            constructor(e3) {
              super(), this._action = e3, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new s2.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
            }
            handleUserInput() {
              this._didUserInput = true;
            }
            writeSync(e3, t3) {
              if (void 0 !== t3 && this._syncCalls > t3)
                return void (this._syncCalls = 0);
              if (this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting)
                return;
              let i3;
              for (this._isSyncWriting = true; i3 = this._writeBuffer.shift(); ) {
                this._action(i3);
                const e4 = this._callbacks.shift();
                e4 && e4();
              }
              this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
            }
            write(e3, t3) {
              if (this._pendingData > 5e7)
                throw new Error("write data discarded, use flow control to avoid losing data");
              if (!this._writeBuffer.length) {
                if (this._bufferOffset = 0, this._didUserInput)
                  return this._didUserInput = false, this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3), void this._innerWrite();
                setTimeout(() => this._innerWrite());
              }
              this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3);
            }
            _innerWrite(e3 = 0, t3 = true) {
              const i3 = e3 || Date.now();
              for (; this._writeBuffer.length > this._bufferOffset; ) {
                const e4 = this._writeBuffer[this._bufferOffset], s3 = this._action(e4, t3);
                if (s3) {
                  const e5 = (e6) => Date.now() - i3 >= 12 ? setTimeout(() => this._innerWrite(0, e6)) : this._innerWrite(i3, e6);
                  return void s3.catch((e6) => (queueMicrotask(() => {
                    throw e6;
                  }), Promise.resolve(false))).then(e5);
                }
                const r2 = this._callbacks[this._bufferOffset];
                if (r2 && r2(), this._bufferOffset++, this._pendingData -= e4.length, Date.now() - i3 >= 12)
                  break;
              }
              this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
            }
          }
          t2.WriteBuffer = n;
        }, 5941: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.toRgbString = t2.parseColor = void 0;
          const i2 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s2 = /^[\da-f]+$/;
          function r(e3, t3) {
            const i3 = e3.toString(16), s3 = i3.length < 2 ? "0" + i3 : i3;
            switch (t3) {
              case 4:
                return i3[0];
              case 8:
                return s3;
              case 12:
                return (s3 + s3).slice(0, 3);
              default:
                return s3 + s3;
            }
          }
          t2.parseColor = function(e3) {
            if (!e3)
              return;
            let t3 = e3.toLowerCase();
            if (0 === t3.indexOf("rgb:")) {
              t3 = t3.slice(4);
              const e4 = i2.exec(t3);
              if (e4) {
                const t4 = e4[1] ? 15 : e4[4] ? 255 : e4[7] ? 4095 : 65535;
                return [Math.round(parseInt(e4[1] || e4[4] || e4[7] || e4[10], 16) / t4 * 255), Math.round(parseInt(e4[2] || e4[5] || e4[8] || e4[11], 16) / t4 * 255), Math.round(parseInt(e4[3] || e4[6] || e4[9] || e4[12], 16) / t4 * 255)];
              }
            } else if (0 === t3.indexOf("#") && (t3 = t3.slice(1), s2.exec(t3) && [3, 6, 9, 12].includes(t3.length))) {
              const e4 = t3.length / 3, i3 = [0, 0, 0];
              for (let s3 = 0; s3 < 3; ++s3) {
                const r2 = parseInt(t3.slice(e4 * s3, e4 * s3 + e4), 16);
                i3[s3] = 1 === e4 ? r2 << 4 : 2 === e4 ? r2 : 3 === e4 ? r2 >> 4 : r2 >> 8;
              }
              return i3;
            }
          }, t2.toRgbString = function(e3, t3 = 16) {
            const [i3, s3, n] = e3;
            return `rgb:${r(i3, t3)}/${r(s3, t3)}/${r(n, t3)}`;
          };
        }, 5770: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.PAYLOAD_LIMIT = void 0, t2.PAYLOAD_LIMIT = 1e7;
        }, 6351: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DcsHandler = t2.DcsParser = void 0;
          const s2 = i2(482), r = i2(8742), n = i2(5770), o = [];
          t2.DcsParser = class {
            constructor() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {
              }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
            }
            dispose() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._active = o;
            }
            registerHandler(e3, t3) {
              void 0 === this._handlers[e3] && (this._handlers[e3] = []);
              const i3 = this._handlers[e3];
              return i3.push(t3), { dispose: () => {
                const e4 = i3.indexOf(t3);
                -1 !== e4 && i3.splice(e4, 1);
              } };
            }
            clearHandler(e3) {
              this._handlers[e3] && delete this._handlers[e3];
            }
            setHandlerFallback(e3) {
              this._handlerFb = e3;
            }
            reset() {
              if (this._active.length)
                for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3)
                  this._active[e3].unhook(false);
              this._stack.paused = false, this._active = o, this._ident = 0;
            }
            hook(e3, t3) {
              if (this.reset(), this._ident = e3, this._active = this._handlers[e3] || o, this._active.length)
                for (let e4 = this._active.length - 1; e4 >= 0; e4--)
                  this._active[e4].hook(t3);
              else
                this._handlerFb(this._ident, "HOOK", t3);
            }
            put(e3, t3, i3) {
              if (this._active.length)
                for (let s3 = this._active.length - 1; s3 >= 0; s3--)
                  this._active[s3].put(e3, t3, i3);
              else
                this._handlerFb(this._ident, "PUT", (0, s2.utf32ToString)(e3, t3, i3));
            }
            unhook(e3, t3 = true) {
              if (this._active.length) {
                let i3 = false, s3 = this._active.length - 1, r2 = false;
                if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                  for (; s3 >= 0 && (i3 = this._active[s3].unhook(e3), true !== i3); s3--)
                    if (i3 instanceof Promise)
                      return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                  s3--;
                }
                for (; s3 >= 0; s3--)
                  if (i3 = this._active[s3].unhook(false), i3 instanceof Promise)
                    return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
              } else
                this._handlerFb(this._ident, "UNHOOK", e3);
              this._active = o, this._ident = 0;
            }
          };
          const a = new r.Params();
          a.addParam(0), t2.DcsHandler = class {
            constructor(e3) {
              this._handler = e3, this._data = "", this._params = a, this._hitLimit = false;
            }
            hook(e3) {
              this._params = e3.length > 1 || e3.params[0] ? e3.clone() : a, this._data = "", this._hitLimit = false;
            }
            put(e3, t3, i3) {
              this._hitLimit || (this._data += (0, s2.utf32ToString)(e3, t3, i3), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
            }
            unhook(e3) {
              let t3 = false;
              if (this._hitLimit)
                t3 = false;
              else if (e3 && (t3 = this._handler(this._data, this._params), t3 instanceof Promise))
                return t3.then((e4) => (this._params = a, this._data = "", this._hitLimit = false, e4));
              return this._params = a, this._data = "", this._hitLimit = false, t3;
            }
          };
        }, 2015: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.EscapeSequenceParser = t2.VT500_TRANSITION_TABLE = t2.TransitionTable = void 0;
          const s2 = i2(844), r = i2(8742), n = i2(6242), o = i2(6351);
          class a {
            constructor(e3) {
              this.table = new Uint8Array(e3);
            }
            setDefault(e3, t3) {
              this.table.fill(e3 << 4 | t3);
            }
            add(e3, t3, i3, s3) {
              this.table[t3 << 8 | e3] = i3 << 4 | s3;
            }
            addMany(e3, t3, i3, s3) {
              for (let r2 = 0; r2 < e3.length; r2++)
                this.table[t3 << 8 | e3[r2]] = i3 << 4 | s3;
            }
          }
          t2.TransitionTable = a;
          const h = 160;
          t2.VT500_TRANSITION_TABLE = function() {
            const e3 = new a(4095), t3 = Array.apply(null, Array(256)).map((e4, t4) => t4), i3 = (e4, i4) => t3.slice(e4, i4), s3 = i3(32, 127), r2 = i3(0, 24);
            r2.push(25), r2.push.apply(r2, i3(28, 32));
            const n2 = i3(0, 14);
            let o2;
            for (o2 in e3.setDefault(1, 0), e3.addMany(s3, 0, 2, 0), n2)
              e3.addMany([24, 26, 153, 154], o2, 3, 0), e3.addMany(i3(128, 144), o2, 3, 0), e3.addMany(i3(144, 152), o2, 3, 0), e3.add(156, o2, 0, 0), e3.add(27, o2, 11, 1), e3.add(157, o2, 4, 8), e3.addMany([152, 158, 159], o2, 0, 7), e3.add(155, o2, 11, 3), e3.add(144, o2, 11, 9);
            return e3.addMany(r2, 0, 3, 0), e3.addMany(r2, 1, 3, 1), e3.add(127, 1, 0, 1), e3.addMany(r2, 8, 0, 8), e3.addMany(r2, 3, 3, 3), e3.add(127, 3, 0, 3), e3.addMany(r2, 4, 3, 4), e3.add(127, 4, 0, 4), e3.addMany(r2, 6, 3, 6), e3.addMany(r2, 5, 3, 5), e3.add(127, 5, 0, 5), e3.addMany(r2, 2, 3, 2), e3.add(127, 2, 0, 2), e3.add(93, 1, 4, 8), e3.addMany(s3, 8, 5, 8), e3.add(127, 8, 5, 8), e3.addMany([156, 27, 24, 26, 7], 8, 6, 0), e3.addMany(i3(28, 32), 8, 0, 8), e3.addMany([88, 94, 95], 1, 0, 7), e3.addMany(s3, 7, 0, 7), e3.addMany(r2, 7, 0, 7), e3.add(156, 7, 0, 0), e3.add(127, 7, 0, 7), e3.add(91, 1, 11, 3), e3.addMany(i3(64, 127), 3, 7, 0), e3.addMany(i3(48, 60), 3, 8, 4), e3.addMany([60, 61, 62, 63], 3, 9, 4), e3.addMany(i3(48, 60), 4, 8, 4), e3.addMany(i3(64, 127), 4, 7, 0), e3.addMany([60, 61, 62, 63], 4, 0, 6), e3.addMany(i3(32, 64), 6, 0, 6), e3.add(127, 6, 0, 6), e3.addMany(i3(64, 127), 6, 0, 0), e3.addMany(i3(32, 48), 3, 9, 5), e3.addMany(i3(32, 48), 5, 9, 5), e3.addMany(i3(48, 64), 5, 0, 6), e3.addMany(i3(64, 127), 5, 7, 0), e3.addMany(i3(32, 48), 4, 9, 5), e3.addMany(i3(32, 48), 1, 9, 2), e3.addMany(i3(32, 48), 2, 9, 2), e3.addMany(i3(48, 127), 2, 10, 0), e3.addMany(i3(48, 80), 1, 10, 0), e3.addMany(i3(81, 88), 1, 10, 0), e3.addMany([89, 90, 92], 1, 10, 0), e3.addMany(i3(96, 127), 1, 10, 0), e3.add(80, 1, 11, 9), e3.addMany(r2, 9, 0, 9), e3.add(127, 9, 0, 9), e3.addMany(i3(28, 32), 9, 0, 9), e3.addMany(i3(32, 48), 9, 9, 12), e3.addMany(i3(48, 60), 9, 8, 10), e3.addMany([60, 61, 62, 63], 9, 9, 10), e3.addMany(r2, 11, 0, 11), e3.addMany(i3(32, 128), 11, 0, 11), e3.addMany(i3(28, 32), 11, 0, 11), e3.addMany(r2, 10, 0, 10), e3.add(127, 10, 0, 10), e3.addMany(i3(28, 32), 10, 0, 10), e3.addMany(i3(48, 60), 10, 8, 10), e3.addMany([60, 61, 62, 63], 10, 0, 11), e3.addMany(i3(32, 48), 10, 9, 12), e3.addMany(r2, 12, 0, 12), e3.add(127, 12, 0, 12), e3.addMany(i3(28, 32), 12, 0, 12), e3.addMany(i3(32, 48), 12, 9, 12), e3.addMany(i3(48, 64), 12, 0, 11), e3.addMany(i3(64, 127), 12, 12, 13), e3.addMany(i3(64, 127), 10, 12, 13), e3.addMany(i3(64, 127), 9, 12, 13), e3.addMany(r2, 13, 13, 13), e3.addMany(s3, 13, 13, 13), e3.add(127, 13, 0, 13), e3.addMany([27, 156, 24, 26], 13, 14, 0), e3.add(h, 0, 2, 0), e3.add(h, 8, 5, 8), e3.add(h, 6, 0, 6), e3.add(h, 11, 0, 11), e3.add(h, 13, 13, 13), e3;
          }();
          class c extends s2.Disposable {
            constructor(e3 = t2.VT500_TRANSITION_TABLE) {
              super(), this._transitions = e3, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (e4, t3, i3) => {
              }, this._executeHandlerFb = (e4) => {
              }, this._csiHandlerFb = (e4, t3) => {
              }, this._escHandlerFb = (e4) => {
              }, this._errorHandlerFb = (e4) => e4, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, s2.toDisposable)(() => {
                this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
              })), this._oscParser = this.register(new n.OscParser()), this._dcsParser = this.register(new o.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => true);
            }
            _identifier(e3, t3 = [64, 126]) {
              let i3 = 0;
              if (e3.prefix) {
                if (e3.prefix.length > 1)
                  throw new Error("only one byte as prefix supported");
                if (i3 = e3.prefix.charCodeAt(0), i3 && 60 > i3 || i3 > 63)
                  throw new Error("prefix must be in range 0x3c .. 0x3f");
              }
              if (e3.intermediates) {
                if (e3.intermediates.length > 2)
                  throw new Error("only two bytes as intermediates are supported");
                for (let t4 = 0; t4 < e3.intermediates.length; ++t4) {
                  const s4 = e3.intermediates.charCodeAt(t4);
                  if (32 > s4 || s4 > 47)
                    throw new Error("intermediate must be in range 0x20 .. 0x2f");
                  i3 <<= 8, i3 |= s4;
                }
              }
              if (1 !== e3.final.length)
                throw new Error("final must be a single byte");
              const s3 = e3.final.charCodeAt(0);
              if (t3[0] > s3 || s3 > t3[1])
                throw new Error(`final must be in range ${t3[0]} .. ${t3[1]}`);
              return i3 <<= 8, i3 |= s3, i3;
            }
            identToString(e3) {
              const t3 = [];
              for (; e3; )
                t3.push(String.fromCharCode(255 & e3)), e3 >>= 8;
              return t3.reverse().join("");
            }
            setPrintHandler(e3) {
              this._printHandler = e3;
            }
            clearPrintHandler() {
              this._printHandler = this._printHandlerFb;
            }
            registerEscHandler(e3, t3) {
              const i3 = this._identifier(e3, [48, 126]);
              void 0 === this._escHandlers[i3] && (this._escHandlers[i3] = []);
              const s3 = this._escHandlers[i3];
              return s3.push(t3), { dispose: () => {
                const e4 = s3.indexOf(t3);
                -1 !== e4 && s3.splice(e4, 1);
              } };
            }
            clearEscHandler(e3) {
              this._escHandlers[this._identifier(e3, [48, 126])] && delete this._escHandlers[this._identifier(e3, [48, 126])];
            }
            setEscHandlerFallback(e3) {
              this._escHandlerFb = e3;
            }
            setExecuteHandler(e3, t3) {
              this._executeHandlers[e3.charCodeAt(0)] = t3;
            }
            clearExecuteHandler(e3) {
              this._executeHandlers[e3.charCodeAt(0)] && delete this._executeHandlers[e3.charCodeAt(0)];
            }
            setExecuteHandlerFallback(e3) {
              this._executeHandlerFb = e3;
            }
            registerCsiHandler(e3, t3) {
              const i3 = this._identifier(e3);
              void 0 === this._csiHandlers[i3] && (this._csiHandlers[i3] = []);
              const s3 = this._csiHandlers[i3];
              return s3.push(t3), { dispose: () => {
                const e4 = s3.indexOf(t3);
                -1 !== e4 && s3.splice(e4, 1);
              } };
            }
            clearCsiHandler(e3) {
              this._csiHandlers[this._identifier(e3)] && delete this._csiHandlers[this._identifier(e3)];
            }
            setCsiHandlerFallback(e3) {
              this._csiHandlerFb = e3;
            }
            registerDcsHandler(e3, t3) {
              return this._dcsParser.registerHandler(this._identifier(e3), t3);
            }
            clearDcsHandler(e3) {
              this._dcsParser.clearHandler(this._identifier(e3));
            }
            setDcsHandlerFallback(e3) {
              this._dcsParser.setHandlerFallback(e3);
            }
            registerOscHandler(e3, t3) {
              return this._oscParser.registerHandler(e3, t3);
            }
            clearOscHandler(e3) {
              this._oscParser.clearHandler(e3);
            }
            setOscHandlerFallback(e3) {
              this._oscParser.setHandlerFallback(e3);
            }
            setErrorHandler(e3) {
              this._errorHandler = e3;
            }
            clearErrorHandler() {
              this._errorHandler = this._errorHandlerFb;
            }
            reset() {
              this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);
            }
            _preserveStack(e3, t3, i3, s3, r2) {
              this._parseStack.state = e3, this._parseStack.handlers = t3, this._parseStack.handlerPos = i3, this._parseStack.transition = s3, this._parseStack.chunkPos = r2;
            }
            parse(e3, t3, i3) {
              let s3, r2 = 0, n2 = 0, o2 = 0;
              if (this._parseStack.state)
                if (2 === this._parseStack.state)
                  this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1;
                else {
                  if (void 0 === i3 || 1 === this._parseStack.state)
                    throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
                  const t4 = this._parseStack.handlers;
                  let n3 = this._parseStack.handlerPos - 1;
                  switch (this._parseStack.state) {
                    case 3:
                      if (false === i3 && n3 > -1) {
                        for (; n3 >= 0 && (s3 = t4[n3](this._params), true !== s3); n3--)
                          if (s3 instanceof Promise)
                            return this._parseStack.handlerPos = n3, s3;
                      }
                      this._parseStack.handlers = [];
                      break;
                    case 4:
                      if (false === i3 && n3 > -1) {
                        for (; n3 >= 0 && (s3 = t4[n3](), true !== s3); n3--)
                          if (s3 instanceof Promise)
                            return this._parseStack.handlerPos = n3, s3;
                      }
                      this._parseStack.handlers = [];
                      break;
                    case 6:
                      if (r2 = e3[this._parseStack.chunkPos], s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2, i3), s3)
                        return s3;
                      27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                      break;
                    case 5:
                      if (r2 = e3[this._parseStack.chunkPos], s3 = this._oscParser.end(24 !== r2 && 26 !== r2, i3), s3)
                        return s3;
                      27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  }
                  this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
                }
              for (let i4 = o2; i4 < t3; ++i4) {
                switch (r2 = e3[i4], n2 = this._transitions.table[this.currentState << 8 | (r2 < 160 ? r2 : h)], n2 >> 4) {
                  case 2:
                    for (let s4 = i4 + 1; ; ++s4) {
                      if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                    }
                    break;
                  case 3:
                    this._executeHandlers[r2] ? this._executeHandlers[r2]() : this._executeHandlerFb(r2), this.precedingCodepoint = 0;
                    break;
                  case 0:
                    break;
                  case 1:
                    if (this._errorHandler({ position: i4, code: r2, currentState: this.currentState, collect: this._collect, params: this._params, abort: false }).abort)
                      return;
                    break;
                  case 7:
                    const o3 = this._csiHandlers[this._collect << 8 | r2];
                    let a2 = o3 ? o3.length - 1 : -1;
                    for (; a2 >= 0 && (s3 = o3[a2](this._params), true !== s3); a2--)
                      if (s3 instanceof Promise)
                        return this._preserveStack(3, o3, a2, n2, i4), s3;
                    a2 < 0 && this._csiHandlerFb(this._collect << 8 | r2, this._params), this.precedingCodepoint = 0;
                    break;
                  case 8:
                    do {
                      switch (r2) {
                        case 59:
                          this._params.addParam(0);
                          break;
                        case 58:
                          this._params.addSubParam(-1);
                          break;
                        default:
                          this._params.addDigit(r2 - 48);
                      }
                    } while (++i4 < t3 && (r2 = e3[i4]) > 47 && r2 < 60);
                    i4--;
                    break;
                  case 9:
                    this._collect <<= 8, this._collect |= r2;
                    break;
                  case 10:
                    const c2 = this._escHandlers[this._collect << 8 | r2];
                    let l = c2 ? c2.length - 1 : -1;
                    for (; l >= 0 && (s3 = c2[l](), true !== s3); l--)
                      if (s3 instanceof Promise)
                        return this._preserveStack(4, c2, l, n2, i4), s3;
                    l < 0 && this._escHandlerFb(this._collect << 8 | r2), this.precedingCodepoint = 0;
                    break;
                  case 11:
                    this._params.reset(), this._params.addParam(0), this._collect = 0;
                    break;
                  case 12:
                    this._dcsParser.hook(this._collect << 8 | r2, this._params);
                    break;
                  case 13:
                    for (let s4 = i4 + 1; ; ++s4)
                      if (s4 >= t3 || 24 === (r2 = e3[s4]) || 26 === r2 || 27 === r2 || r2 > 127 && r2 < h) {
                        this._dcsParser.put(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                    break;
                  case 14:
                    if (s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2), s3)
                      return this._preserveStack(6, [], 0, n2, i4), s3;
                    27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                    break;
                  case 4:
                    this._oscParser.start();
                    break;
                  case 5:
                    for (let s4 = i4 + 1; ; s4++)
                      if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 127 && r2 < h) {
                        this._oscParser.put(e3, i4, s4), i4 = s4 - 1;
                        break;
                      }
                    break;
                  case 6:
                    if (s3 = this._oscParser.end(24 !== r2 && 26 !== r2), s3)
                      return this._preserveStack(5, [], 0, n2, i4), s3;
                    27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                }
                this.currentState = 15 & n2;
              }
            }
          }
          t2.EscapeSequenceParser = c;
        }, 6242: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OscHandler = t2.OscParser = void 0;
          const s2 = i2(5770), r = i2(482), n = [];
          t2.OscParser = class {
            constructor() {
              this._state = 0, this._active = n, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
            }
            registerHandler(e3, t3) {
              void 0 === this._handlers[e3] && (this._handlers[e3] = []);
              const i3 = this._handlers[e3];
              return i3.push(t3), { dispose: () => {
                const e4 = i3.indexOf(t3);
                -1 !== e4 && i3.splice(e4, 1);
              } };
            }
            clearHandler(e3) {
              this._handlers[e3] && delete this._handlers[e3];
            }
            setHandlerFallback(e3) {
              this._handlerFb = e3;
            }
            dispose() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._active = n;
            }
            reset() {
              if (2 === this._state)
                for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3)
                  this._active[e3].end(false);
              this._stack.paused = false, this._active = n, this._id = -1, this._state = 0;
            }
            _start() {
              if (this._active = this._handlers[this._id] || n, this._active.length)
                for (let e3 = this._active.length - 1; e3 >= 0; e3--)
                  this._active[e3].start();
              else
                this._handlerFb(this._id, "START");
            }
            _put(e3, t3, i3) {
              if (this._active.length)
                for (let s3 = this._active.length - 1; s3 >= 0; s3--)
                  this._active[s3].put(e3, t3, i3);
              else
                this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e3, t3, i3));
            }
            start() {
              this.reset(), this._state = 1;
            }
            put(e3, t3, i3) {
              if (3 !== this._state) {
                if (1 === this._state)
                  for (; t3 < i3; ) {
                    const i4 = e3[t3++];
                    if (59 === i4) {
                      this._state = 2, this._start();
                      break;
                    }
                    if (i4 < 48 || 57 < i4)
                      return void (this._state = 3);
                    -1 === this._id && (this._id = 0), this._id = 10 * this._id + i4 - 48;
                  }
                2 === this._state && i3 - t3 > 0 && this._put(e3, t3, i3);
              }
            }
            end(e3, t3 = true) {
              if (0 !== this._state) {
                if (3 !== this._state)
                  if (1 === this._state && this._start(), this._active.length) {
                    let i3 = false, s3 = this._active.length - 1, r2 = false;
                    if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                      for (; s3 >= 0 && (i3 = this._active[s3].end(e3), true !== i3); s3--)
                        if (i3 instanceof Promise)
                          return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                      s3--;
                    }
                    for (; s3 >= 0; s3--)
                      if (i3 = this._active[s3].end(false), i3 instanceof Promise)
                        return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
                  } else
                    this._handlerFb(this._id, "END", e3);
                this._active = n, this._id = -1, this._state = 0;
              }
            }
          }, t2.OscHandler = class {
            constructor(e3) {
              this._handler = e3, this._data = "", this._hitLimit = false;
            }
            start() {
              this._data = "", this._hitLimit = false;
            }
            put(e3, t3, i3) {
              this._hitLimit || (this._data += (0, r.utf32ToString)(e3, t3, i3), this._data.length > s2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
            }
            end(e3) {
              let t3 = false;
              if (this._hitLimit)
                t3 = false;
              else if (e3 && (t3 = this._handler(this._data), t3 instanceof Promise))
                return t3.then((e4) => (this._data = "", this._hitLimit = false, e4));
              return this._data = "", this._hitLimit = false, t3;
            }
          };
        }, 8742: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Params = void 0;
          const i2 = 2147483647;
          class s2 {
            static fromArray(e3) {
              const t3 = new s2();
              if (!e3.length)
                return t3;
              for (let i3 = Array.isArray(e3[0]) ? 1 : 0; i3 < e3.length; ++i3) {
                const s3 = e3[i3];
                if (Array.isArray(s3))
                  for (let e4 = 0; e4 < s3.length; ++e4)
                    t3.addSubParam(s3[e4]);
                else
                  t3.addParam(s3);
              }
              return t3;
            }
            constructor(e3 = 32, t3 = 32) {
              if (this.maxLength = e3, this.maxSubParamsLength = t3, t3 > 256)
                throw new Error("maxSubParamsLength must not be greater than 256");
              this.params = new Int32Array(e3), this.length = 0, this._subParams = new Int32Array(t3), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e3), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
            }
            clone() {
              const e3 = new s2(this.maxLength, this.maxSubParamsLength);
              return e3.params.set(this.params), e3.length = this.length, e3._subParams.set(this._subParams), e3._subParamsLength = this._subParamsLength, e3._subParamsIdx.set(this._subParamsIdx), e3._rejectDigits = this._rejectDigits, e3._rejectSubDigits = this._rejectSubDigits, e3._digitIsSub = this._digitIsSub, e3;
            }
            toArray() {
              const e3 = [];
              for (let t3 = 0; t3 < this.length; ++t3) {
                e3.push(this.params[t3]);
                const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
                s3 - i3 > 0 && e3.push(Array.prototype.slice.call(this._subParams, i3, s3));
              }
              return e3;
            }
            reset() {
              this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
            }
            addParam(e3) {
              if (this._digitIsSub = false, this.length >= this.maxLength)
                this._rejectDigits = true;
              else {
                if (e3 < -1)
                  throw new Error("values lesser than -1 are not allowed");
                this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e3 > i2 ? i2 : e3;
              }
            }
            addSubParam(e3) {
              if (this._digitIsSub = true, this.length)
                if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength)
                  this._rejectSubDigits = true;
                else {
                  if (e3 < -1)
                    throw new Error("values lesser than -1 are not allowed");
                  this._subParams[this._subParamsLength++] = e3 > i2 ? i2 : e3, this._subParamsIdx[this.length - 1]++;
                }
            }
            hasSubParams(e3) {
              return (255 & this._subParamsIdx[e3]) - (this._subParamsIdx[e3] >> 8) > 0;
            }
            getSubParams(e3) {
              const t3 = this._subParamsIdx[e3] >> 8, i3 = 255 & this._subParamsIdx[e3];
              return i3 - t3 > 0 ? this._subParams.subarray(t3, i3) : null;
            }
            getSubParamsAll() {
              const e3 = {};
              for (let t3 = 0; t3 < this.length; ++t3) {
                const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
                s3 - i3 > 0 && (e3[t3] = this._subParams.slice(i3, s3));
              }
              return e3;
            }
            addDigit(e3) {
              let t3;
              if (this._rejectDigits || !(t3 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits)
                return;
              const s3 = this._digitIsSub ? this._subParams : this.params, r = s3[t3 - 1];
              s3[t3 - 1] = ~r ? Math.min(10 * r + e3, i2) : e3;
            }
          }
          t2.Params = s2;
        }, 5741: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.AddonManager = void 0, t2.AddonManager = class {
            constructor() {
              this._addons = [];
            }
            dispose() {
              for (let e3 = this._addons.length - 1; e3 >= 0; e3--)
                this._addons[e3].instance.dispose();
            }
            loadAddon(e3, t3) {
              const i2 = { instance: t3, dispose: t3.dispose, isDisposed: false };
              this._addons.push(i2), t3.dispose = () => this._wrappedAddonDispose(i2), t3.activate(e3);
            }
            _wrappedAddonDispose(e3) {
              if (e3.isDisposed)
                return;
              let t3 = -1;
              for (let i2 = 0; i2 < this._addons.length; i2++)
                if (this._addons[i2] === e3) {
                  t3 = i2;
                  break;
                }
              if (-1 === t3)
                throw new Error("Could not dispose an addon that has not been loaded");
              e3.isDisposed = true, e3.dispose.apply(e3.instance), this._addons.splice(t3, 1);
            }
          };
        }, 8771: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferApiView = void 0;
          const s2 = i2(3785), r = i2(511);
          t2.BufferApiView = class {
            constructor(e3, t3) {
              this._buffer = e3, this.type = t3;
            }
            init(e3) {
              return this._buffer = e3, this;
            }
            get cursorY() {
              return this._buffer.y;
            }
            get cursorX() {
              return this._buffer.x;
            }
            get viewportY() {
              return this._buffer.ydisp;
            }
            get baseY() {
              return this._buffer.ybase;
            }
            get length() {
              return this._buffer.lines.length;
            }
            getLine(e3) {
              const t3 = this._buffer.lines.get(e3);
              if (t3)
                return new s2.BufferLineApiView(t3);
            }
            getNullCell() {
              return new r.CellData();
            }
          };
        }, 3785: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLineApiView = void 0;
          const s2 = i2(511);
          t2.BufferLineApiView = class {
            constructor(e3) {
              this._line = e3;
            }
            get isWrapped() {
              return this._line.isWrapped;
            }
            get length() {
              return this._line.length;
            }
            getCell(e3, t3) {
              if (!(e3 < 0 || e3 >= this._line.length))
                return t3 ? (this._line.loadCell(e3, t3), t3) : this._line.loadCell(e3, new s2.CellData());
            }
            translateToString(e3, t3, i3) {
              return this._line.translateToString(e3, t3, i3);
            }
          };
        }, 8285: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferNamespaceApi = void 0;
          const s2 = i2(8771), r = i2(8460), n = i2(844);
          class o extends n.Disposable {
            constructor(e3) {
              super(), this._core = e3, this._onBufferChange = this.register(new r.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new s2.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s2.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
            }
            get active() {
              if (this._core.buffers.active === this._core.buffers.normal)
                return this.normal;
              if (this._core.buffers.active === this._core.buffers.alt)
                return this.alternate;
              throw new Error("Active buffer is neither normal nor alternate");
            }
            get normal() {
              return this._normal.init(this._core.buffers.normal);
            }
            get alternate() {
              return this._alternate.init(this._core.buffers.alt);
            }
          }
          t2.BufferNamespaceApi = o;
        }, 7975: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ParserApi = void 0, t2.ParserApi = class {
            constructor(e3) {
              this._core = e3;
            }
            registerCsiHandler(e3, t3) {
              return this._core.registerCsiHandler(e3, (e4) => t3(e4.toArray()));
            }
            addCsiHandler(e3, t3) {
              return this.registerCsiHandler(e3, t3);
            }
            registerDcsHandler(e3, t3) {
              return this._core.registerDcsHandler(e3, (e4, i2) => t3(e4, i2.toArray()));
            }
            addDcsHandler(e3, t3) {
              return this.registerDcsHandler(e3, t3);
            }
            registerEscHandler(e3, t3) {
              return this._core.registerEscHandler(e3, t3);
            }
            addEscHandler(e3, t3) {
              return this.registerEscHandler(e3, t3);
            }
            registerOscHandler(e3, t3) {
              return this._core.registerOscHandler(e3, t3);
            }
            addOscHandler(e3, t3) {
              return this.registerOscHandler(e3, t3);
            }
          };
        }, 7090: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeApi = void 0, t2.UnicodeApi = class {
            constructor(e3) {
              this._core = e3;
            }
            register(e3) {
              this._core.unicodeService.register(e3);
            }
            get versions() {
              return this._core.unicodeService.versions;
            }
            get activeVersion() {
              return this._core.unicodeService.activeVersion;
            }
            set activeVersion(e3) {
              this._core.unicodeService.activeVersion = e3;
            }
          };
        }, 744: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferService = t2.MINIMUM_ROWS = t2.MINIMUM_COLS = void 0;
          const n = i2(8460), o = i2(844), a = i2(5295), h = i2(2585);
          t2.MINIMUM_COLS = 2, t2.MINIMUM_ROWS = 1;
          let c = t2.BufferService = class extends o.Disposable {
            get buffer() {
              return this.buffers.active;
            }
            constructor(e3) {
              super(), this.isUserScrolling = false, this._onResize = this.register(new n.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e3.rawOptions.cols || 0, t2.MINIMUM_COLS), this.rows = Math.max(e3.rawOptions.rows || 0, t2.MINIMUM_ROWS), this.buffers = this.register(new a.BufferSet(e3, this));
            }
            resize(e3, t3) {
              this.cols = e3, this.rows = t3, this.buffers.resize(e3, t3), this._onResize.fire({ cols: e3, rows: t3 });
            }
            reset() {
              this.buffers.reset(), this.isUserScrolling = false;
            }
            scroll(e3, t3 = false) {
              const i3 = this.buffer;
              let s3;
              s3 = this._cachedBlankLine, s3 && s3.length === this.cols && s3.getFg(0) === e3.fg && s3.getBg(0) === e3.bg || (s3 = i3.getBlankLine(e3, t3), this._cachedBlankLine = s3), s3.isWrapped = t3;
              const r2 = i3.ybase + i3.scrollTop, n2 = i3.ybase + i3.scrollBottom;
              if (0 === i3.scrollTop) {
                const e4 = i3.lines.isFull;
                n2 === i3.lines.length - 1 ? e4 ? i3.lines.recycle().copyFrom(s3) : i3.lines.push(s3.clone()) : i3.lines.splice(n2 + 1, 0, s3.clone()), e4 ? this.isUserScrolling && (i3.ydisp = Math.max(i3.ydisp - 1, 0)) : (i3.ybase++, this.isUserScrolling || i3.ydisp++);
              } else {
                const e4 = n2 - r2 + 1;
                i3.lines.shiftElements(r2 + 1, e4 - 1, -1), i3.lines.set(n2, s3.clone());
              }
              this.isUserScrolling || (i3.ydisp = i3.ybase), this._onScroll.fire(i3.ydisp);
            }
            scrollLines(e3, t3, i3) {
              const s3 = this.buffer;
              if (e3 < 0) {
                if (0 === s3.ydisp)
                  return;
                this.isUserScrolling = true;
              } else
                e3 + s3.ydisp >= s3.ybase && (this.isUserScrolling = false);
              const r2 = s3.ydisp;
              s3.ydisp = Math.max(Math.min(s3.ydisp + e3, s3.ybase), 0), r2 !== s3.ydisp && (t3 || this._onScroll.fire(s3.ydisp));
            }
          };
          t2.BufferService = c = s2([r(0, h.IOptionsService)], c);
        }, 7994: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CharsetService = void 0, t2.CharsetService = class {
            constructor() {
              this.glevel = 0, this._charsets = [];
            }
            reset() {
              this.charset = void 0, this._charsets = [], this.glevel = 0;
            }
            setgLevel(e3) {
              this.glevel = e3, this.charset = this._charsets[e3];
            }
            setgCharset(e3, t3) {
              this._charsets[e3] = t3, this.glevel === e3 && (this.charset = t3);
            }
          };
        }, 1753: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreMouseService = void 0;
          const n = i2(2585), o = i2(8460), a = i2(844), h = { NONE: { events: 0, restrict: () => false }, X10: { events: 1, restrict: (e3) => 4 !== e3.button && 1 === e3.action && (e3.ctrl = false, e3.alt = false, e3.shift = false, true) }, VT200: { events: 19, restrict: (e3) => 32 !== e3.action }, DRAG: { events: 23, restrict: (e3) => 32 !== e3.action || 3 !== e3.button }, ANY: { events: 31, restrict: (e3) => true } };
          function c(e3, t3) {
            let i3 = (e3.ctrl ? 16 : 0) | (e3.shift ? 4 : 0) | (e3.alt ? 8 : 0);
            return 4 === e3.button ? (i3 |= 64, i3 |= e3.action) : (i3 |= 3 & e3.button, 4 & e3.button && (i3 |= 64), 8 & e3.button && (i3 |= 128), 32 === e3.action ? i3 |= 32 : 0 !== e3.action || t3 || (i3 |= 3)), i3;
          }
          const l = String.fromCharCode, d = { DEFAULT: (e3) => {
            const t3 = [c(e3, false) + 32, e3.col + 32, e3.row + 32];
            return t3[0] > 255 || t3[1] > 255 || t3[2] > 255 ? "" : `\x1B[M${l(t3[0])}${l(t3[1])}${l(t3[2])}`;
          }, SGR: (e3) => {
            const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
            return `\x1B[<${c(e3, true)};${e3.col};${e3.row}${t3}`;
          }, SGR_PIXELS: (e3) => {
            const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
            return `\x1B[<${c(e3, true)};${e3.x};${e3.y}${t3}`;
          } };
          let _ = t2.CoreMouseService = class extends a.Disposable {
            constructor(e3, t3) {
              super(), this._bufferService = e3, this._coreService = t3, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
              for (const e4 of Object.keys(h))
                this.addProtocol(e4, h[e4]);
              for (const e4 of Object.keys(d))
                this.addEncoding(e4, d[e4]);
              this.reset();
            }
            addProtocol(e3, t3) {
              this._protocols[e3] = t3;
            }
            addEncoding(e3, t3) {
              this._encodings[e3] = t3;
            }
            get activeProtocol() {
              return this._activeProtocol;
            }
            get areMouseEventsActive() {
              return 0 !== this._protocols[this._activeProtocol].events;
            }
            set activeProtocol(e3) {
              if (!this._protocols[e3])
                throw new Error(`unknown protocol "${e3}"`);
              this._activeProtocol = e3, this._onProtocolChange.fire(this._protocols[e3].events);
            }
            get activeEncoding() {
              return this._activeEncoding;
            }
            set activeEncoding(e3) {
              if (!this._encodings[e3])
                throw new Error(`unknown encoding "${e3}"`);
              this._activeEncoding = e3;
            }
            reset() {
              this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
            }
            triggerMouseEvent(e3) {
              if (e3.col < 0 || e3.col >= this._bufferService.cols || e3.row < 0 || e3.row >= this._bufferService.rows)
                return false;
              if (4 === e3.button && 32 === e3.action)
                return false;
              if (3 === e3.button && 32 !== e3.action)
                return false;
              if (4 !== e3.button && (2 === e3.action || 3 === e3.action))
                return false;
              if (e3.col++, e3.row++, 32 === e3.action && this._lastEvent && this._equalEvents(this._lastEvent, e3, "SGR_PIXELS" === this._activeEncoding))
                return false;
              if (!this._protocols[this._activeProtocol].restrict(e3))
                return false;
              const t3 = this._encodings[this._activeEncoding](e3);
              return t3 && ("DEFAULT" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t3) : this._coreService.triggerDataEvent(t3, true)), this._lastEvent = e3, true;
            }
            explainEvents(e3) {
              return { down: !!(1 & e3), up: !!(2 & e3), drag: !!(4 & e3), move: !!(8 & e3), wheel: !!(16 & e3) };
            }
            _equalEvents(e3, t3, i3) {
              if (i3) {
                if (e3.x !== t3.x)
                  return false;
                if (e3.y !== t3.y)
                  return false;
              } else {
                if (e3.col !== t3.col)
                  return false;
                if (e3.row !== t3.row)
                  return false;
              }
              return e3.button === t3.button && e3.action === t3.action && e3.ctrl === t3.ctrl && e3.alt === t3.alt && e3.shift === t3.shift;
            }
          };
          t2.CoreMouseService = _ = s2([r(0, n.IBufferService), r(1, n.ICoreService)], _);
        }, 6975: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreService = void 0;
          const n = i2(1439), o = i2(8460), a = i2(844), h = i2(2585), c = Object.freeze({ insertMode: false }), l = Object.freeze({ applicationCursorKeys: false, applicationKeypad: false, bracketedPasteMode: false, origin: false, reverseWraparound: false, sendFocus: false, wraparound: true });
          let d = t2.CoreService = class extends a.Disposable {
            constructor(e3, t3, i3) {
              super(), this._bufferService = e3, this._logService = t3, this._optionsService = i3, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new o.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
            }
            reset() {
              this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
            }
            triggerDataEvent(e3, t3 = false) {
              if (this._optionsService.rawOptions.disableStdin)
                return;
              const i3 = this._bufferService.buffer;
              t3 && this._optionsService.rawOptions.scrollOnUserInput && i3.ybase !== i3.ydisp && this._onRequestScrollToBottom.fire(), t3 && this._onUserInput.fire(), this._logService.debug(`sending data "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onData.fire(e3);
            }
            triggerBinaryEvent(e3) {
              this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onBinary.fire(e3));
            }
          };
          t2.CoreService = d = s2([r(0, h.IBufferService), r(1, h.ILogService), r(2, h.IOptionsService)], d);
        }, 9074: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.DecorationService = void 0;
          const s2 = i2(8055), r = i2(8460), n = i2(844), o = i2(6106);
          let a = 0, h = 0;
          class c extends n.Disposable {
            get decorations() {
              return this._decorations.values();
            }
            constructor() {
              super(), this._decorations = new o.SortedList((e3) => null == e3 ? void 0 : e3.marker.line), this._onDecorationRegistered = this.register(new r.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)(() => this.reset()));
            }
            registerDecoration(e3) {
              if (e3.marker.isDisposed)
                return;
              const t3 = new l(e3);
              if (t3) {
                const e4 = t3.marker.onDispose(() => t3.dispose());
                t3.onDispose(() => {
                  t3 && (this._decorations.delete(t3) && this._onDecorationRemoved.fire(t3), e4.dispose());
                }), this._decorations.insert(t3), this._onDecorationRegistered.fire(t3);
              }
              return t3;
            }
            reset() {
              for (const e3 of this._decorations.values())
                e3.dispose();
              this._decorations.clear();
            }
            *getDecorationsAtCell(e3, t3, i3) {
              var s3, r2, n2;
              let o2 = 0, a2 = 0;
              for (const h2 of this._decorations.getKeyIterator(t3))
                o2 = null !== (s3 = h2.options.x) && void 0 !== s3 ? s3 : 0, a2 = o2 + (null !== (r2 = h2.options.width) && void 0 !== r2 ? r2 : 1), e3 >= o2 && e3 < a2 && (!i3 || (null !== (n2 = h2.options.layer) && void 0 !== n2 ? n2 : "bottom") === i3) && (yield h2);
            }
            forEachDecorationAtCell(e3, t3, i3, s3) {
              this._decorations.forEachByKey(t3, (t4) => {
                var r2, n2, o2;
                a = null !== (r2 = t4.options.x) && void 0 !== r2 ? r2 : 0, h = a + (null !== (n2 = t4.options.width) && void 0 !== n2 ? n2 : 1), e3 >= a && e3 < h && (!i3 || (null !== (o2 = t4.options.layer) && void 0 !== o2 ? o2 : "bottom") === i3) && s3(t4);
              });
            }
          }
          t2.DecorationService = c;
          class l extends n.Disposable {
            get isDisposed() {
              return this._isDisposed;
            }
            get backgroundColorRGB() {
              return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s2.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
            }
            get foregroundColorRGB() {
              return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s2.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
            }
            constructor(e3) {
              super(), this.options = e3, this.onRenderEmitter = this.register(new r.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e3.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
            }
            dispose() {
              this._onDispose.fire(), super.dispose();
            }
          }
        }, 4348: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.InstantiationService = t2.ServiceCollection = void 0;
          const s2 = i2(2585), r = i2(8343);
          class n {
            constructor(...e3) {
              this._entries = /* @__PURE__ */ new Map();
              for (const [t3, i3] of e3)
                this.set(t3, i3);
            }
            set(e3, t3) {
              const i3 = this._entries.get(e3);
              return this._entries.set(e3, t3), i3;
            }
            forEach(e3) {
              for (const [t3, i3] of this._entries.entries())
                e3(t3, i3);
            }
            has(e3) {
              return this._entries.has(e3);
            }
            get(e3) {
              return this._entries.get(e3);
            }
          }
          t2.ServiceCollection = n, t2.InstantiationService = class {
            constructor() {
              this._services = new n(), this._services.set(s2.IInstantiationService, this);
            }
            setService(e3, t3) {
              this._services.set(e3, t3);
            }
            getService(e3) {
              return this._services.get(e3);
            }
            createInstance(e3, ...t3) {
              const i3 = (0, r.getServiceDependencies)(e3).sort((e4, t4) => e4.index - t4.index), s3 = [];
              for (const t4 of i3) {
                const i4 = this._services.get(t4.id);
                if (!i4)
                  throw new Error(`[createInstance] ${e3.name} depends on UNKNOWN service ${t4.id}.`);
                s3.push(i4);
              }
              const n2 = i3.length > 0 ? i3[0].index : t3.length;
              if (t3.length !== n2)
                throw new Error(`[createInstance] First service dependency of ${e3.name} at position ${n2 + 1} conflicts with ${t3.length} static arguments`);
              return new e3(...[...t3, ...s3]);
            }
          };
        }, 7866: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a2 = e3.length - 1; a2 >= 0; a2--)
                (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.traceCall = t2.setTraceLogger = t2.LogService = void 0;
          const n = i2(844), o = i2(2585), a = { trace: o.LogLevelEnum.TRACE, debug: o.LogLevelEnum.DEBUG, info: o.LogLevelEnum.INFO, warn: o.LogLevelEnum.WARN, error: o.LogLevelEnum.ERROR, off: o.LogLevelEnum.OFF };
          let h, c = t2.LogService = class extends n.Disposable {
            get logLevel() {
              return this._logLevel;
            }
            constructor(e3) {
              super(), this._optionsService = e3, this._logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), h = this;
            }
            _updateLogLevel() {
              this._logLevel = a[this._optionsService.rawOptions.logLevel];
            }
            _evalLazyOptionalParams(e3) {
              for (let t3 = 0; t3 < e3.length; t3++)
                "function" == typeof e3[t3] && (e3[t3] = e3[t3]());
            }
            _log(e3, t3, i3) {
              this._evalLazyOptionalParams(i3), e3.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + t3, ...i3);
            }
            trace(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.TRACE && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.trace.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.log, e3, t3);
            }
            debug(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.DEBUG && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.debug.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.log, e3, t3);
            }
            info(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.INFO && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.info.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.info, e3, t3);
            }
            warn(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.WARN && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.warn.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.warn, e3, t3);
            }
            error(e3, ...t3) {
              var i3, s3;
              this._logLevel <= o.LogLevelEnum.ERROR && this._log(null !== (s3 = null === (i3 = this._optionsService.options.logger) || void 0 === i3 ? void 0 : i3.error.bind(this._optionsService.options.logger)) && void 0 !== s3 ? s3 : console.error, e3, t3);
            }
          };
          t2.LogService = c = s2([r(0, o.IOptionsService)], c), t2.setTraceLogger = function(e3) {
            h = e3;
          }, t2.traceCall = function(e3, t3, i3) {
            if ("function" != typeof i3.value)
              throw new Error("not supported");
            const s3 = i3.value;
            i3.value = function(...e4) {
              if (h.logLevel !== o.LogLevelEnum.TRACE)
                return s3.apply(this, e4);
              h.trace(`GlyphRenderer#${s3.name}(${e4.map((e5) => JSON.stringify(e5)).join(", ")})`);
              const t4 = s3.apply(this, e4);
              return h.trace(`GlyphRenderer#${s3.name} return`, t4), t4;
            };
          };
        }, 7302: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionsService = t2.DEFAULT_OPTIONS = void 0;
          const s2 = i2(8460), r = i2(844), n = i2(6114);
          t2.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: false, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: true, drawBoldTextInBrightColors: true, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: false, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: true, scrollSensitivity: 1, screenReaderMode: false, smoothScrollDuration: 0, macOptionIsMeta: false, macOptionClickForcesSelection: false, minimumContrastRatio: 1, disableStdin: false, allowProposedApi: false, allowTransparency: false, tabStopWidth: 8, theme: {}, rightClickSelectsWord: n.isMac, windowOptions: {}, windowsMode: false, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: true, convertEol: false, termName: "xterm", cancelEvents: false, overviewRulerWidth: 0 };
          const o = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
          class a extends r.Disposable {
            constructor(e3) {
              super(), this._onOptionChange = this.register(new s2.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
              const i3 = Object.assign({}, t2.DEFAULT_OPTIONS);
              for (const t3 in e3)
                if (t3 in i3)
                  try {
                    const s3 = e3[t3];
                    i3[t3] = this._sanitizeAndValidateOption(t3, s3);
                  } catch (e4) {
                    console.error(e4);
                  }
              this.rawOptions = i3, this.options = Object.assign({}, i3), this._setupOptions();
            }
            onSpecificOptionChange(e3, t3) {
              return this.onOptionChange((i3) => {
                i3 === e3 && t3(this.rawOptions[e3]);
              });
            }
            onMultipleOptionChange(e3, t3) {
              return this.onOptionChange((i3) => {
                -1 !== e3.indexOf(i3) && t3();
              });
            }
            _setupOptions() {
              const e3 = (e4) => {
                if (!(e4 in t2.DEFAULT_OPTIONS))
                  throw new Error(`No option with key "${e4}"`);
                return this.rawOptions[e4];
              }, i3 = (e4, i4) => {
                if (!(e4 in t2.DEFAULT_OPTIONS))
                  throw new Error(`No option with key "${e4}"`);
                i4 = this._sanitizeAndValidateOption(e4, i4), this.rawOptions[e4] !== i4 && (this.rawOptions[e4] = i4, this._onOptionChange.fire(e4));
              };
              for (const t3 in this.rawOptions) {
                const s3 = { get: e3.bind(this, t3), set: i3.bind(this, t3) };
                Object.defineProperty(this.options, t3, s3);
              }
            }
            _sanitizeAndValidateOption(e3, i3) {
              switch (e3) {
                case "cursorStyle":
                  if (i3 || (i3 = t2.DEFAULT_OPTIONS[e3]), !/* @__PURE__ */ function(e4) {
                    return "block" === e4 || "underline" === e4 || "bar" === e4;
                  }(i3))
                    throw new Error(`"${i3}" is not a valid value for ${e3}`);
                  break;
                case "wordSeparator":
                  i3 || (i3 = t2.DEFAULT_OPTIONS[e3]);
                  break;
                case "fontWeight":
                case "fontWeightBold":
                  if ("number" == typeof i3 && 1 <= i3 && i3 <= 1e3)
                    break;
                  i3 = o.includes(i3) ? i3 : t2.DEFAULT_OPTIONS[e3];
                  break;
                case "cursorWidth":
                  i3 = Math.floor(i3);
                case "lineHeight":
                case "tabStopWidth":
                  if (i3 < 1)
                    throw new Error(`${e3} cannot be less than 1, value: ${i3}`);
                  break;
                case "minimumContrastRatio":
                  i3 = Math.max(1, Math.min(21, Math.round(10 * i3) / 10));
                  break;
                case "scrollback":
                  if ((i3 = Math.min(i3, 4294967295)) < 0)
                    throw new Error(`${e3} cannot be less than 0, value: ${i3}`);
                  break;
                case "fastScrollSensitivity":
                case "scrollSensitivity":
                  if (i3 <= 0)
                    throw new Error(`${e3} cannot be less than or equal to 0, value: ${i3}`);
                  break;
                case "rows":
                case "cols":
                  if (!i3 && 0 !== i3)
                    throw new Error(`${e3} must be numeric, value: ${i3}`);
                  break;
                case "windowsPty":
                  i3 = null != i3 ? i3 : {};
              }
              return i3;
            }
          }
          t2.OptionsService = a;
        }, 2660: function(e2, t2, i2) {
          var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
              o2 = Reflect.decorate(e3, t3, i3, s3);
            else
              for (var a = e3.length - 1; a >= 0; a--)
                (r2 = e3[a]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
          }, r = this && this.__param || function(e3, t3) {
            return function(i3, s3) {
              t3(i3, s3, e3);
            };
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkService = void 0;
          const n = i2(2585);
          let o = t2.OscLinkService = class {
            constructor(e3) {
              this._bufferService = e3, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
            }
            registerLink(e3) {
              const t3 = this._bufferService.buffer;
              if (void 0 === e3.id) {
                const i4 = t3.addMarker(t3.ybase + t3.y), s4 = { data: e3, id: this._nextId++, lines: [i4] };
                return i4.onDispose(() => this._removeMarkerFromLink(s4, i4)), this._dataByLinkId.set(s4.id, s4), s4.id;
              }
              const i3 = e3, s3 = this._getEntryIdKey(i3), r2 = this._entriesWithId.get(s3);
              if (r2)
                return this.addLineToLink(r2.id, t3.ybase + t3.y), r2.id;
              const n2 = t3.addMarker(t3.ybase + t3.y), o2 = { id: this._nextId++, key: this._getEntryIdKey(i3), data: i3, lines: [n2] };
              return n2.onDispose(() => this._removeMarkerFromLink(o2, n2)), this._entriesWithId.set(o2.key, o2), this._dataByLinkId.set(o2.id, o2), o2.id;
            }
            addLineToLink(e3, t3) {
              const i3 = this._dataByLinkId.get(e3);
              if (i3 && i3.lines.every((e4) => e4.line !== t3)) {
                const e4 = this._bufferService.buffer.addMarker(t3);
                i3.lines.push(e4), e4.onDispose(() => this._removeMarkerFromLink(i3, e4));
              }
            }
            getLinkData(e3) {
              var t3;
              return null === (t3 = this._dataByLinkId.get(e3)) || void 0 === t3 ? void 0 : t3.data;
            }
            _getEntryIdKey(e3) {
              return `${e3.id};;${e3.uri}`;
            }
            _removeMarkerFromLink(e3, t3) {
              const i3 = e3.lines.indexOf(t3);
              -1 !== i3 && (e3.lines.splice(i3, 1), 0 === e3.lines.length && (void 0 !== e3.data.id && this._entriesWithId.delete(e3.key), this._dataByLinkId.delete(e3.id)));
            }
          };
          t2.OscLinkService = o = s2([r(0, n.IBufferService)], o);
        }, 8343: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.createDecorator = t2.getServiceDependencies = t2.serviceRegistry = void 0;
          const i2 = "di$target", s2 = "di$dependencies";
          t2.serviceRegistry = /* @__PURE__ */ new Map(), t2.getServiceDependencies = function(e3) {
            return e3[s2] || [];
          }, t2.createDecorator = function(e3) {
            if (t2.serviceRegistry.has(e3))
              return t2.serviceRegistry.get(e3);
            const r = function(e4, t3, n) {
              if (3 !== arguments.length)
                throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
              !function(e5, t4, r2) {
                t4[i2] === t4 ? t4[s2].push({ id: e5, index: r2 }) : (t4[s2] = [{ id: e5, index: r2 }], t4[i2] = t4);
              }(r, e4, n);
            };
            return r.toString = () => e3, t2.serviceRegistry.set(e3, r), r;
          };
        }, 2585: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.IDecorationService = t2.IUnicodeService = t2.IOscLinkService = t2.IOptionsService = t2.ILogService = t2.LogLevelEnum = t2.IInstantiationService = t2.ICharsetService = t2.ICoreService = t2.ICoreMouseService = t2.IBufferService = void 0;
          const s2 = i2(8343);
          var r;
          t2.IBufferService = (0, s2.createDecorator)("BufferService"), t2.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t2.ICoreService = (0, s2.createDecorator)("CoreService"), t2.ICharsetService = (0, s2.createDecorator)("CharsetService"), t2.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), function(e3) {
            e3[e3.TRACE = 0] = "TRACE", e3[e3.DEBUG = 1] = "DEBUG", e3[e3.INFO = 2] = "INFO", e3[e3.WARN = 3] = "WARN", e3[e3.ERROR = 4] = "ERROR", e3[e3.OFF = 5] = "OFF";
          }(r || (t2.LogLevelEnum = r = {})), t2.ILogService = (0, s2.createDecorator)("LogService"), t2.IOptionsService = (0, s2.createDecorator)("OptionsService"), t2.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t2.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t2.IDecorationService = (0, s2.createDecorator)("DecorationService");
        }, 1480: (e2, t2, i2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeService = void 0;
          const s2 = i2(8460), r = i2(225);
          t2.UnicodeService = class {
            constructor() {
              this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new s2.EventEmitter(), this.onChange = this._onChange.event;
              const e3 = new r.UnicodeV6();
              this.register(e3), this._active = e3.version, this._activeProvider = e3;
            }
            dispose() {
              this._onChange.dispose();
            }
            get versions() {
              return Object.keys(this._providers);
            }
            get activeVersion() {
              return this._active;
            }
            set activeVersion(e3) {
              if (!this._providers[e3])
                throw new Error(`unknown Unicode version "${e3}"`);
              this._active = e3, this._activeProvider = this._providers[e3], this._onChange.fire(e3);
            }
            register(e3) {
              this._providers[e3.version] = e3;
            }
            wcwidth(e3) {
              return this._activeProvider.wcwidth(e3);
            }
            getStringCellWidth(e3) {
              let t3 = 0;
              const i3 = e3.length;
              for (let s3 = 0; s3 < i3; ++s3) {
                let r2 = e3.charCodeAt(s3);
                if (55296 <= r2 && r2 <= 56319) {
                  if (++s3 >= i3)
                    return t3 + this.wcwidth(r2);
                  const n = e3.charCodeAt(s3);
                  56320 <= n && n <= 57343 ? r2 = 1024 * (r2 - 55296) + n - 56320 + 65536 : t3 += this.wcwidth(n);
                }
                t3 += this.wcwidth(r2);
              }
              return t3;
            }
          };
        } }, t = {};
        function i(s2) {
          var r = t[s2];
          if (void 0 !== r)
            return r.exports;
          var n = t[s2] = { exports: {} };
          return e[s2].call(n.exports, n, n.exports, i), n.exports;
        }
        var s = {};
        return (() => {
          var e2 = s;
          Object.defineProperty(e2, "__esModule", { value: true }), e2.Terminal = void 0;
          const t2 = i(9042), r = i(3236), n = i(844), o = i(5741), a = i(8285), h = i(7975), c = i(7090), l = ["cols", "rows"];
          class d extends n.Disposable {
            constructor(e3) {
              super(), this._core = this.register(new r.Terminal(e3)), this._addonManager = this.register(new o.AddonManager()), this._publicOptions = Object.assign({}, this._core.options);
              const t3 = (e4) => this._core.options[e4], i2 = (e4, t4) => {
                this._checkReadonlyOptions(e4), this._core.options[e4] = t4;
              };
              for (const e4 in this._core.options) {
                const s2 = { get: t3.bind(this, e4), set: i2.bind(this, e4) };
                Object.defineProperty(this._publicOptions, e4, s2);
              }
            }
            _checkReadonlyOptions(e3) {
              if (l.includes(e3))
                throw new Error(`Option "${e3}" can only be set in the constructor`);
            }
            _checkProposedApi() {
              if (!this._core.optionsService.rawOptions.allowProposedApi)
                throw new Error("You must set the allowProposedApi option to true to use proposed API");
            }
            get onBell() {
              return this._core.onBell;
            }
            get onBinary() {
              return this._core.onBinary;
            }
            get onCursorMove() {
              return this._core.onCursorMove;
            }
            get onData() {
              return this._core.onData;
            }
            get onKey() {
              return this._core.onKey;
            }
            get onLineFeed() {
              return this._core.onLineFeed;
            }
            get onRender() {
              return this._core.onRender;
            }
            get onResize() {
              return this._core.onResize;
            }
            get onScroll() {
              return this._core.onScroll;
            }
            get onSelectionChange() {
              return this._core.onSelectionChange;
            }
            get onTitleChange() {
              return this._core.onTitleChange;
            }
            get onWriteParsed() {
              return this._core.onWriteParsed;
            }
            get element() {
              return this._core.element;
            }
            get parser() {
              return this._parser || (this._parser = new h.ParserApi(this._core)), this._parser;
            }
            get unicode() {
              return this._checkProposedApi(), new c.UnicodeApi(this._core);
            }
            get textarea() {
              return this._core.textarea;
            }
            get rows() {
              return this._core.rows;
            }
            get cols() {
              return this._core.cols;
            }
            get buffer() {
              return this._buffer || (this._buffer = this.register(new a.BufferNamespaceApi(this._core))), this._buffer;
            }
            get markers() {
              return this._checkProposedApi(), this._core.markers;
            }
            get modes() {
              const e3 = this._core.coreService.decPrivateModes;
              let t3 = "none";
              switch (this._core.coreMouseService.activeProtocol) {
                case "X10":
                  t3 = "x10";
                  break;
                case "VT200":
                  t3 = "vt200";
                  break;
                case "DRAG":
                  t3 = "drag";
                  break;
                case "ANY":
                  t3 = "any";
              }
              return { applicationCursorKeysMode: e3.applicationCursorKeys, applicationKeypadMode: e3.applicationKeypad, bracketedPasteMode: e3.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: t3, originMode: e3.origin, reverseWraparoundMode: e3.reverseWraparound, sendFocusMode: e3.sendFocus, wraparoundMode: e3.wraparound };
            }
            get options() {
              return this._publicOptions;
            }
            set options(e3) {
              for (const t3 in e3)
                this._publicOptions[t3] = e3[t3];
            }
            blur() {
              this._core.blur();
            }
            focus() {
              this._core.focus();
            }
            resize(e3, t3) {
              this._verifyIntegers(e3, t3), this._core.resize(e3, t3);
            }
            open(e3) {
              this._core.open(e3);
            }
            attachCustomKeyEventHandler(e3) {
              this._core.attachCustomKeyEventHandler(e3);
            }
            registerLinkProvider(e3) {
              return this._core.registerLinkProvider(e3);
            }
            registerCharacterJoiner(e3) {
              return this._checkProposedApi(), this._core.registerCharacterJoiner(e3);
            }
            deregisterCharacterJoiner(e3) {
              this._checkProposedApi(), this._core.deregisterCharacterJoiner(e3);
            }
            registerMarker(e3 = 0) {
              return this._verifyIntegers(e3), this._core.registerMarker(e3);
            }
            registerDecoration(e3) {
              var t3, i2, s2;
              return this._checkProposedApi(), this._verifyPositiveIntegers(null !== (t3 = e3.x) && void 0 !== t3 ? t3 : 0, null !== (i2 = e3.width) && void 0 !== i2 ? i2 : 0, null !== (s2 = e3.height) && void 0 !== s2 ? s2 : 0), this._core.registerDecoration(e3);
            }
            hasSelection() {
              return this._core.hasSelection();
            }
            select(e3, t3, i2) {
              this._verifyIntegers(e3, t3, i2), this._core.select(e3, t3, i2);
            }
            getSelection() {
              return this._core.getSelection();
            }
            getSelectionPosition() {
              return this._core.getSelectionPosition();
            }
            clearSelection() {
              this._core.clearSelection();
            }
            selectAll() {
              this._core.selectAll();
            }
            selectLines(e3, t3) {
              this._verifyIntegers(e3, t3), this._core.selectLines(e3, t3);
            }
            dispose() {
              super.dispose();
            }
            scrollLines(e3) {
              this._verifyIntegers(e3), this._core.scrollLines(e3);
            }
            scrollPages(e3) {
              this._verifyIntegers(e3), this._core.scrollPages(e3);
            }
            scrollToTop() {
              this._core.scrollToTop();
            }
            scrollToBottom() {
              this._core.scrollToBottom();
            }
            scrollToLine(e3) {
              this._verifyIntegers(e3), this._core.scrollToLine(e3);
            }
            clear() {
              this._core.clear();
            }
            write(e3, t3) {
              this._core.write(e3, t3);
            }
            writeln(e3, t3) {
              this._core.write(e3), this._core.write("\r\n", t3);
            }
            paste(e3) {
              this._core.paste(e3);
            }
            refresh(e3, t3) {
              this._verifyIntegers(e3, t3), this._core.refresh(e3, t3);
            }
            reset() {
              this._core.reset();
            }
            clearTextureAtlas() {
              this._core.clearTextureAtlas();
            }
            loadAddon(e3) {
              this._addonManager.loadAddon(this, e3);
            }
            static get strings() {
              return t2;
            }
            _verifyIntegers(...e3) {
              for (const t3 of e3)
                if (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0)
                  throw new Error("This API only accepts integers");
            }
            _verifyPositiveIntegers(...e3) {
              for (const t3 of e3)
                if (t3 && (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0 || t3 < 0))
                  throw new Error("This API only accepts positive integers");
            }
          }
          e2.Terminal = d;
        })(), s;
      })());
    }
  });

  // node_modules/@xterm/addon-fit/lib/addon-fit.js
  var require_addon_fit = __commonJS({
    "node_modules/@xterm/addon-fit/lib/addon-fit.js"(exports, module2) {
      !function(e, t) {
        "object" == typeof exports && "object" == typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.FitAddon = t() : e.FitAddon = t();
      }(self, () => (() => {
        "use strict";
        var e = {};
        return (() => {
          var t = e;
          Object.defineProperty(t, "__esModule", { value: true }), t.FitAddon = void 0, t.FitAddon = class {
            activate(e2) {
              this._terminal = e2;
            }
            dispose() {
            }
            fit() {
              const e2 = this.proposeDimensions();
              if (!e2 || !this._terminal || isNaN(e2.cols) || isNaN(e2.rows))
                return;
              const t2 = this._terminal._core;
              this._terminal.rows === e2.rows && this._terminal.cols === e2.cols || (t2._renderService.clear(), this._terminal.resize(e2.cols, e2.rows));
            }
            proposeDimensions() {
              if (!this._terminal)
                return;
              if (!this._terminal.element || !this._terminal.element.parentElement)
                return;
              const e2 = this._terminal._core, t2 = e2._renderService.dimensions;
              if (0 === t2.css.cell.width || 0 === t2.css.cell.height)
                return;
              const r = 0 === this._terminal.options.scrollback ? 0 : e2.viewport.scrollBarWidth, i = window.getComputedStyle(this._terminal.element.parentElement), o = parseInt(i.getPropertyValue("height")), s = Math.max(0, parseInt(i.getPropertyValue("width"))), n = window.getComputedStyle(this._terminal.element), l = o - (parseInt(n.getPropertyValue("padding-top")) + parseInt(n.getPropertyValue("padding-bottom"))), a = s - (parseInt(n.getPropertyValue("padding-right")) + parseInt(n.getPropertyValue("padding-left"))) - r;
              return { cols: Math.max(2, Math.floor(a / t2.css.cell.width)), rows: Math.max(1, Math.floor(l / t2.css.cell.height)) };
            }
          };
        })(), e;
      })());
    }
  });

  // lib/index.js
  var import_api2 = __toESM(require_dist());

  // node_modules/cborg/lib/is.js
  var typeofs = [
    "string",
    "number",
    "bigint",
    "symbol"
  ];
  var objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "HTMLElement",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function is(value) {
    if (value === null) {
      return "null";
    }
    if (value === void 0) {
      return "undefined";
    }
    if (value === true || value === false) {
      return "boolean";
    }
    const typeOf = typeof value;
    if (typeofs.includes(typeOf)) {
      return typeOf;
    }
    if (typeOf === "function") {
      return "Function";
    }
    if (Array.isArray(value)) {
      return "Array";
    }
    if (isBuffer(value)) {
      return "Buffer";
    }
    const objectType = getObjectType(value);
    if (objectType) {
      return objectType;
    }
    return "Object";
  }
  function isBuffer(value) {
    return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
  }
  function getObjectType(value) {
    const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
    if (objectTypeNames.includes(objectTypeName)) {
      return objectTypeName;
    }
    return void 0;
  }

  // node_modules/cborg/lib/token.js
  var Type = class {
    /**
     * @param {number} major
     * @param {string} name
     * @param {boolean} terminal
     */
    constructor(major, name, terminal) {
      this.major = major;
      this.majorEncoded = major << 5;
      this.name = name;
      this.terminal = terminal;
    }
    /* c8 ignore next 3 */
    toString() {
      return `Type[${this.major}].${this.name}`;
    }
    /**
     * @param {Type} typ
     * @returns {number}
     */
    compare(typ) {
      return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
    }
  };
  Type.uint = new Type(0, "uint", true);
  Type.negint = new Type(1, "negint", true);
  Type.bytes = new Type(2, "bytes", true);
  Type.string = new Type(3, "string", true);
  Type.array = new Type(4, "array", false);
  Type.map = new Type(5, "map", false);
  Type.tag = new Type(6, "tag", false);
  Type.float = new Type(7, "float", true);
  Type.false = new Type(7, "false", true);
  Type.true = new Type(7, "true", true);
  Type.null = new Type(7, "null", true);
  Type.undefined = new Type(7, "undefined", true);
  Type.break = new Type(7, "break", true);
  var Token = class {
    /**
     * @param {Type} type
     * @param {any} [value]
     * @param {number} [encodedLength]
     */
    constructor(type, value, encodedLength) {
      this.type = type;
      this.value = value;
      this.encodedLength = encodedLength;
      this.encodedBytes = void 0;
      this.byteValue = void 0;
    }
    /* c8 ignore next 3 */
    toString() {
      return `Token[${this.type}].${this.value}`;
    }
  };

  // node_modules/cborg/lib/byte-utils.js
  var useBuffer = globalThis.process && // @ts-ignore
  !globalThis.process.browser && // @ts-ignore
  globalThis.Buffer && // @ts-ignore
  typeof globalThis.Buffer.isBuffer === "function";
  var textDecoder = new TextDecoder();
  var textEncoder = new TextEncoder();
  function isBuffer2(buf2) {
    return useBuffer && globalThis.Buffer.isBuffer(buf2);
  }
  function asU8A(buf2) {
    if (!(buf2 instanceof Uint8Array)) {
      return Uint8Array.from(buf2);
    }
    return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
  }
  var toString = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return end - start > 64 ? (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8")
      ) : utf8Slice(bytes, start, end);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
    }
  );
  var fromString = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {string} string
     */
    (string) => {
      return string.length > 64 ? (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(string)
      ) : utf8ToBytes(string);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {string} string
     */
    (string) => {
      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);
    }
  );
  var slice = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      if (isBuffer2(bytes)) {
        return new Uint8Array(bytes.subarray(start, end));
      }
      return bytes.slice(start, end);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start, end) => {
      return bytes.slice(start, end);
    }
  );
  var concat = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array[]} chunks
     * @param {number} length
     * @returns {Uint8Array}
     */
    (chunks, length4) => {
      chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(c)
      ));
      return asU8A(globalThis.Buffer.concat(chunks, length4));
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array[]} chunks
     * @param {number} length
     * @returns {Uint8Array}
     */
    (chunks, length4) => {
      const out = new Uint8Array(length4);
      let off = 0;
      for (let b of chunks) {
        if (off + b.length > out.length) {
          b = b.subarray(0, out.length - off);
        }
        out.set(b, off);
        off += b.length;
      }
      return out;
    }
  );
  var alloc = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {number} size
     * @returns {Uint8Array}
     */
    (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {number} size
     * @returns {Uint8Array}
     */
    (size) => {
      return new Uint8Array(size);
    }
  );
  function compare(b1, b2) {
    if (isBuffer2(b1) && isBuffer2(b2)) {
      return b1.compare(b2);
    }
    for (let i = 0; i < b1.length; i++) {
      if (b1[i] === b2[i]) {
        continue;
      }
      return b1[i] < b2[i] ? -1 : 1;
    }
    return 0;
  }
  function utf8ToBytes(str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
      let c = str.charCodeAt(i);
      if (c < 128) {
        out[p++] = c;
      } else if (c < 2048) {
        out[p++] = c >> 6 | 192;
        out[p++] = c & 63 | 128;
      } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        out[p++] = c >> 18 | 240;
        out[p++] = c >> 12 & 63 | 128;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      } else {
        out[p++] = c >> 12 | 224;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      }
    }
    return out;
  }
  function utf8Slice(buf2, offset, end) {
    const res = [];
    while (offset < end) {
      const firstByte = buf2[offset];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (offset + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[offset + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[offset + 1];
            thirdByte = buf2[offset + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[offset + 1];
            thirdByte = buf2[offset + 2];
            fourthByte = buf2[offset + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      offset += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }

  // node_modules/cborg/lib/bl.js
  var defaultChunkSize = 256;
  var Bl = class {
    /**
     * @param {number} [chunkSize]
     */
    constructor(chunkSize = defaultChunkSize) {
      this.chunkSize = chunkSize;
      this.cursor = 0;
      this.maxCursor = -1;
      this.chunks = [];
      this._initReuseChunk = null;
    }
    reset() {
      this.cursor = 0;
      this.maxCursor = -1;
      if (this.chunks.length) {
        this.chunks = [];
      }
      if (this._initReuseChunk !== null) {
        this.chunks.push(this._initReuseChunk);
        this.maxCursor = this._initReuseChunk.length - 1;
      }
    }
    /**
     * @param {Uint8Array|number[]} bytes
     */
    push(bytes) {
      let topChunk = this.chunks[this.chunks.length - 1];
      const newMax = this.cursor + bytes.length;
      if (newMax <= this.maxCursor + 1) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        topChunk.set(bytes, chunkPos);
      } else {
        if (topChunk) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          if (chunkPos < topChunk.length) {
            this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
            this.maxCursor = this.cursor - 1;
          }
        }
        if (bytes.length < 64 && bytes.length < this.chunkSize) {
          topChunk = alloc(this.chunkSize);
          this.chunks.push(topChunk);
          this.maxCursor += topChunk.length;
          if (this._initReuseChunk === null) {
            this._initReuseChunk = topChunk;
          }
          topChunk.set(bytes, 0);
        } else {
          this.chunks.push(bytes);
          this.maxCursor += bytes.length;
        }
      }
      this.cursor += bytes.length;
    }
    /**
     * @param {boolean} [reset]
     * @returns {Uint8Array}
     */
    toBytes(reset = false) {
      let byts;
      if (this.chunks.length === 1) {
        const chunk = this.chunks[0];
        if (reset && this.cursor > chunk.length / 2) {
          byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
          this._initReuseChunk = null;
          this.chunks = [];
        } else {
          byts = slice(chunk, 0, this.cursor);
        }
      } else {
        byts = concat(this.chunks, this.cursor);
      }
      if (reset) {
        this.reset();
      }
      return byts;
    }
  };

  // node_modules/cborg/lib/common.js
  var decodeErrPrefix = "CBOR decode error:";
  var encodeErrPrefix = "CBOR encode error:";
  var uintMinorPrefixBytes = [];
  uintMinorPrefixBytes[23] = 1;
  uintMinorPrefixBytes[24] = 2;
  uintMinorPrefixBytes[25] = 3;
  uintMinorPrefixBytes[26] = 5;
  uintMinorPrefixBytes[27] = 9;
  function assertEnoughData(data, pos, need) {
    if (data.length - pos < need) {
      throw new Error(`${decodeErrPrefix} not enough data for type`);
    }
  }

  // node_modules/cborg/lib/0uint.js
  var uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
  function readUint8(data, offset, options) {
    assertEnoughData(data, offset, 1);
    const value = data[offset];
    if (options.strict === true && value < uintBoundaries[0]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint16(data, offset, options) {
    assertEnoughData(data, offset, 2);
    const value = data[offset] << 8 | data[offset + 1];
    if (options.strict === true && value < uintBoundaries[1]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint32(data, offset, options) {
    assertEnoughData(data, offset, 4);
    const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    if (options.strict === true && value < uintBoundaries[2]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value;
  }
  function readUint64(data, offset, options) {
    assertEnoughData(data, offset, 8);
    const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
    const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
    if (options.strict === true && value < uintBoundaries[3]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    if (value <= Number.MAX_SAFE_INTEGER) {
      return Number(value);
    }
    if (options.allowBigInt === true) {
      return value;
    }
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  function decodeUint8(data, pos, _minor, options) {
    return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
  }
  function decodeUint16(data, pos, _minor, options) {
    return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
  }
  function decodeUint32(data, pos, _minor, options) {
    return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
  }
  function decodeUint64(data, pos, _minor, options) {
    return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
  }
  function encodeUint(buf2, token) {
    return encodeUintValue(buf2, 0, token.value);
  }
  function encodeUintValue(buf2, major, uint) {
    if (uint < uintBoundaries[0]) {
      const nuint = Number(uint);
      buf2.push([major | nuint]);
    } else if (uint < uintBoundaries[1]) {
      const nuint = Number(uint);
      buf2.push([major | 24, nuint]);
    } else if (uint < uintBoundaries[2]) {
      const nuint = Number(uint);
      buf2.push([major | 25, nuint >>> 8, nuint & 255]);
    } else if (uint < uintBoundaries[3]) {
      const nuint = Number(uint);
      buf2.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
    } else {
      const buint = BigInt(uint);
      if (buint < uintBoundaries[4]) {
        const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
        let lo = Number(buint & BigInt(4294967295));
        let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
        set[8] = lo & 255;
        lo = lo >> 8;
        set[7] = lo & 255;
        lo = lo >> 8;
        set[6] = lo & 255;
        lo = lo >> 8;
        set[5] = lo & 255;
        set[4] = hi & 255;
        hi = hi >> 8;
        set[3] = hi & 255;
        hi = hi >> 8;
        set[2] = hi & 255;
        hi = hi >> 8;
        set[1] = hi & 255;
        buf2.push(set);
      } else {
        throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
      }
    }
  }
  encodeUint.encodedSize = function encodedSize(token) {
    return encodeUintValue.encodedSize(token.value);
  };
  encodeUintValue.encodedSize = function encodedSize2(uint) {
    if (uint < uintBoundaries[0]) {
      return 1;
    }
    if (uint < uintBoundaries[1]) {
      return 2;
    }
    if (uint < uintBoundaries[2]) {
      return 3;
    }
    if (uint < uintBoundaries[3]) {
      return 5;
    }
    return 9;
  };
  encodeUint.compareTokens = function compareTokens(tok1, tok2) {
    return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
      /* c8 ignore next */
      0
    );
  };

  // node_modules/cborg/lib/1negint.js
  function decodeNegint8(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
  }
  function decodeNegint16(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
  }
  function decodeNegint32(data, pos, _minor, options) {
    return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
  }
  var neg1b = BigInt(-1);
  var pos1b = BigInt(1);
  function decodeNegint64(data, pos, _minor, options) {
    const int = readUint64(data, pos + 1, options);
    if (typeof int !== "bigint") {
      const value = -1 - int;
      if (value >= Number.MIN_SAFE_INTEGER) {
        return new Token(Type.negint, value, 9);
      }
    }
    if (options.allowBigInt !== true) {
      throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
    }
    return new Token(Type.negint, neg1b - BigInt(int), 9);
  }
  function encodeNegint(buf2, token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    encodeUintValue(buf2, token.type.majorEncoded, unsigned);
  }
  encodeNegint.encodedSize = function encodedSize3(token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    if (unsigned < uintBoundaries[0]) {
      return 1;
    }
    if (unsigned < uintBoundaries[1]) {
      return 2;
    }
    if (unsigned < uintBoundaries[2]) {
      return 3;
    }
    if (unsigned < uintBoundaries[3]) {
      return 5;
    }
    return 9;
  };
  encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
    return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
      /* c8 ignore next */
      0
    );
  };

  // node_modules/cborg/lib/2bytes.js
  function toToken(data, pos, prefix, length4) {
    assertEnoughData(data, pos, prefix + length4);
    const buf2 = slice(data, pos + prefix, pos + prefix + length4);
    return new Token(Type.bytes, buf2, prefix + length4);
  }
  function decodeBytesCompact(data, pos, minor, _options) {
    return toToken(data, pos, 1, minor);
  }
  function decodeBytes8(data, pos, _minor, options) {
    return toToken(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeBytes16(data, pos, _minor, options) {
    return toToken(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeBytes32(data, pos, _minor, options) {
    return toToken(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeBytes64(data, pos, _minor, options) {
    const l = readUint64(data, pos + 1, options);
    if (typeof l === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
    }
    return toToken(data, pos, 9, l);
  }
  function tokenBytes(token) {
    if (token.encodedBytes === void 0) {
      token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;
    }
    return token.encodedBytes;
  }
  function encodeBytes(buf2, token) {
    const bytes = tokenBytes(token);
    encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
    buf2.push(bytes);
  }
  encodeBytes.encodedSize = function encodedSize4(token) {
    const bytes = tokenBytes(token);
    return encodeUintValue.encodedSize(bytes.length) + bytes.length;
  };
  encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
    return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
  };
  function compareBytes(b1, b2) {
    return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
  }

  // node_modules/cborg/lib/3string.js
  function toToken2(data, pos, prefix, length4, options) {
    const totLength = prefix + length4;
    assertEnoughData(data, pos, totLength);
    const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);
    if (options.retainStringBytes === true) {
      tok.byteValue = slice(data, pos + prefix, pos + totLength);
    }
    return tok;
  }
  function decodeStringCompact(data, pos, minor, options) {
    return toToken2(data, pos, 1, minor, options);
  }
  function decodeString8(data, pos, _minor, options) {
    return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
  }
  function decodeString16(data, pos, _minor, options) {
    return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
  }
  function decodeString32(data, pos, _minor, options) {
    return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
  }
  function decodeString64(data, pos, _minor, options) {
    const l = readUint64(data, pos + 1, options);
    if (typeof l === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
    }
    return toToken2(data, pos, 9, l, options);
  }
  var encodeString = encodeBytes;

  // node_modules/cborg/lib/4array.js
  function toToken3(_data, _pos, prefix, length4) {
    return new Token(Type.array, length4, prefix);
  }
  function decodeArrayCompact(data, pos, minor, _options) {
    return toToken3(data, pos, 1, minor);
  }
  function decodeArray8(data, pos, _minor, options) {
    return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeArray16(data, pos, _minor, options) {
    return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeArray32(data, pos, _minor, options) {
    return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeArray64(data, pos, _minor, options) {
    const l = readUint64(data, pos + 1, options);
    if (typeof l === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
    }
    return toToken3(data, pos, 9, l);
  }
  function decodeArrayIndefinite(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken3(data, pos, 1, Infinity);
  }
  function encodeArray(buf2, token) {
    encodeUintValue(buf2, Type.array.majorEncoded, token.value);
  }
  encodeArray.compareTokens = encodeUint.compareTokens;
  encodeArray.encodedSize = function encodedSize5(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/lib/5map.js
  function toToken4(_data, _pos, prefix, length4) {
    return new Token(Type.map, length4, prefix);
  }
  function decodeMapCompact(data, pos, minor, _options) {
    return toToken4(data, pos, 1, minor);
  }
  function decodeMap8(data, pos, _minor, options) {
    return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
  }
  function decodeMap16(data, pos, _minor, options) {
    return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
  }
  function decodeMap32(data, pos, _minor, options) {
    return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
  }
  function decodeMap64(data, pos, _minor, options) {
    const l = readUint64(data, pos + 1, options);
    if (typeof l === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
    }
    return toToken4(data, pos, 9, l);
  }
  function decodeMapIndefinite(data, pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken4(data, pos, 1, Infinity);
  }
  function encodeMap(buf2, token) {
    encodeUintValue(buf2, Type.map.majorEncoded, token.value);
  }
  encodeMap.compareTokens = encodeUint.compareTokens;
  encodeMap.encodedSize = function encodedSize6(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/lib/6tag.js
  function decodeTagCompact(_data, _pos, minor, _options) {
    return new Token(Type.tag, minor, 1);
  }
  function decodeTag8(data, pos, _minor, options) {
    return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
  }
  function decodeTag16(data, pos, _minor, options) {
    return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
  }
  function decodeTag32(data, pos, _minor, options) {
    return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
  }
  function decodeTag64(data, pos, _minor, options) {
    return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
  }
  function encodeTag(buf2, token) {
    encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
  }
  encodeTag.compareTokens = encodeUint.compareTokens;
  encodeTag.encodedSize = function encodedSize7(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/lib/7float.js
  var MINOR_FALSE = 20;
  var MINOR_TRUE = 21;
  var MINOR_NULL = 22;
  var MINOR_UNDEFINED = 23;
  function decodeUndefined(_data, _pos, _minor, options) {
    if (options.allowUndefined === false) {
      throw new Error(`${decodeErrPrefix} undefined values are not supported`);
    } else if (options.coerceUndefinedToNull === true) {
      return new Token(Type.null, null, 1);
    }
    return new Token(Type.undefined, void 0, 1);
  }
  function decodeBreak(_data, _pos, _minor, options) {
    if (options.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return new Token(Type.break, void 0, 1);
  }
  function createToken(value, bytes, options) {
    if (options) {
      if (options.allowNaN === false && Number.isNaN(value)) {
        throw new Error(`${decodeErrPrefix} NaN values are not supported`);
      }
      if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
        throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
      }
    }
    return new Token(Type.float, value, bytes);
  }
  function decodeFloat16(data, pos, _minor, options) {
    return createToken(readFloat16(data, pos + 1), 3, options);
  }
  function decodeFloat32(data, pos, _minor, options) {
    return createToken(readFloat32(data, pos + 1), 5, options);
  }
  function decodeFloat64(data, pos, _minor, options) {
    return createToken(readFloat64(data, pos + 1), 9, options);
  }
  function encodeFloat(buf2, token, options) {
    const float = token.value;
    if (float === false) {
      buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
    } else if (float === true) {
      buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
    } else if (float === null) {
      buf2.push([Type.float.majorEncoded | MINOR_NULL]);
    } else if (float === void 0) {
      buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
    } else {
      let decoded;
      let success = false;
      if (!options || options.float64 !== true) {
        encodeFloat16(float);
        decoded = readFloat16(ui8a, 1);
        if (float === decoded || Number.isNaN(float)) {
          ui8a[0] = 249;
          buf2.push(ui8a.slice(0, 3));
          success = true;
        } else {
          encodeFloat32(float);
          decoded = readFloat32(ui8a, 1);
          if (float === decoded) {
            ui8a[0] = 250;
            buf2.push(ui8a.slice(0, 5));
            success = true;
          }
        }
      }
      if (!success) {
        encodeFloat64(float);
        decoded = readFloat64(ui8a, 1);
        ui8a[0] = 251;
        buf2.push(ui8a.slice(0, 9));
      }
    }
  }
  encodeFloat.encodedSize = function encodedSize8(token, options) {
    const float = token.value;
    if (float === false || float === true || float === null || float === void 0) {
      return 1;
    }
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      let decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        return 3;
      }
      encodeFloat32(float);
      decoded = readFloat32(ui8a, 1);
      if (float === decoded) {
        return 5;
      }
    }
    return 9;
  };
  var buffer = new ArrayBuffer(9);
  var dataView = new DataView(buffer, 1);
  var ui8a = new Uint8Array(buffer, 0);
  function encodeFloat16(inp) {
    if (inp === Infinity) {
      dataView.setUint16(0, 31744, false);
    } else if (inp === -Infinity) {
      dataView.setUint16(0, 64512, false);
    } else if (Number.isNaN(inp)) {
      dataView.setUint16(0, 32256, false);
    } else {
      dataView.setFloat32(0, inp);
      const valu32 = dataView.getUint32(0);
      const exponent = (valu32 & 2139095040) >> 23;
      const mantissa = valu32 & 8388607;
      if (exponent === 255) {
        dataView.setUint16(0, 31744, false);
      } else if (exponent === 0) {
        dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
      } else {
        const logicalExponent = exponent - 127;
        if (logicalExponent < -24) {
          dataView.setUint16(0, 0);
        } else if (logicalExponent < -14) {
          dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
          1 << 24 + logicalExponent, false);
        } else {
          dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
        }
      }
    }
  }
  function readFloat16(ui8a2, pos) {
    if (ui8a2.length - pos < 2) {
      throw new Error(`${decodeErrPrefix} not enough data for float16`);
    }
    const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
    if (half === 31744) {
      return Infinity;
    }
    if (half === 64512) {
      return -Infinity;
    }
    if (half === 32256) {
      return NaN;
    }
    const exp = half >> 10 & 31;
    const mant = half & 1023;
    let val;
    if (exp === 0) {
      val = mant * __pow(2, -24);
    } else if (exp !== 31) {
      val = (mant + 1024) * __pow(2, exp - 25);
    } else {
      val = mant === 0 ? Infinity : NaN;
    }
    return half & 32768 ? -val : val;
  }
  function encodeFloat32(inp) {
    dataView.setFloat32(0, inp, false);
  }
  function readFloat32(ui8a2, pos) {
    if (ui8a2.length - pos < 4) {
      throw new Error(`${decodeErrPrefix} not enough data for float32`);
    }
    const offset = (ui8a2.byteOffset || 0) + pos;
    return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
  }
  function encodeFloat64(inp) {
    dataView.setFloat64(0, inp, false);
  }
  function readFloat64(ui8a2, pos) {
    if (ui8a2.length - pos < 8) {
      throw new Error(`${decodeErrPrefix} not enough data for float64`);
    }
    const offset = (ui8a2.byteOffset || 0) + pos;
    return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
  }
  encodeFloat.compareTokens = encodeUint.compareTokens;

  // node_modules/cborg/lib/jump.js
  function invalidMinor(data, pos, minor) {
    throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
  }
  function errorer(msg) {
    return () => {
      throw new Error(`${decodeErrPrefix} ${msg}`);
    };
  }
  var jump = [];
  for (let i = 0; i <= 23; i++) {
    jump[i] = invalidMinor;
  }
  jump[24] = decodeUint8;
  jump[25] = decodeUint16;
  jump[26] = decodeUint32;
  jump[27] = decodeUint64;
  jump[28] = invalidMinor;
  jump[29] = invalidMinor;
  jump[30] = invalidMinor;
  jump[31] = invalidMinor;
  for (let i = 32; i <= 55; i++) {
    jump[i] = invalidMinor;
  }
  jump[56] = decodeNegint8;
  jump[57] = decodeNegint16;
  jump[58] = decodeNegint32;
  jump[59] = decodeNegint64;
  jump[60] = invalidMinor;
  jump[61] = invalidMinor;
  jump[62] = invalidMinor;
  jump[63] = invalidMinor;
  for (let i = 64; i <= 87; i++) {
    jump[i] = decodeBytesCompact;
  }
  jump[88] = decodeBytes8;
  jump[89] = decodeBytes16;
  jump[90] = decodeBytes32;
  jump[91] = decodeBytes64;
  jump[92] = invalidMinor;
  jump[93] = invalidMinor;
  jump[94] = invalidMinor;
  jump[95] = errorer("indefinite length bytes/strings are not supported");
  for (let i = 96; i <= 119; i++) {
    jump[i] = decodeStringCompact;
  }
  jump[120] = decodeString8;
  jump[121] = decodeString16;
  jump[122] = decodeString32;
  jump[123] = decodeString64;
  jump[124] = invalidMinor;
  jump[125] = invalidMinor;
  jump[126] = invalidMinor;
  jump[127] = errorer("indefinite length bytes/strings are not supported");
  for (let i = 128; i <= 151; i++) {
    jump[i] = decodeArrayCompact;
  }
  jump[152] = decodeArray8;
  jump[153] = decodeArray16;
  jump[154] = decodeArray32;
  jump[155] = decodeArray64;
  jump[156] = invalidMinor;
  jump[157] = invalidMinor;
  jump[158] = invalidMinor;
  jump[159] = decodeArrayIndefinite;
  for (let i = 160; i <= 183; i++) {
    jump[i] = decodeMapCompact;
  }
  jump[184] = decodeMap8;
  jump[185] = decodeMap16;
  jump[186] = decodeMap32;
  jump[187] = decodeMap64;
  jump[188] = invalidMinor;
  jump[189] = invalidMinor;
  jump[190] = invalidMinor;
  jump[191] = decodeMapIndefinite;
  for (let i = 192; i <= 215; i++) {
    jump[i] = decodeTagCompact;
  }
  jump[216] = decodeTag8;
  jump[217] = decodeTag16;
  jump[218] = decodeTag32;
  jump[219] = decodeTag64;
  jump[220] = invalidMinor;
  jump[221] = invalidMinor;
  jump[222] = invalidMinor;
  jump[223] = invalidMinor;
  for (let i = 224; i <= 243; i++) {
    jump[i] = errorer("simple values are not supported");
  }
  jump[244] = invalidMinor;
  jump[245] = invalidMinor;
  jump[246] = invalidMinor;
  jump[247] = decodeUndefined;
  jump[248] = errorer("simple values are not supported");
  jump[249] = decodeFloat16;
  jump[250] = decodeFloat32;
  jump[251] = decodeFloat64;
  jump[252] = invalidMinor;
  jump[253] = invalidMinor;
  jump[254] = invalidMinor;
  jump[255] = decodeBreak;
  var quick = [];
  for (let i = 0; i < 24; i++) {
    quick[i] = new Token(Type.uint, i, 1);
  }
  for (let i = -1; i >= -24; i--) {
    quick[31 - i] = new Token(Type.negint, i, 1);
  }
  quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
  quick[96] = new Token(Type.string, "", 1);
  quick[128] = new Token(Type.array, 0, 1);
  quick[160] = new Token(Type.map, 0, 1);
  quick[244] = new Token(Type.false, false, 1);
  quick[245] = new Token(Type.true, true, 1);
  quick[246] = new Token(Type.null, null, 1);

  // node_modules/cborg/lib/encode.js
  function makeCborEncoders() {
    const encoders = [];
    encoders[Type.uint.major] = encodeUint;
    encoders[Type.negint.major] = encodeNegint;
    encoders[Type.bytes.major] = encodeBytes;
    encoders[Type.string.major] = encodeString;
    encoders[Type.array.major] = encodeArray;
    encoders[Type.map.major] = encodeMap;
    encoders[Type.tag.major] = encodeTag;
    encoders[Type.float.major] = encodeFloat;
    return encoders;
  }
  var cborEncoders = makeCborEncoders();
  var buf = new Bl();
  var Ref = class _Ref {
    /**
     * @param {object|any[]} obj
     * @param {Reference|undefined} parent
     */
    constructor(obj, parent) {
      this.obj = obj;
      this.parent = parent;
    }
    /**
     * @param {object|any[]} obj
     * @returns {boolean}
     */
    includes(obj) {
      let p = this;
      do {
        if (p.obj === obj) {
          return true;
        }
      } while (p = p.parent);
      return false;
    }
    /**
     * @param {Reference|undefined} stack
     * @param {object|any[]} obj
     * @returns {Reference}
     */
    static createCheck(stack, obj) {
      if (stack && stack.includes(obj)) {
        throw new Error(`${encodeErrPrefix} object contains circular references`);
      }
      return new _Ref(obj, stack);
    }
  };
  var simpleTokens = {
    null: new Token(Type.null, null),
    undefined: new Token(Type.undefined, void 0),
    true: new Token(Type.true, true),
    false: new Token(Type.false, false),
    emptyArray: new Token(Type.array, 0),
    emptyMap: new Token(Type.map, 0)
  };
  var typeEncoders = {
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    number(obj, _typ, _options, _refStack) {
      if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
        return new Token(Type.float, obj);
      } else if (obj >= 0) {
        return new Token(Type.uint, obj);
      } else {
        return new Token(Type.negint, obj);
      }
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    bigint(obj, _typ, _options, _refStack) {
      if (obj >= BigInt(0)) {
        return new Token(Type.uint, obj);
      } else {
        return new Token(Type.negint, obj);
      }
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    Uint8Array(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, obj);
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    string(obj, _typ, _options, _refStack) {
      return new Token(Type.string, obj);
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    boolean(obj, _typ, _options, _refStack) {
      return obj ? simpleTokens.true : simpleTokens.false;
    },
    /**
     * @param {any} _obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    null(_obj, _typ, _options, _refStack) {
      return simpleTokens.null;
    },
    /**
     * @param {any} _obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    undefined(_obj, _typ, _options, _refStack) {
      return simpleTokens.undefined;
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    ArrayBuffer(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, new Uint8Array(obj));
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    DataView(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} options
     * @param {Reference} [refStack]
     * @returns {TokenOrNestedTokens}
     */
    Array(obj, _typ, options, refStack) {
      if (!obj.length) {
        if (options.addBreakTokens === true) {
          return [simpleTokens.emptyArray, new Token(Type.break)];
        }
        return simpleTokens.emptyArray;
      }
      refStack = Ref.createCheck(refStack, obj);
      const entries = [];
      let i = 0;
      for (const e of obj) {
        entries[i++] = objectToTokens(e, options, refStack);
      }
      if (options.addBreakTokens) {
        return [new Token(Type.array, obj.length), entries, new Token(Type.break)];
      }
      return [new Token(Type.array, obj.length), entries];
    },
    /**
     * @param {any} obj
     * @param {string} typ
     * @param {EncodeOptions} options
     * @param {Reference} [refStack]
     * @returns {TokenOrNestedTokens}
     */
    Object(obj, typ, options, refStack) {
      const isMap = typ !== "Object";
      const keys = isMap ? obj.keys() : Object.keys(obj);
      const length4 = isMap ? obj.size : keys.length;
      if (!length4) {
        if (options.addBreakTokens === true) {
          return [simpleTokens.emptyMap, new Token(Type.break)];
        }
        return simpleTokens.emptyMap;
      }
      refStack = Ref.createCheck(refStack, obj);
      const entries = [];
      let i = 0;
      for (const key of keys) {
        entries[i++] = [
          objectToTokens(key, options, refStack),
          objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
        ];
      }
      sortMapEntries(entries, options);
      if (options.addBreakTokens) {
        return [new Token(Type.map, length4), entries, new Token(Type.break)];
      }
      return [new Token(Type.map, length4), entries];
    }
  };
  typeEncoders.Map = typeEncoders.Object;
  typeEncoders.Buffer = typeEncoders.Uint8Array;
  for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
    typeEncoders[`${typ}Array`] = typeEncoders.DataView;
  }
  function objectToTokens(obj, options = {}, refStack) {
    const typ = is(obj);
    const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
    options.typeEncoders[typ] || typeEncoders[typ];
    if (typeof customTypeEncoder === "function") {
      const tokens = customTypeEncoder(obj, typ, options, refStack);
      if (tokens != null) {
        return tokens;
      }
    }
    const typeEncoder = typeEncoders[typ];
    if (!typeEncoder) {
      throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
    }
    return typeEncoder(obj, typ, options, refStack);
  }
  function sortMapEntries(entries, options) {
    if (options.mapSorter) {
      entries.sort(options.mapSorter);
    }
  }

  // node_modules/cborg/lib/decode.js
  var defaultDecodeOptions = {
    strict: false,
    allowIndefinite: true,
    allowUndefined: true,
    allowBigInt: true
  };
  var Tokeniser = class {
    /**
     * @param {Uint8Array} data
     * @param {DecodeOptions} options
     */
    constructor(data, options = {}) {
      this._pos = 0;
      this.data = data;
      this.options = options;
    }
    pos() {
      return this._pos;
    }
    done() {
      return this._pos >= this.data.length;
    }
    next() {
      const byt = this.data[this._pos];
      let token = quick[byt];
      if (token === void 0) {
        const decoder2 = jump[byt];
        if (!decoder2) {
          throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
        }
        const minor = byt & 31;
        token = decoder2(this.data, this._pos, minor, this.options);
      }
      this._pos += token.encodedLength;
      return token;
    }
  };
  var DONE = Symbol.for("DONE");
  var BREAK = Symbol.for("BREAK");
  function tokenToArray(token, tokeniser, options) {
    const arr = [];
    for (let i = 0; i < token.value; i++) {
      const value = tokensToObject(tokeniser, options);
      if (value === BREAK) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
      }
      if (value === DONE) {
        throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
      }
      arr[i] = value;
    }
    return arr;
  }
  function tokenToMap(token, tokeniser, options) {
    const useMaps = options.useMaps === true;
    const obj = useMaps ? void 0 : {};
    const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
    for (let i = 0; i < token.value; i++) {
      const key = tokensToObject(tokeniser, options);
      if (key === BREAK) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
      }
      if (key === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
      }
      if (useMaps !== true && typeof key !== "string") {
        throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
      }
      if (options.rejectDuplicateMapKeys === true) {
        if (useMaps && m.has(key) || !useMaps && key in obj) {
          throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
        }
      }
      const value = tokensToObject(tokeniser, options);
      if (value === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
      }
      if (useMaps) {
        m.set(key, value);
      } else {
        obj[key] = value;
      }
    }
    return useMaps ? m : obj;
  }
  function tokensToObject(tokeniser, options) {
    if (tokeniser.done()) {
      return DONE;
    }
    const token = tokeniser.next();
    if (token.type === Type.break) {
      return BREAK;
    }
    if (token.type.terminal) {
      return token.value;
    }
    if (token.type === Type.array) {
      return tokenToArray(token, tokeniser, options);
    }
    if (token.type === Type.map) {
      return tokenToMap(token, tokeniser, options);
    }
    if (token.type === Type.tag) {
      if (options.tags && typeof options.tags[token.value] === "function") {
        const tagged = tokensToObject(tokeniser, options);
        return options.tags[token.value](tagged);
      }
      throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
    }
    throw new Error("unsupported");
  }
  function decodeFirst(data, options) {
    if (!(data instanceof Uint8Array)) {
      throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
    }
    options = Object.assign({}, defaultDecodeOptions, options);
    const tokeniser = options.tokenizer || new Tokeniser(data, options);
    const decoded = tokensToObject(tokeniser, options);
    if (decoded === DONE) {
      throw new Error(`${decodeErrPrefix} did not find any content to decode`);
    }
    if (decoded === BREAK) {
      throw new Error(`${decodeErrPrefix} got unexpected break`);
    }
    return [decoded, data.subarray(tokeniser.pos())];
  }
  function decode(data, options) {
    const [decoded, remainder] = decodeFirst(data, options);
    if (remainder.length > 0) {
      throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
    }
    return decoded;
  }

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bytes.js
  var empty = new Uint8Array(0);
  function equals(aa, bb) {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/vendor/base-x.js
  function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode10(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length4 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length4) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i2;
        pbegin++;
      }
      var it2 = size - length4;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length4 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length4) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length4;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode16(string) {
      var buffer2 = decodeUnsafe(string);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name} character`);
    }
    return {
      encode: encode10,
      decodeUnsafe,
      decode: decode16
    };
  }
  var src = base;
  var _brrp__multiformats_scope_baseX = src;
  var base_x_default = _brrp__multiformats_scope_baseX;

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base.js
  var Encoder = class {
    constructor(name, prefix, baseEncode) {
      __publicField(this, "name");
      __publicField(this, "prefix");
      __publicField(this, "baseEncode");
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder = class {
    constructor(name, prefix, baseDecode) {
      __publicField(this, "name");
      __publicField(this, "prefix");
      __publicField(this, "baseDecode");
      __publicField(this, "prefixCodePoint");
      this.name = name;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder2) {
      return or(this, decoder2);
    }
  };
  var ComposedDecoder = class {
    constructor(decoders) {
      __publicField(this, "decoders");
      this.decoders = decoders;
    }
    or(decoder2) {
      return or(this, decoder2);
    }
    decode(input) {
      const prefix = input[0];
      const decoder2 = this.decoders[prefix];
      if (decoder2 != null) {
        return decoder2.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or(left, right) {
    var _a3, _b;
    return new ComposedDecoder(__spreadValues(__spreadValues({}, (_a3 = left.decoders) != null ? _a3 : { [left.prefix]: left }), (_b = right.decoders) != null ? _b : { [right.prefix]: right }));
  }
  var Codec = class {
    constructor(name, prefix, baseEncode, baseDecode) {
      __publicField(this, "name");
      __publicField(this, "prefix");
      __publicField(this, "baseEncode");
      __publicField(this, "baseDecode");
      __publicField(this, "encoder");
      __publicField(this, "decoder");
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name, prefix, baseEncode);
      this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from({ name, prefix, encode: encode10, decode: decode16 }) {
    return new Codec(name, prefix, encode10, decode16);
  }
  function baseX({ name, prefix, alphabet }) {
    const { encode: encode10, decode: decode16 } = base_x_default(alphabet, name);
    return from({
      prefix,
      name,
      encode: encode10,
      decode: (text) => coerce(decode16(text))
    });
  }
  function decode2(string, alphabet, bitsPerChar, name) {
    const codes = {};
    for (let i = 0; i < alphabet.length; ++i) {
      codes[alphabet[i]] = i;
    }
    let end = string.length;
    while (string[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = codes[string[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode2(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer2 = buffer2 << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet[mask & buffer2 >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
    return from({
      prefix,
      name,
      encode(input) {
        return encode2(input, alphabet, bitsPerChar);
      },
      decode(input) {
        return decode2(input, alphabet, bitsPerChar, name);
      }
    });
  }

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base32.js
  var base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_1 = encode3;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode3(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode3.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode3 = read;
  var MSB$1 = 128;
  var REST$1 = 127;
  function read(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
    do {
      if (counter >= l) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf2[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read.bytes = counter - offset;
    return res;
  }
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode3,
    encodingLength: length
  };
  var _brrp_varint = varint;
  var varint_default = _brrp_varint;

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/varint.js
  function decode4(data, offset = 0) {
    const code = varint_default.decode(data, offset);
    return [code, varint_default.decode.bytes];
  }
  function encodeTo(int, target2, offset = 0) {
    varint_default.encode(int, target2, offset);
    return target2;
  }
  function encodingLength(int) {
    return varint_default.encodingLength(int);
  }

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/hashes/digest.js
  function create(code, digest) {
    const size = digest.byteLength;
    const sizeOffset = encodingLength(code);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
  }
  function decode5(multihash) {
    const bytes = coerce(multihash);
    const [code, sizeOffset] = decode4(bytes);
    const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code, size, digest, bytes);
  }
  function equals2(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
    }
  }
  var Digest = class {
    /**
     * Creates a multihash digest.
     */
    constructor(code, size, digest, bytes) {
      __publicField(this, "code");
      __publicField(this, "size");
      __publicField(this, "digest");
      __publicField(this, "bytes");
      this.code = code;
      this.size = size;
      this.digest = digest;
      this.bytes = bytes;
    }
  };

  // node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/cid.js
  function format(link, base4) {
    const { bytes, version: version2 } = link;
    switch (version2) {
      case 0:
        return toStringV0(bytes, baseCache(link), base4 != null ? base4 : base58btc.encoder);
      default:
        return toStringV1(bytes, baseCache(link), base4 != null ? base4 : base32.encoder);
    }
  }
  var cache = /* @__PURE__ */ new WeakMap();
  function baseCache(cid) {
    const baseCache3 = cache.get(cid);
    if (baseCache3 == null) {
      const baseCache4 = /* @__PURE__ */ new Map();
      cache.set(cid, baseCache4);
      return baseCache4;
    }
    return baseCache3;
  }
  var _a;
  var CID = class _CID {
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version2, code, multihash, bytes) {
      __publicField(this, "code");
      __publicField(this, "version");
      __publicField(this, "multihash");
      __publicField(this, "bytes");
      __publicField(this, "/");
      __publicField(this, _a, "CID");
      this.code = code;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes;
      this["/"] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code, multihash } = this;
          if (code !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code, digest } = this.multihash;
          const multihash = create(code, digest);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
    }
    toString(base4) {
      return format(this, base4);
    }
    toJSON() {
      return { "/": format(this) };
    }
    link() {
      return this;
    }
    // Legacy
    [(_a = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version2, code, multihash, bytes } = value;
        return new _CID(version2, code, multihash, bytes != null ? bytes : encodeCID(version2, code, multihash.bytes));
      } else if (value[cidSymbol] === true) {
        const { version: version2, multihash, code } = value;
        const digest = decode5(multihash);
        return _CID.create(version2, code, digest);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version2, code, digest) {
      if (typeof code !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version2) {
        case 0: {
          if (code !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new _CID(version2, code, digest, digest.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID(version2, code, digest.bytes);
          return new _CID(version2, code, digest, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest) {
      return _CID.create(0, DAG_PB_CODE, digest);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code, digest) {
      return _CID.create(1, code, digest);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes) {
      const [cid, remainder] = _CID.decodeFirst(bytes);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes) {
      const specs = _CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
      return [cid, bytes.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length4] = decode4(initialBytes.subarray(offset));
        offset += length4;
        return i;
      };
      let version2 = next();
      let codec = DAG_PB_CODE;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version2, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base4) {
      const [prefix, bytes] = parseCIDtoBytes(source, base4);
      const cid = _CID.decode(bytes);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes(source, base4) {
    switch (source[0]) {
      case "Q": {
        const decoder2 = base4 != null ? base4 : base58btc;
        return [
          base58btc.prefix,
          decoder2.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder2 = base4 != null ? base4 : base58btc;
        return [base58btc.prefix, decoder2.decode(source)];
      }
      case base32.prefix: {
        const decoder2 = base4 != null ? base4 : base32;
        return [base32.prefix, decoder2.decode(source)];
      }
      default: {
        if (base4 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base4.decode(source)];
      }
    }
  }
  function toStringV0(bytes, cache3, base4) {
    const { prefix } = base4;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
    }
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base4.encode(bytes).slice(1);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV1(bytes, cache3, base4) {
    const { prefix } = base4;
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base4.encode(bytes);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE = 112;
  var SHA_256_CODE = 18;
  function encodeCID(version2, code, multihash) {
    const codeOffset = encodingLength(version2);
    const hashOffset = codeOffset + encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version2, bytes, 0);
    encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  }
  var cidSymbol = Symbol.for("@ipld/js-cid/CID");

  // node_modules/@ipld/dag-cbor/src/index.js
  var CID_CBOR_TAG = 42;
  function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
      throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
    }
    return CID.decode(bytes.subarray(1));
  }
  var decodeOptions = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // this will lead to BigInt for ints outside of
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */
    tags: []
  };
  decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
  var decode6 = (data) => decode(data, decodeOptions);

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/bytes.js
  var empty2 = new Uint8Array(0);
  function equals3(aa, bb) {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce2(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/vendor/base-x.js
  function base2(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode10(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length4 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length4) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i2;
        pbegin++;
      }
      var it2 = size - length4;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length4 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length4) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length4;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode16(string) {
      var buffer2 = decodeUnsafe(string);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name} character`);
    }
    return {
      encode: encode10,
      decodeUnsafe,
      decode: decode16
    };
  }
  var src2 = base2;
  var _brrp__multiformats_scope_baseX2 = src2;
  var base_x_default2 = _brrp__multiformats_scope_baseX2;

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/bases/base.js
  var Encoder2 = class {
    constructor(name, prefix, baseEncode) {
      __publicField(this, "name");
      __publicField(this, "prefix");
      __publicField(this, "baseEncode");
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder2 = class {
    constructor(name, prefix, baseDecode) {
      __publicField(this, "name");
      __publicField(this, "prefix");
      __publicField(this, "baseDecode");
      __publicField(this, "prefixCodePoint");
      this.name = name;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder2) {
      return or2(this, decoder2);
    }
  };
  var ComposedDecoder2 = class {
    constructor(decoders) {
      __publicField(this, "decoders");
      this.decoders = decoders;
    }
    or(decoder2) {
      return or2(this, decoder2);
    }
    decode(input) {
      const prefix = input[0];
      const decoder2 = this.decoders[prefix];
      if (decoder2 != null) {
        return decoder2.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or2(left, right) {
    var _a3, _b;
    return new ComposedDecoder2(__spreadValues(__spreadValues({}, (_a3 = left.decoders) != null ? _a3 : { [left.prefix]: left }), (_b = right.decoders) != null ? _b : { [right.prefix]: right }));
  }
  var Codec2 = class {
    constructor(name, prefix, baseEncode, baseDecode) {
      __publicField(this, "name");
      __publicField(this, "prefix");
      __publicField(this, "baseEncode");
      __publicField(this, "baseDecode");
      __publicField(this, "encoder");
      __publicField(this, "decoder");
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder2(name, prefix, baseEncode);
      this.decoder = new Decoder2(name, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from2({ name, prefix, encode: encode10, decode: decode16 }) {
    return new Codec2(name, prefix, encode10, decode16);
  }
  function baseX2({ name, prefix, alphabet }) {
    const { encode: encode10, decode: decode16 } = base_x_default2(alphabet, name);
    return from2({
      prefix,
      name,
      encode: encode10,
      decode: (text) => coerce2(decode16(text))
    });
  }
  function decode7(string, alphabet, bitsPerChar, name) {
    const codes = {};
    for (let i = 0; i < alphabet.length; ++i) {
      codes[alphabet[i]] = i;
    }
    let end = string.length;
    while (string[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = codes[string[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode4(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer2 = buffer2 << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet[mask & buffer2 >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function rfc46482({ name, prefix, bitsPerChar, alphabet }) {
    return from2({
      prefix,
      name,
      encode(input) {
        return encode4(input, alphabet, bitsPerChar);
      },
      decode(input) {
        return decode7(input, alphabet, bitsPerChar, name);
      }
    });
  }

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/bases/base32.js
  var base322 = rfc46482({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper2 = rfc46482({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad2 = rfc46482({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper2 = rfc46482({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex2 = rfc46482({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper2 = rfc46482({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad2 = rfc46482({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper2 = rfc46482({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z2 = rfc46482({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/bases/base58.js
  var base58btc2 = baseX2({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr2 = baseX2({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/vendor/varint.js
  var encode_12 = encode5;
  var MSB2 = 128;
  var REST2 = 127;
  var MSBALL2 = ~REST2;
  var INT2 = Math.pow(2, 31);
  function encode5(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT2) {
      out[offset++] = num & 255 | MSB2;
      num /= 128;
    }
    while (num & MSBALL2) {
      out[offset++] = num & 255 | MSB2;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode5.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode8 = read2;
  var MSB$12 = 128;
  var REST$12 = 127;
  function read2(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
    do {
      if (counter >= l) {
        read2.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf2[counter++];
      res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$12);
    read2.bytes = counter - offset;
    return res;
  }
  var N12 = Math.pow(2, 7);
  var N22 = Math.pow(2, 14);
  var N32 = Math.pow(2, 21);
  var N42 = Math.pow(2, 28);
  var N52 = Math.pow(2, 35);
  var N62 = Math.pow(2, 42);
  var N72 = Math.pow(2, 49);
  var N82 = Math.pow(2, 56);
  var N92 = Math.pow(2, 63);
  var length2 = function(value) {
    return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
  };
  var varint2 = {
    encode: encode_12,
    decode: decode8,
    encodingLength: length2
  };
  var _brrp_varint2 = varint2;
  var varint_default2 = _brrp_varint2;

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/varint.js
  function decode9(data, offset = 0) {
    const code = varint_default2.decode(data, offset);
    return [code, varint_default2.decode.bytes];
  }
  function encodeTo2(int, target2, offset = 0) {
    varint_default2.encode(int, target2, offset);
    return target2;
  }
  function encodingLength2(int) {
    return varint_default2.encodingLength(int);
  }

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/hashes/digest.js
  function create2(code, digest) {
    const size = digest.byteLength;
    const sizeOffset = encodingLength2(code);
    const digestOffset = sizeOffset + encodingLength2(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo2(code, bytes, 0);
    encodeTo2(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest2(code, size, digest, bytes);
  }
  function decode10(multihash) {
    const bytes = coerce2(multihash);
    const [code, sizeOffset] = decode9(bytes);
    const [size, digestOffset] = decode9(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest2(code, size, digest, bytes);
  }
  function equals4(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals3(a.bytes, data.bytes);
    }
  }
  var Digest2 = class {
    /**
     * Creates a multihash digest.
     */
    constructor(code, size, digest, bytes) {
      __publicField(this, "code");
      __publicField(this, "size");
      __publicField(this, "digest");
      __publicField(this, "bytes");
      this.code = code;
      this.size = size;
      this.digest = digest;
      this.bytes = bytes;
    }
  };

  // node_modules/@ipld/car/node_modules/multiformats/dist/src/cid.js
  function format2(link, base4) {
    const { bytes, version: version2 } = link;
    switch (version2) {
      case 0:
        return toStringV02(bytes, baseCache2(link), base4 != null ? base4 : base58btc2.encoder);
      default:
        return toStringV12(bytes, baseCache2(link), base4 != null ? base4 : base322.encoder);
    }
  }
  var cache2 = /* @__PURE__ */ new WeakMap();
  function baseCache2(cid) {
    const baseCache3 = cache2.get(cid);
    if (baseCache3 == null) {
      const baseCache4 = /* @__PURE__ */ new Map();
      cache2.set(cid, baseCache4);
      return baseCache4;
    }
    return baseCache3;
  }
  var _a2;
  var CID2 = class _CID {
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version2, code, multihash, bytes) {
      __publicField(this, "code");
      __publicField(this, "version");
      __publicField(this, "multihash");
      __publicField(this, "bytes");
      __publicField(this, "/");
      __publicField(this, _a2, "CID");
      this.code = code;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes;
      this["/"] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code, multihash } = this;
          if (code !== DAG_PB_CODE2) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE2) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code, digest } = this.multihash;
          const multihash = create2(code, digest);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals4(self2.multihash, unknown.multihash);
    }
    toString(base4) {
      return format2(this, base4);
    }
    toJSON() {
      return { "/": format2(this) };
    }
    link() {
      return this;
    }
    // Legacy
    [(_a2 = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version2, code, multihash, bytes } = value;
        return new _CID(version2, code, multihash, bytes != null ? bytes : encodeCID2(version2, code, multihash.bytes));
      } else if (value[cidSymbol2] === true) {
        const { version: version2, multihash, code } = value;
        const digest = decode10(multihash);
        return _CID.create(version2, code, digest);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version2, code, digest) {
      if (typeof code !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version2) {
        case 0: {
          if (code !== DAG_PB_CODE2) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
          } else {
            return new _CID(version2, code, digest, digest.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID2(version2, code, digest.bytes);
          return new _CID(version2, code, digest, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest) {
      return _CID.create(0, DAG_PB_CODE2, digest);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code, digest) {
      return _CID.create(1, code, digest);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes) {
      const [cid, remainder] = _CID.decodeFirst(bytes);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes) {
      const specs = _CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
      return [cid, bytes.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length4] = decode9(initialBytes.subarray(offset));
        offset += length4;
        return i;
      };
      let version2 = next();
      let codec = DAG_PB_CODE2;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version2, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base4) {
      const [prefix, bytes] = parseCIDtoBytes2(source, base4);
      const cid = _CID.decode(bytes);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache2(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes2(source, base4) {
    switch (source[0]) {
      case "Q": {
        const decoder2 = base4 != null ? base4 : base58btc2;
        return [
          base58btc2.prefix,
          decoder2.decode(`${base58btc2.prefix}${source}`)
        ];
      }
      case base58btc2.prefix: {
        const decoder2 = base4 != null ? base4 : base58btc2;
        return [base58btc2.prefix, decoder2.decode(source)];
      }
      case base322.prefix: {
        const decoder2 = base4 != null ? base4 : base322;
        return [base322.prefix, decoder2.decode(source)];
      }
      default: {
        if (base4 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base4.decode(source)];
      }
    }
  }
  function toStringV02(bytes, cache3, base4) {
    const { prefix } = base4;
    if (prefix !== base58btc2.prefix) {
      throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
    }
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base4.encode(bytes).slice(1);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV12(bytes, cache3, base4) {
    const { prefix } = base4;
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base4.encode(bytes);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE2 = 112;
  var SHA_256_CODE2 = 18;
  function encodeCID2(version2, code, multihash) {
    const codeOffset = encodingLength2(version2);
    const hashOffset = codeOffset + encodingLength2(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo2(version2, bytes, 0);
    encodeTo2(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  }
  var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");

  // node_modules/@ipld/car/src/decoder-common.js
  var import_varint3 = __toESM(require_varint(), 1);
  var CIDV0_BYTES = {
    SHA2_256: 18,
    LENGTH: 32,
    DAG_PB: 112
  };
  var V2_HEADER_LENGTH = (
    /* characteristics */
    16 + 8 + 8 + 8
  );
  function decodeVarint(bytes, seeker) {
    if (!bytes.length) {
      throw new Error("Unexpected end of data");
    }
    const i = import_varint3.default.decode(bytes);
    seeker.seek(
      /** @type {number} */
      import_varint3.default.decode.bytes
    );
    return i;
  }
  function decodeV2Header(bytes) {
    const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;
    const header = {
      version: 2,
      /** @type {[bigint, bigint]} */
      characteristics: [
        dv.getBigUint64(offset, true),
        dv.getBigUint64(offset += 8, true)
      ],
      dataOffset: Number(dv.getBigUint64(offset += 8, true)),
      dataSize: Number(dv.getBigUint64(offset += 8, true)),
      indexOffset: Number(dv.getBigUint64(offset += 8, true))
    };
    return header;
  }
  function getMultihashLength(bytes) {
    import_varint3.default.decode(bytes);
    const codeLength = (
      /** @type {number} */
      import_varint3.default.decode.bytes
    );
    const length4 = import_varint3.default.decode(bytes.subarray(import_varint3.default.decode.bytes));
    const lengthLength = (
      /** @type {number} */
      import_varint3.default.decode.bytes
    );
    const mhLength = codeLength + lengthLength + length4;
    return mhLength;
  }

  // node_modules/@ipld/car/src/header-validator.js
  var Kinds = {
    Null: (
      /** @returns {undefined|null} */
      (obj) => obj === null ? obj : void 0
    ),
    Int: (
      /** @returns {undefined|number} */
      (obj) => Number.isInteger(obj) ? obj : void 0
    ),
    Float: (
      /** @returns {undefined|number} */
      (obj) => typeof obj === "number" && Number.isFinite(obj) ? obj : void 0
    ),
    String: (
      /** @returns {undefined|string} */
      (obj) => typeof obj === "string" ? obj : void 0
    ),
    Bool: (
      /** @returns {undefined|boolean} */
      (obj) => typeof obj === "boolean" ? obj : void 0
    ),
    Bytes: (
      /** @returns {undefined|Uint8Array} */
      (obj) => obj instanceof Uint8Array ? obj : void 0
    ),
    Link: (
      /** @returns {undefined|object} */
      (obj) => obj !== null && typeof obj === "object" && obj.asCID === obj ? obj : void 0
    ),
    List: (
      /** @returns {undefined|Array<any>} */
      (obj) => Array.isArray(obj) ? obj : void 0
    ),
    Map: (
      /** @returns {undefined|object} */
      (obj) => obj !== null && typeof obj === "object" && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : void 0
    )
  };
  var Types = {
    "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
    "CarV1HeaderOrV2Pragma > roots (anon)": (
      /** @returns {undefined|any} */
      (obj) => {
        if (Kinds.List(obj) === void 0) {
          return void 0;
        }
        for (let i = 0; i < obj.length; i++) {
          let v = obj[i];
          v = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
          if (v === void 0) {
            return void 0;
          }
          if (v !== obj[i]) {
            const ret = obj.slice(0, i);
            for (let j = i; j < obj.length; j++) {
              let v2 = obj[j];
              v2 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
              if (v2 === void 0) {
                return void 0;
              }
              ret.push(v2);
            }
            return ret;
          }
        }
        return obj;
      }
    ),
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: (
      /** @returns {undefined|any} */
      (obj) => {
        if (Kinds.Map(obj) === void 0) {
          return void 0;
        }
        const entries = Object.entries(obj);
        let ret = obj;
        let requiredCount = 1;
        for (let i = 0; i < entries.length; i++) {
          const [key, value] = entries[i];
          switch (key) {
            case "roots":
              {
                const v = Types["CarV1HeaderOrV2Pragma > roots (anon)"](obj[key]);
                if (v === void 0) {
                  return void 0;
                }
                if (v !== value || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j = 0; j < i; j++) {
                      ret[entries[j][0]] = entries[j][1];
                    }
                  }
                  ret.roots = v;
                }
              }
              break;
            case "version":
              {
                requiredCount--;
                const v = Types.Int(obj[key]);
                if (v === void 0) {
                  return void 0;
                }
                if (v !== value || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j = 0; j < i; j++) {
                      ret[entries[j][0]] = entries[j][1];
                    }
                  }
                  ret.version = v;
                }
              }
              break;
            default:
              return void 0;
          }
        }
        if (requiredCount > 0) {
          return void 0;
        }
        return ret;
      }
    )
  };
  var Reprs = {
    "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
    "CarV1HeaderOrV2Pragma > roots (anon)": (
      /** @returns {undefined|any} */
      (obj) => {
        if (Kinds.List(obj) === void 0) {
          return void 0;
        }
        for (let i = 0; i < obj.length; i++) {
          let v = obj[i];
          v = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
          if (v === void 0) {
            return void 0;
          }
          if (v !== obj[i]) {
            const ret = obj.slice(0, i);
            for (let j = i; j < obj.length; j++) {
              let v2 = obj[j];
              v2 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
              if (v2 === void 0) {
                return void 0;
              }
              ret.push(v2);
            }
            return ret;
          }
        }
        return obj;
      }
    ),
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: (
      /** @returns {undefined|any} */
      (obj) => {
        if (Kinds.Map(obj) === void 0) {
          return void 0;
        }
        const entries = Object.entries(obj);
        let ret = obj;
        let requiredCount = 1;
        for (let i = 0; i < entries.length; i++) {
          const [key, value] = entries[i];
          switch (key) {
            case "roots":
              {
                const v = Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](value);
                if (v === void 0) {
                  return void 0;
                }
                if (v !== value || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j = 0; j < i; j++) {
                      ret[entries[j][0]] = entries[j][1];
                    }
                  }
                  ret.roots = v;
                }
              }
              break;
            case "version":
              {
                requiredCount--;
                const v = Reprs.Int(value);
                if (v === void 0) {
                  return void 0;
                }
                if (v !== value || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j = 0; j < i; j++) {
                      ret[entries[j][0]] = entries[j][1];
                    }
                  }
                  ret.version = v;
                }
              }
              break;
            default:
              return void 0;
          }
        }
        if (requiredCount > 0) {
          return void 0;
        }
        return ret;
      }
    )
  };
  var CarV1HeaderOrV2Pragma = {
    toTyped: Types.CarV1HeaderOrV2Pragma,
    toRepresentation: Reprs.CarV1HeaderOrV2Pragma
  };

  // node_modules/cborg/lib/length.js
  var cborEncoders2 = makeCborEncoders();

  // node_modules/@ipld/car/src/buffer-writer.js
  var import_varint4 = __toESM(require_varint(), 1);
  var headerPreludeTokens = [
    new Token(Type.map, 2),
    new Token(Type.string, "version"),
    new Token(Type.uint, 1),
    new Token(Type.string, "roots")
  ];
  var CID_TAG = new Token(Type.tag, 42);

  // node_modules/@ipld/car/src/indexed-reader.js
  var import_fs = __toESM(__require("fs"), 1);
  var import_stream = __require("stream");

  // node_modules/@ipld/car/src/decoder.js
  function readHeader(reader, strictVersion) {
    return __async(this, null, function* () {
      const length4 = decodeVarint(yield reader.upTo(8), reader);
      if (length4 === 0) {
        throw new Error("Invalid CAR header (zero length)");
      }
      const header = yield reader.exactly(length4, true);
      const block = decode6(header);
      if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
        throw new Error("Invalid CAR header format");
      }
      if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
      }
      if (block.version === 1) {
        if (!Array.isArray(block.roots)) {
          throw new Error("Invalid CAR header format");
        }
        return block;
      }
      if (block.roots !== void 0) {
        throw new Error("Invalid CAR header format");
      }
      const v2Header = decodeV2Header(yield reader.exactly(V2_HEADER_LENGTH, true));
      reader.seek(v2Header.dataOffset - reader.pos);
      const v1Header = yield readHeader(reader, 1);
      return Object.assign(v1Header, v2Header);
    });
  }
  function readCid(reader) {
    return __async(this, null, function* () {
      const first = yield reader.exactly(2, false);
      if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
        const bytes2 = yield reader.exactly(34, true);
        const multihash2 = decode10(bytes2);
        return CID2.create(0, CIDV0_BYTES.DAG_PB, multihash2);
      }
      const version2 = decodeVarint(yield reader.upTo(8), reader);
      if (version2 !== 1) {
        throw new Error(`Unexpected CID version (${version2})`);
      }
      const codec = decodeVarint(yield reader.upTo(8), reader);
      const bytes = yield reader.exactly(getMultihashLength(yield reader.upTo(8)), true);
      const multihash = decode10(bytes);
      return CID2.create(version2, codec, multihash);
    });
  }
  function readBlockHead(reader) {
    return __async(this, null, function* () {
      const start = reader.pos;
      let length4 = decodeVarint(yield reader.upTo(8), reader);
      if (length4 === 0) {
        throw new Error("Invalid CAR section (zero length)");
      }
      length4 += reader.pos - start;
      const cid = yield readCid(reader);
      const blockLength = length4 - Number(reader.pos - start);
      return { cid, length: length4, blockLength };
    });
  }
  function readBlock(reader) {
    return __async(this, null, function* () {
      const { cid, blockLength } = yield readBlockHead(reader);
      const bytes = yield reader.exactly(blockLength, true);
      return { bytes, cid };
    });
  }
  function readBlockIndex(reader) {
    return __async(this, null, function* () {
      const offset = reader.pos;
      const { cid, length: length4, blockLength } = yield readBlockHead(reader);
      const index = { cid, length: length4, blockLength, offset, blockOffset: reader.pos };
      reader.seek(index.blockLength);
      return index;
    });
  }
  function createDecoder(reader) {
    const headerPromise = (() => __async(this, null, function* () {
      const header = yield readHeader(reader);
      if (header.version === 2) {
        const v1length = reader.pos - header.dataOffset;
        reader = limitReader(reader, header.dataSize - v1length);
      }
      return header;
    }))();
    return {
      header: () => headerPromise,
      blocks() {
        return __asyncGenerator(this, null, function* () {
          yield new __await(headerPromise);
          while ((yield new __await(reader.upTo(8))).length > 0) {
            yield yield new __await(readBlock(reader));
          }
        });
      },
      blocksIndex() {
        return __asyncGenerator(this, null, function* () {
          yield new __await(headerPromise);
          while ((yield new __await(reader.upTo(8))).length > 0) {
            yield yield new __await(readBlockIndex(reader));
          }
        });
      }
    };
  }
  function bytesReader(bytes) {
    let pos = 0;
    return {
      upTo(length4) {
        return __async(this, null, function* () {
          const out = bytes.subarray(pos, pos + Math.min(length4, bytes.length - pos));
          return out;
        });
      },
      exactly(length4, seek = false) {
        return __async(this, null, function* () {
          if (length4 > bytes.length - pos) {
            throw new Error("Unexpected end of data");
          }
          const out = bytes.subarray(pos, pos + length4);
          if (seek) {
            pos += length4;
          }
          return out;
        });
      },
      seek(length4) {
        pos += length4;
      },
      get pos() {
        return pos;
      }
    };
  }
  function chunkReader(readChunk) {
    let pos = 0;
    let have = 0;
    let offset = 0;
    let currentChunk = new Uint8Array(0);
    const read5 = (length4) => __async(this, null, function* () {
      have = currentChunk.length - offset;
      const bufa = [currentChunk.subarray(offset)];
      while (have < length4) {
        const chunk = yield readChunk();
        if (chunk == null) {
          break;
        }
        if (have < 0) {
          if (chunk.length > have) {
            bufa.push(chunk.subarray(-have));
          }
        } else {
          bufa.push(chunk);
        }
        have += chunk.length;
      }
      currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
      let off = 0;
      for (const b of bufa) {
        currentChunk.set(b, off);
        off += b.length;
      }
      offset = 0;
    });
    return {
      upTo(length4) {
        return __async(this, null, function* () {
          if (currentChunk.length - offset < length4) {
            yield read5(length4);
          }
          return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length4));
        });
      },
      exactly(length4, seek = false) {
        return __async(this, null, function* () {
          if (currentChunk.length - offset < length4) {
            yield read5(length4);
          }
          if (currentChunk.length - offset < length4) {
            throw new Error("Unexpected end of data");
          }
          const out = currentChunk.subarray(offset, offset + length4);
          if (seek) {
            pos += length4;
            offset += length4;
          }
          return out;
        });
      },
      seek(length4) {
        pos += length4;
        offset += length4;
      },
      get pos() {
        return pos;
      }
    };
  }
  function asyncIterableReader(asyncIterable) {
    const iterator = asyncIterable[Symbol.asyncIterator]();
    function readChunk() {
      return __async(this, null, function* () {
        const next = yield iterator.next();
        if (next.done) {
          return null;
        }
        return next.value;
      });
    }
    return chunkReader(readChunk);
  }
  function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    return {
      upTo(length4) {
        return __async(this, null, function* () {
          let bytes = yield reader.upTo(length4);
          if (bytes.length + bytesRead > byteLimit) {
            bytes = bytes.subarray(0, byteLimit - bytesRead);
          }
          return bytes;
        });
      },
      exactly(length4, seek = false) {
        return __async(this, null, function* () {
          const bytes = yield reader.exactly(length4, seek);
          if (bytes.length + bytesRead > byteLimit) {
            throw new Error("Unexpected end of data");
          }
          if (seek) {
            bytesRead += length4;
          }
          return bytes;
        });
      },
      seek(length4) {
        bytesRead += length4;
        reader.seek(length4);
      },
      get pos() {
        return reader.pos;
      }
    };
  }

  // node_modules/@ipld/car/src/reader-browser.js
  var CarReader = class {
    /**
     * @constructs CarReader
     * @param {CarHeader|CarV2Header} header
     * @param {Block[]} blocks
     */
    constructor(header, blocks) {
      this._header = header;
      this._blocks = blocks;
      this._keys = blocks.map((b) => b.cid.toString());
    }
    /**
     * @property
     * @memberof CarReader
     * @instance
     */
    get version() {
      return this._header.version;
    }
    /**
     * Get the list of roots defined by the CAR referenced by this reader. May be
     * zero or more `CID`s.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @returns {Promise<CID[]>}
     */
    getRoots() {
      return __async(this, null, function* () {
        return this._header.roots;
      });
    }
    /**
     * Check whether a given `CID` exists within the CAR referenced by this
     * reader.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @param {CID} key
     * @returns {Promise<boolean>}
     */
    has(key) {
      return __async(this, null, function* () {
        return this._keys.indexOf(key.toString()) > -1;
      });
    }
    /**
     * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
     * referenced by this reader matching the provided `CID`. In the case where
     * the provided `CID` doesn't exist within the CAR, `undefined` will be
     * returned.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @param {CID} key
     * @returns {Promise<Block | undefined>}
     */
    get(key) {
      return __async(this, null, function* () {
        const index = this._keys.indexOf(key.toString());
        return index > -1 ? this._blocks[index] : void 0;
      });
    }
    /**
     * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all
     * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
     * the CAR referenced by this reader.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @generator
     * @returns {AsyncGenerator<Block>}
     */
    blocks() {
      return __asyncGenerator(this, null, function* () {
        for (const block of this._blocks) {
          yield block;
        }
      });
    }
    /**
     * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of
     * the `CID`s contained within the CAR referenced by this reader.
     *
     * @function
     * @memberof CarReader
     * @instance
     * @async
     * @generator
     * @returns {AsyncGenerator<CID>}
     */
    cids() {
      return __asyncGenerator(this, null, function* () {
        for (const block of this._blocks) {
          yield block.cid;
        }
      });
    }
    /**
     * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a
     * decode fully in memory and maintains the decoded state in memory for full
     * access to the data via the `CarReader` API.
     *
     * @async
     * @static
     * @memberof CarReader
     * @param {Uint8Array} bytes
     * @returns {Promise<CarReader>}
     */
    static fromBytes(bytes) {
      return __async(this, null, function* () {
        if (!(bytes instanceof Uint8Array)) {
          throw new TypeError("fromBytes() requires a Uint8Array");
        }
        return decodeReaderComplete(bytesReader(bytes));
      });
    }
    /**
     * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as
     * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
     * This performs a decode fully in memory and maintains the decoded state in
     * memory for full access to the data via the `CarReader` API.
     *
     * Care should be taken for large archives; this API may not be appropriate
     * where memory is a concern or the archive is potentially larger than the
     * amount of memory that the runtime can handle.
     *
     * @async
     * @static
     * @memberof CarReader
     * @param {AsyncIterable<Uint8Array>} asyncIterable
     * @returns {Promise<CarReader>}
     */
    static fromIterable(asyncIterable) {
      return __async(this, null, function* () {
        if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
          throw new TypeError("fromIterable() requires an async iterable");
        }
        return decodeReaderComplete(asyncIterableReader(asyncIterable));
      });
    }
  };
  function decodeReaderComplete(reader) {
    return __async(this, null, function* () {
      const decoder2 = createDecoder(reader);
      const header = yield decoder2.header();
      const blocks = [];
      try {
        for (var iter = __forAwait(decoder2.blocks()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const block = temp.value;
          blocks.push(block);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return new CarReader(header, blocks);
    });
  }

  // node_modules/@ipld/car/src/encoder.js
  var import_varint5 = __toESM(require_varint(), 1);

  // node_modules/cbor-x/index.js
  var cbor_x_exports = {};
  __export(cbor_x_exports, {
    ALWAYS: () => ALWAYS,
    DECIMAL_FIT: () => DECIMAL_FIT,
    DECIMAL_ROUND: () => DECIMAL_ROUND,
    Decoder: () => Decoder3,
    Encoder: () => Encoder3,
    FLOAT32_OPTIONS: () => FLOAT32_OPTIONS,
    NEVER: () => NEVER,
    REUSE_BUFFER_MODE: () => REUSE_BUFFER_MODE,
    Tag: () => Tag,
    addExtension: () => addExtension2,
    clearSource: () => clearSource,
    decode: () => decode11,
    decodeIter: () => decodeIter,
    decodeMultiple: () => decodeMultiple,
    encode: () => encode7,
    encodeAsAsyncIterable: () => encodeAsAsyncIterable,
    encodeAsIterable: () => encodeAsIterable,
    encodeIter: () => encodeIter,
    isNativeAccelerationEnabled: () => isNativeAccelerationEnabled,
    roundFloat32: () => roundFloat32
  });

  // node_modules/cbor-x/decode.js
  var decoder;
  try {
    decoder = new TextDecoder();
  } catch (error) {
  }
  var src3;
  var srcEnd;
  var position = 0;
  var EMPTY_ARRAY = [];
  var LEGACY_RECORD_INLINE_ID = 105;
  var RECORD_DEFINITIONS_ID = 57342;
  var RECORD_INLINE_ID = 57343;
  var BUNDLED_STRINGS_ID = 57337;
  var PACKED_REFERENCE_TAG_ID = 6;
  var STOP_CODE = {};
  var strings = EMPTY_ARRAY;
  var stringPosition = 0;
  var currentDecoder = {};
  var currentStructures;
  var srcString;
  var srcStringStart = 0;
  var srcStringEnd = 0;
  var bundledStrings;
  var referenceMap;
  var currentExtensions = [];
  var currentExtensionRanges = [];
  var packedValues;
  var dataView2;
  var restoreMapsAsObject;
  var defaultOptions = {
    useRecords: false,
    mapsAsObjects: true
  };
  var sequentialMode = false;
  var inlineObjectReadThreshold = 2;
  try {
    new Function("");
  } catch (error) {
    inlineObjectReadThreshold = Infinity;
  }
  var Decoder3 = class _Decoder {
    constructor(options) {
      if (options) {
        if ((options.keyMap || options._keyMap) && !options.useRecords) {
          options.useRecords = false;
          options.mapsAsObjects = true;
        }
        if (options.useRecords === false && options.mapsAsObjects === void 0)
          options.mapsAsObjects = true;
        if (options.getStructures)
          options.getShared = options.getStructures;
        if (options.getShared && !options.structures)
          (options.structures = []).uninitialized = true;
        if (options.keyMap) {
          this.mapKey = /* @__PURE__ */ new Map();
          for (let [k, v] of Object.entries(options.keyMap))
            this.mapKey.set(v, k);
        }
      }
      Object.assign(this, options);
    }
    /*
    decodeKey(key) {
    	return this.keyMap
    		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
    		: key
    }
    */
    decodeKey(key) {
      return this.keyMap ? this.mapKey.get(key) || key : key;
    }
    encodeKey(key) {
      return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
    }
    encodeKeys(rec) {
      if (!this._keyMap)
        return rec;
      let map = /* @__PURE__ */ new Map();
      for (let [k, v] of Object.entries(rec))
        map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
      return map;
    }
    decodeKeys(map) {
      if (!this._keyMap || map.constructor.name != "Map")
        return map;
      if (!this._mapKey) {
        this._mapKey = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(this._keyMap))
          this._mapKey.set(v, k);
      }
      let res = {};
      map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
      return res;
    }
    mapDecode(source, end) {
      let res = this.decode(source);
      if (this._keyMap) {
        switch (res.constructor.name) {
          case "Array":
            return res.map((r) => this.decodeKeys(r));
        }
      }
      return res;
    }
    decode(source, end) {
      if (src3) {
        return saveState(() => {
          clearSource();
          return this ? this.decode(source, end) : _Decoder.prototype.decode.call(defaultOptions, source, end);
        });
      }
      srcEnd = end > -1 ? end : source.length;
      position = 0;
      stringPosition = 0;
      srcStringEnd = 0;
      srcString = null;
      strings = EMPTY_ARRAY;
      bundledStrings = null;
      src3 = source;
      try {
        dataView2 = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
      } catch (error) {
        src3 = null;
        if (source instanceof Uint8Array)
          throw error;
        throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
      }
      if (this instanceof _Decoder) {
        currentDecoder = this;
        packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
        if (this.structures) {
          currentStructures = this.structures;
          return checkedRead();
        } else if (!currentStructures || currentStructures.length > 0) {
          currentStructures = [];
        }
      } else {
        currentDecoder = defaultOptions;
        if (!currentStructures || currentStructures.length > 0)
          currentStructures = [];
        packedValues = null;
      }
      return checkedRead();
    }
    decodeMultiple(source, forEach) {
      let values, lastPosition = 0;
      try {
        let size = source.length;
        sequentialMode = true;
        let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
        if (forEach) {
          if (forEach(value) === false) {
            return;
          }
          while (position < size) {
            lastPosition = position;
            if (forEach(checkedRead()) === false) {
              return;
            }
          }
        } else {
          values = [value];
          while (position < size) {
            lastPosition = position;
            values.push(checkedRead());
          }
          return values;
        }
      } catch (error) {
        error.lastPosition = lastPosition;
        error.values = values;
        throw error;
      } finally {
        sequentialMode = false;
        clearSource();
      }
    }
  };
  function checkedRead() {
    try {
      let result = read3();
      if (bundledStrings) {
        if (position >= bundledStrings.postBundlePosition) {
          let error = new Error("Unexpected bundle position");
          error.incomplete = true;
          throw error;
        }
        position = bundledStrings.postBundlePosition;
        bundledStrings = null;
      }
      if (position == srcEnd) {
        currentStructures = null;
        src3 = null;
        if (referenceMap)
          referenceMap = null;
      } else if (position > srcEnd) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      } else if (!sequentialMode) {
        throw new Error("Data read, but end of buffer not reached");
      }
      return result;
    } catch (error) {
      clearSource();
      if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
        error.incomplete = true;
      }
      throw error;
    }
  }
  function read3() {
    let token = src3[position++];
    let majorType = token >> 5;
    token = token & 31;
    if (token > 23) {
      switch (token) {
        case 24:
          token = src3[position++];
          break;
        case 25:
          if (majorType == 7) {
            return getFloat16();
          }
          token = dataView2.getUint16(position);
          position += 2;
          break;
        case 26:
          if (majorType == 7) {
            let value = dataView2.getFloat32(position);
            if (currentDecoder.useFloat32 > 2) {
              let multiplier = mult10[(src3[position] & 127) << 1 | src3[position + 1] >> 7];
              position += 4;
              return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
            }
            position += 4;
            return value;
          }
          token = dataView2.getUint32(position);
          position += 4;
          break;
        case 27:
          if (majorType == 7) {
            let value = dataView2.getFloat64(position);
            position += 8;
            return value;
          }
          if (majorType > 1) {
            if (dataView2.getUint32(position) > 0)
              throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
            token = dataView2.getUint32(position + 4);
          } else if (currentDecoder.int64AsNumber) {
            token = dataView2.getUint32(position) * 4294967296;
            token += dataView2.getUint32(position + 4);
          } else
            token = dataView2.getBigUint64(position);
          position += 8;
          break;
        case 31:
          switch (majorType) {
            case 2:
            case 3:
              throw new Error("Indefinite length not supported for byte or text strings");
            case 4:
              let array = [];
              let value, i = 0;
              while ((value = read3()) != STOP_CODE) {
                array[i++] = value;
              }
              return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
            case 5:
              let key;
              if (currentDecoder.mapsAsObjects) {
                let object = {};
                if (currentDecoder.keyMap)
                  while ((key = read3()) != STOP_CODE)
                    object[safeKey(currentDecoder.decodeKey(key))] = read3();
                else
                  while ((key = read3()) != STOP_CODE)
                    object[safeKey(key)] = read3();
                return object;
              } else {
                if (restoreMapsAsObject) {
                  currentDecoder.mapsAsObjects = true;
                  restoreMapsAsObject = false;
                }
                let map = /* @__PURE__ */ new Map();
                if (currentDecoder.keyMap)
                  while ((key = read3()) != STOP_CODE)
                    map.set(currentDecoder.decodeKey(key), read3());
                else
                  while ((key = read3()) != STOP_CODE)
                    map.set(key, read3());
                return map;
              }
            case 7:
              return STOP_CODE;
            default:
              throw new Error("Invalid major type for indefinite length " + majorType);
          }
        default:
          throw new Error("Unknown token " + token);
      }
    }
    switch (majorType) {
      case 0:
        return token;
      case 1:
        return ~token;
      case 2:
        return readBin(token);
      case 3:
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
        }
        if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
          let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
          if (string != null)
            return string;
        }
        return readFixedString(token);
      case 4:
        let array = new Array(token);
        for (let i = 0; i < token; i++)
          array[i] = read3();
        return array;
      case 5:
        if (currentDecoder.mapsAsObjects) {
          let object = {};
          if (currentDecoder.keyMap)
            for (let i = 0; i < token; i++)
              object[safeKey(currentDecoder.decodeKey(read3()))] = read3();
          else
            for (let i = 0; i < token; i++)
              object[safeKey(read3())] = read3();
          return object;
        } else {
          if (restoreMapsAsObject) {
            currentDecoder.mapsAsObjects = true;
            restoreMapsAsObject = false;
          }
          let map = /* @__PURE__ */ new Map();
          if (currentDecoder.keyMap)
            for (let i = 0; i < token; i++)
              map.set(currentDecoder.decodeKey(read3()), read3());
          else
            for (let i = 0; i < token; i++)
              map.set(read3(), read3());
          return map;
        }
      case 6:
        if (token >= BUNDLED_STRINGS_ID) {
          let structure = currentStructures[token & 8191];
          if (structure) {
            if (!structure.read)
              structure.read = createStructureReader(structure);
            return structure.read();
          }
          if (token < 65536) {
            if (token == RECORD_INLINE_ID) {
              let length4 = readJustLength();
              let id = read3();
              let structure2 = read3();
              recordDefinition(id, structure2);
              let object = {};
              if (currentDecoder.keyMap)
                for (let i = 2; i < length4; i++) {
                  let key = currentDecoder.decodeKey(structure2[i - 2]);
                  object[safeKey(key)] = read3();
                }
              else
                for (let i = 2; i < length4; i++) {
                  let key = structure2[i - 2];
                  object[safeKey(key)] = read3();
                }
              return object;
            } else if (token == RECORD_DEFINITIONS_ID) {
              let length4 = readJustLength();
              let id = read3();
              for (let i = 2; i < length4; i++) {
                recordDefinition(id++, read3());
              }
              return read3();
            } else if (token == BUNDLED_STRINGS_ID) {
              return readBundleExt();
            }
            if (currentDecoder.getShared) {
              loadShared();
              structure = currentStructures[token & 8191];
              if (structure) {
                if (!structure.read)
                  structure.read = createStructureReader(structure);
                return structure.read();
              }
            }
          }
        }
        let extension = currentExtensions[token];
        if (extension) {
          if (extension.handlesRead)
            return extension(read3);
          else
            return extension(read3());
        } else {
          let input = read3();
          for (let i = 0; i < currentExtensionRanges.length; i++) {
            let value = currentExtensionRanges[i](token, input);
            if (value !== void 0)
              return value;
          }
          return new Tag(input, token);
        }
      case 7:
        switch (token) {
          case 20:
            return false;
          case 21:
            return true;
          case 22:
            return null;
          case 23:
            return;
          case 31:
          default:
            let packedValue = (packedValues || getPackedValues())[token];
            if (packedValue !== void 0)
              return packedValue;
            throw new Error("Unknown token " + token);
        }
      default:
        if (isNaN(token)) {
          let error = new Error("Unexpected end of CBOR data");
          error.incomplete = true;
          throw error;
        }
        throw new Error("Unknown CBOR token " + token);
    }
  }
  var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
  function createStructureReader(structure) {
    function readObject() {
      let length4 = src3[position++];
      length4 = length4 & 31;
      if (length4 > 23) {
        switch (length4) {
          case 24:
            length4 = src3[position++];
            break;
          case 25:
            length4 = dataView2.getUint16(position);
            position += 2;
            break;
          case 26:
            length4 = dataView2.getUint32(position);
            position += 4;
            break;
          default:
            throw new Error("Expected array header, but got " + src3[position - 1]);
        }
      }
      let compiledReader = this.compiledReader;
      while (compiledReader) {
        if (compiledReader.propertyCount === length4)
          return compiledReader(read3);
        compiledReader = compiledReader.next;
      }
      if (this.slowReads++ >= inlineObjectReadThreshold) {
        let array = this.length == length4 ? this : this.slice(0, length4);
        compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
        if (this.compiledReader)
          compiledReader.next = this.compiledReader;
        compiledReader.propertyCount = length4;
        this.compiledReader = compiledReader;
        return compiledReader(read3);
      }
      let object = {};
      if (currentDecoder.keyMap)
        for (let i = 0; i < length4; i++)
          object[safeKey(currentDecoder.decodeKey(this[i]))] = read3();
      else
        for (let i = 0; i < length4; i++) {
          object[safeKey(this[i])] = read3();
        }
      return object;
    }
    structure.slowReads = 0;
    return readObject;
  }
  function safeKey(key) {
    return key === "__proto__" ? "__proto_" : key;
  }
  var readFixedString = readStringJS;
  var isNativeAccelerationEnabled = false;
  function readStringJS(length4) {
    let result;
    if (length4 < 16) {
      if (result = shortStringInJS(length4))
        return result;
    }
    if (length4 > 64 && decoder)
      return decoder.decode(src3.subarray(position, position += length4));
    const end = position + length4;
    const units = [];
    result = "";
    while (position < end) {
      const byte1 = src3[position++];
      if ((byte1 & 128) === 0) {
        units.push(byte1);
      } else if ((byte1 & 224) === 192) {
        const byte2 = src3[position++] & 63;
        units.push((byte1 & 31) << 6 | byte2);
      } else if ((byte1 & 240) === 224) {
        const byte2 = src3[position++] & 63;
        const byte3 = src3[position++] & 63;
        units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
      } else if ((byte1 & 248) === 240) {
        const byte2 = src3[position++] & 63;
        const byte3 = src3[position++] & 63;
        const byte4 = src3[position++] & 63;
        let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (unit > 65535) {
          unit -= 65536;
          units.push(unit >>> 10 & 1023 | 55296);
          unit = 56320 | unit & 1023;
        }
        units.push(unit);
      } else {
        units.push(byte1);
      }
      if (units.length >= 4096) {
        result += fromCharCode.apply(String, units);
        units.length = 0;
      }
    }
    if (units.length > 0) {
      result += fromCharCode.apply(String, units);
    }
    return result;
  }
  var fromCharCode = String.fromCharCode;
  function longStringInJS(length4) {
    let start = position;
    let bytes = new Array(length4);
    for (let i = 0; i < length4; i++) {
      const byte = src3[position++];
      if ((byte & 128) > 0) {
        position = start;
        return;
      }
      bytes[i] = byte;
    }
    return fromCharCode.apply(String, bytes);
  }
  function shortStringInJS(length4) {
    if (length4 < 4) {
      if (length4 < 2) {
        if (length4 === 0)
          return "";
        else {
          let a = src3[position++];
          if ((a & 128) > 1) {
            position -= 1;
            return;
          }
          return fromCharCode(a);
        }
      } else {
        let a = src3[position++];
        let b = src3[position++];
        if ((a & 128) > 0 || (b & 128) > 0) {
          position -= 2;
          return;
        }
        if (length4 < 3)
          return fromCharCode(a, b);
        let c = src3[position++];
        if ((c & 128) > 0) {
          position -= 3;
          return;
        }
        return fromCharCode(a, b, c);
      }
    } else {
      let a = src3[position++];
      let b = src3[position++];
      let c = src3[position++];
      let d = src3[position++];
      if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
        position -= 4;
        return;
      }
      if (length4 < 6) {
        if (length4 === 4)
          return fromCharCode(a, b, c, d);
        else {
          let e = src3[position++];
          if ((e & 128) > 0) {
            position -= 5;
            return;
          }
          return fromCharCode(a, b, c, d, e);
        }
      } else if (length4 < 8) {
        let e = src3[position++];
        let f = src3[position++];
        if ((e & 128) > 0 || (f & 128) > 0) {
          position -= 6;
          return;
        }
        if (length4 < 7)
          return fromCharCode(a, b, c, d, e, f);
        let g = src3[position++];
        if ((g & 128) > 0) {
          position -= 7;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g);
      } else {
        let e = src3[position++];
        let f = src3[position++];
        let g = src3[position++];
        let h = src3[position++];
        if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
          position -= 8;
          return;
        }
        if (length4 < 10) {
          if (length4 === 8)
            return fromCharCode(a, b, c, d, e, f, g, h);
          else {
            let i = src3[position++];
            if ((i & 128) > 0) {
              position -= 9;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i);
          }
        } else if (length4 < 12) {
          let i = src3[position++];
          let j = src3[position++];
          if ((i & 128) > 0 || (j & 128) > 0) {
            position -= 10;
            return;
          }
          if (length4 < 11)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j);
          let k = src3[position++];
          if ((k & 128) > 0) {
            position -= 11;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
        } else {
          let i = src3[position++];
          let j = src3[position++];
          let k = src3[position++];
          let l = src3[position++];
          if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
            position -= 12;
            return;
          }
          if (length4 < 14) {
            if (length4 === 12)
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
            else {
              let m = src3[position++];
              if ((m & 128) > 0) {
                position -= 13;
                return;
              }
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
            }
          } else {
            let m = src3[position++];
            let n = src3[position++];
            if ((m & 128) > 0 || (n & 128) > 0) {
              position -= 14;
              return;
            }
            if (length4 < 15)
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
            let o = src3[position++];
            if ((o & 128) > 0) {
              position -= 15;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
          }
        }
      }
    }
  }
  function readBin(length4) {
    return currentDecoder.copyBuffers ? (
      // specifically use the copying slice (not the node one)
      Uint8Array.prototype.slice.call(src3, position, position += length4)
    ) : src3.subarray(position, position += length4);
  }
  var f32Array = new Float32Array(1);
  var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
  function getFloat16() {
    let byte0 = src3[position++];
    let byte1 = src3[position++];
    let exponent = (byte0 & 127) >> 2;
    if (exponent === 31) {
      if (byte1 || byte0 & 3)
        return NaN;
      return byte0 & 128 ? -Infinity : Infinity;
    }
    if (exponent === 0) {
      let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
      return byte0 & 128 ? -abs : abs;
    }
    u8Array[3] = byte0 & 128 | // sign bit
    (exponent >> 1) + 56;
    u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
    byte1 >> 3;
    u8Array[1] = byte1 << 5;
    u8Array[0] = 0;
    return f32Array[0];
  }
  var keyCache = new Array(4096);
  var Tag = class {
    constructor(value, tag) {
      this.value = value;
      this.tag = tag;
    }
  };
  currentExtensions[0] = (dateString) => {
    return new Date(dateString);
  };
  currentExtensions[1] = (epochSec) => {
    return new Date(Math.round(epochSec * 1e3));
  };
  currentExtensions[2] = (buffer2) => {
    let value = BigInt(0);
    for (let i = 0, l = buffer2.byteLength; i < l; i++) {
      value = BigInt(buffer2[i]) + value << BigInt(8);
    }
    return value;
  };
  currentExtensions[3] = (buffer2) => {
    return BigInt(-1) - currentExtensions[2](buffer2);
  };
  currentExtensions[4] = (fraction) => {
    return +(fraction[1] + "e" + fraction[0]);
  };
  currentExtensions[5] = (fraction) => {
    return fraction[1] * Math.exp(fraction[0] * Math.log(2));
  };
  var recordDefinition = (id, structure) => {
    id = id - 57344;
    let existingStructure = currentStructures[id];
    if (existingStructure && existingStructure.isShared) {
      (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
    }
    currentStructures[id] = structure;
    structure.read = createStructureReader(structure);
  };
  currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
    let length4 = data.length;
    let structure = data[1];
    recordDefinition(data[0], structure);
    let object = {};
    for (let i = 2; i < length4; i++) {
      let key = structure[i - 2];
      object[safeKey(key)] = data[i];
    }
    return object;
  };
  currentExtensions[14] = (value) => {
    if (bundledStrings)
      return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
    return new Tag(value, 14);
  };
  currentExtensions[15] = (value) => {
    if (bundledStrings)
      return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
    return new Tag(value, 15);
  };
  var glbl = { Error, RegExp };
  currentExtensions[27] = (data) => {
    return (glbl[data[0]] || Error)(data[1], data[2]);
  };
  var packedTable = (read5) => {
    if (src3[position++] != 132) {
      let error = new Error("Packed values structure must be followed by a 4 element array");
      if (src3.length < position)
        error.incomplete = true;
      throw error;
    }
    let newPackedValues = read5();
    if (!newPackedValues || !newPackedValues.length) {
      let error = new Error("Packed values structure must be followed by a 4 element array");
      error.incomplete = true;
      throw error;
    }
    packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
    packedValues.prefixes = read5();
    packedValues.suffixes = read5();
    return read5();
  };
  packedTable.handlesRead = true;
  currentExtensions[51] = packedTable;
  currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
    if (!packedValues) {
      if (currentDecoder.getShared)
        loadShared();
      else
        return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
    if (typeof data == "number")
      return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
    let error = new Error("No support for non-integer packed references yet");
    if (data === void 0)
      error.incomplete = true;
    throw error;
  };
  currentExtensions[28] = (read5) => {
    if (!referenceMap) {
      referenceMap = /* @__PURE__ */ new Map();
      referenceMap.id = 0;
    }
    let id = referenceMap.id++;
    let token = src3[position];
    let target2;
    if (token >> 5 == 4)
      target2 = [];
    else
      target2 = {};
    let refEntry = { target: target2 };
    referenceMap.set(id, refEntry);
    let targetProperties = read5();
    if (refEntry.used)
      return Object.assign(target2, targetProperties);
    refEntry.target = targetProperties;
    return targetProperties;
  };
  currentExtensions[28].handlesRead = true;
  currentExtensions[29] = (id) => {
    let refEntry = referenceMap.get(id);
    refEntry.used = true;
    return refEntry.target;
  };
  currentExtensions[258] = (array) => new Set(array);
  (currentExtensions[259] = (read5) => {
    if (currentDecoder.mapsAsObjects) {
      currentDecoder.mapsAsObjects = false;
      restoreMapsAsObject = true;
    }
    return read5();
  }).handlesRead = true;
  function combine(a, b) {
    if (typeof a === "string")
      return a + b;
    if (a instanceof Array)
      return a.concat(b);
    return Object.assign({}, a, b);
  }
  function getPackedValues() {
    if (!packedValues) {
      if (currentDecoder.getShared)
        loadShared();
      else
        throw new Error("No packed values available");
    }
    return packedValues;
  }
  var SHARED_DATA_TAG_ID = 1399353956;
  currentExtensionRanges.push((tag, input) => {
    if (tag >= 225 && tag <= 255)
      return combine(getPackedValues().prefixes[tag - 224], input);
    if (tag >= 28704 && tag <= 32767)
      return combine(getPackedValues().prefixes[tag - 28672], input);
    if (tag >= 1879052288 && tag <= 2147483647)
      return combine(getPackedValues().prefixes[tag - 1879048192], input);
    if (tag >= 216 && tag <= 223)
      return combine(input, getPackedValues().suffixes[tag - 216]);
    if (tag >= 27647 && tag <= 28671)
      return combine(input, getPackedValues().suffixes[tag - 27639]);
    if (tag >= 1811940352 && tag <= 1879048191)
      return combine(input, getPackedValues().suffixes[tag - 1811939328]);
    if (tag == SHARED_DATA_TAG_ID) {
      return {
        packedValues,
        structures: currentStructures.slice(0),
        version: input
      };
    }
    if (tag == 55799)
      return input;
  });
  var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
  var typedArrays = [
    Uint8Array,
    Uint8ClampedArray,
    Uint16Array,
    Uint32Array,
    typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
    Int8Array,
    Int16Array,
    Int32Array,
    typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
    Float32Array,
    Float64Array
  ];
  var typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
  for (let i = 0; i < typedArrays.length; i++) {
    registerTypedArray(typedArrays[i], typedArrayTags[i]);
  }
  function registerTypedArray(TypedArray, tag) {
    let dvMethod = "get" + TypedArray.name.slice(0, -5);
    let bytesPerElement;
    if (typeof TypedArray === "function")
      bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
    else
      TypedArray = null;
    for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
      if (!littleEndian && bytesPerElement == 1)
        continue;
      let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
      currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer2) => {
        if (!TypedArray)
          throw new Error("Could not find typed array for code " + tag);
        if (!currentDecoder.copyBuffers) {
          if (bytesPerElement === 1 || bytesPerElement === 2 && !(buffer2.byteOffset & 1) || bytesPerElement === 4 && !(buffer2.byteOffset & 3) || bytesPerElement === 8 && !(buffer2.byteOffset & 7))
            return new TypedArray(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
        }
        return new TypedArray(Uint8Array.prototype.slice.call(buffer2, 0).buffer);
      } : (buffer2) => {
        if (!TypedArray)
          throw new Error("Could not find typed array for code " + tag);
        let dv = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
        let elements = buffer2.length >> sizeShift;
        let ta = new TypedArray(elements);
        let method = dv[dvMethod];
        for (let i = 0; i < elements; i++) {
          ta[i] = method.call(dv, i << sizeShift, littleEndian);
        }
        return ta;
      };
    }
  }
  function readBundleExt() {
    let length4 = readJustLength();
    let bundlePosition = position + read3();
    for (let i = 2; i < length4; i++) {
      let bundleLength = readJustLength();
      position += bundleLength;
    }
    let dataPosition = position;
    position = bundlePosition;
    bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
    bundledStrings.position0 = 0;
    bundledStrings.position1 = 0;
    bundledStrings.postBundlePosition = position;
    position = dataPosition;
    return read3();
  }
  function readJustLength() {
    let token = src3[position++] & 31;
    if (token > 23) {
      switch (token) {
        case 24:
          token = src3[position++];
          break;
        case 25:
          token = dataView2.getUint16(position);
          position += 2;
          break;
        case 26:
          token = dataView2.getUint32(position);
          position += 4;
          break;
      }
    }
    return token;
  }
  function loadShared() {
    if (currentDecoder.getShared) {
      let sharedData = saveState(() => {
        src3 = null;
        return currentDecoder.getShared();
      }) || {};
      let updatedStructures = sharedData.structures || [];
      currentDecoder.sharedVersion = sharedData.version;
      packedValues = currentDecoder.sharedValues = sharedData.packedValues;
      if (currentStructures === true)
        currentDecoder.structures = currentStructures = updatedStructures;
      else
        currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
  function saveState(callback) {
    let savedSrcEnd = srcEnd;
    let savedPosition = position;
    let savedStringPosition = stringPosition;
    let savedSrcStringStart = srcStringStart;
    let savedSrcStringEnd = srcStringEnd;
    let savedSrcString = srcString;
    let savedStrings = strings;
    let savedReferenceMap = referenceMap;
    let savedBundledStrings = bundledStrings;
    let savedSrc = new Uint8Array(src3.slice(0, srcEnd));
    let savedStructures = currentStructures;
    let savedDecoder = currentDecoder;
    let savedSequentialMode = sequentialMode;
    let value = callback();
    srcEnd = savedSrcEnd;
    position = savedPosition;
    stringPosition = savedStringPosition;
    srcStringStart = savedSrcStringStart;
    srcStringEnd = savedSrcStringEnd;
    srcString = savedSrcString;
    strings = savedStrings;
    referenceMap = savedReferenceMap;
    bundledStrings = savedBundledStrings;
    src3 = savedSrc;
    sequentialMode = savedSequentialMode;
    currentStructures = savedStructures;
    currentDecoder = savedDecoder;
    dataView2 = new DataView(src3.buffer, src3.byteOffset, src3.byteLength);
    return value;
  }
  function clearSource() {
    src3 = null;
    referenceMap = null;
    currentStructures = null;
  }
  function addExtension(extension) {
    currentExtensions[extension.tag] = extension.decode;
  }
  var mult10 = new Array(147);
  for (let i = 0; i < 256; i++) {
    mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
  }
  var defaultDecoder = new Decoder3({ useRecords: false });
  var decode11 = defaultDecoder.decode;
  var decodeMultiple = defaultDecoder.decodeMultiple;
  var FLOAT32_OPTIONS = {
    NEVER: 0,
    ALWAYS: 1,
    DECIMAL_ROUND: 3,
    DECIMAL_FIT: 4
  };
  function roundFloat32(float32Number) {
    f32Array[0] = float32Number;
    let multiplier = mult10[(u8Array[3] & 127) << 1 | u8Array[2] >> 7];
    return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
  }

  // node_modules/cbor-x/encode.js
  var textEncoder2;
  try {
    textEncoder2 = new TextEncoder();
  } catch (error) {
  }
  var extensions;
  var extensionClasses;
  var Buffer2 = typeof globalThis === "object" && globalThis.Buffer;
  var hasNodeBuffer = typeof Buffer2 !== "undefined";
  var ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;
  var ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;
  var MAX_STRUCTURES = 256;
  var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
  var throwOnIterable;
  var target;
  var targetView;
  var position2 = 0;
  var safeEnd;
  var bundledStrings2 = null;
  var MAX_BUNDLE_SIZE = 61440;
  var hasNonLatin = /[\u0080-\uFFFF]/;
  var RECORD_SYMBOL = Symbol("record-id");
  var Encoder3 = class extends Decoder3 {
    constructor(options) {
      super(options);
      this.offset = 0;
      let typeBuffer;
      let start;
      let sharedStructures;
      let hasSharedUpdate;
      let structures;
      let referenceMap2;
      options = options || {};
      let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position3, maxBytes) {
        return target.utf8Write(string, position3, maxBytes);
      } : textEncoder2 && textEncoder2.encodeInto ? function(string, position3) {
        return textEncoder2.encodeInto(string, target.subarray(position3)).written;
      } : false;
      let encoder = this;
      let hasSharedStructures = options.structures || options.saveStructures;
      let maxSharedStructures = options.maxSharedStructures;
      if (maxSharedStructures == null)
        maxSharedStructures = hasSharedStructures ? 128 : 0;
      if (maxSharedStructures > 8190)
        throw new Error("Maximum maxSharedStructure is 8190");
      let isSequential = options.sequential;
      if (isSequential) {
        maxSharedStructures = 0;
      }
      if (!this.structures)
        this.structures = [];
      if (this.saveStructures)
        this.saveShared = this.saveStructures;
      let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;
      let sharedPackedObjectMap2;
      if (sharedValues) {
        sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
        for (let i = 0, l = sharedValues.length; i < l; i++) {
          sharedPackedObjectMap2[sharedValues[i]] = i;
        }
      }
      let recordIdsToRemove = [];
      let transitionsCount = 0;
      let serializationsSinceTransitionRebuild = 0;
      this.mapEncode = function(value, encodeOptions) {
        if (this._keyMap && !this._mapped) {
          switch (value.constructor.name) {
            case "Array":
              value = value.map((r) => this.encodeKeys(r));
              break;
          }
        }
        return this.encode(value, encodeOptions);
      };
      this.encode = function(value, encodeOptions) {
        if (!target) {
          target = new ByteArrayAllocate(8192);
          targetView = new DataView(target.buffer, 0, 8192);
          position2 = 0;
        }
        safeEnd = target.length - 10;
        if (safeEnd - position2 < 2048) {
          target = new ByteArrayAllocate(target.length);
          targetView = new DataView(target.buffer, 0, target.length);
          safeEnd = target.length - 10;
          position2 = 0;
        } else if (encodeOptions === REUSE_BUFFER_MODE)
          position2 = position2 + 7 & 2147483640;
        start = position2;
        if (encoder.useSelfDescribedHeader) {
          targetView.setUint32(position2, 3654940416);
          position2 += 3;
        }
        referenceMap2 = encoder.structuredClone ? /* @__PURE__ */ new Map() : null;
        if (encoder.bundleStrings && typeof value !== "string") {
          bundledStrings2 = [];
          bundledStrings2.size = Infinity;
        } else
          bundledStrings2 = null;
        sharedStructures = encoder.structures;
        if (sharedStructures) {
          if (sharedStructures.uninitialized) {
            let sharedData = encoder.getShared() || {};
            encoder.structures = sharedStructures = sharedData.structures || [];
            encoder.sharedVersion = sharedData.version;
            let sharedValues2 = encoder.sharedValues = sharedData.packedValues;
            if (sharedValues2) {
              sharedPackedObjectMap2 = {};
              for (let i = 0, l = sharedValues2.length; i < l; i++)
                sharedPackedObjectMap2[sharedValues2[i]] = i;
            }
          }
          let sharedStructuresLength = sharedStructures.length;
          if (sharedStructuresLength > maxSharedStructures && !isSequential)
            sharedStructuresLength = maxSharedStructures;
          if (!sharedStructures.transitions) {
            sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
            for (let i = 0; i < sharedStructuresLength; i++) {
              let keys = sharedStructures[i];
              if (!keys)
                continue;
              let nextTransition, transition = sharedStructures.transitions;
              for (let j = 0, l = keys.length; j < l; j++) {
                if (transition[RECORD_SYMBOL] === void 0)
                  transition[RECORD_SYMBOL] = i;
                let key = keys[j];
                nextTransition = transition[key];
                if (!nextTransition) {
                  nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                }
                transition = nextTransition;
              }
              transition[RECORD_SYMBOL] = i | 1048576;
            }
          }
          if (!isSequential)
            sharedStructures.nextId = sharedStructuresLength;
        }
        if (hasSharedUpdate)
          hasSharedUpdate = false;
        structures = sharedStructures || [];
        packedObjectMap2 = sharedPackedObjectMap2;
        if (options.pack) {
          let packedValues2 = /* @__PURE__ */ new Map();
          packedValues2.values = [];
          packedValues2.encoder = encoder;
          packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
          packedValues2.objectMap = sharedPackedObjectMap2 || false;
          packedValues2.samplingPackedValues = samplingPackedValues;
          findRepetitiveStrings(value, packedValues2);
          if (packedValues2.values.length > 0) {
            target[position2++] = 216;
            target[position2++] = 51;
            writeArrayHeader(4);
            let valuesArray = packedValues2.values;
            encode10(valuesArray);
            writeArrayHeader(0);
            writeArrayHeader(0);
            packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
            for (let i = 0, l = valuesArray.length; i < l; i++) {
              packedObjectMap2[valuesArray[i]] = i;
            }
          }
        }
        throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
        try {
          if (throwOnIterable)
            return;
          encode10(value);
          if (bundledStrings2) {
            writeBundles(start, encode10);
          }
          encoder.offset = position2;
          if (referenceMap2 && referenceMap2.idsToInsert) {
            position2 += referenceMap2.idsToInsert.length * 2;
            if (position2 > safeEnd)
              makeRoom(position2);
            encoder.offset = position2;
            let serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);
            referenceMap2 = null;
            return serialized;
          }
          if (encodeOptions & REUSE_BUFFER_MODE) {
            target.start = start;
            target.end = position2;
            return target;
          }
          return target.subarray(start, position2);
        } finally {
          if (sharedStructures) {
            if (serializationsSinceTransitionRebuild < 10)
              serializationsSinceTransitionRebuild++;
            if (sharedStructures.length > maxSharedStructures)
              sharedStructures.length = maxSharedStructures;
            if (transitionsCount > 1e4) {
              sharedStructures.transitions = null;
              serializationsSinceTransitionRebuild = 0;
              transitionsCount = 0;
              if (recordIdsToRemove.length > 0)
                recordIdsToRemove = [];
            } else if (recordIdsToRemove.length > 0 && !isSequential) {
              for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
                recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
              }
              recordIdsToRemove = [];
            }
          }
          if (hasSharedUpdate && encoder.saveShared) {
            if (encoder.structures.length > maxSharedStructures) {
              encoder.structures = encoder.structures.slice(0, maxSharedStructures);
            }
            let returnBuffer = target.subarray(start, position2);
            if (encoder.updateSharedData() === false)
              return encoder.encode(value);
            return returnBuffer;
          }
          if (encodeOptions & RESET_BUFFER_MODE)
            position2 = start;
        }
      };
      this.findCommonStringsToPack = () => {
        samplingPackedValues = /* @__PURE__ */ new Map();
        if (!sharedPackedObjectMap2)
          sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
        return (options2) => {
          let threshold = options2 && options2.threshold || 4;
          let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
          if (!sharedValues)
            sharedValues = this.sharedValues = [];
          for (let [key, status] of samplingPackedValues) {
            if (status.count > threshold) {
              sharedPackedObjectMap2[key] = position3++;
              sharedValues.push(key);
              hasSharedUpdate = true;
            }
          }
          while (this.saveShared && this.updateSharedData() === false) {
          }
          samplingPackedValues = null;
        };
      };
      const encode10 = (value) => {
        if (position2 > safeEnd)
          target = makeRoom(position2);
        var type = typeof value;
        var length4;
        if (type === "string") {
          if (packedObjectMap2) {
            let packedPosition = packedObjectMap2[value];
            if (packedPosition >= 0) {
              if (packedPosition < 16)
                target[position2++] = packedPosition + 224;
              else {
                target[position2++] = 198;
                if (packedPosition & 1)
                  encode10(15 - packedPosition >> 1);
                else
                  encode10(packedPosition - 16 >> 1);
              }
              return;
            } else if (samplingPackedValues && !options.pack) {
              let status = samplingPackedValues.get(value);
              if (status)
                status.count++;
              else
                samplingPackedValues.set(value, {
                  count: 1
                });
            }
          }
          let strLength = value.length;
          if (bundledStrings2 && strLength >= 4 && strLength < 1024) {
            if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
              let extStart;
              let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
              if (position2 + maxBytes2 > safeEnd)
                target = makeRoom(position2 + maxBytes2);
              target[position2++] = 217;
              target[position2++] = 223;
              target[position2++] = 249;
              target[position2++] = bundledStrings2.position ? 132 : 130;
              target[position2++] = 26;
              extStart = position2 - start;
              position2 += 4;
              if (bundledStrings2.position) {
                writeBundles(start, encode10);
              }
              bundledStrings2 = ["", ""];
              bundledStrings2.size = 0;
              bundledStrings2.position = extStart;
            }
            let twoByte = hasNonLatin.test(value);
            bundledStrings2[twoByte ? 0 : 1] += value;
            target[position2++] = twoByte ? 206 : 207;
            encode10(strLength);
            return;
          }
          let headerSize;
          if (strLength < 32) {
            headerSize = 1;
          } else if (strLength < 256) {
            headerSize = 2;
          } else if (strLength < 65536) {
            headerSize = 3;
          } else {
            headerSize = 5;
          }
          let maxBytes = strLength * 3;
          if (position2 + maxBytes > safeEnd)
            target = makeRoom(position2 + maxBytes);
          if (strLength < 64 || !encodeUtf8) {
            let i, c1, c2, strPosition = position2 + headerSize;
            for (i = 0; i < strLength; i++) {
              c1 = value.charCodeAt(i);
              if (c1 < 128) {
                target[strPosition++] = c1;
              } else if (c1 < 2048) {
                target[strPosition++] = c1 >> 6 | 192;
                target[strPosition++] = c1 & 63 | 128;
              } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
                c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                i++;
                target[strPosition++] = c1 >> 18 | 240;
                target[strPosition++] = c1 >> 12 & 63 | 128;
                target[strPosition++] = c1 >> 6 & 63 | 128;
                target[strPosition++] = c1 & 63 | 128;
              } else {
                target[strPosition++] = c1 >> 12 | 224;
                target[strPosition++] = c1 >> 6 & 63 | 128;
                target[strPosition++] = c1 & 63 | 128;
              }
            }
            length4 = strPosition - position2 - headerSize;
          } else {
            length4 = encodeUtf8(value, position2 + headerSize, maxBytes);
          }
          if (length4 < 24) {
            target[position2++] = 96 | length4;
          } else if (length4 < 256) {
            if (headerSize < 2) {
              target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length4);
            }
            target[position2++] = 120;
            target[position2++] = length4;
          } else if (length4 < 65536) {
            if (headerSize < 3) {
              target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length4);
            }
            target[position2++] = 121;
            target[position2++] = length4 >> 8;
            target[position2++] = length4 & 255;
          } else {
            if (headerSize < 5) {
              target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length4);
            }
            target[position2++] = 122;
            targetView.setUint32(position2, length4);
            position2 += 4;
          }
          position2 += length4;
        } else if (type === "number") {
          if (!this.alwaysUseFloat && value >>> 0 === value) {
            if (value < 24) {
              target[position2++] = value;
            } else if (value < 256) {
              target[position2++] = 24;
              target[position2++] = value;
            } else if (value < 65536) {
              target[position2++] = 25;
              target[position2++] = value >> 8;
              target[position2++] = value & 255;
            } else {
              target[position2++] = 26;
              targetView.setUint32(position2, value);
              position2 += 4;
            }
          } else if (!this.alwaysUseFloat && value >> 0 === value) {
            if (value >= -24) {
              target[position2++] = 31 - value;
            } else if (value >= -256) {
              target[position2++] = 56;
              target[position2++] = ~value;
            } else if (value >= -65536) {
              target[position2++] = 57;
              targetView.setUint16(position2, ~value);
              position2 += 2;
            } else {
              target[position2++] = 58;
              targetView.setUint32(position2, ~value);
              position2 += 4;
            }
          } else {
            let useFloat32;
            if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
              target[position2++] = 250;
              targetView.setFloat32(position2, value);
              let xShifted;
              if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
              (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
                position2 += 4;
                return;
              } else
                position2--;
            }
            target[position2++] = 251;
            targetView.setFloat64(position2, value);
            position2 += 8;
          }
        } else if (type === "object") {
          if (!value)
            target[position2++] = 246;
          else {
            if (referenceMap2) {
              let referee = referenceMap2.get(value);
              if (referee) {
                target[position2++] = 216;
                target[position2++] = 29;
                target[position2++] = 25;
                if (!referee.references) {
                  let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                  referee.references = [];
                  idsToInsert.push(referee);
                }
                referee.references.push(position2 - start);
                position2 += 2;
                return;
              } else
                referenceMap2.set(value, { offset: position2 - start });
            }
            let constructor = value.constructor;
            if (constructor === Object) {
              writeObject(value, true);
            } else if (constructor === Array) {
              length4 = value.length;
              if (length4 < 24) {
                target[position2++] = 128 | length4;
              } else {
                writeArrayHeader(length4);
              }
              for (let i = 0; i < length4; i++) {
                encode10(value[i]);
              }
            } else if (constructor === Map) {
              if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                target[position2++] = 217;
                target[position2++] = 1;
                target[position2++] = 3;
              }
              length4 = value.size;
              if (length4 < 24) {
                target[position2++] = 160 | length4;
              } else if (length4 < 256) {
                target[position2++] = 184;
                target[position2++] = length4;
              } else if (length4 < 65536) {
                target[position2++] = 185;
                target[position2++] = length4 >> 8;
                target[position2++] = length4 & 255;
              } else {
                target[position2++] = 186;
                targetView.setUint32(position2, length4);
                position2 += 4;
              }
              if (encoder.keyMap) {
                for (let [key, entryValue] of value) {
                  encode10(encoder.encodeKey(key));
                  encode10(entryValue);
                }
              } else {
                for (let [key, entryValue] of value) {
                  encode10(key);
                  encode10(entryValue);
                }
              }
            } else {
              for (let i = 0, l = extensions.length; i < l; i++) {
                let extensionClass = extensionClasses[i];
                if (value instanceof extensionClass) {
                  let extension = extensions[i];
                  let tag = extension.tag;
                  if (tag == void 0)
                    tag = extension.getTag && extension.getTag.call(this, value);
                  if (tag < 24) {
                    target[position2++] = 192 | tag;
                  } else if (tag < 256) {
                    target[position2++] = 216;
                    target[position2++] = tag;
                  } else if (tag < 65536) {
                    target[position2++] = 217;
                    target[position2++] = tag >> 8;
                    target[position2++] = tag & 255;
                  } else if (tag > -1) {
                    target[position2++] = 218;
                    targetView.setUint32(position2, tag);
                    position2 += 4;
                  }
                  extension.encode.call(this, value, encode10, makeRoom);
                  return;
                }
              }
              if (value[Symbol.iterator]) {
                if (throwOnIterable) {
                  let error = new Error("Iterable should be serialized as iterator");
                  error.iteratorNotHandled = true;
                  throw error;
                }
                target[position2++] = 159;
                for (let entry of value) {
                  encode10(entry);
                }
                target[position2++] = 255;
                return;
              }
              if (value[Symbol.asyncIterator] || isBlob(value)) {
                let error = new Error("Iterable/blob should be serialized as iterator");
                error.iteratorNotHandled = true;
                throw error;
              }
              if (this.useToJSON && value.toJSON) {
                const json = value.toJSON();
                if (json !== value)
                  return encode10(json);
              }
              writeObject(value, !value.hasOwnProperty);
            }
          }
        } else if (type === "boolean") {
          target[position2++] = value ? 245 : 244;
        } else if (type === "bigint") {
          if (value < BigInt(1) << BigInt(64) && value >= 0) {
            target[position2++] = 27;
            targetView.setBigUint64(position2, value);
          } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
            target[position2++] = 59;
            targetView.setBigUint64(position2, -value - BigInt(1));
          } else {
            if (this.largeBigIntToFloat) {
              target[position2++] = 251;
              targetView.setFloat64(position2, Number(value));
            } else {
              throw new RangeError(value + " was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");
            }
          }
          position2 += 8;
        } else if (type === "undefined") {
          target[position2++] = 247;
        } else {
          throw new Error("Unknown type: " + type);
        }
      };
      const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
        let keys = Object.keys(object);
        let vals = Object.values(object);
        let length4 = keys.length;
        if (length4 < 24) {
          target[position2++] = 160 | length4;
        } else if (length4 < 256) {
          target[position2++] = 184;
          target[position2++] = length4;
        } else if (length4 < 65536) {
          target[position2++] = 185;
          target[position2++] = length4 >> 8;
          target[position2++] = length4 & 255;
        } else {
          target[position2++] = 186;
          targetView.setUint32(position2, length4);
          position2 += 4;
        }
        let key;
        if (encoder.keyMap) {
          for (let i = 0; i < length4; i++) {
            encode10(encoder.encodeKey(keys[i]));
            encode10(vals[i]);
          }
        } else {
          for (let i = 0; i < length4; i++) {
            encode10(keys[i]);
            encode10(vals[i]);
          }
        }
      } : (object, safePrototype) => {
        target[position2++] = 185;
        let objectOffset = position2 - start;
        position2 += 2;
        let size = 0;
        if (encoder.keyMap) {
          for (let key in object)
            if (safePrototype || object.hasOwnProperty(key)) {
              encode10(encoder.encodeKey(key));
              encode10(object[key]);
              size++;
            }
        } else {
          for (let key in object)
            if (safePrototype || object.hasOwnProperty(key)) {
              encode10(key);
              encode10(object[key]);
              size++;
            }
        }
        target[objectOffset++ + start] = size >> 8;
        target[objectOffset + start] = size & 255;
      } : (object, safePrototype) => {
        let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
        let newTransitions = 0;
        let length4 = 0;
        let parentRecordId;
        let keys;
        if (this.keyMap) {
          keys = Object.keys(object).map((k) => this.encodeKey(k));
          length4 = keys.length;
          for (let i = 0; i < length4; i++) {
            let key = keys[i];
            nextTransition = transition[key];
            if (!nextTransition) {
              nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
          }
        } else {
          for (let key in object)
            if (safePrototype || object.hasOwnProperty(key)) {
              nextTransition = transition[key];
              if (!nextTransition) {
                if (transition[RECORD_SYMBOL] & 1048576) {
                  parentRecordId = transition[RECORD_SYMBOL] & 65535;
                }
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                newTransitions++;
              }
              transition = nextTransition;
              length4++;
            }
        }
        let recordId = transition[RECORD_SYMBOL];
        if (recordId !== void 0) {
          recordId &= 65535;
          target[position2++] = 217;
          target[position2++] = recordId >> 8 | 224;
          target[position2++] = recordId & 255;
        } else {
          if (!keys)
            keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
          if (parentRecordId === void 0) {
            recordId = structures.nextId++;
            if (!recordId) {
              recordId = 0;
              structures.nextId = 1;
            }
            if (recordId >= MAX_STRUCTURES) {
              structures.nextId = (recordId = maxSharedStructures) + 1;
            }
          } else {
            recordId = parentRecordId;
          }
          structures[recordId] = keys;
          if (recordId < maxSharedStructures) {
            target[position2++] = 217;
            target[position2++] = recordId >> 8 | 224;
            target[position2++] = recordId & 255;
            transition = structures.transitions;
            for (let i = 0; i < length4; i++) {
              if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
                transition[RECORD_SYMBOL] = recordId;
              transition = transition[keys[i]];
            }
            transition[RECORD_SYMBOL] = recordId | 1048576;
            hasSharedUpdate = true;
          } else {
            transition[RECORD_SYMBOL] = recordId;
            targetView.setUint32(position2, 3655335680);
            position2 += 3;
            if (newTransitions)
              transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
            if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
              recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
            recordIdsToRemove.push(transition);
            writeArrayHeader(length4 + 2);
            encode10(57344 + recordId);
            encode10(keys);
            if (safePrototype === null)
              return;
            for (let key in object)
              if (safePrototype || object.hasOwnProperty(key))
                encode10(object[key]);
            return;
          }
        }
        if (length4 < 24) {
          target[position2++] = 128 | length4;
        } else {
          writeArrayHeader(length4);
        }
        if (safePrototype === null)
          return;
        for (let key in object)
          if (safePrototype || object.hasOwnProperty(key))
            encode10(object[key]);
      };
      const makeRoom = (end) => {
        let newSize;
        if (end > 16777216) {
          if (end - start > MAX_BUFFER_SIZE)
            throw new Error("Encoded buffer would be larger than maximum buffer size");
          newSize = Math.min(
            MAX_BUFFER_SIZE,
            Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
          );
        } else
          newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
        let newBuffer = new ByteArrayAllocate(newSize);
        targetView = new DataView(newBuffer.buffer, 0, newSize);
        if (target.copy)
          target.copy(newBuffer, 0, start, end);
        else
          newBuffer.set(target.slice(start, end));
        position2 -= start;
        start = 0;
        safeEnd = newBuffer.length - 10;
        return target = newBuffer;
      };
      let chunkThreshold = 100;
      let continuedChunkThreshold = 1e3;
      this.encodeAsIterable = function(value, options2) {
        return startEncoding(value, options2, encodeObjectAsIterable);
      };
      this.encodeAsAsyncIterable = function(value, options2) {
        return startEncoding(value, options2, encodeObjectAsAsyncIterable);
      };
      function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
        let constructor = object.constructor;
        if (constructor === Object) {
          let useRecords = encoder.useRecords !== false;
          if (useRecords)
            writeObject(object, null);
          else
            writeEntityLength(Object.keys(object).length, 160);
          for (let key in object) {
            let value = object[key];
            if (!useRecords)
              encode10(key);
            if (value && typeof value === "object") {
              if (iterateProperties[key])
                yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties[key]));
              else
                yield* __yieldStar(tryEncode(value, iterateProperties, key));
            } else
              encode10(value);
          }
        } else if (constructor === Array) {
          let length4 = object.length;
          writeArrayHeader(length4);
          for (let i = 0; i < length4; i++) {
            let value = object[i];
            if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
              if (iterateProperties.element)
                yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties.element));
              else
                yield* __yieldStar(tryEncode(value, iterateProperties, "element"));
            } else
              encode10(value);
          }
        } else if (object[Symbol.iterator]) {
          target[position2++] = 159;
          for (let value of object) {
            if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
              if (iterateProperties.element)
                yield* __yieldStar(encodeObjectAsIterable(value, iterateProperties.element));
              else
                yield* __yieldStar(tryEncode(value, iterateProperties, "element"));
            } else
              encode10(value);
          }
          target[position2++] = 255;
        } else if (isBlob(object)) {
          writeEntityLength(object.size, 64);
          yield target.subarray(start, position2);
          yield object;
          restartEncoding();
        } else if (object[Symbol.asyncIterator]) {
          target[position2++] = 159;
          yield target.subarray(start, position2);
          yield object;
          restartEncoding();
          target[position2++] = 255;
        } else {
          encode10(object);
        }
        if (finalIterable && position2 > start)
          yield target.subarray(start, position2);
        else if (position2 - start > chunkThreshold) {
          yield target.subarray(start, position2);
          restartEncoding();
        }
      }
      function* tryEncode(value, iterateProperties, key) {
        let restart = position2 - start;
        try {
          encode10(value);
          if (position2 - start > chunkThreshold) {
            yield target.subarray(start, position2);
            restartEncoding();
          }
        } catch (error) {
          if (error.iteratorNotHandled) {
            iterateProperties[key] = {};
            position2 = start + restart;
            yield* __yieldStar(encodeObjectAsIterable.call(this, value, iterateProperties[key]));
          } else
            throw error;
        }
      }
      function restartEncoding() {
        chunkThreshold = continuedChunkThreshold;
        encoder.encode(null, THROW_ON_ITERABLE);
      }
      function startEncoding(value, options2, encodeIterable) {
        if (options2 && options2.chunkThreshold)
          chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
        else
          chunkThreshold = 100;
        if (value && typeof value === "object") {
          encoder.encode(null, THROW_ON_ITERABLE);
          return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
        }
        return [encoder.encode(value)];
      }
      function encodeObjectAsAsyncIterable(value, iterateProperties) {
        return __asyncGenerator(this, null, function* () {
          for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
            let constructor = encodedValue.constructor;
            if (constructor === ByteArray || constructor === Uint8Array)
              yield encodedValue;
            else if (isBlob(encodedValue)) {
              let reader = encodedValue.stream().getReader();
              let next;
              while (!(next = yield new __await(reader.read())).done) {
                yield next.value;
              }
            } else if (encodedValue[Symbol.asyncIterator]) {
              try {
                for (var iter = __forAwait(encodedValue), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
                  let asyncValue = temp.value;
                  restartEncoding();
                  if (asyncValue)
                    yield* __yieldStar(encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {})));
                  else
                    yield encoder.encode(asyncValue);
                }
              } catch (temp) {
                error = [temp];
              } finally {
                try {
                  more && (temp = iter.return) && (yield new __await(temp.call(iter)));
                } finally {
                  if (error)
                    throw error[0];
                }
              }
            } else {
              yield encodedValue;
            }
          }
        });
      }
    }
    useBuffer(buffer2) {
      target = buffer2;
      targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
      position2 = 0;
    }
    clearSharedData() {
      if (this.structures)
        this.structures = [];
      if (this.sharedValues)
        this.sharedValues = void 0;
    }
    updateSharedData() {
      let lastVersion = this.sharedVersion || 0;
      this.sharedVersion = lastVersion + 1;
      let structuresCopy = this.structures.slice(0);
      let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
      let saveResults = this.saveShared(
        sharedData,
        (existingShared) => (existingShared && existingShared.version || 0) == lastVersion
      );
      if (saveResults === false) {
        sharedData = this.getShared() || {};
        this.structures = sharedData.structures || [];
        this.sharedValues = sharedData.packedValues;
        this.sharedVersion = sharedData.version;
        this.structures.nextId = this.structures.length;
      } else {
        structuresCopy.forEach((structure, i) => this.structures[i] = structure);
      }
      return saveResults;
    }
  };
  function writeEntityLength(length4, majorValue) {
    if (length4 < 24)
      target[position2++] = majorValue | length4;
    else if (length4 < 256) {
      target[position2++] = majorValue | 24;
      target[position2++] = length4;
    } else if (length4 < 65536) {
      target[position2++] = majorValue | 25;
      target[position2++] = length4 >> 8;
      target[position2++] = length4 & 255;
    } else {
      target[position2++] = majorValue | 26;
      targetView.setUint32(position2, length4);
      position2 += 4;
    }
  }
  var SharedData = class {
    constructor(structures, values, version2) {
      this.structures = structures;
      this.packedValues = values;
      this.version = version2;
    }
  };
  function writeArrayHeader(length4) {
    if (length4 < 24)
      target[position2++] = 128 | length4;
    else if (length4 < 256) {
      target[position2++] = 152;
      target[position2++] = length4;
    } else if (length4 < 65536) {
      target[position2++] = 153;
      target[position2++] = length4 >> 8;
      target[position2++] = length4 & 255;
    } else {
      target[position2++] = 154;
      targetView.setUint32(position2, length4);
      position2 += 4;
    }
  }
  var BlobConstructor = typeof Blob === "undefined" ? function() {
  } : Blob;
  function isBlob(object) {
    if (object instanceof BlobConstructor)
      return true;
    let tag = object[Symbol.toStringTag];
    return tag === "Blob" || tag === "File";
  }
  function findRepetitiveStrings(value, packedValues2) {
    switch (typeof value) {
      case "string":
        if (value.length > 3) {
          if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
            return;
          let packedStatus = packedValues2.get(value);
          if (packedStatus) {
            if (++packedStatus.count == 2) {
              packedValues2.values.push(value);
            }
          } else {
            packedValues2.set(value, {
              count: 1
            });
            if (packedValues2.samplingPackedValues) {
              let status = packedValues2.samplingPackedValues.get(value);
              if (status)
                status.count++;
              else
                packedValues2.samplingPackedValues.set(value, {
                  count: 1
                });
            }
          }
        }
        break;
      case "object":
        if (value) {
          if (value instanceof Array) {
            for (let i = 0, l = value.length; i < l; i++) {
              findRepetitiveStrings(value[i], packedValues2);
            }
          } else {
            let includeKeys = !packedValues2.encoder.useRecords;
            for (var key in value) {
              if (value.hasOwnProperty(key)) {
                if (includeKeys)
                  findRepetitiveStrings(key, packedValues2);
                findRepetitiveStrings(value[key], packedValues2);
              }
            }
          }
        }
        break;
      case "function":
        console.log(value);
    }
  }
  var isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
  extensionClasses = [
    Date,
    Set,
    Error,
    RegExp,
    Tag,
    ArrayBuffer,
    Uint8Array,
    Uint8ClampedArray,
    Uint16Array,
    Uint32Array,
    typeof BigUint64Array == "undefined" ? function() {
    } : BigUint64Array,
    Int8Array,
    Int16Array,
    Int32Array,
    typeof BigInt64Array == "undefined" ? function() {
    } : BigInt64Array,
    Float32Array,
    Float64Array,
    SharedData
  ];
  extensions = [
    {
      // Date
      tag: 1,
      encode(date, encode10) {
        let seconds = date.getTime() / 1e3;
        if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
          target[position2++] = 26;
          targetView.setUint32(position2, seconds);
          position2 += 4;
        } else {
          target[position2++] = 251;
          targetView.setFloat64(position2, seconds);
          position2 += 8;
        }
      }
    },
    {
      // Set
      tag: 258,
      // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
      encode(set, encode10) {
        let array = Array.from(set);
        encode10(array);
      }
    },
    {
      // Error
      tag: 27,
      // http://cbor.schmorp.de/generic-object
      encode(error, encode10) {
        encode10([error.name, error.message]);
      }
    },
    {
      // RegExp
      tag: 27,
      // http://cbor.schmorp.de/generic-object
      encode(regex, encode10) {
        encode10(["RegExp", regex.source, regex.flags]);
      }
    },
    {
      // Tag
      getTag(tag) {
        return tag.tag;
      },
      encode(tag, encode10) {
        encode10(tag.value);
      }
    },
    {
      // ArrayBuffer
      encode(arrayBuffer, encode10, makeRoom) {
        writeBuffer(arrayBuffer, makeRoom);
      }
    },
    {
      // Uint8Array
      getTag(typedArray) {
        if (typedArray.constructor === Uint8Array) {
          if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
            return 64;
        }
      },
      encode(typedArray, encode10, makeRoom) {
        writeBuffer(typedArray, makeRoom);
      }
    },
    typedArrayEncoder(68, 1),
    typedArrayEncoder(69, 2),
    typedArrayEncoder(70, 4),
    typedArrayEncoder(71, 8),
    typedArrayEncoder(72, 1),
    typedArrayEncoder(77, 2),
    typedArrayEncoder(78, 4),
    typedArrayEncoder(79, 8),
    typedArrayEncoder(85, 4),
    typedArrayEncoder(86, 8),
    {
      encode(sharedData, encode10) {
        let packedValues2 = sharedData.packedValues || [];
        let sharedStructures = sharedData.structures || [];
        if (packedValues2.values.length > 0) {
          target[position2++] = 216;
          target[position2++] = 51;
          writeArrayHeader(4);
          let valuesArray = packedValues2.values;
          encode10(valuesArray);
          writeArrayHeader(0);
          writeArrayHeader(0);
          packedObjectMap = Object.create(sharedPackedObjectMap || null);
          for (let i = 0, l = valuesArray.length; i < l; i++) {
            packedObjectMap[valuesArray[i]] = i;
          }
        }
        if (sharedStructures) {
          targetView.setUint32(position2, 3655335424);
          position2 += 3;
          let definitions = sharedStructures.slice(0);
          definitions.unshift(57344);
          definitions.push(new Tag(sharedData.version, 1399353956));
          encode10(definitions);
        } else
          encode10(new Tag(sharedData.version, 1399353956));
      }
    }
  ];
  function typedArrayEncoder(tag, size) {
    if (!isLittleEndianMachine2 && size > 1)
      tag -= 4;
    return {
      tag,
      encode: function writeExtBuffer(typedArray, encode10) {
        let length4 = typedArray.byteLength;
        let offset = typedArray.byteOffset || 0;
        let buffer2 = typedArray.buffer || typedArray;
        encode10(hasNodeBuffer ? Buffer2.from(buffer2, offset, length4) : new Uint8Array(buffer2, offset, length4));
      }
    };
  }
  function writeBuffer(buffer2, makeRoom) {
    let length4 = buffer2.byteLength;
    if (length4 < 24) {
      target[position2++] = 64 + length4;
    } else if (length4 < 256) {
      target[position2++] = 88;
      target[position2++] = length4;
    } else if (length4 < 65536) {
      target[position2++] = 89;
      target[position2++] = length4 >> 8;
      target[position2++] = length4 & 255;
    } else {
      target[position2++] = 90;
      targetView.setUint32(position2, length4);
      position2 += 4;
    }
    if (position2 + length4 >= target.length) {
      makeRoom(position2 + length4);
    }
    target.set(buffer2.buffer ? buffer2 : new Uint8Array(buffer2), position2);
    position2 += length4;
  }
  function insertIds(serialized, idsToInsert) {
    let nextId;
    let distanceToMove = idsToInsert.length * 2;
    let lastEnd = serialized.length - distanceToMove;
    idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
    for (let id = 0; id < idsToInsert.length; id++) {
      let referee = idsToInsert[id];
      referee.id = id;
      for (let position3 of referee.references) {
        serialized[position3++] = id >> 8;
        serialized[position3] = id & 255;
      }
    }
    while (nextId = idsToInsert.pop()) {
      let offset = nextId.offset;
      serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
      distanceToMove -= 2;
      let position3 = offset + distanceToMove;
      serialized[position3++] = 216;
      serialized[position3++] = 28;
      lastEnd = offset;
    }
    return serialized;
  }
  function writeBundles(start, encode10) {
    targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);
    let writeStrings = bundledStrings2;
    bundledStrings2 = null;
    encode10(writeStrings[0]);
    encode10(writeStrings[1]);
  }
  function addExtension2(extension) {
    if (extension.Class) {
      if (!extension.encode)
        throw new Error("Extension has no encode function");
      extensionClasses.unshift(extension.Class);
      extensions.unshift(extension);
    }
    addExtension(extension);
  }
  var defaultEncoder = new Encoder3({ useRecords: false });
  var encode7 = defaultEncoder.encode;
  var encodeAsIterable = defaultEncoder.encodeAsIterable;
  var encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
  var { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
  var REUSE_BUFFER_MODE = 512;
  var RESET_BUFFER_MODE = 1024;
  var THROW_ON_ITERABLE = 2048;

  // node_modules/cbor-x/iterators.js
  function encodeIter(objectIterator, options = {}) {
    if (!objectIterator || typeof objectIterator !== "object") {
      throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");
    } else if (typeof objectIterator[Symbol.iterator] === "function") {
      return encodeIterSync(objectIterator, options);
    } else if (typeof objectIterator.then === "function" || typeof objectIterator[Symbol.asyncIterator] === "function") {
      return encodeIterAsync(objectIterator, options);
    } else {
      throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise");
    }
  }
  function* encodeIterSync(objectIterator, options) {
    const encoder = new Encoder3(options);
    for (const value of objectIterator) {
      yield encoder.encode(value);
    }
  }
  function encodeIterAsync(objectIterator, options) {
    return __asyncGenerator(this, null, function* () {
      const encoder = new Encoder3(options);
      try {
        for (var iter = __forAwait(objectIterator), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const value = temp.value;
          yield encoder.encode(value);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  function decodeIter(bufferIterator, options = {}) {
    if (!bufferIterator || typeof bufferIterator !== "object") {
      throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");
    }
    const decoder2 = new Decoder3(options);
    let incomplete;
    const parser = (chunk) => {
      let yields;
      if (incomplete) {
        chunk = Buffer.concat([incomplete, chunk]);
        incomplete = void 0;
      }
      try {
        yields = decoder2.decodeMultiple(chunk);
      } catch (err) {
        if (err.incomplete) {
          incomplete = chunk.slice(err.lastPosition);
          yields = err.values;
        } else {
          throw err;
        }
      }
      return yields;
    };
    if (typeof bufferIterator[Symbol.iterator] === "function") {
      return function* iter() {
        for (const value of bufferIterator) {
          yield* __yieldStar(parser(value));
        }
      }();
    } else if (typeof bufferIterator[Symbol.asyncIterator] === "function") {
      return function iter() {
        return __asyncGenerator(this, null, function* () {
          try {
            for (var iter2 = __forAwait(bufferIterator), more, temp, error; more = !(temp = yield new __await(iter2.next())).done; more = false) {
              const value = temp.value;
              yield* __yieldStar(parser(value));
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter2.return) && (yield new __await(temp.call(iter2)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        });
      }();
    }
  }

  // node_modules/multiformats/esm/src/index.js
  var src_exports2 = {};
  __export(src_exports2, {
    CID: () => CID3,
    bytes: () => bytes_exports2,
    digest: () => digest_exports3,
    hasher: () => hasher_exports,
    varint: () => varint_exports3
  });

  // node_modules/multiformats/esm/src/varint.js
  var varint_exports3 = {};
  __export(varint_exports3, {
    decode: () => decode13,
    encodeTo: () => encodeTo3,
    encodingLength: () => encodingLength3
  });

  // node_modules/multiformats/esm/vendor/varint.js
  var encode_13 = encode8;
  var MSB3 = 128;
  var REST3 = 127;
  var MSBALL3 = ~REST3;
  var INT3 = Math.pow(2, 31);
  function encode8(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT3) {
      out[offset++] = num & 255 | MSB3;
      num /= 128;
    }
    while (num & MSBALL3) {
      out[offset++] = num & 255 | MSB3;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode8.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode12 = read4;
  var MSB$13 = 128;
  var REST$13 = 127;
  function read4(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
    do {
      if (counter >= l) {
        read4.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf2[counter++];
      res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$13);
    read4.bytes = counter - offset;
    return res;
  }
  var N13 = Math.pow(2, 7);
  var N23 = Math.pow(2, 14);
  var N33 = Math.pow(2, 21);
  var N43 = Math.pow(2, 28);
  var N53 = Math.pow(2, 35);
  var N63 = Math.pow(2, 42);
  var N73 = Math.pow(2, 49);
  var N83 = Math.pow(2, 56);
  var N93 = Math.pow(2, 63);
  var length3 = function(value) {
    return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
  };
  var varint6 = {
    encode: encode_13,
    decode: decode12,
    encodingLength: length3
  };
  var _brrp_varint3 = varint6;
  var varint_default3 = _brrp_varint3;

  // node_modules/multiformats/esm/src/varint.js
  var decode13 = (data, offset = 0) => {
    const code = varint_default3.decode(data, offset);
    return [
      code,
      varint_default3.decode.bytes
    ];
  };
  var encodeTo3 = (int, target2, offset = 0) => {
    varint_default3.encode(int, target2, offset);
    return target2;
  };
  var encodingLength3 = (int) => {
    return varint_default3.encodingLength(int);
  };

  // node_modules/multiformats/esm/src/hashes/digest.js
  var digest_exports3 = {};
  __export(digest_exports3, {
    Digest: () => Digest3,
    create: () => create4,
    decode: () => decode14,
    equals: () => equals6
  });

  // node_modules/multiformats/esm/src/bytes.js
  var bytes_exports2 = {};
  __export(bytes_exports2, {
    coerce: () => coerce3,
    empty: () => empty3,
    equals: () => equals5,
    fromHex: () => fromHex,
    fromString: () => fromString2,
    isBinary: () => isBinary,
    toHex: () => toHex,
    toString: () => toString2
  });
  var empty3 = new Uint8Array(0);
  var toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
  var fromHex = (hex) => {
    const hexes = hex.match(/../g);
    return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty3;
  };
  var equals5 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  var coerce3 = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var isBinary = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
  var fromString2 = (str) => new TextEncoder().encode(str);
  var toString2 = (b) => new TextDecoder().decode(b);

  // node_modules/multiformats/esm/src/hashes/digest.js
  var create4 = (code, digest) => {
    const size = digest.byteLength;
    const sizeOffset = encodingLength3(code);
    const digestOffset = sizeOffset + encodingLength3(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo3(code, bytes, 0);
    encodeTo3(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest3(code, size, digest, bytes);
  };
  var decode14 = (multihash) => {
    const bytes = coerce3(multihash);
    const [code, sizeOffset] = decode13(bytes);
    const [size, digestOffset] = decode13(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest3(code, size, digest, bytes);
  };
  var equals6 = (a, b) => {
    if (a === b) {
      return true;
    } else {
      return a.code === b.code && a.size === b.size && equals5(a.bytes, b.bytes);
    }
  };
  var Digest3 = class {
    constructor(code, size, digest, bytes) {
      this.code = code;
      this.size = size;
      this.digest = digest;
      this.bytes = bytes;
    }
  };

  // node_modules/multiformats/esm/vendor/base-x.js
  function base3(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode10(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length4 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length4) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i2;
        pbegin++;
      }
      var it2 = size - length4;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length4 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length4) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length4;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode16(string) {
      var buffer2 = decodeUnsafe(string);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name} character`);
    }
    return {
      encode: encode10,
      decodeUnsafe,
      decode: decode16
    };
  }
  var src4 = base3;
  var _brrp__multiformats_scope_baseX3 = src4;
  var base_x_default3 = _brrp__multiformats_scope_baseX3;

  // node_modules/multiformats/esm/src/bases/base.js
  var Encoder4 = class {
    constructor(name, prefix, baseEncode) {
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder4 = class {
    constructor(name, prefix, baseDecode) {
      this.name = name;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder2) {
      return or3(this, decoder2);
    }
  };
  var ComposedDecoder3 = class {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder2) {
      return or3(this, decoder2);
    }
    decode(input) {
      const prefix = input[0];
      const decoder2 = this.decoders[prefix];
      if (decoder2) {
        return decoder2.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or3 = (left, right) => new ComposedDecoder3(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
  var Codec3 = class {
    constructor(name, prefix, baseEncode, baseDecode) {
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder4(name, prefix, baseEncode);
      this.decoder = new Decoder4(name, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from3 = ({ name, prefix, encode: encode10, decode: decode16 }) => new Codec3(name, prefix, encode10, decode16);
  var baseX3 = ({ prefix, name, alphabet }) => {
    const { encode: encode10, decode: decode16 } = base_x_default3(alphabet, name);
    return from3({
      prefix,
      name,
      encode: encode10,
      decode: (text) => coerce3(decode16(text))
    });
  };
  var decode15 = (string, alphabet, bitsPerChar, name) => {
    const codes = {};
    for (let i = 0; i < alphabet.length; ++i) {
      codes[alphabet[i]] = i;
    }
    let end = string.length;
    while (string[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = codes[string[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer2 >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode9 = (data, alphabet, bitsPerChar) => {
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer2 = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer2 = buffer2 << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet[mask & buffer2 >> bits];
      }
    }
    if (bits) {
      out += alphabet[mask & buffer2 << bitsPerChar - bits];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc46483 = ({ name, prefix, bitsPerChar, alphabet }) => {
    return from3({
      prefix,
      name,
      encode(input) {
        return encode9(input, alphabet, bitsPerChar);
      },
      decode(input) {
        return decode15(input, alphabet, bitsPerChar, name);
      }
    });
  };

  // node_modules/multiformats/esm/src/bases/base58.js
  var base58btc3 = baseX3({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr3 = baseX3({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/multiformats/esm/src/bases/base32.js
  var base323 = rfc46483({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper3 = rfc46483({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad3 = rfc46483({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper3 = rfc46483({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex3 = rfc46483({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper3 = rfc46483({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad3 = rfc46483({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper3 = rfc46483({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z3 = rfc46483({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/multiformats/esm/src/cid.js
  var CID3 = class _CID {
    constructor(version2, code, multihash, bytes) {
      this.code = code;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes;
      this.byteOffset = bytes.byteOffset;
      this.byteLength = bytes.byteLength;
      this.asCID = this;
      this._baseCache = /* @__PURE__ */ new Map();
      Object.defineProperties(this, {
        byteOffset: hidden,
        byteLength: hidden,
        code: readonly,
        version: readonly,
        multihash: readonly,
        bytes: readonly,
        _baseCache: hidden,
        asCID: hidden
      });
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        default: {
          const { code, multihash } = this;
          if (code !== DAG_PB_CODE3) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE3) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code, digest } = this.multihash;
          const multihash = create4(code, digest);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return other && this.code === other.code && this.version === other.version && equals6(this.multihash, other.multihash);
    }
    toString(base4) {
      const { bytes, version: version2, _baseCache } = this;
      switch (version2) {
        case 0:
          return toStringV03(bytes, _baseCache, base4 || base58btc3.encoder);
        default:
          return toStringV13(bytes, _baseCache, base4 || base323.encoder);
      }
    }
    toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(value) {
      deprecate(/^0\.0/, IS_CID_DEPRECATION);
      return !!(value && (value[cidSymbol3] || value.asCID === value));
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
      if (value instanceof _CID) {
        return value;
      } else if (value != null && value.asCID === value) {
        const { version: version2, code, multihash, bytes } = value;
        return new _CID(version2, code, multihash, bytes || encodeCID3(version2, code, multihash.bytes));
      } else if (value != null && value[cidSymbol3] === true) {
        const { version: version2, multihash, code } = value;
        const digest = decode14(multihash);
        return _CID.create(version2, code, digest);
      } else {
        return null;
      }
    }
    static create(version2, code, digest) {
      if (typeof code !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      switch (version2) {
        case 0: {
          if (code !== DAG_PB_CODE3) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`);
          } else {
            return new _CID(version2, code, digest, digest.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID3(version2, code, digest.bytes);
          return new _CID(version2, code, digest, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest) {
      return _CID.create(0, DAG_PB_CODE3, digest);
    }
    static createV1(code, digest) {
      return _CID.create(1, code, digest);
    }
    static decode(bytes) {
      const [cid, remainder] = _CID.decodeFirst(bytes);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    static decodeFirst(bytes) {
      const specs = _CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce3(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
      return [
        cid,
        bytes.subarray(specs.size)
      ];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length4] = decode13(initialBytes.subarray(offset));
        offset += length4;
        return i;
      };
      let version2 = next();
      let codec = DAG_PB_CODE3;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else if (version2 === 1) {
        codec = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return {
        version: version2,
        codec,
        multihashCode,
        digestSize,
        multihashSize,
        size
      };
    }
    static parse(source, base4) {
      const [prefix, bytes] = parseCIDtoBytes3(source, base4);
      const cid = _CID.decode(bytes);
      cid._baseCache.set(prefix, source);
      return cid;
    }
  };
  var parseCIDtoBytes3 = (source, base4) => {
    switch (source[0]) {
      case "Q": {
        const decoder2 = base4 || base58btc3;
        return [
          base58btc3.prefix,
          decoder2.decode(`${base58btc3.prefix}${source}`)
        ];
      }
      case base58btc3.prefix: {
        const decoder2 = base4 || base58btc3;
        return [
          base58btc3.prefix,
          decoder2.decode(source)
        ];
      }
      case base323.prefix: {
        const decoder2 = base4 || base323;
        return [
          base323.prefix,
          decoder2.decode(source)
        ];
      }
      default: {
        if (base4 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [
          source[0],
          base4.decode(source)
        ];
      }
    }
  };
  var toStringV03 = (bytes, cache3, base4) => {
    const { prefix } = base4;
    if (prefix !== base58btc3.prefix) {
      throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
    }
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base4.encode(bytes).slice(1);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var toStringV13 = (bytes, cache3, base4) => {
    const { prefix } = base4;
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base4.encode(bytes);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  };
  var DAG_PB_CODE3 = 112;
  var SHA_256_CODE3 = 18;
  var encodeCID3 = (version2, code, multihash) => {
    const codeOffset = encodingLength3(version2);
    const hashOffset = codeOffset + encodingLength3(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo3(version2, bytes, 0);
    encodeTo3(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  };
  var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");
  var readonly = {
    writable: false,
    configurable: false,
    enumerable: true
  };
  var hidden = {
    writable: false,
    enumerable: false,
    configurable: false
  };
  var version = "0.0.0-dev";
  var deprecate = (range, message) => {
    if (range.test(version)) {
      console.warn(message);
    } else {
      throw new Error(message);
    }
  };
  var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

  // node_modules/multiformats/esm/src/hashes/hasher.js
  var hasher_exports = {};
  __export(hasher_exports, {
    Hasher: () => Hasher,
    from: () => from4
  });
  var from4 = ({ name, code, encode: encode10 }) => new Hasher(name, code, encode10);
  var Hasher = class {
    constructor(name, code, encode10) {
      this.name = name;
      this.code = code;
      this.encode = encode10;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest) => create4(this.code, digest));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // lib/index.js
  var import_xterm2 = __toESM(require_xterm());
  var import_addon_fit2 = __toESM(require_addon_fit());

  // lib/firehose.js
  var cbor_x_extended = false;
  function firehose(callbacks) {
    const WebSocketImpl = typeof WebSocket === "function" ? WebSocket : cacheRequire("ws");
    if (!cbor_x_extended) {
      cbor_x_extended = true;
      addExtension2({
        Class: CID3,
        tag: 42,
        encode: () => {
          throw new Error("cannot encode cids");
        },
        decode: (bytes) => {
          if (bytes[0] !== 0)
            throw new Error("invalid cid for cbor tag 42");
          return CID3.decode(bytes.subarray(1));
        }
      });
    }
    let now = Date.now();
    const wsAddress = "wss://bsky.network/xrpc/com.atproto.sync.subscribeRepos";
    const ws = new WebSocketImpl(wsAddress);
    ws.addEventListener("message", handleMessage);
    ws.addEventListener("error", (error) => handleError(error));
    return { stop };
    function stop() {
      ws.close();
    }
    function handleMessage(event) {
      return __async(this, null, function* () {
        var _a3, _b;
        now = Date.now();
        if (typeof ((_a3 = event.data) == null ? void 0 : _a3.arrayBuffer) === "function")
          return event.data.arrayBuffer().then(convertMessageBuf);
        else if (typeof ((_b = event.data) == null ? void 0 : _b.byteLength) === "number")
          return convertMessageBuf(event.data);
      });
    }
    function convertMessageBuf(messageBuf) {
      return __async(this, null, function* () {
        var _a3;
        const entry = (
          /** @type {any[]} */
          decodeMultiple(new Uint8Array(messageBuf))
        );
        if (!entry || ((_a3 = entry[0]) == null ? void 0 : _a3.op) !== 1)
          return;
        const commit = entry[1];
        if (!commit.blocks)
          return;
        if (!commit.repo)
          return;
        const car = yield CarReader.fromBytes(commit.blocks);
        for (const op of commit.ops) {
          const block = op.cid && (yield car.get(
            /** @type {*} */
            op.cid
          ));
          if (!block)
            continue;
          const record = decode11(block.bytes);
          callbacks.record(op, commit, record);
        }
      });
    }
    function handleError(event) {
      if (typeof callbacks.error !== "function")
        return;
      callbacks.error(event, now);
    }
  }

  // lib/init-xterm.js
  var import_addon_fit = __toESM(require_addon_fit());
  var import_xterm = __toESM(require_xterm());
  function initXTerminal() {
    const termContainer = document.createElement("div");
    termContainer.className = "terminalContainer";
    termContainer.style.cssText = `
  position: absolute;
  left: 0; top: 0;
  width: 100%; height: 100%;
  border: solid 1em transparent;
  box-sizing: border-box;
  `;
    const termHost = document.createElement("div");
    termHost.className = "terminalHost";
    termHost.style.cssText = `
  position: relative;
  width: 100%; height: 100%;
  box-sizing: border-box;
  `;
    document.body.appendChild(termContainer);
    termContainer.appendChild(termHost);
    const measure = document.createElement("div");
    measure.style.cssText = `
  font-size: 2vh;
  z-index: -1;
  position: absolute;
  opacity: 0;
  `;
    measure.textContent = "M";
    document.body.appendChild(measure);
    const sz = measure.getBoundingClientRect();
    document.body.removeChild(measure);
    const terminal = new import_xterm.Terminal({
      allowTransparency: true,
      cursorBlink: true,
      cursorStyle: "underline",
      disableStdin: false,
      fontSize: Math.round(sz.height),
      theme: {
        background: "#00000000"
      }
    });
    const fitAddon = new import_addon_fit.FitAddon();
    terminal.loadAddon(fitAddon);
    terminal.open(termHost);
    fitAddon.fit();
    var debounce;
    window.addEventListener("resize", () => {
      clearTimeout(debounce);
      debounce = setTimeout(() => fitAddon.fit(), 150);
    });
    terminal.focus();
    return { read: read5, write, red, green, blue, nocolor };
    function write(text) {
      return terminal.write(text);
    }
    function red() {
      terminal.write("x1B[38;5;197m");
    }
    function green() {
      terminal.write("\x1B[38;5;3m");
    }
    function blue() {
      terminal.write("\x1B[38;5;51m");
    }
    function nocolor() {
      terminal.write("\x1B[0m");
    }
    function read5(silent) {
      return new Promise((resolve) => {
        let buf2 = "";
        const dataSub = terminal.onData((data) => {
          buf2 += data = [...data].filter(
            (ch) => ch.length > 1 || ch.charCodeAt(0) >= 32 && ch.charCodeAt(0) !== 127
          ).join("");
          terminal.write(!silent ? data : data.replace(/./g, "*"));
        });
        const keySub = terminal.onKey((e) => {
          if (e.key === "\r") {
            dataSub.dispose();
            keySub.dispose();
            terminal.write("\r\n");
            resolve(buf2);
          }
          if (e.key === "\x7F") {
            if (buf2) {
              const newBuf = buf2.slice(0, buf2.length - 1);
              buf2 = newBuf;
              terminal.write("\b \b");
            }
          }
        });
      });
    }
  }

  // lib/init-at-client.js
  var import_api = __toESM(require_dist());
  function patchBskyAgent(atClient) {
    atClient.com.atproto.sync._service.xrpc.baseClient.lex.assertValidXrpcOutput = function(lexUri, value, ...rest) {
      return true;
    };
  }
  function patchBskyAgentWithCORSProxy(atClient) {
    atClient.com.atproto.sync._service.xrpc.baseClient.lex.assertValidXrpcOutput = function(lexUri, value, ...rest) {
      return true;
    };
    if (typeof window !== "undefined" && window) {
      const baseFetch = atClient.com.atproto.sync._service.xrpc.baseClient.fetch;
      atClient.com.atproto.sync._service.xrpc.baseClient.fetch = function(reqUri, ...args) {
        if (/com\.atproto/.test(reqUri))
          reqUri = "https://corsproxy.io/?" + reqUri;
        return baseFetch.call(
          atClient.com.atproto.sync._service.xrpc.baseClient,
          reqUri,
          ...args
        );
      };
    }
  }

  // lib/index.js
  function exportToGlobal(exports) {
    exports.atproto = import_api2.default;
    exports.cbor_x = cbor_x_exports;
    exports.ipld_car = { CarReader };
    exports.multiformats = src_exports2;
    exports.xterm = import_xterm2.default;
    exports.xterm_fit = import_addon_fit2.default;
    exports.initXTerminal = initXTerminal;
    exports.patchBskyAgent = patchBskyAgent;
    exports.patchBskyAgentWithCORSProxy = patchBskyAgentWithCORSProxy;
    exports.firehose = firehose;
  }
  if (typeof window !== "undefined" && window) {
    exportToGlobal(window);
  } else if (typeof process !== "undefined" && typeof (process == null ? void 0 : process.exit) === "function") {
    module.exports = {};
    exportToGlobal(module.exports);
  }
})();
//# sourceMappingURL=libs.js.map
